;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0](function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
(function() {
  var $, ExploreView, FavoriteView, ImageView, UserView;

  if (!Array.prototype.map) {
    window.location.href = "http://browsehappy.com/";
  }

  AV.initialize("ub6plmew80eyd77dcq9p75iue0sywi9zunod1tuq94frmvix", "rl6gggtdevzwvk7g5sbmqx1657giipy5x246dkbrx0t8k6tj");

  UserView = require('./views/user-view.coffee');

  ImageView = require('./views/image-view.coffee');

  ExploreView = require('./views/explore-view.coffee');

  FavoriteView = require('./views/favorite-view.coffee');

  $ = require('jquery');

  $(function() {
    new UserView();
    new ImageView();
    $('#nav > ul > li').click(function() {
      $('#nav > ul > li.current').removeClass('current');
      return $(this).addClass('current');
    });
    $('#nav-create').click(function() {
      return new ImageView();
    });
    $('#nav-explore').click(function() {
      return new ExploreView();
    });
    return $('#nav-favorite').click(function() {
      return new FavoriteView();
    });
  });

}).call(this);


},{"./views/user-view.coffee":2,"./views/image-view.coffee":3,"./views/explore-view.coffee":4,"./views/favorite-view.coffee":5,"jquery":6}],6:[function(require,module,exports){
(function(){/*!
 * jQuery JavaScript Library v2.1.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-05-01T17:11Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		return !jQuery.isArray( obj ) && obj - parseFloat( obj ) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android < 4.0, iOS < 6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.19
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-04-18
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare,
		doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", function() {
				setDocument();
			}, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", function() {
				setDocument();
			});
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowclip^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android < 4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Math.random();
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android < 4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



/*
	Implementation Summary

	1. Enforce API surface and semantic compatibility with 1.9.x branch
	2. Improve the module's maintainability by reducing the storage
		paths to a single mechanism.
	3. Use the same single mechanism to support "private" and "user" data.
	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	5. Avoid exposing implementation details on user objects (eg. expando properties)
	6. Provide a clear path for implementation upgrade to WeakMap in 2014
*/
var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// #11217 - WebKit loses check when the name is after the checked attribute
	// Support: Windows Web Apps (WWA)
	// `name` and `type` need .setAttribute for WWA
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE9-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome < 28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android < 4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Create "bubbling" focus and blur events
// Support: Firefox, Chrome, Safari
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE 9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE 9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Support: IE >= 9
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Support: IE >= 9
		// Fix Cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Fixes #12346
					// Support: Webkit, IE
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') in IE9, see #12537
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {
				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {
				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS 5.1, Android 4.x, Android 2.3
	// Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
	support.checkOn = input.value !== "";

	// Must access the parent to make an option select properly
	// Support: IE9, IE10
	support.optSelected = opt.selected;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Check if an input maintains its value after becoming a radio
	// Support: IE9, IE10
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

// Support: IE9+
// Selectedness for an option in an optgroup can be inaccurate
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
	jQuery( window ).on( "unload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// We assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

})()
},{}],7:[function(require,module,exports){
(function() {
  var ANN, ann, fitness, network;

  ANN = require('./ann.coffee');

  network = require('./network');

  ann = ANN.fromJSON(network);

  fitness = function(scheme) {
    return ann.rate({
      colors: scheme
    });
  };

  module.exports = fitness;

}).call(this);


},{"./ann.coffee":8,"./network":9}],9:[function(require,module,exports){
module.exports = {
    "layers":[{"out_depth":1,"out_sx":16,"out_sy":1,"layer_type":"input"},{"out_depth":16,"out_sx":1,"out_sy":1,"layer_type":"fc","num_inputs":16,"l1_decay_mul":0,"l2_decay_mul":1,"filters":[{"sx":1,"sy":1,"depth":16,"w":{"0":0.2525886495663514,"1":-0.07680017355707727,"2":-0.5357068214324251,"3":0.1344456583849557,"4":-0.022957461708018205,"5":-0.610064206386567,"6":0.14367585659678608,"7":0.30138725302221675,"8":-0.23102918837745198,"9":0.0615381804002426,"10":0.3435844011486207,"11":-0.41790759834814756,"12":0.45750927112478057,"13":0.2724431498661552,"14":-0.3381481167835181,"15":-0.5151236522944815,"BYTES_PER_ELEMENT":8,"buffer":{"0":52,"1":156,"2":78,"3":149,"4":105,"5":42,"6":208,"7":63,"8":170,"9":56,"10":193,"11":25,"12":45,"13":169,"14":179,"15":191,"16":237,"17":123,"18":201,"19":161,"20":130,"21":36,"22":225,"23":191,"24":28,"25":33,"26":237,"27":236,"28":131,"29":53,"30":193,"31":63,"32":206,"33":192,"34":240,"35":44,"36":41,"37":130,"38":151,"39":191,"40":249,"41":126,"42":220,"43":94,"44":165,"45":133,"46":227,"47":191,"48":245,"49":107,"50":167,"51":112,"52":248,"53":99,"54":194,"55":63,"56":67,"57":89,"58":202,"59":194,"60":237,"61":73,"62":211,"63":63,"64":135,"65":84,"66":64,"67":76,"68":93,"69":146,"70":205,"71":191,"72":222,"73":124,"74":140,"75":176,"76":238,"77":129,"78":175,"79":63,"80":45,"81":87,"82":150,"83":109,"84":73,"85":253,"86":213,"87":63,"88":193,"89":238,"90":233,"91":130,"92":255,"93":190,"94":218,"95":191,"96":52,"97":65,"98":70,"99":247,"100":212,"101":71,"102":221,"103":63,"104":115,"105":112,"106":172,"107":100,"108":181,"109":111,"110":209,"111":63,"112":60,"113":130,"114":178,"115":255,"116":55,"117":164,"118":213,"119":191,"120":40,"121":7,"122":0,"123":153,"124":228,"125":123,"126":224,"127":191,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":0.23409085069971794,"1":-0.05967542614339212,"2":-0.36579543983555757,"3":0.44429371825838465,"4":0.3962361683969425,"5":-0.9611913156683988,"6":-0.14359663704391612,"7":0.04941540216373019,"8":-0.17955209459218854,"9":0.07703622981987243,"10":-0.16245493065748828,"11":-0.4370528176896718,"12":0.12202663124649674,"13":0.00924684529823964,"14":-0.32166162970998474,"15":-0.5310358046734102,"BYTES_PER_ELEMENT":8,"buffer":{"0":97,"1":40,"2":6,"3":98,"4":176,"5":246,"6":205,"7":63,"8":138,"9":75,"10":82,"11":7,"12":199,"13":141,"14":174,"15":191,"16":111,"17":168,"18":199,"19":70,"20":49,"21":105,"22":215,"23":191,"24":101,"25":59,"26":111,"27":235,"28":78,"29":111,"30":220,"31":63,"32":61,"33":118,"34":48,"35":242,"36":238,"37":91,"38":217,"39":63,"40":235,"41":214,"42":63,"43":74,"44":20,"45":194,"46":238,"47":191,"48":104,"49":168,"50":245,"51":229,"52":95,"53":97,"54":194,"55":191,"56":80,"57":127,"58":108,"59":192,"60":249,"61":76,"62":169,"63":63,"64":227,"65":210,"66":25,"67":35,"68":144,"69":251,"70":198,"71":191,"72":86,"73":249,"74":174,"75":119,"76":165,"77":184,"78":179,"79":63,"80":224,"81":185,"82":31,"83":187,"84":82,"85":203,"86":196,"87":191,"88":189,"89":131,"90":166,"91":97,"92":172,"93":248,"94":219,"95":191,"96":122,"97":219,"98":113,"99":38,"100":35,"101":61,"102":191,"103":63,"104":85,"105":72,"106":45,"107":145,"108":2,"109":240,"110":130,"111":63,"112":103,"113":224,"114":254,"115":168,"116":26,"117":150,"118":212,"119":191,"120":147,"121":121,"122":194,"123":204,"124":62,"125":254,"126":224,"127":191,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":-0.14801256242996283,"1":-0.07514854484183148,"2":0.0822743869567087,"3":-0.42809519476876123,"4":-0.17531091340370134,"5":0.42223787288324804,"6":-0.44606094169396704,"7":-0.3046919556680011,"8":0.04343483937450778,"9":-0.3008742675699029,"10":-0.2534209514105979,"11":0.4194524600359459,"12":-0.2826705689675775,"13":-0.4150519760902032,"14":0.44044396816742987,"15":0.2542320024331879,"BYTES_PER_ELEMENT":8,"buffer":{"0":39,"1":85,"2":132,"3":93,"4":19,"5":242,"6":194,"7":191,"8":52,"9":10,"10":112,"11":94,"12":239,"13":60,"14":179,"15":191,"16":21,"17":11,"18":71,"19":41,"20":239,"21":15,"22":181,"23":63,"24":52,"25":210,"26":70,"27":99,"28":233,"29":101,"30":219,"31":191,"32":85,"33":179,"34":217,"35":135,"36":150,"37":112,"38":198,"39":191,"40":75,"41":162,"42":202,"43":255,"44":241,"45":5,"46":219,"47":63,"48":170,"49":78,"50":38,"51":49,"52":67,"53":140,"54":220,"55":191,"56":182,"57":177,"58":60,"59":176,"60":18,"61":128,"62":211,"63":191,"64":83,"65":181,"66":61,"67":93,"68":23,"69":61,"70":166,"71":63,"72":134,"73":236,"74":218,"75":36,"76":134,"77":65,"78":211,"79":191,"80":149,"81":128,"82":155,"83":130,"84":12,"85":56,"86":208,"87":191,"88":79,"89":49,"90":133,"91":33,"92":79,"93":216,"94":218,"95":63,"96":48,"97":122,"98":80,"99":76,"100":70,"101":23,"102":210,"103":191,"104":109,"105":165,"106":220,"107":41,"108":54,"109":144,"110":218,"111":191,"112":15,"113":249,"114":191,"115":229,"116":59,"117":48,"118":220,"119":63,"120":64,"121":4,"122":3,"123":78,"124":86,"125":69,"126":208,"127":63,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":-0.4710054193012012,"1":0.1272685549091037,"2":-0.07961314298392345,"3":-0.11806472918194665,"4":0.05216846331872486,"5":0.49211858401557285,"6":-0.3647202093144102,"7":0.26078521904586993,"8":0.32462041166295635,"9":-0.12592865125406782,"10":-0.08728315926720073,"11":0.13280823387965723,"12":-0.2515661542075084,"13":-0.25816155263458523,"14":0.05167653979148573,"15":0.30295885145993967,"BYTES_PER_ELEMENT":8,"buffer":{"0":152,"1":203,"2":8,"3":234,"4":243,"5":36,"6":222,"7":191,"8":103,"9":103,"10":146,"11":4,"12":86,"13":74,"14":192,"15":63,"16":251,"17":157,"18":114,"19":229,"20":134,"21":97,"22":180,"23":191,"24":87,"25":198,"26":165,"27":118,"28":125,"29":57,"30":190,"31":191,"32":149,"33":73,"34":172,"35":39,"36":211,"37":181,"38":170,"39":63,"40":24,"41":114,"42":6,"43":242,"44":222,"45":126,"46":223,"47":63,"48":204,"49":133,"50":204,"51":110,"52":147,"53":87,"54":215,"55":191,"56":228,"57":66,"58":197,"59":124,"60":180,"61":176,"62":208,"63":63,"64":141,"65":54,"66":237,"67":176,"68":148,"69":198,"70":212,"71":63,"72":136,"73":255,"74":97,"75":23,"76":110,"77":30,"78":192,"79":191,"80":206,"81":79,"82":139,"83":106,"84":48,"85":88,"86":182,"87":191,"88":240,"89":137,"90":147,"91":54,"92":220,"93":255,"94":192,"95":63,"96":238,"97":130,"98":70,"99":237,"100":168,"101":25,"102":208,"103":191,"104":171,"105":155,"106":105,"107":8,"108":184,"109":133,"110":208,"111":191,"112":120,"113":239,"114":191,"115":240,"116":88,"117":117,"118":170,"119":63,"120":103,"121":119,"122":195,"123":133,"124":173,"125":99,"126":211,"127":63,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":-0.5099907046719344,"1":-0.4622580757868327,"2":0.4132171337244385,"3":0.04032117505643704,"4":-0.1874843812282591,"5":1.201496452360171,"6":-0.08381130494801392,"7":-0.22903222514041416,"8":0.3822996194906178,"9":0.46406164161972335,"10":-0.07025372903888255,"11":0.26425605929181,"12":-0.49264480944818434,"13":0.2905574816230955,"14":0.29973352878627885,"15":0.3996335500949661,"BYTES_PER_ELEMENT":8,"buffer":{"0":249,"1":142,"2":186,"3":6,"4":216,"5":81,"6":224,"7":191,"8":217,"9":62,"10":116,"11":229,"12":162,"13":149,"14":221,"15":191,"16":151,"17":146,"18":223,"19":70,"20":38,"21":114,"22":218,"23":63,"24":205,"25":73,"26":104,"27":32,"28":250,"29":164,"30":164,"31":63,"32":254,"33":109,"34":241,"35":250,"36":124,"37":255,"38":199,"39":191,"40":239,"41":89,"42":18,"43":88,"44":84,"45":57,"46":243,"47":63,"48":232,"49":107,"50":201,"51":93,"52":168,"53":116,"54":181,"55":191,"56":230,"57":165,"58":90,"59":142,"60":237,"61":80,"62":205,"63":191,"64":147,"65":17,"66":191,"67":210,"68":152,"69":119,"70":216,"71":63,"72":27,"73":109,"74":133,"75":153,"76":47,"77":179,"78":221,"79":63,"80":52,"81":224,"82":164,"83":252,"84":37,"85":252,"86":177,"87":191,"88":253,"89":102,"90":27,"91":63,"92":146,"93":233,"94":208,"95":63,"96":80,"97":241,"98":71,"99":24,"100":126,"101":135,"102":223,"103":191,"104":235,"105":121,"106":75,"107":104,"108":126,"109":152,"110":210,"111":63,"112":37,"113":182,"114":233,"115":137,"116":213,"117":46,"118":211,"119":63,"120":87,"121":180,"122":2,"123":153,"124":152,"125":147,"126":217,"127":63,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":0.38669243744401505,"1":-0.030315183240394204,"2":-0.3274543794499032,"3":0.22842479289894016,"4":-0.107958536357186,"5":-0.4801565453454784,"6":0.22589049922355064,"7":-0.08901690912877631,"8":-0.19430321820845872,"9":0.32202886138056735,"10":-0.1246372285003018,"11":0.2542238550369736,"12":-0.08136267838820152,"13":-0.07550573533166453,"14":-0.10244134067145114,"15":-0.094155236010734,"BYTES_PER_ELEMENT":8,"buffer":{"0":60,"1":175,"2":27,"3":163,"4":145,"5":191,"6":216,"7":63,"8":233,"9":228,"10":91,"11":130,"12":241,"13":10,"14":159,"15":191,"16":244,"17":213,"18":170,"19":54,"20":3,"21":245,"22":212,"23":191,"24":205,"25":90,"26":140,"27":11,"28":6,"29":61,"30":205,"31":63,"32":112,"33":103,"34":250,"35":174,"36":43,"37":163,"38":187,"39":191,"40":229,"41":6,"42":206,"43":132,"44":226,"45":186,"46":222,"47":191,"48":176,"49":53,"50":82,"51":217,"52":250,"53":233,"54":204,"55":63,"56":229,"57":196,"58":127,"59":233,"60":207,"61":201,"62":182,"63":191,"64":183,"65":63,"66":219,"67":135,"68":237,"69":222,"70":200,"71":191,"72":145,"73":217,"74":255,"75":240,"76":30,"77":156,"78":212,"79":63,"80":41,"81":219,"82":69,"83":180,"84":57,"85":232,"86":191,"87":191,"88":85,"89":204,"90":207,"91":33,"92":52,"93":69,"94":208,"95":63,"96":158,"97":211,"98":202,"99":58,"100":47,"101":212,"102":180,"103":191,"104":59,"105":241,"106":232,"107":7,"108":88,"109":84,"110":179,"111":191,"112":22,"113":57,"114":241,"115":127,"116":152,"117":57,"118":186,"119":191,"120":172,"121":203,"122":105,"123":187,"124":142,"125":26,"126":184,"127":191,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":-0.39058069801918716,"1":-0.22623334508977702,"2":0.11154511927633683,"3":-0.35405450349690065,"4":0.08705271501794282,"5":0.20320706283109868,"6":-0.34021123234142736,"7":0.007835133383031179,"8":0.7885554068392913,"9":-0.23291979793833836,"10":-0.35133196178122084,"11":-0.10932196137563811,"12":-0.3172768165305093,"13":-0.5516429501994218,"14":-0.14452531696294293,"15":0.3657548639018371,"BYTES_PER_ELEMENT":8,"buffer":{"0":158,"1":61,"2":28,"3":47,"4":70,"5":255,"6":216,"7":191,"8":101,"9":111,"10":54,"11":217,"12":54,"13":245,"14":204,"15":191,"16":65,"17":254,"18":81,"19":143,"20":56,"21":142,"22":188,"23":63,"24":63,"25":83,"26":97,"27":56,"28":212,"29":168,"30":214,"31":191,"32":212,"33":178,"34":7,"35":52,"36":22,"37":73,"38":182,"39":63,"40":40,"41":128,"42":150,"43":100,"44":176,"45":2,"46":202,"47":63,"48":182,"49":217,"50":40,"51":85,"52":5,"53":198,"54":213,"55":191,"56":173,"57":140,"58":30,"59":205,"60":221,"61":11,"62":128,"63":63,"64":236,"65":173,"66":110,"67":140,"68":216,"69":59,"70":233,"71":63,"72":63,"73":56,"74":94,"75":225,"76":80,"77":208,"78":205,"79":191,"80":142,"81":243,"82":120,"83":13,"84":57,"85":124,"86":214,"87":191,"88":249,"89":202,"90":215,"91":40,"92":134,"93":252,"94":187,"95":191,"96":12,"97":195,"98":177,"99":107,"100":67,"101":78,"102":212,"103":191,"104":122,"105":157,"106":197,"107":29,"108":15,"109":167,"110":225,"111":191,"112":69,"113":98,"114":230,"115":58,"116":206,"117":127,"118":194,"119":191,"120":176,"121":236,"122":179,"123":22,"124":135,"125":104,"126":215,"127":63,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":0.04219450710221414,"1":0.08219379469650318,"2":-0.20659758012531407,"3":-0.18466126144744835,"4":-0.3390166162868054,"5":-0.4624746871201401,"6":0.5085582044147469,"7":0.20714995065029407,"8":-0.46478484802626274,"9":-0.006840144254360119,"10":0.1932219081050788,"11":-0.3693049683048941,"12":0.7333563819544033,"13":-0.056573704662630495,"14":-0.22608023530913582,"15":-0.2743601640046705,"BYTES_PER_ELEMENT":8,"buffer":{"0":171,"1":82,"2":38,"3":184,"4":132,"5":154,"6":165,"7":63,"8":172,"9":214,"10":39,"11":12,"12":167,"13":10,"14":181,"15":63,"16":85,"17":21,"18":9,"19":29,"20":202,"21":113,"22":202,"23":191,"24":113,"25":160,"26":96,"27":239,"28":250,"29":162,"30":199,"31":191,"32":125,"33":39,"34":240,"35":191,"36":114,"37":178,"38":213,"39":191,"40":87,"41":42,"42":26,"43":110,"44":47,"45":153,"46":221,"47":191,"48":189,"49":92,"50":2,"51":219,"52":27,"53":70,"54":224,"55":63,"56":136,"57":156,"58":180,"59":187,"60":227,"61":131,"62":202,"63":63,"64":134,"65":190,"66":124,"67":242,"68":8,"69":191,"70":221,"71":191,"72":172,"73":88,"74":245,"75":61,"76":105,"77":4,"78":124,"79":191,"80":201,"81":76,"82":23,"83":216,"84":126,"85":187,"86":200,"87":63,"88":104,"89":171,"90":71,"91":78,"92":177,"93":162,"94":215,"95":191,"96":84,"97":211,"98":153,"99":205,"100":167,"101":119,"102":231,"103":63,"104":230,"105":218,"106":173,"107":134,"108":58,"109":247,"110":172,"111":191,"112":81,"113":93,"114":118,"115":120,"116":50,"117":240,"118":204,"119":191,"120":153,"121":106,"122":238,"123":238,"124":29,"125":143,"126":209,"127":191,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":-0.5396686606574662,"1":-0.02436227219146904,"2":-0.182509678528021,"3":-0.19978929632789402,"4":-0.31361707853372545,"5":0.28209855546898244,"6":-0.17652132434323037,"7":-0.08865969160107756,"8":0.3762946130271747,"9":-0.543147921110474,"10":-0.6949053924113018,"11":0.24562397616636994,"12":-0.09258692259789553,"13":0.46235207784158794,"14":-0.07616538391333212,"15":0.15702707106477112,"BYTES_PER_ELEMENT":8,"buffer":{"0":231,"1":101,"2":6,"3":54,"4":247,"5":68,"6":225,"7":191,"8":164,"9":65,"10":70,"11":105,"12":108,"13":242,"14":152,"15":191,"16":3,"17":156,"18":61,"19":38,"20":122,"21":92,"22":199,"23":191,"24":41,"25":218,"26":232,"27":22,"28":178,"29":146,"30":201,"31":191,"32":22,"33":62,"34":241,"35":93,"36":77,"37":18,"38":212,"39":191,"40":98,"41":61,"42":127,"43":25,"44":231,"45":13,"46":210,"47":63,"48":118,"49":230,"50":140,"51":49,"52":64,"53":152,"54":198,"55":191,"56":64,"57":107,"58":230,"59":203,"60":102,"61":178,"62":182,"63":191,"64":84,"65":54,"66":39,"67":0,"68":54,"69":21,"70":216,"71":63,"72":125,"73":234,"74":193,"75":191,"76":119,"77":97,"78":225,"79":191,"80":14,"81":15,"82":199,"83":59,"84":170,"85":60,"86":230,"87":191,"88":218,"89":191,"90":95,"91":64,"92":155,"93":112,"94":207,"95":63,"96":244,"97":97,"98":152,"99":204,"100":198,"101":179,"102":183,"103":191,"104":24,"105":78,"106":100,"107":43,"108":45,"109":151,"110":221,"111":63,"112":85,"113":187,"114":254,"115":24,"116":147,"117":127,"118":179,"119":191,"120":125,"121":169,"122":103,"123":139,"124":118,"125":25,"126":196,"127":63,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":-0.43864876007201786,"1":0.34689674628426426,"2":0.35163020605040446,"3":-0.11878079634597237,"4":-0.43908416072527434,"5":0.5322359886316363,"6":-0.084847796052466,"7":0.12273485618520656,"8":0.5606807700816236,"9":-0.5521717336867416,"10":-0.38317171537379313,"11":0.30117694603496326,"12":-0.3593391639470459,"13":-0.4997842683758727,"14":0.5186804940092943,"15":1.150802725136032,"BYTES_PER_ELEMENT":8,"buffer":{"0":87,"1":45,"2":188,"3":63,"4":210,"5":18,"6":220,"7":191,"8":104,"9":77,"10":24,"11":105,"12":142,"13":51,"14":214,"15":63,"16":49,"17":108,"18":209,"19":250,"20":27,"21":129,"22":214,"23":63,"24":191,"25":227,"26":178,"27":19,"28":107,"29":104,"30":190,"31":191,"32":34,"33":109,"34":160,"35":115,"36":244,"37":25,"38":220,"39":191,"40":218,"41":170,"42":157,"43":196,"44":19,"45":8,"46":225,"47":63,"48":92,"49":218,"50":46,"51":205,"52":149,"53":184,"54":181,"55":191,"56":187,"57":12,"58":101,"59":49,"60":141,"61":107,"62":191,"63":63,"64":182,"65":228,"66":95,"67":204,"68":24,"69":241,"70":225,"71":63,"72":196,"73":185,"74":62,"75":14,"76":100,"77":171,"78":225,"79":191,"80":34,"81":23,"82":146,"83":168,"84":226,"85":133,"86":216,"87":191,"88":114,"89":224,"90":97,"91":171,"92":123,"93":70,"94":211,"95":63,"96":86,"97":197,"98":84,"99":177,"100":105,"101":255,"102":214,"103":191,"104":193,"105":178,"106":238,"107":39,"108":119,"109":252,"110":223,"111":191,"112":53,"113":250,"114":218,"115":213,"116":7,"117":153,"118":224,"119":63,"120":1,"121":182,"122":73,"123":30,"124":176,"125":105,"126":242,"127":63,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":-0.02320087763227333,"1":0.012410705138058534,"2":-0.2783715545701031,"3":0.7525549074234468,"4":0.07128581303033447,"5":-0.29209765229343115,"6":-0.0013400016990404789,"7":0.2393561821514457,"8":-0.25729482667515974,"9":0.3258966340763653,"10":0.1335218841086687,"11":-0.3903156435713374,"12":0.05575797424188608,"13":0.0915107905314032,"14":-0.17190743082482182,"15":-0.26560324698429716,"BYTES_PER_ELEMENT":8,"buffer":{"0":169,"1":43,"2":173,"3":138,"4":248,"5":193,"6":151,"7":191,"8":194,"9":142,"10":129,"11":165,"12":200,"13":106,"14":137,"15":63,"16":56,"17":250,"18":192,"19":236,"20":214,"21":208,"22":209,"23":191,"24":18,"25":127,"26":122,"27":7,"28":238,"29":20,"30":232,"31":63,"32":147,"33":81,"34":162,"35":123,"36":201,"37":63,"38":178,"39":63,"40":181,"41":172,"42":245,"43":89,"44":186,"45":177,"46":210,"47":191,"48":33,"49":106,"50":85,"51":222,"52":95,"53":244,"54":85,"55":191,"56":219,"57":202,"58":55,"59":47,"60":57,"61":163,"62":206,"63":63,"64":183,"65":252,"66":127,"67":184,"68":132,"69":119,"70":208,"71":191,"72":135,"73":1,"74":79,"75":142,"76":125,"77":219,"78":212,"79":63,"80":55,"81":5,"82":198,"83":190,"84":62,"85":23,"86":193,"87":63,"88":186,"89":99,"90":16,"91":119,"92":238,"93":250,"94":216,"95":191,"96":124,"97":96,"98":184,"99":39,"100":79,"101":140,"102":172,"103":63,"104":111,"105":64,"106":144,"107":76,"108":64,"109":109,"110":183,"111":63,"112":183,"113":126,"114":170,"115":12,"116":16,"117":1,"118":198,"119":191,"120":234,"121":146,"122":224,"123":194,"124":164,"125":255,"126":208,"127":191,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":-0.34873689257070595,"1":-0.08273455533265167,"2":0.02275882805733802,"3":-0.28498556258855445,"4":0.13411768809901947,"5":0.3799888135703318,"6":-0.08477493294040774,"7":-0.5002333755418681,"8":0.4704683025529959,"9":-0.11787310066914695,"10":-0.14909246652198574,"11":0.28405575293535923,"12":0.07341834953275399,"13":-0.05432763482863846,"14":0.35672800527051857,"15":0.37628494626488107,"BYTES_PER_ELEMENT":8,"buffer":{"0":128,"1":253,"2":31,"3":139,"4":180,"5":81,"6":214,"7":191,"8":156,"9":32,"10":103,"11":129,"12":23,"13":46,"14":181,"15":191,"16":45,"17":100,"18":206,"19":24,"20":23,"21":78,"22":151,"23":63,"24":164,"25":153,"26":201,"27":21,"28":52,"29":61,"30":210,"31":191,"32":68,"33":167,"34":25,"35":182,"36":196,"37":42,"38":193,"39":63,"40":189,"41":88,"42":200,"43":153,"44":188,"45":81,"46":216,"47":63,"48":177,"49":232,"50":127,"51":92,"52":207,"53":179,"54":181,"55":191,"56":133,"57":61,"58":138,"59":108,"60":233,"61":1,"62":224,"63":191,"64":152,"65":67,"66":81,"67":21,"68":39,"69":28,"70":222,"71":63,"72":243,"73":188,"74":115,"75":120,"76":238,"77":44,"78":190,"79":191,"80":25,"81":93,"82":229,"83":65,"84":118,"85":21,"86":195,"87":191,"88":6,"89":70,"90":70,"91":46,"92":248,"93":45,"94":210,"95":63,"96":187,"97":98,"98":43,"99":130,"100":139,"101":203,"102":178,"103":63,"104":18,"105":80,"106":183,"107":237,"108":212,"109":208,"110":171,"111":191,"112":127,"113":17,"114":13,"115":179,"116":161,"117":212,"118":214,"119":63,"120":118,"121":211,"122":139,"123":116,"124":13,"125":21,"126":216,"127":63,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":-0.272833806854509,"1":-0.1307992354662556,"2":-0.06047409136199869,"3":-0.030343138966675585,"4":-0.45851259877491374,"5":1.219569326263438,"6":-0.27136771988483344,"7":-0.33971364697101214,"8":0.6753212372111551,"9":-0.3903714965053561,"10":-0.09942713409677445,"11":0.23829467854022582,"12":-0.06719116819467384,"13":0.17283920727189817,"14":0.34153953468766024,"15":0.5808723479444033,"BYTES_PER_ELEMENT":8,"buffer":{"0":34,"1":187,"2":107,"3":237,"4":27,"5":118,"6":209,"7":191,"8":244,"9":173,"10":85,"11":131,"12":7,"13":190,"14":192,"15":191,"16":84,"17":105,"18":79,"19":201,"20":117,"21":246,"22":174,"23":191,"24":214,"25":84,"26":20,"27":150,"28":69,"29":18,"30":159,"31":191,"32":205,"33":179,"34":34,"35":58,"36":69,"37":88,"38":221,"39":191,"40":122,"41":25,"42":56,"43":32,"44":91,"45":131,"46":243,"47":63,"48":212,"49":27,"50":134,"51":182,"52":22,"53":94,"54":209,"55":191,"56":106,"57":180,"58":239,"59":78,"60":222,"61":189,"62":213,"63":191,"64":169,"65":183,"66":131,"67":72,"68":59,"69":156,"70":229,"71":63,"72":66,"73":253,"74":177,"75":186,"76":216,"77":251,"78":216,"79":191,"80":220,"81":216,"82":71,"83":129,"84":14,"85":116,"86":185,"87":191,"88":169,"89":15,"90":146,"91":165,"92":112,"93":128,"94":206,"95":63,"96":151,"97":229,"98":249,"99":189,"100":112,"101":51,"102":177,"103":191,"104":228,"105":132,"106":89,"107":91,"108":152,"109":31,"110":198,"111":63,"112":93,"113":146,"114":241,"115":162,"116":200,"117":219,"118":213,"119":63,"120":96,"121":77,"122":50,"123":155,"124":129,"125":150,"126":226,"127":63,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":0.43126034541738817,"1":-0.16890851572473597,"2":-0.27889608847204844,"3":-0.07499046902893124,"4":0.1329436515325012,"5":-0.9050764240020188,"6":0.24198877231762256,"7":0.15643782165647951,"8":-0.4923073447759514,"9":0.3112764022012672,"10":0.25701383444372855,"11":-0.27769976105332894,"12":0.30025852734909975,"13":0.3306641965026016,"14":-0.505606982054452,"15":-0.5894450836533925,"BYTES_PER_ELEMENT":8,"buffer":{"0":51,"1":71,"2":232,"3":253,"4":196,"5":153,"6":219,"7":63,"8":196,"9":221,"10":134,"11":83,"12":203,"13":158,"14":197,"15":191,"16":185,"17":16,"18":190,"19":250,"20":110,"21":217,"22":209,"23":191,"24":151,"25":175,"26":253,"27":75,"28":147,"29":50,"30":179,"31":191,"32":44,"33":126,"34":197,"35":45,"36":76,"37":4,"38":193,"39":63,"40":130,"41":4,"42":47,"43":213,"44":98,"45":246,"46":236,"47":191,"48":134,"49":59,"50":141,"51":243,"52":124,"53":249,"54":206,"55":63,"56":170,"57":159,"58":239,"59":143,"60":39,"61":6,"62":196,"63":63,"64":244,"65":43,"66":89,"67":170,"68":246,"69":129,"70":223,"71":191,"72":158,"73":36,"74":222,"75":219,"76":243,"77":235,"78":211,"79":63,"80":57,"81":139,"82":99,"83":39,"84":234,"85":114,"86":208,"87":63,"88":32,"89":48,"90":245,"91":55,"92":213,"93":197,"94":209,"95":191,"96":238,"97":206,"98":211,"99":138,"100":111,"101":55,"102":211,"103":63,"104":100,"105":244,"106":123,"107":41,"108":154,"109":41,"110":213,"111":63,"112":62,"113":179,"114":145,"115":177,"116":238,"117":45,"118":224,"119":191,"120":171,"121":137,"122":162,"123":239,"124":187,"125":220,"126":226,"127":191,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":0.21302160487549796,"1":-0.0373396060939552,"2":-0.45676212817898615,"3":0.015197745824825784,"4":0.29859512557476087,"5":-0.30962160581130105,"6":0.3402401703125077,"7":0.20908071228374298,"8":-0.5714850466447771,"9":0.258103143204705,"10":0.10241065969947827,"11":-0.09078274880601025,"12":-0.27741276733995934,"13":0.08458380158877318,"14":-0.4094332367426209,"15":-0.5858270529948841,"BYTES_PER_ELEMENT":8,"buffer":{"0":173,"1":14,"2":36,"3":189,"4":74,"5":68,"6":203,"7":63,"8":56,"9":194,"10":9,"11":70,"12":45,"13":30,"14":163,"15":191,"16":115,"17":32,"18":165,"19":56,"20":151,"21":59,"22":221,"23":191,"24":117,"25":10,"26":83,"27":234,"28":254,"29":31,"30":143,"31":63,"32":206,"33":171,"34":197,"35":186,"36":46,"37":28,"38":211,"39":63,"40":248,"41":12,"42":198,"43":35,"44":215,"45":208,"46":211,"47":191,"48":175,"49":197,"50":17,"51":181,"52":126,"53":198,"54":213,"55":63,"56":246,"57":212,"58":189,"59":34,"60":40,"61":195,"62":202,"63":63,"64":89,"65":193,"66":47,"67":2,"68":155,"69":73,"70":226,"71":191,"72":221,"73":198,"74":195,"75":11,"76":195,"77":132,"78":208,"79":63,"80":144,"81":201,"82":43,"83":194,"84":149,"85":55,"86":186,"87":63,"88":18,"89":173,"90":41,"91":201,"92":137,"93":61,"94":183,"95":191,"96":108,"97":243,"98":205,"99":122,"100":33,"101":193,"102":209,"103":191,"104":174,"105":90,"106":152,"107":181,"108":72,"109":167,"110":181,"111":63,"112":110,"113":30,"114":109,"115":118,"116":39,"117":52,"118":218,"119":191,"120":232,"121":51,"122":55,"123":96,"124":24,"125":191,"126":226,"127":191,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":0.15033836499376213,"1":-0.023565299901076125,"2":-0.36772830419034935,"3":-0.08589884855606995,"4":0.12268007113729457,"5":-0.412581502032541,"6":-0.12367152741018005,"7":0.15825467128482432,"8":-0.06792914127741673,"9":0.036781012921518585,"10":-0.022124071438292908,"11":-0.5078258020317232,"12":-0.05240565228243262,"13":0.33931721491464856,"14":-0.30622966299474885,"15":-0.3880877687550592,"BYTES_PER_ELEMENT":8,"buffer":{"0":166,"1":188,"2":125,"3":156,"4":73,"5":62,"6":195,"7":63,"8":27,"9":12,"10":149,"11":129,"12":128,"13":33,"14":152,"15":191,"16":231,"17":232,"18":19,"19":76,"20":220,"21":136,"22":215,"23":191,"24":245,"25":247,"26":79,"27":137,"28":119,"29":253,"30":181,"31":191,"32":156,"33":215,"34":103,"35":13,"36":246,"37":103,"38":191,"39":63,"40":61,"41":132,"42":138,"43":62,"44":188,"45":103,"46":218,"47":191,"48":175,"49":79,"50":172,"51":237,"52":239,"53":168,"54":191,"55":191,"56":57,"57":196,"58":205,"59":102,"60":176,"61":65,"62":196,"63":63,"64":188,"65":91,"66":59,"67":224,"68":205,"69":99,"70":177,"71":191,"72":144,"73":45,"74":57,"75":255,"76":245,"77":212,"78":162,"79":63,"80":139,"81":153,"82":32,"83":77,"84":177,"85":167,"86":150,"87":191,"88":176,"89":81,"90":121,"91":229,"92":27,"93":64,"94":224,"95":191,"96":235,"97":112,"98":91,"99":229,"100":233,"101":212,"102":170,"103":191,"104":87,"105":206,"106":65,"107":141,"108":95,"109":183,"110":213,"111":63,"112":190,"113":41,"114":232,"115":76,"116":68,"117":153,"118":211,"119":191,"120":47,"121":245,"122":177,"123":20,"124":110,"125":214,"126":216,"127":191,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}}],"biases":{"sx":1,"sy":1,"depth":16,"w":{"0":-0.010235482372221178,"1":-0.0015693192437123572,"2":-0.1405960069181526,"3":-0.11274332527770345,"4":-0.13373199233946675,"5":-0.020886013477531218,"6":-0.09070499267894701,"7":-0.028720550706144484,"8":-0.1415525558606107,"9":-0.17187631024080122,"10":-0.003532647324825346,"11":-0.09317454298126056,"12":-0.09446926377020352,"13":0.049054123642365284,"14":0.009319476243605325,"15":-0.0424060296471316,"BYTES_PER_ELEMENT":8,"buffer":{"0":74,"1":58,"2":97,"3":48,"4":87,"5":246,"6":132,"7":191,"8":72,"9":225,"10":9,"11":181,"12":51,"13":182,"14":89,"15":191,"16":30,"17":177,"18":212,"19":201,"20":12,"21":255,"22":193,"23":191,"24":126,"25":247,"26":232,"27":30,"28":191,"29":220,"30":188,"31":191,"32":132,"33":114,"34":195,"35":66,"36":33,"37":30,"38":193,"39":191,"40":48,"41":186,"42":81,"43":163,"44":36,"45":99,"46":149,"47":191,"48":213,"49":214,"50":35,"51":65,"52":113,"53":56,"54":183,"55":191,"56":239,"57":36,"58":6,"59":136,"60":235,"61":104,"62":157,"63":191,"64":157,"65":19,"66":11,"67":231,"68":100,"69":30,"70":194,"71":191,"72":129,"73":127,"74":184,"75":253,"76":10,"77":0,"78":198,"79":191,"80":158,"81":69,"82":79,"83":151,"84":127,"85":240,"86":108,"87":191,"88":85,"89":156,"90":236,"91":110,"92":73,"93":218,"94":183,"95":191,"96":219,"97":198,"98":94,"99":62,"100":35,"101":47,"102":184,"103":191,"104":209,"105":72,"106":142,"107":65,"108":159,"109":29,"110":169,"111":63,"112":145,"113":2,"114":117,"115":237,"116":22,"117":22,"118":131,"119":63,"120":131,"121":171,"122":249,"123":60,"124":62,"125":182,"126":165,"127":191,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}}},{"out_depth":16,"out_sx":1,"out_sy":1,"layer_type":"sigmoid"},{"out_depth":2,"out_sx":1,"out_sy":1,"layer_type":"fc","num_inputs":16,"l1_decay_mul":0,"l2_decay_mul":1,"filters":[{"sx":1,"sy":1,"depth":16,"w":{"0":-0.3759722768764831,"1":-0.3754254283808404,"2":0.1036348276890404,"3":0.06782176434761017,"4":0.37314526289484257,"5":-0.021785350645442417,"6":0.22213495686253187,"7":-0.2195615298734453,"8":0.14134448923543433,"9":0.47735421586198346,"10":-0.19691498964011725,"11":-0.010123399036331065,"12":0.5729536225967267,"13":-0.44540329952226887,"14":-0.6187571285675108,"15":0.17544714508110476,"BYTES_PER_ELEMENT":8,"buffer":{"0":25,"1":199,"2":88,"3":6,"4":238,"5":15,"6":216,"7":191,"8":71,"9":225,"10":62,"11":96,"12":248,"13":6,"14":216,"15":191,"16":127,"17":169,"18":166,"19":227,"20":207,"21":135,"22":186,"23":63,"24":44,"25":123,"26":212,"27":99,"28":196,"29":92,"30":177,"31":63,"32":91,"33":154,"34":50,"35":171,"36":156,"37":225,"38":215,"39":63,"40":132,"41":93,"42":55,"43":34,"44":230,"45":78,"46":150,"47":191,"48":222,"49":239,"50":130,"51":19,"52":235,"53":110,"54":204,"55":63,"56":2,"57":18,"58":34,"59":155,"60":151,"61":26,"62":204,"63":191,"64":185,"65":53,"66":94,"67":131,"68":147,"69":23,"70":194,"71":63,"72":80,"73":9,"74":111,"75":178,"76":248,"77":140,"78":222,"79":63,"80":137,"81":89,"82":76,"83":168,"84":130,"85":52,"86":201,"87":191,"88":182,"89":127,"90":72,"91":158,"92":147,"93":187,"94":132,"95":191,"96":116,"97":175,"98":229,"99":213,"100":162,"101":85,"102":226,"103":63,"104":254,"105":161,"106":62,"107":215,"108":124,"109":129,"110":220,"111":191,"112":143,"113":168,"114":235,"115":191,"116":219,"117":204,"118":227,"119":191,"120":134,"121":99,"122":38,"123":83,"124":13,"125":117,"126":198,"127":63,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}},{"sx":1,"sy":1,"depth":16,"w":{"0":0.3093039393764935,"1":0.20147455556518265,"2":-0.13404390712930891,"3":-0.14782933181657587,"4":0.00216032944797874,"5":0.27763574205861674,"6":-0.007772610376730164,"7":0.1634410237562346,"8":-0.08299122730134843,"9":-0.37690884476048986,"10":0.3443127865513931,"11":-0.38221378743184925,"12":-0.3777576266604131,"13":0.39267719512035276,"14":0.19835226209206158,"15":0.5324302664494638,"BYTES_PER_ELEMENT":8,"buffer":{"0":42,"1":88,"2":9,"3":192,"4":162,"5":203,"6":211,"7":63,"8":199,"9":117,"10":144,"11":17,"12":235,"13":201,"14":201,"15":63,"16":200,"17":153,"18":172,"19":202,"20":89,"21":40,"22":193,"23":191,"24":68,"25":87,"26":197,"27":80,"28":18,"29":236,"30":194,"31":191,"32":32,"33":37,"34":124,"35":10,"36":138,"37":178,"38":97,"39":63,"40":182,"41":234,"42":21,"43":180,"44":200,"45":196,"46":209,"47":63,"48":4,"49":50,"50":246,"51":53,"52":44,"53":214,"54":127,"55":191,"56":244,"57":203,"58":237,"59":173,"60":162,"61":235,"62":196,"63":63,"64":207,"65":59,"66":29,"67":191,"68":233,"69":62,"70":181,"71":191,"72":201,"73":113,"74":116,"75":70,"76":70,"77":31,"78":216,"79":191,"80":156,"81":77,"82":117,"83":127,"84":56,"85":9,"86":214,"87":63,"88":217,"89":103,"90":70,"91":209,"92":48,"93":118,"94":216,"95":191,"96":30,"97":140,"98":20,"99":83,"100":46,"101":45,"102":216,"103":191,"104":193,"105":82,"106":187,"107":135,"108":159,"109":33,"110":217,"111":63,"112":124,"113":242,"114":98,"115":95,"116":155,"117":99,"118":201,"119":63,"120":230,"121":161,"122":185,"123":50,"124":171,"125":9,"126":225,"127":63,"byteLength":128},"length":16,"byteOffset":0,"byteLength":128}}],"biases":{"sx":1,"sy":1,"depth":2,"w":{"0":-0.04284965105420425,"1":0.04284965105420421,"BYTES_PER_ELEMENT":8,"buffer":{"0":193,"1":123,"2":216,"3":179,"4":99,"5":240,"6":165,"7":191,"8":188,"9":123,"10":216,"11":179,"12":99,"13":240,"14":165,"15":63,"byteLength":16},"length":2,"byteOffset":0,"byteLength":16}}},{"out_depth":2,"out_sx":1,"out_sy":1,"layer_type":"softmax","num_inputs":2}]};

},{}],2:[function(require,module,exports){
(function() {
  var $, AV, DialogView, UserView;

  $ = require('jquery');

  AV = window.AV;

  DialogView = require('./dialog-view.coffee');

  UserView = (function() {
    function UserView() {
      if (UserView.instance) {
        return UserView.instance;
      }
      UserView.instance = this;
      this.updateNav();
      this.bind(AV);
    }

    UserView.prototype.updateNav = function() {
      var html, user;
      user = AV.User.current();
      if (user != null) {
        html = "<li>" + user.attributes.username + "</li>";
        html += '<li id="logout">Logout</li>';
        $('#nav-favorite').show();
      } else {
        html = "<li id=\"login-button\">Login</li><li id=\"signup-button\">Signup</li>";
        $('#nav-favorite').hide();
      }
      return $('#user').html("<ul>" + html + "</ul>");
    };

    UserView.prototype.displayLoginView = function() {
      var $view, dialogView, html,
        _this = this;
      html = "<div id=\"login\">\n    <h2>Login</h2>\n    <input type=\"text\" placeholder=\"Username\" class=\"username\">\n    <input type=\"password\" placeholder=\"Password\" class=\"password\">\n    <div class=\"submit\">Login</div>\n    <div id=\"reset-password-button\">Forgot password?</div>\n</div>";
      $view = $(html);
      $view.find('#reset-password-button').click(function() {
        return _this.displayPasswordResetView();
      });
      dialogView = new DialogView($view);
      return $view.find('.submit').click(function() {
        var $this, handler, password, user, username;
        user = new AV.User();
        username = $view.find('.username').val();
        password = $view.find('.password').val();
        $this = $(_this);
        handler = {
          success: function(user) {
            _this.updateNav();
            return dialogView.hide();
          },
          error: function(user, error) {
            return alert("Error: " + error.code + " " + error.message);
          }
        };
        return AV.User.logIn(username, password, handler);
      });
    };

    UserView.prototype.displaySignupView = function() {
      var $view, dialogView, html,
        _this = this;
      html = "<div id=\"signup\">\n    <h2>Sign Up</h2>\n    <input type=\"text\" placeholder=\"Username\" class=\"username\">\n    <input type=\"password\" placeholder=\"Password\" class=\"password\">\n    <input type=\"email\" placeholder=\"Email\" class=\"email\">\n    <div class=\"submit\">Submit</div>\n</div>";
      $view = $(html);
      dialogView = new DialogView($view);
      return $view.find('.submit').click(function() {
        var email, handler, password, user, username;
        user = new AV.User();
        username = $view.find('.username').val();
        password = $view.find('.password').val();
        email = $view.find('.email').val();
        user.set("username", username);
        user.set("password", password);
        user.set("email", email);
        handler = {
          success: function(user) {
            _this.updateNav();
            return dialogView.hide();
          },
          error: function(user, error) {
            return alert("Error: " + error.code + " " + error.message);
          }
        };
        return user.signUp(null, handler);
      });
    };

    UserView.prototype.displayPasswordResetView = function() {
      var $view, dialogView, html;
      html = "<div id=\"password-reset\">\n    <h2>Reset Password</h2>\n    <input type=\"email\" placeholder=\"Email\" class=\"email\">\n    <div class=\"submit\">Reset</div>\n</div>";
      $view = $(html);
      dialogView = new DialogView($view);
      return $view.find('.submit').click(function() {
        var email, handler;
        email = $('#password-reset .email').val();
        handler = {
          success: function() {
            return dialogView.hide();
          },
          error: function(error) {
            return alert("Error: " + error.code + " " + error.message);
          }
        };
        return AV.User.requestPasswordReset(email, handler);
      });
    };

    UserView.prototype.bind = function(AV) {
      var _this = this;
      $('#user').on('click', '#login-button', function() {
        return _this.displayLoginView();
      });
      $('#user').on('click', '#signup-button', function() {
        return _this.displaySignupView();
      });
      return $('#user').on('click', '#logout', function() {
        AV.User.logOut();
        return self.updateNav();
      });
    };

    return UserView;

  })();

  module.exports = UserView;

}).call(this);


},{"./dialog-view.coffee":10,"jquery":6}],4:[function(require,module,exports){
(function() {
  var $, AV, ExploreView, SchemesView;

  SchemesView = require('./schemes-view.coffee');

  $ = require('jquery');

  AV = window.AV;

  ExploreView = (function() {
    function ExploreView() {
      var Scheme, query;
      Scheme = AV.Object.extend('Scheme');
      query = new AV.Query(Scheme);
      query.equalTo('score', 1);
      query.limit(100).find({
        success: function(schemes) {
          schemes = schemes.map(function(scheme) {
            return JSON.parse(scheme.attributes.colors);
          });
          new SchemesView(schemes);
          return $('#image').hide();
        }
      });
    }

    return ExploreView;

  })();

  module.exports = ExploreView;

}).call(this);


},{"./schemes-view.coffee":11,"jquery":6}],5:[function(require,module,exports){
(function() {
  var $, AV, FavoriteView, SchemesView;

  SchemesView = require('./schemes-view.coffee');

  $ = require('jquery');

  AV = window.AV;

  FavoriteView = (function() {
    function FavoriteView() {
      var Scheme, query, user, username;
      user = AV.User.current();
      if (user) {
        username = user.attributes.username;
        Scheme = AV.Object.extend("Scheme");
        query = new AV.Query(Scheme);
        query.descending("updatedAt");
        query.equalTo("owner", username);
        query.equalTo("score", 1);
        query.limit(100).find({
          success: function(schemes) {
            var score;
            schemes = schemes.map(function(scheme) {
              return JSON.parse(scheme.attributes.colors);
            });
            new SchemesView(schemes, score = 1);
            return $('#image').hide();
          }
        });
      }
    }

    return FavoriteView;

  })();

  module.exports = FavoriteView;

}).call(this);


},{"./schemes-view.coffee":11,"jquery":6}],3:[function(require,module,exports){
(function() {
  var $, GenePool, ImageView, SchemesView, colorsClustering, fitness, parseImage;

  colorsClustering = require("colors-clustering");

  GenePool = require('gene-pool');

  fitness = require('../fitness.coffee');

  $ = require('jquery');

  SchemesView = require('./schemes-view.coffee');

  parseImage = function(url) {
    var config, displayColors;
    config = {
      src: url,
      minCount: 7
    };
    displayColors = function(clusters) {
      var html;
      html = clusters.map(function(cluster) {
        var color;
        color = cluster.color;
        return "<div class='color' style='background: rgb(" + (color.join(',')) + ")'></div>";
      });
      html = "<div class='colors'>" + (html.join('')) + "</div>";
      return $("#colors").html(html);
    };
    colorsClustering(config, function(clusters) {
      var colorSchemes, opts;
      clusters.sort(function(a, b) {
        return b.weight - a.weight;
      });
      displayColors(clusters);
      opts = {
        genes: clusters.map(function(color) {
          return color.color;
        }),
        weights: clusters.map(function(color) {
          return color.weight;
        }),
        K: 20,
        N: 5,
        mutationRate: 0.2,
        birthRate: 1,
        fitness: fitness
      };
      colorSchemes = new GenePool(opts);
      return colorSchemes.timeout(800, function(err, schemes) {
        if (err) {
          console.error(err);
        }
        return new SchemesView(schemes);
      });
    });
    return $('#image').css({
      backgroundImage: "url(" + url + ")"
    });
  };

  ImageView = (function() {
    function ImageView(url) {
      var target;
      if (url == null) {
        url = './static/images/default.jpg';
      }
      $('#image').show();
      parseImage(url);
      target = $('#image')[0];
      target.ondragover = function(event) {
        return event.preventDefault();
      };
      target.ondragend = function(event) {
        return event.preventDefault();
      };
      target.ondragenter = function(event) {
        return event.preventDefault();
      };
      target.ondragleave = function(event) {
        return event.preventDefault();
      };
      target.ondrag = function(event) {
        return event.preventDefault();
      };
      target.ondrop = function(event) {
        event.preventDefault();
        url = URL.createObjectURL(event.dataTransfer.files[0]);
        return parseImage(url);
      };
      $('#load-image').on('click', function() {
        var $input;
        $input = $('<input type="file">');
        $('body').append($input);
        $input.on('change', function(e) {
          var files;
          files = $input[0].files;
          if (files) {
            url = URL.createObjectURL(files[0]);
            parseImage(url);
            return $input.remove();
          }
        });
        return $input.click();
      });
    }

    return ImageView;

  })();

  module.exports = ImageView;

}).call(this);


},{"../fitness.coffee":7,"./schemes-view.coffee":11,"gene-pool":12,"jquery":6,"colors-clustering":13}],14:[function(require,module,exports){
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot

module.exports = Math.hypot || function() {
    var y = 0;
    var length = arguments.length;

    for (var i = 0; i < length; i++) {
        if (arguments[i] === Infinity || arguments[i] === -Infinity) {
            return Infinity;
        }
        y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
};

},{}],15:[function(require,module,exports){
(function() {
  var generate;

  generate = function(name, schemes) {
    var gpl;
    gpl = "GIMP Palette\nName: " + name + "\n#";
    gpl += '\n';
    schemes.forEach(function(scheme) {
      gpl += scheme.join(' ');
      return gpl += '\n';
    });
    return gpl;
  };

  module.exports = generate;

}).call(this);


},{}],10:[function(require,module,exports){
(function() {
  var $, DialogView;

  $ = require('jquery');

  DialogView = (function() {
    function DialogView($children) {
      var $view;
      $view = $('#dialog');
      $view.html('');
      $view.append($children);
      if (!DialogView.bound) {
        this.bind();
        DialogView.bound = true;
      }
      $view.fadeIn();
    }

    DialogView.prototype.bind = function() {
      var $view,
        _this = this;
      $(document).on('keydown', function(e) {
        if (e.keyCode === 27) {
          return _this.hide();
        }
      });
      $view = $('#dialog');
      return $view.on('click', function(e) {
        if (e.target.id === 'dialog') {
          return _this.hide();
        }
      });
    };

    DialogView.prototype.hide = function() {
      return $('#dialog').fadeOut();
    };

    return DialogView;

  })();

  module.exports = DialogView;

}).call(this);


},{"jquery":6}],12:[function(require,module,exports){
var GenePool = require('./gene-pool');

// N: 个体基因数
// K: 种群规模（种群稳定时的数量）
// genes: 基因
// weights: 基因权重，影响出现的可能性大小
// mutationRate: 基因突变率，大约有多少比例的基因需要突变
// birthRate: 出生率

// timeout: 最大时限

function Population(opts) {

    // allow use object for gene
    var genes = opts.genes.map(function(gene, index) {
        return index;
    });
    this.oriGenes = opts.genes;
    this.fitness = function(individual) {
        individual = individual.map(function(geneIndex) {
            return opts.genes[geneIndex];
        });
        return opts.fitness(individual);
    };

    this.genePool = GenePool(genes, opts.N, opts.weights);
    this.K = opts.K;
    this.N = opts.N;
    // the very first generation
    this.population = [];
    this.history = {}; // 记住产生过的个体

    // 默认尝试1000次仍无新结果则取消尝试
    this.maxLoop = opts.maxLoop || 1000;

    this.birthRate = opts.birthRate;
    this.mutationRate = opts.mutationRate;
}

var population = Population.prototype;

// 繁殖
population.reproduce = function() {
    var child,
        gene;

    var maxLoop = this.maxLoop;

    // 初代基因总是由突变产生
    var mutationRate = this.population.length > 0 ? this.mutationRate : 2;

    while(this.population.length < this.K * (1 + this.birthRate)) {
        if(maxLoop < 0) {
            throw new Error('Fail to get new individual: exceeds the maxLoop, opts.maxLoop=' + this.maxLoop);
        }
        maxLoop--;
        child = [];
        while(child.length < this.N) {
            if(Math.random() < mutationRate) {
                // 基因突变
                gene = this.genePool.getRandomGene();
            } else {
                // 从当前种群里获取基因
                gene = this.getRandomGene();
            }
            if(child.indexOf(gene) < 0) {
                child.push(gene);
            }
        }
        // try to add child
        child.sort();
        var id = JSON.stringify(child);
        if(!this.history[id]) {
            this.history[id] = 1;
            this.population.push(child);
        }
    }
};

// 人工定向选择
population.select = function() {
    var self = this;

    // Sort by fitness
    var fitness = this.population.map(function(individual, i) {
        return {index: i, fitness: self.fitness(individual)};
    }).sort(function(a, b) {
        return b.fitness - a.fitness;
    });

    var population = fitness.map(function(elem) {
        return self.population[elem.index];
    });

    // kill weaker invididuals
    while(population.length > this.K) {
        population.pop();
    }

    this.population = population;
};

// 从当前种群中随机获取基因
population.getRandomGene = function() {
    var random = Math.random();
    // 随机选择，越靠前（fitness较高）的基因有较大概率得到遗传
    var individual = this.population[(random * random * this.population.length) | 0]; 
    return individual[(this.N * random) | 0];
};

// 下一代
population.next = function() {

    // 先繁殖
    this.reproduce();

    // 定向选择
    this.select();

};

population.toArray = function() {
    var genes = this.oriGenes;
    return this.population.map(function(individual) {
        return individual.map(function(geneIndex) {
            return genes[geneIndex];
        });
    });
};

population.timeout = function(timeout, callback) {
    var self = this;
    var end = Date.now() + timeout;
    var iter = function() {
        if(Date.now() < end) {
            try {
                self.next();
                setTimeout(iter, 1);
            } catch(e) {
                self.select();
                callback(null, self.toArray());
            }
        } else {
            callback(null, self.toArray());
        }
    };
    iter();
};

module.exports = Population;

},{"./gene-pool":16}],11:[function(require,module,exports){
(function() {
  var $, AV, DetailView, SchemesView, getScore, setScore;

  AV = window.AV;

  $ = require('jquery');

  DetailView = require('./detail-view.coffee');

  getScore = function($scheme) {
    if ($scheme.find('.fa-heart-o').hasClass('selected')) {
      return 1;
    } else if ($scheme.find('.fa-trash-o').hasClass('selected')) {
      return -1;
    } else {
      return 0;
    }
  };

  setScore = function($scheme, score) {
    var Scheme, colors, length, query, user, username;
    colors = $scheme.data('scheme');
    colors.sort(function(a, b) {
      return a.some(function(elem, index) {
        return elem > b[index];
      });
    });
    length = colors.length;
    colors = JSON.stringify(colors);
    user = AV.User.current();
    if (!user) {
      $('#login-button').click();
      return;
    }
    $scheme.find('.fa-heart-o').toggleClass('selected', score > 0);
    $scheme.find('.fa-trash-o').toggleClass('selected', score < 0);
    username = user.attributes.username;
    Scheme = AV.Object.extend("Scheme");
    query = new AV.Query(Scheme);
    query.equalTo("colors", colors);
    query.equalTo("owner", username);
    return query.find({
      success: function(record) {
        var ACL, scheme;
        if (record.length === 0) {
          scheme = new Scheme();
          scheme.set('colors', colors);
          scheme.set('length', length);
          scheme.set('score', score);
          scheme.set('owner', username);
          ACL = new AV.ACL(AV.User.current());
          ACL.setPublicReadAccess(true);
          scheme.setACL(ACL);
          return scheme.save();
        } else {
          scheme = record[0];
          scheme.set('score', score);
          return scheme.save();
        }
      }
    });
  };

  SchemesView = (function() {
    function SchemesView(schemes, score) {
      var $container;
      this.score = score != null ? score : 0;
      $container = $('#schemes');
      $container.html('');
      $container.append(this.generate(schemes));
    }

    SchemesView.prototype.generate = function(schemes) {
      var _this = this;
      return schemes.map(function(colors) {
        return _this.generateScheme(colors);
      });
    };

    SchemesView.prototype.generateScheme = function(colors) {
      var $scheme, colorsHTML, html;
      colors.sort(function(a, b) {
        return a.some(function(elem, index) {
          return elem > b[index];
        });
      });
      colorsHTML = colors.map(function(color) {
        return "<div class='color' style='background: rgb(" + (color.join(',')) + ")'></div>";
      });
      html = "<div class='scheme' data-scheme='" + (JSON.stringify(colors)) + "'>            <div class='colors'>" + (colorsHTML.join('')) + "</div>            <i class='fa fa-download detail button'></i>            <i class='fa fa-heart-o button'></i>            <i class='fa fa-trash-o button'></i></div>";
      $scheme = $(html);
      $scheme.find('.fa-heart-o').toggleClass('selected', this.score > 0);
      $scheme.find('.fa-trash-o').toggleClass('selected', this.score < 0);
      $scheme.on('click', '.fa-heart-o', function() {
        if (getScore($scheme) === 1) {
          return setScore($scheme, 0);
        } else {
          return setScore($scheme, 1);
        }
      });
      $scheme.on('click', '.fa-trash-o', function() {
        if (getScore($scheme) === -1) {
          return setScore($scheme, 0);
        } else {
          return setScore($scheme, -1);
        }
      });
      $scheme.on('click', '.detail, .colors', function() {
        return new DetailView(colors);
      });
      return $scheme[0];
    };

    return SchemesView;

  })();

  module.exports = SchemesView;

}).call(this);


},{"./detail-view.coffee":17,"jquery":6}],16:[function(require,module,exports){
// genes: 基因库
// n: 单个个体基因数
// weights: 每个基因的权重，影响出现的随机程度

function GenePool(genes, n, weights) {

    if(n > genes.length) {
        throw new Error("n must <= genes.length");
    }

    weights = weights || genes.map(function() { return 1; });

    // 随机取得一条基因
    var getRandomGene = (function(genes, weights) {
        var sum = 0;
        var weightBounds = weights.map(function(weight) {
            sum += weight;
            return sum;
        });
        return (function() {
            var random = Math.random() * sum;
            for(var i = 0; i < weightBounds.length; i++) {
                if(random < weightBounds[i]) {
                    return genes[i];
                }
            }
            return genes[weightBounds.length - 1];
        });
    })(genes, weights);

    // 获取一个随机个体（数组），该个体内含 n 条不重复的基因
    var getRandomIndividual = function() {
        var genes = [],
            gene = null;
        while(genes.length < n) {
            gene = getRandomGene();
            if(genes.indexOf(gene) < 0) {
                genes.push(gene);
            } else {
                genes = []; // 保证概率分布结果符合预期，见：https://github.com/zenozeng/gene-pool/issues/2
            }
        }
        return genes;
    };

    return {
        getRandomGene: getRandomGene,
        getRandomIndividual: getRandomIndividual
    };
}

module.exports = GenePool;



},{}],18:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],8:[function(require,module,exports){
(function(process){(function() {
  var ANN, Promise, converter, convnet, hypot, math, _;

  converter = require('color-convert')();

  _ = require('lodash');

  math = require('mathjs');

  convnet = require('convnetjs');

  Promise = require('promise');

  hypot = require('./lib/hypot');

  ANN = (function() {
    function ANN(options) {
      var defaults, layers;
      if (options == null) {
        options = {};
      }
      defaults = {
        iterations: 1000
      };
      layers = [
        {
          type: 'input',
          out_sx: 16,
          out_sy: 1,
          out_depth: 1
        }, {
          type: 'fc',
          num_neurons: 16,
          activation: 'sigmoid'
        }, {
          type: 'softmax',
          num_classes: 2
        }
      ];
      this.net = new convnet.Net();
      this.net.makeLayers(layers);
      this.options = _.defaults(options, defaults);
      this.trainer = new convnet.Trainer(this.net, {
        method: 'adadelta',
        learning_rate: 0.05,
        l2_decay: 0.0005,
        batch_size: 5
      });
    }

    ANN.prototype.preprocess = function(colors) {
      var c1, c2, d, distance, hslMatrix, vector, _i, _j, _len, _len1;
      hslMatrix = colors.map(function(rgb) {
        var hsl;
        hsl = converter.rgb(rgb).hsl();
        return hsl.map(function(elem, index) {
          if (index === 0) {
            elem /= 360;
          } else {
            elem /= 100;
          }
          return parseFloat(elem.toFixed(3));
        });
      });
      vector = _.flatten(hslMatrix);
      distance = [];
      for (_i = 0, _len = hslMatrix.length; _i < _len; _i++) {
        c1 = hslMatrix[_i];
        for (_j = 0, _len1 = hslMatrix.length; _j < _len1; _j++) {
          c2 = hslMatrix[_j];
          if (c1 !== c2) {
            d = c1.map(function(elem, i) {
              return elem - c2[i];
            });
            distance.push(hypot.apply(null, d));
          }
        }
      }
      vector.push(Math.min.apply(null, distance));
      return new convnet.Vol(vector);
    };

    ANN.prototype.train = function(data) {
      var error, getError, trainData, trainLabels, __, _i, _ref,
        _this = this;
      trainLabels = data.map(function(scheme) {
        if (scheme.score > 0) {
          return 0;
        } else {
          return 1;
        }
      });
      trainData = data.map(function(scheme) {
        return _this.preprocess(scheme.colors);
      });
      getError = function() {
        var count, unmatchCount;
        count = 0;
        unmatchCount = 0;
        trainData.forEach(function(data, i) {
          var isPositive, isReallyPositive;
          isPositive = _this.rate(data, true) > 0;
          isReallyPositive = trainLabels[i] === 0;
          count++;
          if (isPositive !== isReallyPositive) {
            return unmatchCount++;
          }
        });
        return unmatchCount / count;
      };
      for (__ = _i = 0, _ref = this.options.iterations; 0 <= _ref ? _i <= _ref : _i >= _ref; __ = 0 <= _ref ? ++_i : --_i) {
        trainData.forEach(function(data, i) {
          return _this.trainer.train(data, trainLabels[i]);
        });
        error = getError();
        console.log(process.pid, error);
        if (error < 0.32) {
          break;
        }
      }
      return new Promise(function(resolve, reject) {
        return resolve();
      });
    };

    ANN.prototype.verify = function(data) {
      var getResults, res,
        _this = this;
      getResults = function(data) {
        var passed, rate, tests;
        tests = data.map(function(scheme) {
          var rate;
          rate = _this.rate(scheme);
          return scheme.score * rate > 0;
        });
        passed = (tests.filter(function(elem) {
          return elem;
        })).length;
        rate = passed / tests.length;
        return {
          total: tests.length,
          passed: passed,
          rate: rate
        };
      };
      return res = {
        all: getResults(data),
        positive: getResults(data.filter(function(scheme) {
          return scheme.score > 0;
        })),
        negative: getResults(data.filter(function(scheme) {
          return scheme.score < 0;
        })),
        network: this.toJSON()
      };
    };

    ANN.prototype.rate = function(scheme, preprocessed) {
      var input, negative, positive, w;
      if (preprocessed == null) {
        preprocessed = false;
      }
      if (!preprocessed) {
        input = this.preprocess(scheme.colors);
      } else {
        input = scheme;
      }
      w = this.net.forward(input).w;
      positive = w[0];
      negative = w[1];
      return positive - negative;
    };

    ANN.prototype.toJSON = function() {
      return JSON.stringify(this.net.toJSON());
    };

    return ANN;

  })();

  ANN.fromJSON = function(json) {
    var ann;
    ann = new ANN;
    ann.net.fromJSON(json);
    return ann;
  };

  module.exports = ANN;

}).call(this);


})(require("__browserify_process"))
},{"./lib/hypot":14,"lodash":19,"convnetjs":20,"promise":21,"color-convert":22,"mathjs":23,"__browserify_process":18}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Canvas, Image, calcClusters, clustering;

  calcClusters = require("./lib/clustering.js");

  Canvas = require("canvas-browserify");

  Image = Canvas.Image;

  clustering = function(config, callback) {
    var defaultConfig, img, k, timeImgStart, v;
    defaultConfig = {
      debug: false,
      maxWidth: 30,
      maxHeight: 30,
      minCount: 1
    };
    for (k in config) {
      v = config[k];
      defaultConfig[k] = v;
    }
    config = defaultConfig;
    img = new Image;
    timeImgStart = (new Date()).getTime();
    img.onload = function() {
      var canvas, ctx, height, i, image, imgData, pixels, scale, timeStart, width, _ref;
      if (config.debug) {
        console.log("load image in " + ((new Date()).getTime() - timeImgStart) + "ms");
      }
      timeStart = (new Date()).getTime();
      image = this;
      scale = Math.max(image.width / config.maxWidth, image.height / config.maxHeight, 1);
      _ref = [image.width, image.height].map(function(elem) {
        return parseInt(elem / scale);
      }), width = _ref[0], height = _ref[1];
      canvas = new Canvas(width, height);
      ctx = canvas.getContext("2d");
      ctx.drawImage(this, 0, 0, image.width, image.height, 0, 0, width, height);
      imgData = ctx.getImageData(0, 0, width, height);
      pixels = [];
      i = 0;
      while (i < imgData.data.length) {
        pixels.push([imgData.data[i], imgData.data[i + 1], imgData.data[i + 2], imgData.data[i + 3]]);
        i += 4;
      }
      if (config.debug) {
        console.log("parse image in " + ((new Date()).getTime() - timeStart) + "ms");
      }
      return typeof callback === "function" ? callback(calcClusters(pixels, config)) : void 0;
    };
    return img.src = config.src;
  };

  module.exports = clustering;

}).call(this);

},{"./lib/clustering.js":24,"canvas-browserify":25}],20:[function(require,module,exports){
(function(){var convnetjs = convnetjs || { REVISION: 'ALPHA' };
(function(global) {
  "use strict";

  // Random number utilities
  var return_v = false;
  var v_val = 0.0;
  var gaussRandom = function() {
    if(return_v) { 
      return_v = false;
      return v_val; 
    }
    var u = 2*Math.random()-1;
    var v = 2*Math.random()-1;
    var r = u*u + v*v;
    if(r == 0 || r > 1) return gaussRandom();
    var c = Math.sqrt(-2*Math.log(r)/r);
    v_val = v*c; // cache this
    return_v = true;
    return u*c;
  }
  var randf = function(a, b) { return Math.random()*(b-a)+a; }
  var randi = function(a, b) { return Math.floor(Math.random()*(b-a)+a); }
  var randn = function(mu, std){ return mu+gaussRandom()*std; }

  // Array utilities
  var zeros = function(n) {
    if(typeof(n)==='undefined' || isNaN(n)) { return []; }
    if(typeof ArrayBuffer === 'undefined') {
      // lacking browser support
      var arr = new Array(n);
      for(var i=0;i<n;i++) { arr[i]= 0; }
      return arr;
    } else {
      return new Float64Array(n);
    }
  }

  var arrContains = function(arr, elt) {
    for(var i=0,n=arr.length;i<n;i++) {
      if(arr[i]===elt) return true;
    }
    return false;
  }

  var arrUnique = function(arr) {
    var b = [];
    for(var i=0,n=arr.length;i<n;i++) {
      if(!arrContains(b, arr[i])) {
        b.push(arr[i]);
      }
    }
    return b;
  }

  // return max and min of a given non-empty array.
  var maxmin = function(w) {
    if(w.length === 0) { return {}; } // ... ;s
    var maxv = w[0];
    var minv = w[0];
    var maxi = 0;
    var mini = 0;
    var n = w.length;
    for(var i=1;i<n;i++) {
      if(w[i] > maxv) { maxv = w[i]; maxi = i; } 
      if(w[i] < minv) { minv = w[i]; mini = i; } 
    }
    return {maxi: maxi, maxv: maxv, mini: mini, minv: minv, dv:maxv-minv};
  }

  // create random permutation of numbers, in range [0...n-1]
  var randperm = function(n) {
    var i = n,
        j = 0,
        temp;
    var array = [];
    for(var q=0;q<n;q++)array[q]=q;
    while (i--) {
        j = Math.floor(Math.random() * (i+1));
        temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    return array;
  }

  // sample from list lst according to probabilities in list probs
  // the two lists are of same size, and probs adds up to 1
  var weightedSample = function(lst, probs) {
    var p = randf(0, 1.0);
    var cumprob = 0.0;
    for(var k=0,n=lst.length;k<n;k++) {
      cumprob += probs[k];
      if(p < cumprob) { return lst[k]; }
    }
  }

  // syntactic sugar function for getting default parameter values
  var getopt = function(opt, field_name, default_value) {
    return typeof opt[field_name] !== 'undefined' ? opt[field_name] : default_value;
  }

  global.randf = randf;
  global.randi = randi;
  global.randn = randn;
  global.zeros = zeros;
  global.maxmin = maxmin;
  global.randperm = randperm;
  global.weightedSample = weightedSample;
  global.arrUnique = arrUnique;
  global.arrContains = arrContains;
  global.getopt = getopt;
  
})(convnetjs);
(function(global) {
  "use strict";

  // Vol is the basic building block of all data in a net.
  // it is essentially just a 3D volume of numbers, with a
  // width (sx), height (sy), and depth (depth).
  // it is used to hold data for all filters, all volumes,
  // all weights, and also stores all gradients w.r.t. 
  // the data. c is optionally a value to initialize the volume
  // with. If c is missing, fills the Vol with random numbers.
  var Vol = function(sx, sy, depth, c) {
    // this is how you check if a variable is an array. Oh, Javascript :)
    if(Object.prototype.toString.call(sx) === '[object Array]') {
      // we were given a list in sx, assume 1D volume and fill it up
      this.sx = 1;
      this.sy = 1;
      this.depth = sx.length;
      // we have to do the following copy because we want to use
      // fast typed arrays, not an ordinary javascript array
      this.w = global.zeros(this.depth);
      this.dw = global.zeros(this.depth);
      for(var i=0;i<this.depth;i++) {
        this.w[i] = sx[i];
      }
    } else {
      // we were given dimensions of the vol
      this.sx = sx;
      this.sy = sy;
      this.depth = depth;
      var n = sx*sy*depth;
      this.w = global.zeros(n);
      this.dw = global.zeros(n);
      if(typeof c === 'undefined') {
        // weight normalization is done to equalize the output
        // variance of every neuron, otherwise neurons with a lot
        // of incoming connections have outputs of larger variance
        var scale = Math.sqrt(1.0/(sx*sy*depth));
        for(var i=0;i<n;i++) { 
          this.w[i] = global.randn(0.0, scale);
        }
      } else {
        for(var i=0;i<n;i++) { 
          this.w[i] = c;
        }
      }
    }
  }

  Vol.prototype = {
    get: function(x, y, d) { 
      var ix=((this.sx * y)+x)*this.depth+d;
      return this.w[ix];
    },
    set: function(x, y, d, v) { 
      var ix=((this.sx * y)+x)*this.depth+d;
      this.w[ix] = v; 
    },
    add: function(x, y, d, v) { 
      var ix=((this.sx * y)+x)*this.depth+d;
      this.w[ix] += v; 
    },
    get_grad: function(x, y, d) { 
      var ix = ((this.sx * y)+x)*this.depth+d;
      return this.dw[ix]; 
    },
    set_grad: function(x, y, d, v) { 
      var ix = ((this.sx * y)+x)*this.depth+d;
      this.dw[ix] = v; 
    },
    add_grad: function(x, y, d, v) { 
      var ix = ((this.sx * y)+x)*this.depth+d;
      this.dw[ix] += v; 
    },
    cloneAndZero: function() { return new Vol(this.sx, this.sy, this.depth, 0.0)},
    clone: function() {
      var V = new Vol(this.sx, this.sy, this.depth, 0.0);
      var n = this.w.length;
      for(var i=0;i<n;i++) { V.w[i] = this.w[i]; }
      return V;
    },
    addFrom: function(V) { for(var k=0;k<this.w.length;k++) { this.w[k] += V.w[k]; }},
    addFromScaled: function(V, a) { for(var k=0;k<this.w.length;k++) { this.w[k] += a*V.w[k]; }},
    setConst: function(a) { for(var k=0;k<this.w.length;k++) { this.w[k] = a; }},

    toJSON: function() {
      // todo: we may want to only save d most significant digits to save space
      var json = {}
      json.sx = this.sx; 
      json.sy = this.sy;
      json.depth = this.depth;
      json.w = this.w;
      return json;
      // we wont back up gradients to save space
    },
    fromJSON: function(json) {
      this.sx = json.sx;
      this.sy = json.sy;
      this.depth = json.depth;

      var n = this.sx*this.sy*this.depth;
      this.w = global.zeros(n);
      this.dw = global.zeros(n);
      // copy over the elements.
      for(var i=0;i<n;i++) {
        this.w[i] = json.w[i];
      }
    }
  }

  global.Vol = Vol;
})(convnetjs);
(function(global) {
  "use strict";
  var Vol = global.Vol; // convenience

  // Volume utilities
  // intended for use with data augmentation
  // crop is the size of output
  // dx,dy are offset wrt incoming volume, of the shift
  // fliplr is boolean on whether we also want to flip left<->right
  var augment = function(V, crop, dx, dy, fliplr) {
    // note assumes square outputs of size crop x crop
    if(typeof(fliplr)==='undefined') var fliplr = false;
    if(typeof(dx)==='undefined') var dx = global.randi(0, V.sx - crop);
    if(typeof(dy)==='undefined') var dy = global.randi(0, V.sy - crop);
    
    // randomly sample a crop in the input volume
    var W;
    if(crop !== V.sx || dx!==0 || dy!==0) {
      W = new Vol(crop, crop, V.depth, 0.0);
      for(var x=0;x<crop;x++) {
        for(var y=0;y<crop;y++) {
          if(x+dx<0 || x+dx>=V.sx || y+dy<0 || y+dy>=V.sy) continue; // oob
          for(var d=0;d<V.depth;d++) {
           W.set(x,y,d,V.get(x+dx,y+dy,d)); // copy data over
          }
        }
      }
    } else {
      W = V;
    }

    if(fliplr) {
      // flip volume horziontally
      var W2 = W.cloneAndZero();
      for(var x=0;x<W.sx;x++) {
        for(var y=0;y<W.sy;y++) {
          for(var d=0;d<W.depth;d++) {
           W2.set(x,y,d,W.get(W.sx - x - 1,y,d)); // copy data over
          }
        }
      }
      W = W2; //swap
    }
    return W;
  }

  // img is a DOM element that contains a loaded image
  // returns a Vol of size (W, H, 4). 4 is for RGBA
  var img_to_vol = function(img, convert_grayscale) {

    if(typeof(convert_grayscale)==='undefined') var convert_grayscale = false;

    var canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    var ctx = canvas.getContext("2d");

    // due to a Firefox bug
    try {
      ctx.drawImage(img, 0, 0);
    } catch (e) {
      if (e.name === "NS_ERROR_NOT_AVAILABLE") {
        // sometimes happens, lets just abort
        return false;
      } else {
        throw e;
      }
    }

    try {
      var img_data = ctx.getImageData(0, 0, canvas.width, canvas.height);
    } catch (e) {
      if(e.name === 'IndexSizeError') {
        return false; // not sure what causes this sometimes but okay abort
      } else {
        throw e;
      }
    }

    // prepare the input: get pixels and normalize them
    var p = img_data.data;
    var W = img.width;
    var H = img.height;
    var pv = []
    for(var i=0;i<p.length;i++) {
      pv.push(p[i]/255.0-0.5); // normalize image pixels to [-0.5, 0.5]
    }
    var x = new Vol(W, H, 4, 0.0); //input volume (image)
    x.w = pv;

    if(convert_grayscale) {
      // flatten into depth=1 array
      var x1 = new Vol(W, H, 1, 0.0);
      for(var i=0;i<W;i++) {
        for(var j=0;j<H;j++) {
          x1.set(i,j,0,x.get(i,j,0));
        }
      }
      x = x1;
    }

    return x;
  }
  
  global.augment = augment;
  global.img_to_vol = img_to_vol;

})(convnetjs);
(function(global) {
  "use strict";
  var Vol = global.Vol; // convenience

  // This file contains all layers that do dot products with input,
  // but usually in a different connectivity pattern and weight sharing
  // schemes: 
  // - FullyConn is fully connected dot products 
  // - ConvLayer does convolutions (so weight sharing spatially)
  // putting them together in one file because they are very similar
  var ConvLayer = function(opt) {
    var opt = opt || {};

    // required
    this.out_depth = opt.filters;
    this.sx = opt.sx; // filter size. Should be odd if possible, it's cleaner.
    this.in_depth = opt.in_depth;
    this.in_sx = opt.in_sx;
    this.in_sy = opt.in_sy;
    
    // optional
    this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;
    this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 1; // stride at which we apply filters to input volume
    this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume
    this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;
    this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;

    // computed
    // note we are doing floor, so if the strided convolution of the filter doesnt fit into the input
    // volume exactly, the output volume will be trimmed and not contain the (incomplete) computed
    // final application.
    this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);
    this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);
    this.layer_type = 'conv';

    // initializations
    var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;
    this.filters = [];
    for(var i=0;i<this.out_depth;i++) { this.filters.push(new Vol(this.sx, this.sy, this.in_depth)); }
    this.biases = new Vol(1, 1, this.out_depth, bias);
  }
  ConvLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;

      var A = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);
      for(var d=0;d<this.out_depth;d++) {
        var f = this.filters[d];
        var x = -this.pad;
        var y = -this.pad;
        for(var ax=0; ax<this.out_sx; x+=this.stride,ax++) {
          y = -this.pad;
          for(var ay=0; ay<this.out_sy; y+=this.stride,ay++) {

            // convolve centered at this particular location
            // could be bit more efficient, going for correctness first
            var a = 0.0;
            for(var fx=0;fx<f.sx;fx++) {
              for(var fy=0;fy<f.sy;fy++) {
                for(var fd=0;fd<f.depth;fd++) {
                  var oy = y+fy; // coordinates in the original input array coordinates
                  var ox = x+fx;
                  if(oy>=0 && oy<V.sy && ox>=0 && ox<V.sx) {
                    //a += f.get(fx, fy, fd) * V.get(ox, oy, fd);
                    // avoid function call overhead for efficiency, compromise modularity :(
                    a += f.w[((f.sx * fy)+fx)*f.depth+fd] * V.w[((V.sx * oy)+ox)*V.depth+fd];
                  }
                }
              }
            }
            a += this.biases.w[d];
            A.set(ax, ay, d, a);
          }
        }
      }
      this.out_act = A;
      return this.out_act;
    },
    backward: function() { 

      // compute gradient wrt weights, biases and input data
      var V = this.in_act;
      V.dw = global.zeros(V.w.length); // zero out gradient wrt bottom data, we're about to fill it
      for(var d=0;d<this.out_depth;d++) {
        var f = this.filters[d];
        var x = -this.pad;
        var y = -this.pad;
        for(var ax=0; ax<this.out_sx; x+=this.stride,ax++) {
          y = -this.pad;
          for(var ay=0; ay<this.out_sy; y+=this.stride,ay++) {
            // convolve and add up the gradients. 
            // could be more efficient, going for correctness first
            var chain_grad = this.out_act.get_grad(ax,ay,d); // gradient from above, from chain rule
            for(var fx=0;fx<f.sx;fx++) {
              for(var fy=0;fy<f.sy;fy++) {
                for(var fd=0;fd<f.depth;fd++) {
                  var oy = y+fy;
                  var ox = x+fx;
                  if(oy>=0 && oy<V.sy && ox>=0 && ox<V.sx) {
                    // forward prop calculated: a += f.get(fx, fy, fd) * V.get(ox, oy, fd);
                    //f.add_grad(fx, fy, fd, V.get(ox, oy, fd) * chain_grad);
                    //V.add_grad(ox, oy, fd, f.get(fx, fy, fd) * chain_grad);

                    // avoid function call overhead and use Vols directly for efficiency
                    var ix1 = ((V.sx * oy)+ox)*V.depth+fd;
                    var ix2 = ((f.sx * fy)+fx)*f.depth+fd;
                    f.dw[ix2] += V.w[ix1]*chain_grad;
                    V.dw[ix1] += f.w[ix2]*chain_grad;
                  }
                }
              }
            }
            this.biases.dw[d] += chain_grad;
          }
        }
      }
    },
    getParamsAndGrads: function() {
      var response = [];
      for(var i=0;i<this.out_depth;i++) {
        response.push({params: this.filters[i].w, grads: this.filters[i].dw, l2_decay_mul: this.l2_decay_mul, l1_decay_mul: this.l1_decay_mul});
      }
      response.push({params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0});
      return response;
    },
    toJSON: function() {
      var json = {};
      json.sx = this.sx; // filter size in x, y dims
      json.sy = this.sy;
      json.stride = this.stride;
      json.in_depth = this.in_depth;
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      json.l1_decay_mul = this.l1_decay_mul;
      json.l2_decay_mul = this.l2_decay_mul;
      json.pad = this.pad;
      json.filters = [];
      for(var i=0;i<this.filters.length;i++) {
        json.filters.push(this.filters[i].toJSON());
      }
      json.biases = this.biases.toJSON();
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type;
      this.sx = json.sx; // filter size in x, y dims
      this.sy = json.sy;
      this.stride = json.stride;
      this.in_depth = json.in_depth; // depth of input volume
      this.filters = [];
      this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
      this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
      this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
      for(var i=0;i<json.filters.length;i++) {
        var v = new Vol(0,0,0,0);
        v.fromJSON(json.filters[i]);
        this.filters.push(v);
      }
      this.biases = new Vol(0,0,0,0);
      this.biases.fromJSON(json.biases);
    }
  }

  var FullyConnLayer = function(opt) {
    var opt = opt || {};

    // required
    // ok fine we will allow 'filters' as the word as well
    this.out_depth = typeof opt.num_neurons !== 'undefined' ? opt.num_neurons : opt.filters;

    // optional 
    this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;
    this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;

    // computed
    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
    this.out_sx = 1;
    this.out_sy = 1;
    this.layer_type = 'fc';

    // initializations
    var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;
    this.filters = [];
    for(var i=0;i<this.out_depth ;i++) { this.filters.push(new Vol(1, 1, this.num_inputs)); }
    this.biases = new Vol(1, 1, this.out_depth, bias);
  }

  FullyConnLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;
      var A = new Vol(1, 1, this.out_depth, 0.0);
      var Vw = V.w;
      for(var i=0;i<this.out_depth;i++) {
        var a = 0.0;
        var wi = this.filters[i].w;
        for(var d=0;d<this.num_inputs;d++) {
          a += Vw[d] * wi[d]; // for efficiency use Vols directly for now
        }
        a += this.biases.w[i];
        A.w[i] = a;
      }
      this.out_act = A;
      return this.out_act;
    },
    backward: function() {
      var V = this.in_act;
      V.dw = global.zeros(V.w.length); // zero out the gradient in input Vol
      
      // compute gradient wrt weights and data
      for(var i=0;i<this.out_depth;i++) {
        var tfi = this.filters[i];
        var chain_grad = this.out_act.dw[i];
        for(var d=0;d<this.num_inputs;d++) {
          V.dw[d] += tfi.w[d]*chain_grad; // grad wrt input data
          tfi.dw[d] += V.w[d]*chain_grad; // grad wrt params
        }
        this.biases.dw[i] += chain_grad;
      }
    },
    getParamsAndGrads: function() {
      var response = [];
      for(var i=0;i<this.out_depth;i++) {
        response.push({params: this.filters[i].w, grads: this.filters[i].dw, l1_decay_mul: this.l1_decay_mul, l2_decay_mul: this.l2_decay_mul});
      }
      response.push({params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0});
      return response;
    },
    toJSON: function() {
      var json = {};
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      json.num_inputs = this.num_inputs;
      json.l1_decay_mul = this.l1_decay_mul;
      json.l2_decay_mul = this.l2_decay_mul;
      json.filters = [];
      for(var i=0;i<this.filters.length;i++) {
        json.filters.push(this.filters[i].toJSON());
      }
      json.biases = this.biases.toJSON();
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type;
      this.num_inputs = json.num_inputs;
      this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
      this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
      this.filters = [];
      for(var i=0;i<json.filters.length;i++) {
        var v = new Vol(0,0,0,0);
        v.fromJSON(json.filters[i]);
        this.filters.push(v);
      }
      this.biases = new Vol(0,0,0,0);
      this.biases.fromJSON(json.biases);
    }
  }

  global.ConvLayer = ConvLayer;
  global.FullyConnLayer = FullyConnLayer;
  
})(convnetjs);
(function(global) {
  "use strict";
  var Vol = global.Vol; // convenience
  
  var PoolLayer = function(opt) {

    var opt = opt || {};

    // required
    this.sx = opt.sx; // filter size
    this.in_depth = opt.in_depth;
    this.in_sx = opt.in_sx;
    this.in_sy = opt.in_sy;

    // optional
    this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;
    this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 2;
    this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume

    // computed
    this.out_depth = this.in_depth;
    this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);
    this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);
    this.layer_type = 'pool';
    // store switches for x,y coordinates for where the max comes from, for each output neuron
    this.switchx = global.zeros(this.out_sx*this.out_sy*this.out_depth);
    this.switchy = global.zeros(this.out_sx*this.out_sy*this.out_depth);
  }

  PoolLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;

      var A = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);
      
      var n=0; // a counter for switches
      for(var d=0;d<this.out_depth;d++) {
        var x = -this.pad;
        var y = -this.pad;
        for(var ax=0; ax<this.out_sx; x+=this.stride,ax++) {
          y = -this.pad;
          for(var ay=0; ay<this.out_sy; y+=this.stride,ay++) {

            // convolve centered at this particular location
            var a = -99999; // hopefully small enough ;\
            var winx=-1,winy=-1;
            for(var fx=0;fx<this.sx;fx++) {
              for(var fy=0;fy<this.sy;fy++) {
                var oy = y+fy;
                var ox = x+fx;
                if(oy>=0 && oy<V.sy && ox>=0 && ox<V.sx) {
                  var v = V.get(ox, oy, d);
                  // perform max pooling and store pointers to where
                  // the max came from. This will speed up backprop 
                  // and can help make nice visualizations in future
                  if(v > a) { a = v; winx=ox; winy=oy;}
                }
              }
            }
            this.switchx[n] = winx;
            this.switchy[n] = winy;
            n++;
            A.set(ax, ay, d, a);
          }
        }
      }
      this.out_act = A;
      return this.out_act;
    },
    backward: function() { 
      // pooling layers have no parameters, so simply compute 
      // gradient wrt data here
      var V = this.in_act;
      V.dw = global.zeros(V.w.length); // zero out gradient wrt data
      var A = this.out_act; // computed in forward pass 

      var n = 0;
      for(var d=0;d<this.out_depth;d++) {
        var x = -this.pad;
        var y = -this.pad;
        for(var ax=0; ax<this.out_sx; x+=this.stride,ax++) {
          y = -this.pad;
          for(var ay=0; ay<this.out_sy; y+=this.stride,ay++) {

            var chain_grad = this.out_act.get_grad(ax,ay,d);
            V.add_grad(this.switchx[n], this.switchy[n], d, chain_grad);
            n++;

          }
        }
      }
    },
    getParamsAndGrads: function() {
      return [];
    },
    toJSON: function() {
      var json = {};
      json.sx = this.sx;
      json.sy = this.sy;
      json.stride = this.stride;
      json.in_depth = this.in_depth;
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      json.pad = this.pad;
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type;
      this.sx = json.sx;
      this.sy = json.sy;
      this.stride = json.stride;
      this.in_depth = json.in_depth;
      this.pad = typeof json.pad !== 'undefined' ? json.pad : 0; // backwards compatibility
      this.switchx = global.zeros(this.out_sx*this.out_sy*this.out_depth); // need to re-init these appropriately
      this.switchy = global.zeros(this.out_sx*this.out_sy*this.out_depth);
    }
  }

  global.PoolLayer = PoolLayer;

})(convnetjs);

(function(global) {
  "use strict";
  var Vol = global.Vol; // convenience
  
  var InputLayer = function(opt) {
    var opt = opt || {};

    // this is a bit silly but lets allow people to specify either ins or outs
    this.out_sx = typeof opt.out_sx !== 'undefined' ? opt.out_sx : opt.in_sx;
    this.out_sy = typeof opt.out_sy !== 'undefined' ? opt.out_sy : opt.in_sy;
    this.out_depth = typeof opt.out_depth !== 'undefined' ? opt.out_depth : opt.in_depth;
    this.layer_type = 'input';
  }
  InputLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;
      this.out_act = V;
      return this.out_act; // dummy identity function for now
    },
    backward: function() { },
    getParamsAndGrads: function() {
      return [];
    },
    toJSON: function() {
      var json = {};
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type; 
    }
  }

  global.InputLayer = InputLayer;
})(convnetjs);
(function(global) {
  "use strict";
  var Vol = global.Vol; // convenience
  
  // Layers that implement a loss. Currently these are the layers that 
  // can initiate a backward() pass. In future we probably want a more 
  // flexible system that can accomodate multiple losses to do multi-task
  // learning, and stuff like that. But for now, one of the layers in this
  // file must be the final layer in a Net.

  // This is a classifier, with N discrete classes from 0 to N-1
  // it gets a stream of N incoming numbers and computes the softmax
  // function (exponentiate and normalize to sum to 1 as probabilities should)
  var SoftmaxLayer = function(opt) {
    var opt = opt || {};

    // computed
    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
    this.out_depth = this.num_inputs;
    this.out_sx = 1;
    this.out_sy = 1;
    this.layer_type = 'softmax';
  }

  SoftmaxLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;

      var A = new Vol(1, 1, this.out_depth, 0.0);

      // compute max activation
      var as = V.w;
      var amax = V.w[0];
      for(var i=1;i<this.out_depth;i++) {
        if(as[i] > amax) amax = as[i];
      }

      // compute exponentials (carefully to not blow up)
      var es = global.zeros(this.out_depth);
      var esum = 0.0;
      for(var i=0;i<this.out_depth;i++) {
        var e = Math.exp(as[i] - amax);
        esum += e;
        es[i] = e;
      }

      // normalize and output to sum to one
      for(var i=0;i<this.out_depth;i++) {
        es[i] /= esum;
        A.w[i] = es[i];
      }

      this.es = es; // save these for backprop
      this.out_act = A;
      return this.out_act;
    },
    backward: function(y) {

      // compute and accumulate gradient wrt weights and bias of this layer
      var x = this.in_act;
      x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol

      for(var i=0;i<this.out_depth;i++) {
        var indicator = i === y ? 1.0 : 0.0;
        var mul = -(indicator - this.es[i]);
        x.dw[i] = mul;
      }

      // loss is the class negative log likelihood
      return -Math.log(this.es[y]);
    },
    getParamsAndGrads: function() { 
      return [];
    },
    toJSON: function() {
      var json = {};
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      json.num_inputs = this.num_inputs;
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type;
      this.num_inputs = json.num_inputs;
    }
  }

  // implements an L2 regression cost layer,
  // so penalizes \sum_i(||x_i - y_i||^2), where x is its input
  // and y is the user-provided array of "correct" values.
  var RegressionLayer = function(opt) {
    var opt = opt || {};

    // computed
    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
    this.out_depth = this.num_inputs;
    this.out_sx = 1;
    this.out_sy = 1;
    this.layer_type = 'regression';
  }

  RegressionLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;
      this.out_act = V;
      return V; // identity function
    },
    // y is a list here of size num_inputs
    backward: function(y) { 

      // compute and accumulate gradient wrt weights and bias of this layer
      var x = this.in_act;
      x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol
      var loss = 0.0;
      if(y instanceof Array || y instanceof Float64Array) {
        for(var i=0;i<this.out_depth;i++) {
          var dy = x.w[i] - y[i];
          x.dw[i] = dy;
          loss += 2*dy*dy;
        }
      } else {
        // assume it is a struct with entries .dim and .val
        // and we pass gradient only along dimension dim to be equal to val
        var i = y.dim;
        var yi = y.val;
        var dy = x.w[i] - yi;
        x.dw[i] = dy;
        loss += 2*dy*dy;
      }
      return loss;
    },
    getParamsAndGrads: function() { 
      return [];
    },
    toJSON: function() {
      var json = {};
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      json.num_inputs = this.num_inputs;
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type;
      this.num_inputs = json.num_inputs;
    }
  }

  var SVMLayer = function(opt) {
    var opt = opt || {};

    // computed
    this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
    this.out_depth = this.num_inputs;
    this.out_sx = 1;
    this.out_sy = 1;
    this.layer_type = 'svm';
  }

  SVMLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;
      this.out_act = V; // nothing to do, output raw scores
      return V;
    },
    backward: function(y) {

      // compute and accumulate gradient wrt weights and bias of this layer
      var x = this.in_act;
      x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol

      var yscore = x.w[y]; // score of ground truth
      var margin = 1.0;
      var loss = 0.0;
      for(var i=0;i<this.out_depth;i++) {
        if(-yscore + x.w[i] + margin > 0) {
          // violating example, apply loss
          // I love hinge loss, by the way. Truly.
          // Seriously, compare this SVM code with Softmax forward AND backprop code above
          // it's clear which one is superior, not only in code, simplicity
          // and beauty, but also in practice.
          x.dw[i] += 1;
          x.dw[y] -= 1;
          loss += -yscore + x.w[i] + margin;
        }
      }

      return loss;
    },
    getParamsAndGrads: function() { 
      return [];
    },
    toJSON: function() {
      var json = {};
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      json.num_inputs = this.num_inputs;
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type;
      this.num_inputs = json.num_inputs;
    }
  }
  
  global.RegressionLayer = RegressionLayer;
  global.SoftmaxLayer = SoftmaxLayer;
  global.SVMLayer = SVMLayer;

})(convnetjs);

(function(global) {
  "use strict";
  var Vol = global.Vol; // convenience
  
  // Implements ReLU nonlinearity elementwise
  // x -> max(0, x)
  // the output is in [0, inf)
  var ReluLayer = function(opt) {
    var opt = opt || {};

    // computed
    this.out_sx = opt.in_sx;
    this.out_sy = opt.in_sy;
    this.out_depth = opt.in_depth;
    this.layer_type = 'relu';
  }
  ReluLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;
      var V2 = V.clone();
      var N = V.w.length;
      var V2w = V2.w;
      for(var i=0;i<N;i++) { 
        if(V2w[i] < 0) V2w[i] = 0; // threshold at 0
      }
      this.out_act = V2;
      return this.out_act;
    },
    backward: function() {
      var V = this.in_act; // we need to set dw of this
      var V2 = this.out_act;
      var N = V.w.length;
      V.dw = global.zeros(N); // zero out gradient wrt data
      for(var i=0;i<N;i++) {
        if(V2.w[i] <= 0) V.dw[i] = 0; // threshold
        else V.dw[i] = V2.dw[i];
      }
    },
    getParamsAndGrads: function() {
      return [];
    },
    toJSON: function() {
      var json = {};
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type; 
    }
  }

  // Implements Sigmoid nnonlinearity elementwise
  // x -> 1/(1+e^(-x))
  // so the output is between 0 and 1.
  var SigmoidLayer = function(opt) {
    var opt = opt || {};

    // computed
    this.out_sx = opt.in_sx;
    this.out_sy = opt.in_sy;
    this.out_depth = opt.in_depth;
    this.layer_type = 'sigmoid';
  }
  SigmoidLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;
      var V2 = V.cloneAndZero();
      var N = V.w.length;
      var V2w = V2.w;
      var Vw = V.w;
      for(var i=0;i<N;i++) { 
        V2w[i] = 1.0/(1.0+Math.exp(-Vw[i]));
      }
      this.out_act = V2;
      return this.out_act;
    },
    backward: function() {
      var V = this.in_act; // we need to set dw of this
      var V2 = this.out_act;
      var N = V.w.length;
      V.dw = global.zeros(N); // zero out gradient wrt data
      for(var i=0;i<N;i++) {
        var v2wi = V2.w[i];
        V.dw[i] =  v2wi * (1.0 - v2wi) * V2.dw[i];
      }
    },
    getParamsAndGrads: function() {
      return [];
    },
    toJSON: function() {
      var json = {};
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type; 
    }
  }

  // Implements Maxout nnonlinearity that computes
  // x -> max(x)
  // where x is a vector of size group_size. Ideally of course,
  // the input size should be exactly divisible by group_size
  var MaxoutLayer = function(opt) {
    var opt = opt || {};

    // required
    this.group_size = typeof opt.group_size !== 'undefined' ? opt.group_size : 2;

    // computed
    this.out_sx = opt.in_sx;
    this.out_sy = opt.in_sy;
    this.out_depth = Math.floor(opt.in_depth / this.group_size);
    this.layer_type = 'maxout';

    this.switches = global.zeros(this.out_sx*this.out_sy*this.out_depth); // useful for backprop
  }
  MaxoutLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;
      var N = this.out_depth; 
      var V2 = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);

      // optimization branch. If we're operating on 1D arrays we dont have
      // to worry about keeping track of x,y,d coordinates inside
      // input volumes. In convnets we do :(
      if(this.out_sx === 1 && this.out_sy === 1) {
        for(var i=0;i<N;i++) {
          var ix = i * this.group_size; // base index offset
          var a = V.w[ix];
          var ai = 0;
          for(var j=1;j<this.group_size;j++) {
            var a2 = V.w[ix+j];
            if(a2 > a) {
              a = a2;
              ai = j;
            }
          }
          V2.w[i] = a;
          this.switches[i] = ix + ai;
        }
      } else {
        var n=0; // counter for switches
        for(var x=0;x<V.sx;x++) {
          for(var y=0;y<V.sy;y++) {
            for(var i=0;i<N;i++) {
              var ix = i * this.group_size;
              var a = V.get(x, y, ix);
              var ai = 0;
              for(var j=1;j<this.group_size;j++) {
                var a2 = V.get(x, y, ix+j);
                if(a2 > a) {
                  a = a2;
                  ai = j;
                }
              }
              V2.set(x,y,i,a);
              this.switches[n] = ix + ai;
              n++;
            }
          }
        }

      }
      this.out_act = V2;
      return this.out_act;
    },
    backward: function() {
      var V = this.in_act; // we need to set dw of this
      var V2 = this.out_act;
      var N = this.out_depth;
      V.dw = global.zeros(V.w.length); // zero out gradient wrt data

      // pass the gradient through the appropriate switch
      if(this.out_sx === 1 && this.out_sy === 1) {
        for(var i=0;i<N;i++) {
          var chain_grad = V2.dw[i];
          V.dw[this.switches[i]] = chain_grad;
        }
      } else {
        // bleh okay, lets do this the hard way
        var n=0; // counter for switches
        for(var x=0;x<V2.sx;x++) {
          for(var y=0;y<V2.sy;y++) {
            for(var i=0;i<N;i++) {
              var chain_grad = V2.get_grad(x,y,i);
              V.set_grad(x,y,this.switches[n],chain_grad);
              n++;
            }
          }
        }
      }
    },
    getParamsAndGrads: function() {
      return [];
    },
    toJSON: function() {
      var json = {};
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      json.group_size = this.group_size;
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type; 
      this.group_size = json.group_size;
      this.switches = global.zeros(this.group_size);
    }
  }

  // a helper function, since tanh is not yet part of ECMAScript. Will be in v6.
  function tanh(x) {
    var y = Math.exp(2 * x);
    return (y - 1) / (y + 1);
  }
  // Implements Tanh nnonlinearity elementwise
  // x -> tanh(x) 
  // so the output is between -1 and 1.
  var TanhLayer = function(opt) {
    var opt = opt || {};

    // computed
    this.out_sx = opt.in_sx;
    this.out_sy = opt.in_sy;
    this.out_depth = opt.in_depth;
    this.layer_type = 'tanh';
  }
  TanhLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;
      var V2 = V.cloneAndZero();
      var N = V.w.length;
      for(var i=0;i<N;i++) { 
        V2.w[i] = tanh(V.w[i]);
      }
      this.out_act = V2;
      return this.out_act;
    },
    backward: function() {
      var V = this.in_act; // we need to set dw of this
      var V2 = this.out_act;
      var N = V.w.length;
      V.dw = global.zeros(N); // zero out gradient wrt data
      for(var i=0;i<N;i++) {
        var v2wi = V2.w[i];
        V.dw[i] = (1.0 - v2wi * v2wi) * V2.dw[i];
      }
    },
    getParamsAndGrads: function() {
      return [];
    },
    toJSON: function() {
      var json = {};
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type; 
    }
  }
  
  global.TanhLayer = TanhLayer;
  global.MaxoutLayer = MaxoutLayer;
  global.ReluLayer = ReluLayer;
  global.SigmoidLayer = SigmoidLayer;

})(convnetjs);

(function(global) {
  "use strict";
  var Vol = global.Vol; // convenience

  // An inefficient dropout layer
  // Note this is not most efficient implementation since the layer before
  // computed all these activations and now we're just going to drop them :(
  // same goes for backward pass. Also, if we wanted to be efficient at test time
  // we could equivalently be clever and upscale during train and copy pointers during test
  // todo: make more efficient.
  var DropoutLayer = function(opt) {
    var opt = opt || {};

    // computed
    this.out_sx = opt.in_sx;
    this.out_sy = opt.in_sy;
    this.out_depth = opt.in_depth;
    this.layer_type = 'dropout';
    this.drop_prob = typeof opt.drop_prob !== 'undefined' ? opt.drop_prob : 0.5;
    this.dropped = global.zeros(this.out_sx*this.out_sy*this.out_depth);
  }
  DropoutLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;
      if(typeof(is_training)==='undefined') { is_training = false; } // default is prediction mode
      var V2 = V.clone();
      var N = V.w.length;
      if(is_training) {
        // do dropout
        for(var i=0;i<N;i++) {
          if(Math.random()<this.drop_prob) { V2.w[i]=0; this.dropped[i] = true; } // drop!
          else {this.dropped[i] = false;}
        }
      } else {
        // scale the activations during prediction
        for(var i=0;i<N;i++) { V2.w[i]*=this.drop_prob; }
      }
      this.out_act = V2;
      return this.out_act; // dummy identity function for now
    },
    backward: function() {
      var V = this.in_act; // we need to set dw of this
      var chain_grad = this.out_act;
      var N = V.w.length;
      V.dw = global.zeros(N); // zero out gradient wrt data
      for(var i=0;i<N;i++) {
        if(!(this.dropped[i])) { 
          V.dw[i] = chain_grad.dw[i]; // copy over the gradient
        }
      }
    },
    getParamsAndGrads: function() {
      return [];
    },
    toJSON: function() {
      var json = {};
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      json.drop_prob = this.drop_prob;
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type; 
      this.drop_prob = json.drop_prob;
    }
  }
  

  global.DropoutLayer = DropoutLayer;
})(convnetjs);
(function(global) {
  "use strict";
  var Vol = global.Vol; // convenience
  
  // a bit experimental layer for now. I think it works but I'm not 100%
  // the gradient check is a bit funky. I'll look into this a bit later.
  // Local Response Normalization in window, along depths of volumes
  var LocalResponseNormalizationLayer = function(opt) {
    var opt = opt || {};

    // required
    this.k = opt.k;
    this.n = opt.n;
    this.alpha = opt.alpha;
    this.beta = opt.beta;

    // computed
    this.out_sx = opt.in_sx;
    this.out_sy = opt.in_sy;
    this.out_depth = opt.in_depth;
    this.layer_type = 'lrn';

    // checks
    if(this.n%2 === 0) { console.log('WARNING n should be odd for LRN layer'); }
  }
  LocalResponseNormalizationLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;

      var A = V.cloneAndZero();
      this.S_cache_ = V.cloneAndZero();
      var n2 = Math.floor(this.n/2);
      for(var x=0;x<V.sx;x++) {
        for(var y=0;y<V.sy;y++) {
          for(var i=0;i<V.depth;i++) {

            var ai = V.get(x,y,i);

            // normalize in a window of size n
            var den = 0.0;
            for(var j=Math.max(0,i-n2);j<=Math.min(i+n2,V.depth-1);j++) {
              var aa = V.get(x,y,j);
              den += aa*aa;
            }
            den *= this.alpha / this.n;
            den += this.k;
            this.S_cache_.set(x,y,i,den); // will be useful for backprop
            den = Math.pow(den, this.beta);
            A.set(x,y,i,ai/den);
          }
        }
      }

      this.out_act = A;
      return this.out_act; // dummy identity function for now
    },
    backward: function() { 
      // evaluate gradient wrt data
      var V = this.in_act; // we need to set dw of this
      V.dw = global.zeros(V.w.length); // zero out gradient wrt data
      var A = this.out_act; // computed in forward pass 

      var n2 = Math.floor(this.n/2);
      for(var x=0;x<V.sx;x++) {
        for(var y=0;y<V.sy;y++) {
          for(var i=0;i<V.depth;i++) {

            var chain_grad = this.out_act.get_grad(x,y,i);
            var S = this.S_cache_.get(x,y,i);
            var SB = Math.pow(S, this.beta);
            var SB2 = SB*SB;

            // normalize in a window of size n
            for(var j=Math.max(0,i-n2);j<=Math.min(i+n2,V.depth-1);j++) {              
              var aj = V.get(x,y,j); 
              var g = -aj*this.beta*Math.pow(S,this.beta-1)*this.alpha/this.n*2*aj;
              if(j===i) g+= SB;
              g /= SB2;
              g *= chain_grad;
              V.add_grad(x,y,j,g);
            }

          }
        }
      }
    },
    getParamsAndGrads: function() { return []; },
    toJSON: function() {
      var json = {};
      json.k = this.k;
      json.n = this.n;
      json.alpha = this.alpha; // normalize by size
      json.beta = this.beta;
      json.out_sx = this.out_sx; 
      json.out_sy = this.out_sy;
      json.out_depth = this.out_depth;
      json.layer_type = this.layer_type;
      return json;
    },
    fromJSON: function(json) {
      this.k = json.k;
      this.n = json.n;
      this.alpha = json.alpha; // normalize by size
      this.beta = json.beta;
      this.out_sx = json.out_sx; 
      this.out_sy = json.out_sy;
      this.out_depth = json.out_depth;
      this.layer_type = json.layer_type;
    }
  }
  

  global.LocalResponseNormalizationLayer = LocalResponseNormalizationLayer;
})(convnetjs);
(function(global) {
  "use strict";
  var Vol = global.Vol; // convenience

  // transforms x-> [x, x_i*x_j forall i,j]
  // so the fully connected layer afters will essentially be doing tensor multiplies
  var QuadTransformLayer = function(opt) {
    var opt = opt || {};

    // computed
    this.out_sx = opt.in_sx;
    this.out_sy = opt.in_sy;
    // linear terms, and then quadratic terms, of which there are 1/2*n*(n+1),
    // (offdiagonals and the diagonal total) and arithmetic series.
    // Actually never mind, lets not be fancy here yet and just include
    // terms x_ix_j and x_jx_i twice. Half as efficient but much less
    // headache.
    this.out_depth = opt.in_depth + opt.in_depth * opt.in_depth;
    this.layer_type = 'quadtransform';

  }
  QuadTransformLayer.prototype = {
    forward: function(V, is_training) {
      this.in_act = V;
      var N = this.out_depth;
      var Ni = V.depth;
      var V2 = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);
      for(var x=0;x<V.sx;x++) {
        for(var y=0;y<V.sy;y++) {
          for(var i=0;i<N;i++) {
            if(i<Ni) {
              V2.set(x,y,i,V.get(x,y,i)); // copy these over (linear terms)
            } else {
              var i0 = Math.floor((i-Ni)/Ni);
              var i1 = (i-Ni) - i0*Ni;
              V2.set(x,y,i,V.get(x,y,i0) * V.get(x,y,i1)); // quadratic
            }
          }
        }
      }
      this.out_act = V2;
      return this.out_act; // dummy identity function for now
    },
    backward: function() {
      var V = this.in_act;
      V.dw = global.zeros(V.w.length); // zero out gradient wrt data
      var V2 = this.out_act;
      var N = this.out_depth;
      var Ni = V.depth;
      for(var x=0;x<V.sx;x++) {
        for(var y=0;y<V.sy;y++) {
          for(var i=0;i<N;i++) {
            var chain_grad = V2.get_grad(x,y,i);
            if(i<Ni) {
              V.add_grad(x,y,i,chain_grad);
            } else {
              var i0 = Math.floor((i-Ni)/Ni);
              var i1 = (i-Ni) - i0*Ni;
              V.add_grad(x,y,i0,V.get(x,y,i1)*chain_grad);
              V.add_grad(x,y,i1,V.get(x,y,i0)*chain_grad);
            }
          }
        }
      }
    },
    getParamsAndGrads: function() {
      return [];
    },
    toJSON: function() {
      var json = {};
      json.out_depth = this.out_depth;
      json.out_sx = this.out_sx;
      json.out_sy = this.out_sy;
      json.layer_type = this.layer_type;
      return json;
    },
    fromJSON: function(json) {
      this.out_depth = json.out_depth;
      this.out_sx = json.out_sx;
      this.out_sy = json.out_sy;
      this.layer_type = json.layer_type; 
    }
  }
  

  global.QuadTransformLayer = QuadTransformLayer;
})(convnetjs);
(function(global) {
  "use strict";
  var Vol = global.Vol; // convenience
  
  // Net manages a set of layers
  // For now constraints: Simple linear order of layers, first layer input last layer a cost layer
  var Net = function(options) {
    this.layers = [];
  }

  Net.prototype = {
    
    // takes a list of layer definitions and creates the network layer objects
    makeLayers: function(defs) {

      // few checks for now
      if(defs.length<2) {console.log('ERROR! For now at least have input and softmax layers.');}
      if(defs[0].type !== 'input') {console.log('ERROR! For now first layer should be input.');}

      // desugar syntactic for adding activations and dropouts
      var desugar = function() {
        var new_defs = [];
        for(var i=0;i<defs.length;i++) {
          var def = defs[i];
          
          if(def.type==='softmax' || def.type==='svm') {
            // add an fc layer here, there is no reason the user should
            // have to worry about this and we almost always want to
            new_defs.push({type:'fc', num_neurons: def.num_classes});
          }

          if(def.type==='regression') {
            // add an fc layer here, there is no reason the user should
            // have to worry about this and we almost always want to
            new_defs.push({type:'fc', num_neurons: def.num_neurons});
          }

          if((def.type==='fc' || def.type==='conv') 
              && typeof(def.bias_pref) === 'undefined'){
            def.bias_pref = 0.0;
            if(typeof def.activation !== 'undefined' && def.activation === 'relu') {
              def.bias_pref = 0.1; // relus like a bit of positive bias to get gradients early
              // otherwise it's technically possible that a relu unit will never turn on (by chance)
              // and will never get any gradient and never contribute any computation. Dead relu.
            }
          }
          
          if(typeof def.tensor !== 'undefined') {
            // apply quadratic transform so that the upcoming multiply will include
            // quadratic terms, equivalent to doing a tensor product
            if(def.tensor) {
              new_defs.push({type: 'quadtransform'});
            }
          }

          new_defs.push(def);

          if(typeof def.activation !== 'undefined') {
            if(def.activation==='relu') { new_defs.push({type:'relu'}); }
            else if (def.activation==='sigmoid') { new_defs.push({type:'sigmoid'}); }
            else if (def.activation==='tanh') { new_defs.push({type:'tanh'}); }
            else if (def.activation==='maxout') {
              // create maxout activation, and pass along group size, if provided
              var gs = def.group_size !== 'undefined' ? def.group_size : 2;
              new_defs.push({type:'maxout', group_size:gs});
            }
            else { console.log('ERROR unsupported activation ' + def.activation); }
          }
          if(typeof def.drop_prob !== 'undefined' && def.type !== 'dropout') {
            new_defs.push({type:'dropout', drop_prob: def.drop_prob});
          }

        }
        return new_defs;
      }
      defs = desugar(defs);

      // create the layers
      this.layers = [];
      for(var i=0;i<defs.length;i++) {
        var def = defs[i];
        if(i>0) {
          var prev = this.layers[i-1];
          def.in_sx = prev.out_sx;
          def.in_sy = prev.out_sy;
          def.in_depth = prev.out_depth;
        }

        switch(def.type) {
          case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
          case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
          case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
          case 'input': this.layers.push(new global.InputLayer(def)); break;
          case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
          case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
          case 'conv': this.layers.push(new global.ConvLayer(def)); break;
          case 'pool': this.layers.push(new global.PoolLayer(def)); break;
          case 'relu': this.layers.push(new global.ReluLayer(def)); break;
          case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
          case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
          case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
          case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
          case 'svm': this.layers.push(new global.SVMLayer(def)); break;
          default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
        }
      }
    },

    // forward prop the network. A trainer will pass in is_training = true
    forward: function(V, is_training) {
      if(typeof(is_training)==='undefined') is_training = false;
      var act = this.layers[0].forward(V, is_training);
      for(var i=1;i<this.layers.length;i++) {
        act = this.layers[i].forward(act, is_training);
      }
      return act;
    },
    
    // backprop: compute gradients wrt all parameters
    backward: function(y) {
      var N = this.layers.length;
      var loss = this.layers[N-1].backward(y); // last layer assumed softmax
      for(var i=N-2;i>=0;i--) { // first layer assumed input
        this.layers[i].backward();
      }
      return loss;
    },
    getParamsAndGrads: function() {
      // accumulate parameters and gradients for the entire network
      var response = [];
      for(var i=0;i<this.layers.length;i++) {
        var layer_reponse = this.layers[i].getParamsAndGrads();
        for(var j=0;j<layer_reponse.length;j++) {
          response.push(layer_reponse[j]);
        }
      }
      return response;
    },
    getPrediction: function() {
      var S = this.layers[this.layers.length-1]; // softmax layer
      var p = S.out_act.w;
      var maxv = p[0];
      var maxi = 0;
      for(var i=1;i<p.length;i++) {
        if(p[i] > maxv) { maxv = p[i]; maxi = i;}
      }
      return maxi;
    },
    toJSON: function() {
      var json = {};
      json.layers = [];
      for(var i=0;i<this.layers.length;i++) {
        json.layers.push(this.layers[i].toJSON());
      }
      return json;
    },
    fromJSON: function(json) {
      this.layers = [];
      for(var i=0;i<json.layers.length;i++) {
        var Lj = json.layers[i]
        var t = Lj.layer_type;
        var L;
        if(t==='input') { L = new global.InputLayer(); }
        if(t==='relu') { L = new global.ReluLayer(); }
        if(t==='sigmoid') { L = new global.SigmoidLayer(); }
        if(t==='tanh') { L = new global.TanhLayer(); }
        if(t==='dropout') { L = new global.DropoutLayer(); }
        if(t==='conv') { L = new global.ConvLayer(); }
        if(t==='pool') { L = new global.PoolLayer(); }
        if(t==='lrn') { L = new global.LocalResponseNormalizationLayer(); }
        if(t==='softmax') { L = new global.SoftmaxLayer(); }
        if(t==='regression') { L = new global.RegressionLayer(); }
        if(t==='fc') { L = new global.FullyConnLayer(); }
        if(t==='maxout') { L = new global.MaxoutLayer(); }
        if(t==='quadtransform') { L = new global.QuadTransformLayer(); }
        if(t==='svm') { L = new global.SVMLayer(); }
        L.fromJSON(Lj);
        this.layers.push(L);
      }
    }
  }
  

  global.Net = Net;
})(convnetjs);
(function(global) {
  "use strict";
  var Vol = global.Vol; // convenience

  var Trainer = function(net, options) {

    this.net = net;

    var options = options || {};
    this.learning_rate = typeof options.learning_rate !== 'undefined' ? options.learning_rate : 0.01;
    this.l1_decay = typeof options.l1_decay !== 'undefined' ? options.l1_decay : 0.0;
    this.l2_decay = typeof options.l2_decay !== 'undefined' ? options.l2_decay : 0.0;
    this.batch_size = typeof options.batch_size !== 'undefined' ? options.batch_size : 1;
    this.method = typeof options.method !== 'undefined' ? options.method : 'sgd'; // sgd/adagrad/adadelta/windowgrad

    this.momentum = typeof options.momentum !== 'undefined' ? options.momentum : 0.9;
    this.ro = typeof options.ro !== 'undefined' ? options.ro : 0.95; // used in adadelta
    this.eps = typeof options.eps !== 'undefined' ? options.eps : 1e-6; // used in adadelta

    this.k = 0; // iteration counter
    this.gsum = []; // last iteration gradients (used for momentum calculations)
    this.xsum = []; // used in adadelta
  }

  Trainer.prototype = {
    train: function(x, y) {

      var start = new Date().getTime();
      this.net.forward(x, true); // also set the flag that lets the net know we're just training
      var end = new Date().getTime();
      var fwd_time = end - start;

      var start = new Date().getTime();
      var cost_loss = this.net.backward(y);
      var l2_decay_loss = 0.0;
      var l1_decay_loss = 0.0;
      var end = new Date().getTime();
      var bwd_time = end - start;
      
      this.k++;
      if(this.k % this.batch_size === 0) {

        var pglist = this.net.getParamsAndGrads();

        // initialize lists for accumulators. Will only be done once on first iteration
        if(this.gsum.length === 0 && (this.method !== 'sgd' || this.momentum > 0.0)) {
          // only vanilla sgd doesnt need either lists
          // momentum needs gsum
          // adagrad needs gsum
          // adadelta needs gsum and xsum
          for(var i=0;i<pglist.length;i++) {
            this.gsum.push(global.zeros(pglist[i].params.length));
            if(this.method === 'adadelta') {
              this.xsum.push(global.zeros(pglist[i].params.length));
            } else {
              this.xsum.push([]); // conserve memory
            }
          }
        }

        // perform an update for all sets of weights
        for(var i=0;i<pglist.length;i++) {
          var pg = pglist[i]; // param, gradient, other options in future (custom learning rate etc)
          var p = pg.params;
          var g = pg.grads;

          // learning rate for some parameters.
          var l2_decay_mul = typeof pg.l2_decay_mul !== 'undefined' ? pg.l2_decay_mul : 1.0;
          var l1_decay_mul = typeof pg.l1_decay_mul !== 'undefined' ? pg.l1_decay_mul : 1.0;
          var l2_decay = this.l2_decay * l2_decay_mul;
          var l1_decay = this.l1_decay * l1_decay_mul;

          var plen = p.length;
          for(var j=0;j<plen;j++) {
            l2_decay_loss += l2_decay*p[j]*p[j]/2; // accumulate weight decay loss
            l1_decay_loss += l1_decay*Math.abs(p[j]);
            var l1grad = l1_decay * (p[j] > 0 ? 1 : -1);
            var l2grad = l2_decay * (p[j]);

            var gij = (l2grad + l1grad + g[j]) / this.batch_size; // raw batch gradient

            var gsumi = this.gsum[i];
            var xsumi = this.xsum[i];
            if(this.method === 'adagrad') {
              // adagrad update
              gsumi[j] = gsumi[j] + gij * gij;
              var dx = - this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij;
              p[j] += dx;
            } else if(this.method === 'windowgrad') {
              // this is adagrad but with a moving window weighted average
              // so the gradient is not accumulated over the entire history of the run. 
              // it's also referred to as Idea #1 in Zeiler paper on Adadelta. Seems reasonable to me!
              gsumi[j] = this.ro * gsumi[j] + (1-this.ro) * gij * gij;
              var dx = - this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij; // eps added for better conditioning
              p[j] += dx;
            } else if(this.method === 'adadelta') {
              // assume adadelta if not sgd or adagrad
              gsumi[j] = this.ro * gsumi[j] + (1-this.ro) * gij * gij;
              var dx = - Math.sqrt((xsumi[j] + this.eps)/(gsumi[j] + this.eps)) * gij;
              xsumi[j] = this.ro * xsumi[j] + (1-this.ro) * dx * dx; // yes, xsum lags behind gsum by 1.
              p[j] += dx;
            } else {
              // assume SGD
              if(this.momentum > 0.0) {
                // momentum update
                var dx = this.momentum * gsumi[j] - this.learning_rate * gij; // step
                gsumi[j] = dx; // back this up for next iteration of momentum
                p[j] += dx; // apply corrected gradient
              } else {
                // vanilla sgd
                p[j] +=  - this.learning_rate * gij;
              }
            }
            g[j] = 0.0; // zero out gradient so that we can begin accumulating anew
          }
        }
      }

      // appending softmax_loss for backwards compatibility, but from now on we will always use cost_loss
      // in future, TODO: have to completely redo the way loss is done around the network as currently 
      // loss is a bit of a hack. Ideally, user should specify arbitrary number of loss functions on any layer
      // and it should all be computed correctly and automatically. 
      return {fwd_time: fwd_time, bwd_time: bwd_time, 
              l2_decay_loss: l2_decay_loss, l1_decay_loss: l1_decay_loss,
              cost_loss: cost_loss, softmax_loss: cost_loss, 
              loss: cost_loss + l1_decay_loss + l2_decay_loss}
    }
  }
  
  global.Trainer = Trainer;
  global.SGDTrainer = Trainer; // backwards compatibility
})(convnetjs);

(function(global) {
  "use strict";

  // used utilities, make explicit local references
  var randf = global.randf;
  var randi = global.randi;
  var Net = global.Net;
  var Trainer = global.Trainer;
  var maxmin = global.maxmin;
  var randperm = global.randperm;
  var weightedSample = global.weightedSample;
  var getopt = global.getopt;
  var arrUnique = global.arrUnique;

  /*
  A MagicNet takes data: a list of convnetjs.Vol(), and labels
  which for now are assumed to be class indeces 0..K. MagicNet then:
  - creates data folds for cross-validation
  - samples candidate networks
  - evaluates candidate networks on all data folds
  - produces predictions by model-averaging the best networks
  */
  var MagicNet = function(data, labels, opt) {
    var opt = opt || {};
    if(typeof data === 'undefined') { data = []; }
    if(typeof labels === 'undefined') { labels = []; }

    // required inputs
    this.data = data; // store these pointers to data
    this.labels = labels;

    // optional inputs
    this.train_ratio = getopt(opt, 'train_ratio', 0.7);
    this.num_folds = getopt(opt, 'num_folds', 10);
    this.num_candidates = getopt(opt, 'num_candidates', 50); // we evaluate several in parallel
    // how many epochs of data to train every network? for every fold?
    // higher values mean higher accuracy in final results, but more expensive
    this.num_epochs = getopt(opt, 'num_epochs', 50); 
    // number of best models to average during prediction. Usually higher = better
    this.ensemble_size = getopt(opt, 'ensemble_size', 10);

    // candidate parameters
    this.batch_size_min = getopt(opt, 'batch_size_min', 10);
    this.batch_size_max = getopt(opt, 'batch_size_max', 300);
    this.l2_decay_min = getopt(opt, 'l2_decay_min', -4);
    this.l2_decay_max = getopt(opt, 'l2_decay_max', 2);
    this.learning_rate_min = getopt(opt, 'learning_rate_min', -4);
    this.learning_rate_max = getopt(opt, 'learning_rate_max', 0);
    this.momentum_min = getopt(opt, 'momentum_min', 0.9);
    this.momentum_max = getopt(opt, 'momentum_max', 0.9);
    this.neurons_min = getopt(opt, 'neurons_min', 5);
    this.neurons_max = getopt(opt, 'neurons_max', 30);

    // computed
    this.folds = []; // data fold indices, gets filled by sampleFolds()
    this.candidates = []; // candidate networks that are being currently evaluated
    this.evaluated_candidates = []; // history of all candidates that were fully evaluated on all folds
    this.unique_labels = arrUnique(labels);
    this.iter = 0; // iteration counter, goes from 0 -> num_epochs * num_training_data
    this.foldix = 0; // index of active fold

    // callbacks
    this.finish_fold_callback = null;
    this.finish_batch_callback = null;

    // initializations
    if(this.data.length > 0) {
      this.sampleFolds();
      this.sampleCandidates();
    }
  };

  MagicNet.prototype = {

    // sets this.folds to a sampling of this.num_folds folds
    sampleFolds: function() {
      var N = this.data.length;
      var num_train = Math.floor(this.train_ratio * N);
      this.folds = []; // flush folds, if any
      for(var i=0;i<this.num_folds;i++) {
        var p = randperm(N);
        this.folds.push({train_ix: p.slice(0, num_train), test_ix: p.slice(num_train, N)});
      }
    },

    // returns a random candidate network
    sampleCandidate: function() {
      var input_depth = this.data[0].w.length;
      var num_classes = this.unique_labels.length;

      // sample network topology and hyperparameters
      var layer_defs = [];
      layer_defs.push({type:'input', out_sx:1, out_sy:1, out_depth: input_depth});
      var nl = weightedSample([0,1,2,3], [0.2, 0.3, 0.3, 0.2]); // prefer nets with 1,2 hidden layers
      for(var q=0;q<nl;q++) {
        var ni = randi(this.neurons_min, this.neurons_max);
        var act = ['tanh','maxout','relu'][randi(0,3)];
        if(randf(0,1)<0.5) {
          var dp = Math.random();
          layer_defs.push({type:'fc', num_neurons: ni, activation: act, drop_prob: dp});
        } else {
          layer_defs.push({type:'fc', num_neurons: ni, activation: act});
        }
      }
      layer_defs.push({type:'softmax', num_classes: num_classes});
      var net = new Net();
      net.makeLayers(layer_defs);

      // sample training hyperparameters
      var bs = randi(this.batch_size_min, this.batch_size_max); // batch size
      var l2 = Math.pow(10, randf(this.l2_decay_min, this.l2_decay_max)); // l2 weight decay
      var lr = Math.pow(10, randf(this.learning_rate_min, this.learning_rate_max)); // learning rate
      var mom = randf(this.momentum_min, this.momentum_max); // momentum. Lets just use 0.9, works okay usually ;p
      var tp = randf(0,1); // trainer type
      var trainer_def;
      if(tp<0.33) {
        trainer_def = {method:'adadelta', batch_size:bs, l2_decay:l2};
      } else if(tp<0.66) {
        trainer_def = {method:'adagrad', learning_rate: lr, batch_size:bs, l2_decay:l2};
      } else {
        trainer_def = {method:'sgd', learning_rate: lr, momentum: mom, batch_size:bs, l2_decay:l2};
      }
      
      var trainer = new Trainer(net, trainer_def);

      var cand = {};
      cand.acc = [];
      cand.accv = 0; // this will maintained as sum(acc) for convenience
      cand.layer_defs = layer_defs;
      cand.trainer_def = trainer_def;
      cand.net = net;
      cand.trainer = trainer;
      return cand;
    },

    // sets this.candidates with this.num_candidates candidate nets
    sampleCandidates: function() {
      this.candidates = []; // flush, if any
      for(var i=0;i<this.num_candidates;i++) {
        var cand = this.sampleCandidate();
        this.candidates.push(cand);
      }
    },

    step: function() {
      
      // run an example through current candidate
      this.iter++;

      // step all candidates on a random data point
      var fold = this.folds[this.foldix]; // active fold
      var dataix = fold.train_ix[randi(0, fold.train_ix.length)];
      for(var k=0;k<this.candidates.length;k++) {
        var x = this.data[dataix];
        var l = this.labels[dataix];
        this.candidates[k].trainer.train(x, l);
      }

      // process consequences: sample new folds, or candidates
      var lastiter = this.num_epochs * fold.train_ix.length;
      if(this.iter >= lastiter) {
        // finished evaluation of this fold. Get final validation
        // accuracies, record them, and go on to next fold.
        var val_acc = this.evalValErrors();
        for(var k=0;k<this.candidates.length;k++) {
          var c = this.candidates[k];
          c.acc.push(val_acc[k]);
          c.accv += val_acc[k];
        }
        this.iter = 0; // reset step number
        this.foldix++; // increment fold

        if(this.finish_fold_callback !== null) {
          this.finish_fold_callback();
        }

        if(this.foldix >= this.folds.length) {
          // we finished all folds as well! Record these candidates
          // and sample new ones to evaluate.
          for(var k=0;k<this.candidates.length;k++) {
            this.evaluated_candidates.push(this.candidates[k]);
          }
          // sort evaluated candidates according to accuracy achieved
          this.evaluated_candidates.sort(function(a, b) { 
            return (a.accv / a.acc.length) 
                 > (b.accv / b.acc.length) 
                 ? -1 : 1;
          });
          // and clip only to the top few ones (lets place limit at 3*ensemble_size)
          // otherwise there are concerns with keeping these all in memory 
          // if MagicNet is being evaluated for a very long time
          if(this.evaluated_candidates.length > 3 * this.ensemble_size) {
            this.evaluated_candidates = this.evaluated_candidates.slice(0, 3 * this.ensemble_size);
          }
          if(this.finish_batch_callback !== null) {
            this.finish_batch_callback();
          }
          this.sampleCandidates(); // begin with new candidates
          this.foldix = 0; // reset this
        } else {
          // we will go on to another fold. reset all candidates nets
          for(var k=0;k<this.candidates.length;k++) {
            var c = this.candidates[k];
            var net = new Net();
            net.makeLayers(c.layer_defs);
            var trainer = new Trainer(net, c.trainer_def);
            c.net = net;
            c.trainer = trainer;
          }
        }
      }
    },

    evalValErrors: function() {
      // evaluate candidates on validation data and return performance of current networks
      // as simple list
      var vals = [];
      var fold = this.folds[this.foldix]; // active fold
      for(var k=0;k<this.candidates.length;k++) {
        var net = this.candidates[k].net;
        var v = 0.0;
        for(var q=0;q<fold.test_ix.length;q++) {
          var x = this.data[fold.test_ix[q]];
          var l = this.labels[fold.test_ix[q]];
          net.forward(x);
          var yhat = net.getPrediction();
          v += (yhat === l ? 1.0 : 0.0); // 0 1 loss
        }
        v /= fold.test_ix.length; // normalize
        vals.push(v);
      }
      return vals;
    },

    // returns prediction scores for given test data point, as Vol
    // uses an averaged prediction from the best ensemble_size models
    // x is a Vol.
    predict_soft: function(data) {
      // forward prop the best networks
      // and accumulate probabilities at last layer into a an output Vol
      var nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);
      if(nv === 0) { return new convnetjs.Vol(0,0,0); } // not sure what to do here? we're not ready yet
      var xout, n;
      for(var j=0;j<nv;j++) {
        var net = this.evaluated_candidates[j].net;
        var x = net.forward(data);
        if(j===0) { 
          xout = x; 
          n = x.w.length; 
        } else {
          // add it on
          for(var d=0;d<n;d++) {
            xout.w[d] += x.w[d];
          }
        }
      }
      // produce average
      for(var d=0;d<n;d++) {
        xout.w[d] /= n;
      }
      return xout;
    },

    predict: function(data) {
      var xout = this.predict_soft(data);
      if(xout.w.length !== 0) {
        var stats = maxmin(xout.w);
        var predicted_label = stats.maxi; 
      } else {
        var predicted_label = -1; // error out
      }
      return predicted_label;

    },

    toJSON: function() {
      // dump the top ensemble_size networks as a list
      var nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);
      var json = {};
      json.nets = [];
      for(var i=0;i<nv;i++) {
        json.nets.push(this.evaluated_candidates[i].net.toJSON());
      }
      return json;
    },

    fromJSON: function(json) {
      this.ensemble_size = json.nets.length;
      this.evaluated_candidates = [];
      for(var i=0;i<this.ensemble_size;i++) {
        var net = new Net();
        net.fromJSON(json.nets[i]);
        var dummy_candidate = {};
        dummy_candidate.net = net;
        this.evaluated_candidates.push(dummy_candidate);
      }
    },

    // callback functions
    // called when a fold is finished, while evaluating a batch
    onFinishFold: function(f) { this.finish_fold_callback = f; },
    // called when a batch of candidates has finished evaluating
    onFinishBatch: function(f) { this.finish_batch_callback = f; }
    
  };

  global.MagicNet = MagicNet;
})(convnetjs);
(function(lib) {
  "use strict";
  if (typeof module === "undefined" || typeof module.exports === "undefined") {
    window.jsfeat = lib; // in ordinary browser attach library to window
  } else {
    module.exports = lib; // in nodejs
  }
})(convnetjs);

})()
},{}],19:[function(require,module,exports){
(function(global){/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

})(window)
},{}],25:[function(require,module,exports){

var Canvas = module.exports = function Canvas (w, h) {
  var canvas = document.createElement('canvas')
  canvas.width = w || 300
  canvas.height = h || 150
  return canvas
}

Canvas.Image = function () {
  var img = document.createElement('img')
  return img
}




},{}],17:[function(require,module,exports){
(function() {
  var $, AV, DetailView, DialogView, actPalette, download, generateFilename, gimpPalette;

  $ = require('jquery');

  AV = window.AV;

  actPalette = require('act-js');

  gimpPalette = require('../lib/gimp-palette.coffee');

  DialogView = require('./dialog-view.coffee');

  download = function(filename, content) {
    var $a, a;
    $a = $("<a href=\"" + content + "\" download=\"" + filename + "\"></a>");
    a = $a[0];
    $('body').append($a);
    return setTimeout((function() {
      a.click();
      return $a.remove();
    }), 0);
  };

  generateFilename = function() {
    var name, user, username;
    user = AV.User.current();
    username = user ? user.attributes.username + '@' : '';
    return name = username + 'cocolour.com - ' + (new Date()).getTime();
  };

  DetailView = (function() {
    function DetailView(colors) {
      var $view, html;
      html = "<div id=\"palette-detail\">\n    <h2>Download Palette</h2>\n    <div id=\"palette-detail-colors\">\n    </div>\n    <i class='fa fa-download button download-act'>Adobe Color Table</i>\n    <br>\n    <i class='fa fa-download button download-gimp' title='Save it in ~/.gimp-2.8/palettes/ and restart GIMP.'>Gimp Palette</i>\n</div>";
      $view = $(html);
      $view.find('.download-act').on('click', function() {
        var name;
        name = generateFilename();
        return actPalette(colors, function(err, content) {
          return download(name + '.act', content);
        });
      });
      $view.find('.download-gimp').on('click', function() {
        var content, name;
        name = generateFilename();
        content = gimpPalette(name, colors);
        content = 'data:text/plain;charset=utf-8,' + encodeURIComponent(content);
        return download(name + '.gpl', content);
      });
      $view.find('#palette-detail-colors').html(colors.map(function(color) {
        var hex, rgb;
        rgb = color.join(', ');
        hex = '#' + (color.map(function(d) {
          return d.toString(16);
        })).join('');
        return "<div class=\"color\">\n<div class=\"box\" style=\"background: " + hex + "\"></div>\n" + hex + " (" + rgb + ")</div>";
      }).join(''));
      new DialogView($view);
    }

    return DetailView;

  })();

  module.exports = DetailView;

}).call(this);


},{"../lib/gimp-palette.coffee":15,"./dialog-view.coffee":10,"jquery":6,"act-js":26}],27:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var CIE76;

  CIE76 = function(lab1, lab2) {
    var sum;
    sum = 0;
    lab1.forEach(function(val, i) {
      return sum += Math.pow(val - lab2[i], 2);
    });
    return Math.sqrt(sum);
  };

  module.exports = CIE76;

}).call(this);

},{}],28:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var seeds;

  seeds = "240,248,255\n250,235,215\n0,255,255\n127,255,212\n240,255,255\n245,245,220\n255,228,196\n0,0,0\n255,235,205\n0,0,255\n138,43,226\n165,42,42\n222,184,135\n95,158,160\n127,255,0\n210,105,30\n255,127,80\n100,149,237\n255,248,220\n220,20,60\n0,255,255\n0,0,139\n0,139,139\n184,134,11\n169,169,169\n0,100,0\n169,169,169\n189,183,107\n139,0,139\n85,107,47\n255,140,0\n153,50,204\n139,0,0\n233,150,122\n143,188,143\n72,61,139\n47,79,79\n47,79,79\n0,206,209\n148,0,211\n255,20,147\n0,191,255\n105,105,105\n105,105,105\n30,144,255\n178,34,34\n255,250,240\n34,139,34\n255,0,255\n220,220,220\n248,248,255\n255,215,0\n218,165,32\n128,128,128\n0,128,0\n173,255,47\n128,128,128\n240,255,240\n255,105,180\n205,92,92\n75,0,130\n255,255,240\n240,230,140\n230,230,250\n255,240,245\n124,252,0\n255,250,205\n173,216,230\n240,128,128\n224,255,255\n250,250,210\n211,211,211\n144,238,144\n211,211,211\n255,182,193\n255,160,122\n32,178,170\n135,206,250\n119,136,153\n119,136,153\n176,196,222\n255,255,224\n0,255,0\n50,205,50\n250,240,230\n255,0,255\n128,0,0\n102,205,170\n0,0,205\n186,85,211\n147,112,219\n60,179,113\n123,104,238\n0,250,154\n72,209,204\n199,21,133\n25,25,112\n245,255,250\n255,228,225\n255,228,181\n255,222,173\n0,0,128\n253,245,230\n128,128,0\n107,142,35\n255,165,0\n255,69,0\n218,112,214\n238,232,170\n152,251,152\n175,238,238\n219,112,147\n255,239,213\n255,218,185\n205,133,63\n255,192,203\n221,160,221\n176,224,230\n128,0,128\n255,0,0\n188,143,143\n65,105,225\n139,69,19\n250,128,114\n244,164,96\n46,139,87\n255,245,238\n160,82,45\n192,192,192\n135,206,235\n106,90,205\n112,128,144\n112,128,144\n255,250,250\n0,255,127\n70,130,180\n210,180,140\n0,128,128\n216,191,216\n255,99,71\n64,224,208\n238,130,238\n245,222,179\n255,255,255\n245,245,245\n255,255,0\n154,205,50";

  seeds = seeds.split("\n").map(function(line) {
    return line.split(",");
  });

  module.exports = seeds;

}).call(this);

},{}],21:[function(require,module,exports){
'use strict';

module.exports = require('./lib/core.js')
require('./lib/done.js')
require('./lib/es6-extensions.js')
require('./lib/node-extensions.js')
},{"./lib/core.js":29,"./lib/done.js":30,"./lib/es6-extensions.js":31,"./lib/node-extensions.js":32}],23:[function(require,module,exports){
module.exports = require('./lib/math.js');

},{"./lib/math.js":33}],22:[function(require,module,exports){
var conversions = require("./conversions");

var convert = function() {
   return new Converter();
}

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] =  (function(func) {
    // accept array or plain args
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    }
  })(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = (function(func) { 
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined)
        return val; // keyword

      for (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      return val;
    }
  })(func);
}


/* Converter does lazy conversion and caching */
var Converter = function() {
   this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function(space, args) {
   var values = args[0];
   if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof values == "number") {
      values = Array.prototype.slice.call(args);        
   }

   return this.setValues(space, values);
};
  
/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
   this.space = space;
   this.convs = {};
   this.convs[space] = values;
   return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function(space) {
   var vals = this.convs[space];
   if (!vals) {
      var fspace = this.space,
          from = this.convs[fspace];
      vals = convert[fspace][space](from);

      this.convs[space] = vals;
   }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
   Converter.prototype[space] = function(vals) {
      return this.routeSpace(space, arguments);
   }
});

module.exports = convert;
},{"./conversions":34}],26:[function(require,module,exports){
// There is no version number written in the file.
// The file contains 256 RGB colors.
// The first color in the table is index zero.
// There are three bytes per color in the order Red, Green, Blue.

var generate = function(colors, callback) {
    var array = new Uint8Array(256 * 3 + 2 * 2);
    var i, color;
    for(i = 0; i < 256 * 3; i++) {
        array[i] = 0;
    }
    for(i = 0; i < colors.length; i++) {
        color = colors[i];
        array[3 * i] = color[0]; // R
        array[3 * i + 1] = color[1]; // G
        array[3 * i + 2] = color[2]; // B
    }
    var blob = new Blob([array], {type: "application/octet-stream"});
    var reader = new FileReader();
    reader.onload = function(ev) {
        var err = null;
        callback(err, ev.target.result);
    };
    reader.readAsDataURL(blob);
};

module.exports = generate;

},{}],34:[function(require,module,exports){
/* MIT license */

module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
}


function rgb2hsl(rgb) {
  var r = rgb[0]/255,
      g = rgb[1]/255,
      b = rgb[2]/255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, l;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g)/ delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  l = (min + max) / 2;

  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, v;

  if (max == 0)
    s = 0;
  else
    s = (delta/max * 1000)/10;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  v = ((max / 255) * 1000) / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0]
      w = 1/255 * Math.min(r, Math.min(g, b))
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c, m, y, k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k);
  m = (1 - g - k) / (1 - k);
  y = (1 - b - k) / (1 - k);
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  return [x * 100, y *100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv, v;
  l *= 2;
  s *= (l <= 1) ? l : 2 - l;
  v = (l + s) / 2;
  sv = (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}


function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - (s * f)),
      t = 255 * v * (1 - (s * (1 - f))),
      v = 255 * v;

  switch(hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl, l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= (l <= 1) ? l : 2 - l;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args))
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i, v, f, n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);  // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r, g, b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}


function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r, g, b;

  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  // assume sRGB
  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    : r = (r * 12.92);

  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    : g = (g * 12.92);

  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    : b = (b * 12.92);

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x, y, z, y2;

  if (l <= 8) {
    y = (l * 100) / 903.3;
    y2 = (7.787 * (y / 100)) + (16 / 116);
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr, h, c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a, b, hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue:  [240,248,255],
  antiquewhite: [250,235,215],
  aqua: [0,255,255],
  aquamarine: [127,255,212],
  azure:  [240,255,255],
  beige:  [245,245,220],
  bisque: [255,228,196],
  black:  [0,0,0],
  blanchedalmond: [255,235,205],
  blue: [0,0,255],
  blueviolet: [138,43,226],
  brown:  [165,42,42],
  burlywood:  [222,184,135],
  cadetblue:  [95,158,160],
  chartreuse: [127,255,0],
  chocolate:  [210,105,30],
  coral:  [255,127,80],
  cornflowerblue: [100,149,237],
  cornsilk: [255,248,220],
  crimson:  [220,20,60],
  cyan: [0,255,255],
  darkblue: [0,0,139],
  darkcyan: [0,139,139],
  darkgoldenrod:  [184,134,11],
  darkgray: [169,169,169],
  darkgreen:  [0,100,0],
  darkgrey: [169,169,169],
  darkkhaki:  [189,183,107],
  darkmagenta:  [139,0,139],
  darkolivegreen: [85,107,47],
  darkorange: [255,140,0],
  darkorchid: [153,50,204],
  darkred:  [139,0,0],
  darksalmon: [233,150,122],
  darkseagreen: [143,188,143],
  darkslateblue:  [72,61,139],
  darkslategray:  [47,79,79],
  darkslategrey:  [47,79,79],
  darkturquoise:  [0,206,209],
  darkviolet: [148,0,211],
  deeppink: [255,20,147],
  deepskyblue:  [0,191,255],
  dimgray:  [105,105,105],
  dimgrey:  [105,105,105],
  dodgerblue: [30,144,255],
  firebrick:  [178,34,34],
  floralwhite:  [255,250,240],
  forestgreen:  [34,139,34],
  fuchsia:  [255,0,255],
  gainsboro:  [220,220,220],
  ghostwhite: [248,248,255],
  gold: [255,215,0],
  goldenrod:  [218,165,32],
  gray: [128,128,128],
  green:  [0,128,0],
  greenyellow:  [173,255,47],
  grey: [128,128,128],
  honeydew: [240,255,240],
  hotpink:  [255,105,180],
  indianred:  [205,92,92],
  indigo: [75,0,130],
  ivory:  [255,255,240],
  khaki:  [240,230,140],
  lavender: [230,230,250],
  lavenderblush:  [255,240,245],
  lawngreen:  [124,252,0],
  lemonchiffon: [255,250,205],
  lightblue:  [173,216,230],
  lightcoral: [240,128,128],
  lightcyan:  [224,255,255],
  lightgoldenrodyellow: [250,250,210],
  lightgray:  [211,211,211],
  lightgreen: [144,238,144],
  lightgrey:  [211,211,211],
  lightpink:  [255,182,193],
  lightsalmon:  [255,160,122],
  lightseagreen:  [32,178,170],
  lightskyblue: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  lightsteelblue: [176,196,222],
  lightyellow:  [255,255,224],
  lime: [0,255,0],
  limegreen:  [50,205,50],
  linen:  [250,240,230],
  magenta:  [255,0,255],
  maroon: [128,0,0],
  mediumaquamarine: [102,205,170],
  mediumblue: [0,0,205],
  mediumorchid: [186,85,211],
  mediumpurple: [147,112,219],
  mediumseagreen: [60,179,113],
  mediumslateblue:  [123,104,238],
  mediumspringgreen:  [0,250,154],
  mediumturquoise:  [72,209,204],
  mediumvioletred:  [199,21,133],
  midnightblue: [25,25,112],
  mintcream:  [245,255,250],
  mistyrose:  [255,228,225],
  moccasin: [255,228,181],
  navajowhite:  [255,222,173],
  navy: [0,0,128],
  oldlace:  [253,245,230],
  olive:  [128,128,0],
  olivedrab:  [107,142,35],
  orange: [255,165,0],
  orangered:  [255,69,0],
  orchid: [218,112,214],
  palegoldenrod:  [238,232,170],
  palegreen:  [152,251,152],
  paleturquoise:  [175,238,238],
  palevioletred:  [219,112,147],
  papayawhip: [255,239,213],
  peachpuff:  [255,218,185],
  peru: [205,133,63],
  pink: [255,192,203],
  plum: [221,160,221],
  powderblue: [176,224,230],
  purple: [128,0,128],
  rebeccapurple: [102, 51, 153],
  red:  [255,0,0],
  rosybrown:  [188,143,143],
  royalblue:  [65,105,225],
  saddlebrown:  [139,69,19],
  salmon: [250,128,114],
  sandybrown: [244,164,96],
  seagreen: [46,139,87],
  seashell: [255,245,238],
  sienna: [160,82,45],
  silver: [192,192,192],
  skyblue:  [135,206,235],
  slateblue:  [106,90,205],
  slategray:  [112,128,144],
  slategrey:  [112,128,144],
  snow: [255,250,250],
  springgreen:  [0,255,127],
  steelblue:  [70,130,180],
  tan:  [210,180,140],
  teal: [0,128,128],
  thistle:  [216,191,216],
  tomato: [255,99,71],
  turquoise:  [64,224,208],
  violet: [238,130,238],
  wheat:  [245,222,179],
  white:  [255,255,255],
  whitesmoke: [245,245,245],
  yellow: [255,255,0],
  yellowgreen:  [154,205,50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}

},{}],24:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var calcCenter, calcClusters, calcDistance, color, seeds;

  color = require("color-convert");

  calcDistance = require("./CIE76.js");

  seeds = require("./seeds.js");

  calcCenter = function(labs) {
    var A, B, L, d, lab, len, minDistance, newCenter, _i, _len, _ref;
    _ref = [0, 0, 0], L = _ref[0], A = _ref[1], B = _ref[2];
    labs.forEach(function(lab) {
      L += lab[0];
      A += lab[1];
      return B += lab[2];
    });
    len = labs.length;
    L /= len;
    A /= len;
    B /= len;
    minDistance = null;
    newCenter = null;
    for (_i = 0, _len = labs.length; _i < _len; _i++) {
      lab = labs[_i];
      d = calcDistance([L, A, B], lab);
      if ((newCenter == null) || (d > minDistance)) {
        minDistance = d;
        newCenter = lab;
      }
    }
    return newCenter;
  };

  calcClusters = function(pixels, config) {
    var centers, clusters, end, iter, log, removeEmptyClusters, start, useRandomPixels;
    start = (new Date()).getTime();
    log = function(title, colors) {
      if (colors == null) {
        colors = [];
      }
      if (config.debug) {
        return typeof config.log === "function" ? config.log(title, colors.map(function(lab) {
          return color.lab2rgb(lab);
        })) : void 0;
      }
    };
    pixels = pixels.map(function(rgba) {
      var a, b, g, r, rgb;
      r = rgba[0], g = rgba[1], b = rgba[2], a = rgba[3];
      rgb = [r, g, b];
      if (a !== 255) {
        a /= 255;
        rgb = rgb.map(function(elem) {
          return 255 * (1 - a) + elem * a;
        });
      }
      return color.rgb2lab(rgb);
    });
    centers = seeds.map(function(rgb) {
      return color.rgb2lab(rgb);
    });
    log("Seeds", centers);
    clusters = null;
    iter = function(removeEmptyClusters, useRandomPixels) {
      var i, minDistance, minIndex, pixel, _i, _j, _len, _ref;
      if (removeEmptyClusters == null) {
        removeEmptyClusters = true;
      }
      if (useRandomPixels == null) {
        useRandomPixels = true;
      }
      clusters = [];
      for (i = _i = 0, _ref = centers.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        clusters[i] = [];
      }
      for (_j = 0, _len = pixels.length; _j < _len; _j++) {
        pixel = pixels[_j];
        minIndex = null;
        minDistance = null;
        centers.forEach(function(center, index) {
          var d;
          d = calcDistance(center, pixel);
          if ((minDistance == null) || (d < minDistance)) {
            minIndex = index;
            return minDistance = d;
          }
        });
        clusters[minIndex].push(pixel);
      }
      if (removeEmptyClusters) {
        clusters = clusters.filter(function(clusterPixels) {
          return clusterPixels.length > 0;
        });
      }
      centers = clusters.map(function(clusterPixels) {
        return calcCenter(clusterPixels);
      });
      if (useRandomPixels) {
        while (centers.length < config.minCount) {
          centers.push(pixels[parseInt(Math.random() * pixels.length)]);
        }
      }
      return log("New Clusters", centers);
    };
    iter();
    iter();
    iter();
    iter(removeEmptyClusters = false, useRandomPixels = false);
    centers = centers.map(function(lab) {
      return color.lab2rgb(lab);
    });
    end = (new Date()).getTime();
    log("Calc " + centers.length + " clusters in " + (end - start) + "ms");
    return centers.map(function(center, i) {
      var weight;
      weight = clusters[i].length / pixels.length;
      return {
        color: center,
        weight: weight
      };
    });
  };

  module.exports = calcClusters;

}).call(this);

},{"./CIE76.js":27,"./seeds.js":28,"color-convert":22}],35:[function(require,module,exports){
'use strict';

/**
 * Clone an object
 *
 *     clone(x)
 *
 * Can clone any primitive type, array, and object.
 * If x has a function clone, this function will be invoked to clone the object.
 *
 * @param {*} x
 * @return {*} clone
 */
exports.clone = function clone(x) {
  var type = typeof x;

  // immutable primitive types
  if (type === 'number' || type === 'string' || type === 'boolean' ||
      x === null || x === undefined) {
    return x;
  }

  // use clone function of the object when available
  if (typeof x.clone === 'function') {
    return x.clone();
  }

  // array
  if (Array.isArray(x)) {
    return x.map(function (value) {
      return clone(value);
    });
  }

  if (x instanceof Number)  return new Number(x.valueOf());
  if (x instanceof String)  return new String(x.valueOf());
  if (x instanceof Boolean) return new Boolean(x.valueOf());
  if (x instanceof Date)    return new Date(x.valueOf());
  if (x instanceof RegExp)  throw new TypeError('Cannot clone ' + x);  // TODO: clone a RegExp

  // object
  var m = {};
  for (var key in x) {
    if (x.hasOwnProperty(key)) {
      m[key] = clone(x[key]);
    }
  }
  return m;
};

/**
 * Extend object a with the properties of object b
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.extend = function(a, b) {
  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
};

/**
 * Deep extend an object a with the properties of object b
 * @param {Object} a
 * @param {Object} b
 * @returns {Object}
 */
exports.deepExtend = function deepExtend (a, b) {
  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }

  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          deepExtend(a[prop], b[prop]);
        }
        else {
          a[prop] = b[prop];
        }
      } else if (Array.isArray(b[prop])) {
        throw new TypeError('Arrays are not supported by deepExtend');
      } else {
        a[prop] = b[prop];
      }
    }
  }
  return a;
};

/**
 * Deep test equality of all fields in two pairs of arrays or objects.
 * @param {Array | Object} a
 * @param {Array | Object} b
 * @returns {boolean}
 */
exports.deepEqual = function deepEqual (a, b) {
  var prop, i, len;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }

    if (a.length != b.length) {
      return false;
    }

    for (i = 0, len = a.length; i < len; i++) {
      if (!exports.deepEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }

    for (prop in a) {
      //noinspection JSUnfilteredForInLoop
      if (!exports.deepEqual(a[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      //noinspection JSUnfilteredForInLoop
      if (!exports.deepEqual(a[prop], b[prop])) {
        return false;
      }
    }
    return true;
  }
  else {
    return (typeof a === typeof b) && (a == b);
  }
};

},{}],36:[function(require,module,exports){
'use strict';

/**
 * Test whether value is a Number
 * @param {*} value
 * @return {Boolean} isNumber
 */
exports.isNumber = function(value) {
  return (value instanceof Number) || (typeof value == 'number');
};

/**
 * Check if a number is integer
 * @param {Number | Boolean} value
 * @return {Boolean} isInteger
 */
exports.isInteger = function(value) {
  return (value == Math.round(value));
  // Note: we use ==, not ===, as we can have Booleans as well
};

/**
 * Calculate the sign of a number
 * @param {Number} x
 * @returns {*}
 */
exports.sign = function(x) {
  if (x > 0) {
    return 1;
  }
  else if (x < 0) {
    return -1;
  }
  else {
    return 0;
  }
};

/**
 * Convert a number to a formatted string representation.
 *
 * Syntax:
 *
 *    format(value)
 *    format(value, options)
 *    format(value, precision)
 *    format(value, fn)
 *
 * Where:
 *
 *    {Number} value   The value to be formatted
 *    {Object} options An object with formatting options. Available options:
 *                     {String} notation
 *                         Number notation. Choose from:
 *                         'fixed'          Always use regular number notation.
 *                                          For example '123.40' and '14000000'
 *                         'exponential'    Always use exponential notation.
 *                                          For example '1.234e+2' and '1.4e+7'
 *                         'auto' (default) Regular number notation for numbers
 *                                          having an absolute value between
 *                                          `lower` and `upper` bounds, and uses
 *                                          exponential notation elsewhere.
 *                                          Lower bound is included, upper bound
 *                                          is excluded.
 *                                          For example '123.4' and '1.4e7'.
 *                     {Number} precision   A number between 0 and 16 to round
 *                                          the digits of the number.
 *                                          In case of notations 'exponential' and
 *                                          'auto', `precision` defines the total
 *                                          number of significant digits returned
 *                                          and is undefined by default.
 *                                          In case of notation 'fixed',
 *                                          `precision` defines the number of
 *                                          significant digits after the decimal
 *                                          point, and is 0 by default.
 *                     {Object} exponential An object containing two parameters,
 *                                          {Number} lower and {Number} upper,
 *                                          used by notation 'auto' to determine
 *                                          when to return exponential notation.
 *                                          Default values are `lower=1e-3` and
 *                                          `upper=1e5`.
 *                                          Only applicable for notation `auto`.
 *    {Function} fn    A custom formatting function. Can be used to override the
 *                     built-in notations. Function `fn` is called with `value` as
 *                     parameter and must return a string. Is useful for example to
 *                     format all values inside a matrix in a particular way.
 *
 * Examples:
 *
 *    format(6.4);                                        // '6.4'
 *    format(1240000);                                    // '1.24e6'
 *    format(1/3);                                        // '0.3333333333333333'
 *    format(1/3, 3);                                     // '0.333'
 *    format(21385, 2);                                   // '21000'
 *    format(12.071, {notation: 'fixed'});                // '12'
 *    format(2.3,    {notation: 'fixed', precision: 2});  // '2.30'
 *    format(52.8,   {notation: 'exponential'});          // '5.28e+1'
 *
 * @param {Number} value
 * @param {Object | Function | Number} [options]
 * @return {String} str The formatted value
 */
exports.format = function(value, options) {
  if (typeof options === 'function') {
    // handle format(value, fn)
    return options(value);
  }

  // handle special cases
  if (value === Infinity) {
    return 'Infinity';
  }
  else if (value === -Infinity) {
    return '-Infinity';
  }
  else if (isNaN(value)) {
    return 'NaN';
  }

  // default values for options
  var notation = 'auto';
  var precision = undefined;

  if (options) {
    // determine notation from options
    if (options.notation) {
      notation = options.notation;
    }

    // determine precision from options
    if (exports.isNumber(options)) {
      precision = options;
    }
    else if (options.precision) {
      precision = options.precision;
    }
  }

  // handle the various notations
  switch (notation) {
    case 'fixed':
      return exports.toFixed(value, precision);

    case 'exponential':
      return exports.toExponential(value, precision);

    case 'auto':
      // determine lower and upper bound for exponential notation.
        // TODO: implement support for upper and lower to be BigNumbers themselves
      var lower = 1e-3;
      var upper = 1e5;
      if (options && options.exponential) {
        if (options.exponential.lower !== undefined) {
          lower = options.exponential.lower;
        }
        if (options.exponential.upper !== undefined) {
          upper = options.exponential.upper;
        }
      }

      // handle special case zero
      if (value === 0) return '0';

      // determine whether or not to output exponential notation
      var str;
      var abs = Math.abs(value);
      if (abs >= lower && abs < upper) {
        // normal number notation
        // Note: IE7 does not allow value.toPrecision(undefined)
        var valueStr = precision ?
            value.toPrecision(Math.min(precision, 21)) :
            value.toPrecision();
        str = parseFloat(valueStr) + '';
      }
      else {
        // exponential notation
        str = exports.toExponential(value, precision);
      }

      // remove trailing zeros after the decimal point
      return str.replace(/((\.\d*?)(0+))($|e)/, function () {
        var digits = arguments[2];
        var e = arguments[4];
        return (digits !== '.') ? digits + e : e;
      });

    default:
      throw new Error('Unknown notation "' + notation + '". ' +
          'Choose "auto", "exponential", or "fixed".');
  }
};

/**
 * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
 * @param {Number} value
 * @param {Number} [precision]  Number of digits in formatted output.
 *                              If not provided, the maximum available digits
 *                              is used.
 * @returns {string} str
 */
exports.toExponential = function(value, precision) {
  if (precision !== undefined) {
    return value.toExponential(Math.min(precision - 1, 20));
  }
  else {
    return value.toExponential();
  }
};

/**
 * Format a number with fixed notation.
 * @param {Number} value
 * @param {Number} [precision=0]        Optional number of decimals after the
 *                                      decimal point. Zero by default.
 */
exports.toFixed = function(value, precision) {
  return value.toFixed(Math.min(precision, 20));
};

/**
 * Count the number of significant digits of a number.
 *
 * For example:
 *   2.34 returns 3
 *   0.0034 returns 2
 *   120.5e+30 returns 4
 *
 * @param {Number} value
 * @return {Number} digits   Number of significant digits
 */
exports.digits = function(value) {
  return value
      .toExponential()
      .replace(/e.*$/, '')          // remove exponential notation
      .replace( /^0\.?0*|\./, '')   // remove decimal point and leading zeros
      .length
};

/**
 * Minimum number added to one that makes the result different than one
 */
exports.DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;

/**
 * Compares two floating point numbers.
 * @param {Number} x          First value to compare
 * @param {Number} y          Second value to compare
 * @param {Number} [epsilon]  The maximum relative difference between x and y
 *                            If epsilon is undefined or null, the function will
 *                            test whether x and y are exactly equal.
 * @return {boolean} whether the two numbers are equal
*/
exports.nearlyEqual = function(x, y, epsilon) {
  // if epsilon is null or undefined, test whether x and y are exactly equal
  if (epsilon == null) return x == y;

  // use "==" operator, handles infinities
  if (x == y) return true;

  // NaN
  if (isNaN(x) || isNaN(y)) return false;

  // at this point x and y should be finite
  if(isFinite(x) && isFinite(y)) {
    // check numbers are very close, needed when comparing numbers near zero
    var diff = Math.abs(x - y);
    if (diff < exports.DBL_EPSILON) {
      return true;
    }
    else {
      // use relative error
      return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
    }
  }

  // Infinite and Number or negative Infinite and positive Infinite cases
  return false;
};

},{}],37:[function(require,module,exports){
'use strict';

/**
 * A ResultSet contains a list or results
 * @param {Array} entries
 * @constructor
 */
function ResultSet(entries) {
  if (!(this instanceof ResultSet)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.entries = entries || [];
}

/**
 * Returns the array with results hold by this ResultSet
 * @returns {Array} entries
 */
ResultSet.prototype.valueOf = function () {
  return this.entries;
};

/**
 * Returns the stringified results of the ResultSet
 * @returns {String} string
 */
ResultSet.prototype.toString = function () {
  return '[' + this.entries.join(', ') + ']';
};

module.exports = ResultSet;

},{}],38:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  /**
   * Wrap any value in a Selector, allowing to perform chained operations on
   * the value.
   *
   * All methods available in the math.js library can be called upon the selector,
   * and then will be evaluated with the value itself as first argument.
   * The selector can be closed by executing `selector.done()`, which returns
   * the final value.
   *
   * The Selector has a number of special functions:
   *
   * - `done()`     Finalize the chained operation and return the selectors value.
   * - `valueOf()`  The same as `done()`
   * - `toString()` Executes `math.format()` onto the selectors value, returning
   *                a string representation of the value.
   *
   * Syntax:
   *
   *    math.select(value)
   *
   * Examples:
   *
   *     math.select(3)
   *         .add(4)
   *         .subtract(2)
   *         .done();     // 5
   *
   *     math.select( [[1, 2], [3, 4]] )
   *         .set([1, 1], 8)
   *         .multiply(3)
   *         .done();     // [[24, 6], [9, 12]]
   *
   * @param {*} [value]   A value of any type on which to start a chained operation.
   * @return {math.chaining.Selector} The created selector
   */
  math.select = function select(value) {
    // TODO: check number of arguments
    return new math.chaining.Selector(value);
  };
};

},{}],39:[function(require,module,exports){
'use strict';

module.exports = function (math) {


  /**
   * Compute the standard deviation of a matrix or a  list with values.
   * The standard deviations is defined as the square root of the variance:
   * `std(A) = sqrt(var(A))`.
   * In case of a (multi dimensional) array or matrix, the standard deviation
   * over all elements will be calculated.
   *
   * Optionally, the type of normalization can be specified as second
   * parameter. The parameter `normalization` can be one of the following values:
   *
   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
   * - 'uncorrected'        The sum of squared errors is divided by n
   * - 'biased'             The sum of squared errors is divided by (n + 1)
   *
   * Syntax:
   *
   *     math.std(a, b, c, ...)
   *     math.std(A)
   *     math.std(A, normalization)
   *
   * Examples:
   *
   *     math.std(2, 4, 6);                     // returns 2
   *     math.std([2, 4, 6, 8]);                // returns 2.581988897471611
   *     math.std([2, 4, 6, 8], 'uncorrected'); // returns 2.23606797749979
   *     math.std([2, 4, 6, 8], 'biased');      // returns 2
   *
   *     math.std([[1, 2, 3], [4, 5, 6]]);      // returns 1.8708286933869707
   *
   * See also:
   *
   *    mean, median, max, min, prod, sum, var
   *
   * @param {Array | Matrix} array
   *                        A single matrix or or multiple scalar values
   * @param {String} [normalization='unbiased']
   *                        Determines how to normalize the variance.
   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
   * @return {*} The standard deviation
   */
  math.std = function std(array, normalization) {
    if (arguments.length == 0) {
      throw new SyntaxError('Function std requires one or more parameters (0 provided)');
    }

    var variance = math['var'].apply(null, arguments);
    return math.sqrt(variance);
  };
};

},{}],30:[function(require,module,exports){
'use strict';

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this
  self.then(null, function (err) {
    asap(function () {
      throw err
    })
  })
}
},{"./core.js":29,"asap":40}],29:[function(require,module,exports){
'use strict';

var asap = require('asap')

module.exports = Promise;
function Promise(fn) {
  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
  if (typeof fn !== 'function') throw new TypeError('not a function')
  var state = null
  var value = null
  var deferreds = []
  var self = this

  this.then = function(onFulfilled, onRejected) {
    return new self.constructor(function(resolve, reject) {
      handle(new Handler(onFulfilled, onRejected, resolve, reject))
    })
  }

  function handle(deferred) {
    if (state === null) {
      deferreds.push(deferred)
      return
    }
    asap(function() {
      var cb = state ? deferred.onFulfilled : deferred.onRejected
      if (cb === null) {
        (state ? deferred.resolve : deferred.reject)(value)
        return
      }
      var ret
      try {
        ret = cb(value)
      }
      catch (e) {
        deferred.reject(e)
        return
      }
      deferred.resolve(ret)
    })
  }

  function resolve(newValue) {
    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then
        if (typeof then === 'function') {
          doResolve(then.bind(newValue), resolve, reject)
          return
        }
      }
      state = true
      value = newValue
      finale()
    } catch (e) { reject(e) }
  }

  function reject(newValue) {
    state = false
    value = newValue
    finale()
  }

  function finale() {
    for (var i = 0, len = deferreds.length; i < len; i++)
      handle(deferreds[i])
    deferreds = null
  }

  doResolve(fn, resolve, reject)
}


function Handler(onFulfilled, onRejected, resolve, reject){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
  this.onRejected = typeof onRejected === 'function' ? onRejected : null
  this.resolve = resolve
  this.reject = reject
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, onFulfilled, onRejected) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return
      done = true
      onFulfilled(value)
    }, function (reason) {
      if (done) return
      done = true
      onRejected(reason)
    })
  } catch (ex) {
    if (done) return
    done = true
    onRejected(ex)
  }
}

},{"asap":40}],31:[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

function ValuePromise(value) {
  this.then = function (onFulfilled) {
    if (typeof onFulfilled !== 'function') return this
    return new Promise(function (resolve, reject) {
      asap(function () {
        try {
          resolve(onFulfilled(value))
        } catch (ex) {
          reject(ex);
        }
      })
    })
  }
}
ValuePromise.prototype = Promise.prototype

var TRUE = new ValuePromise(true)
var FALSE = new ValuePromise(false)
var NULL = new ValuePromise(null)
var UNDEFINED = new ValuePromise(undefined)
var ZERO = new ValuePromise(0)
var EMPTYSTRING = new ValuePromise('')

Promise.resolve = function (value) {
  if (value instanceof Promise) return value

  if (value === null) return NULL
  if (value === undefined) return UNDEFINED
  if (value === true) return TRUE
  if (value === false) return FALSE
  if (value === 0) return ZERO
  if (value === '') return EMPTYSTRING

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then
      if (typeof then === 'function') {
        return new Promise(then.bind(value))
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex)
      })
    }
  }

  return new ValuePromise(value)
}

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr)

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([])
    var remaining = args.length
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then
          if (typeof then === 'function') {
            then.call(val, function (val) { res(i, val) }, reject)
            return
          }
        }
        args[i] = val
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex)
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i])
    }
  })
}

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) { 
    reject(value);
  });
}

Promise.race = function (values) {
  return new Promise(function (resolve, reject) { 
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    })
  });
}

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
}

},{"./core.js":29,"asap":40}],41:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var bignumber = require('./util/bignumber');
  var Complex = require('./type/Complex');
  var BigNumber = math.type.BigNumber;

  /**
   * Calculate BigNumber e
   * @returns {BigNumber} Returns e
   */
  function bigE() {
    return new BigNumber(1).exp();
  }

  /**
   * Calculate BigNumber golden ratio, phi = (1+sqrt(5))/2
   * @returns {BigNumber} Returns phi
   */
  function bigPhi() {
    return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);
  }

  /**
   * arctan(x) = x - x^3/3 + x^5/5 - x^7/7 + x^9/9 - ...
   *           = x - x^2*x^1/3 + x^2*x^3/5 - x^2*x^5/7 + x^2*x^7/9 - ...
   * @param {BigNumber} x
   * @returns {BigNumber} arc tangent of x
   */
  function arctan(x) {
    var y = x;
    var yPrev = NaN;
    var x2 = x.times(x);
    var num = x;
    var sign = -1;

    for (var k = 3; !y.equals(yPrev); k += 2) {
      num = num.times(x2);

      yPrev = y;
      y = (sign > 0) ? y.plus(num.div(k)) : y.minus(num.div(k));
      sign = -sign;
    }

    return y;
  }

  /**
   * Calculate BigNumber pi.
   *
   * Uses Machin's formula: pi / 4 = 4 * arctan(1 / 5) - arctan(1 / 239)
   * http://milan.milanovic.org/math/english/pi/machin.html
   * @returns {BigNumber} Returns pi
   */
  function bigPi() {
    // we calculate pi with a few decimal places extra to prevent round off issues
    var Big = BigNumber.constructor({precision: BigNumber.precision + 4});
    var pi4th = new Big(4).times(arctan(new Big(1).div(5)))
        .minus(arctan(new Big(1).div(239)));

    // the final pi has the requested number of decimals
    return new BigNumber(4).times(pi4th);
  }

  /**
   * Calculate BigNumber tau, tau = 2 * pi
   * @returns {BigNumber} Returns tau
   */
  function bigTau() {
    // we calculate pi at a slightly higher precision than configured to prevent round off errors
    // when multiplying by two in the end
    BigNumber.config({precision: config.precision + 2});

    var pi = bigPi();

    BigNumber.config({precision: config.precision});

    return new BigNumber(2).times(pi);
  }

  var big = config.number === 'bignumber';

  // TODO: in case of support for defineProperty, we can lazy evaluate the BigNumber constants by creating them as properties (calculation of PI is slow for example)
  math.pi          = big ? bigPi()  : Math.PI;
  math.tau         = big ? bigTau() : Math.PI * 2;
  math.e           = big ? bigE()   : Math.E;
  math.phi         = big ? bigPhi() : 1.61803398874989484820458683436563811772030917980576286213545; // golden ratio, (1+sqrt(5))/2

  math.i           = new Complex(0, 1);

  math['Infinity'] = Infinity;
  math['NaN']      = NaN;
  math['true']     = true;
  math['false']    = false;
  math['null']     = null;
  math['uninitialized'] = require('./util/array').UNINITIALIZED;

  // uppercase constants (for compatibility with built-in Math)
  math.E           = math.e;
  math.LN2         = big ? new BigNumber(2).ln()                        : Math.LN2;
  math.LN10        = big ? new BigNumber(10).ln()                       : Math.LN10;
  math.LOG2E       = big ? new BigNumber(1).div(new BigNumber(2).ln())  : Math.LOG2E;
  math.LOG10E      = big ? new BigNumber(1).div(new BigNumber(10).ln()) : Math.LOG10E;
  math.PI          = math.pi;
  math.SQRT1_2     = big ? new BigNumber(0.5).sqrt()                    : Math.SQRT1_2;
  math.SQRT2       = big ? new BigNumber(2).sqrt()                      : Math.SQRT2;

  // meta information
  math.version = require('./version');
};

},{"./util/bignumber":42,"./type/Complex":43,"./util/array":44,"./version":45}],32:[function(require,module,exports){
'use strict';

//This file contains then/promise specific extensions that are only useful for node.js interop

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity
  return function () {
    var self = this
    var args = Array.prototype.slice.call(arguments)
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop()
      }
      args.push(function (err, res) {
        if (err) reject(err)
        else resolve(res)
      })
      var res = fn.apply(self, args)
      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
        resolve(res)
      }
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments)
    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
    var ctx = this
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx)
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) { reject(ex) })
      } else {
        asap(function () {
          callback.call(ctx, ex)
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value)
    })
  }, function (err) {
    asap(function () {
      callback.call(ctx, err)
    })
  })
}

},{"./core.js":29,"asap":40}],33:[function(require,module,exports){
'use strict';

var object = require('./util/object');
var digits = require('./util/number').digits;

/**
 * math.js factory function.
 *
 * @param {Object} [config] Available configuration options:
 *                            {String} matrix
 *                              A string 'matrix' (default) or 'array'.
 *                            {String} number
 *                              A string 'number' (default) or 'bignumber'
 *                            {Number} precision
 *                              The number of significant digits for BigNumbers.
 *                              Not applicable for Numbers.
 */
function create (config) {
  // simple test for ES5 support
  if (typeof Object.create !== 'function') {
    throw new Error('ES5 not supported by this JavaScript engine. ' +
        'Please load the es5-shim and es5-sham library for compatibility.');
  }

  // create namespace
  var math = {};

  // create configuration options. These are private
  var _config = {
    // type of default matrix output. Choose 'matrix' (default) or 'array'
    matrix: 'matrix',

    // type of default number output. Choose 'number' (default) or 'bignumber'
    number: 'number',

    // number of significant digits in BigNumbers
    precision: 64,

    // minimum relative difference between two compared values,
    // used by all comparison functions
    epsilon: 1e-14
  };

  /**
   * Set configuration options for math.js, and get current options
   * @param {Object} [options] Available options:
   *                            {String} matrix
   *                              A string 'matrix' (default) or 'array'.
   *                            {String} number
   *                              A string 'number' (default) or 'bignumber'
   *                            {Number} precision
   *                              The number of significant digits for BigNumbers.
   *                              Not applicable for Numbers.
   * @return {Object} Returns the current configuration
   */
  math.config = function(options) {
    if (options) {
      // merge options
      object.deepExtend(_config, options);

      if (options.precision) {
        math.type.BigNumber.config({
          precision: options.precision
        });
      }

      // reload the constants (they depend on option number and precision)
      // this must be done after math.type.BigNumber.config is applied
      require('./constants')(math, _config);

      // TODO: remove deprecated setting some day (deprecated since version 0.17.0)
      if (options.number && options.number.defaultType) {
        throw new Error('setting `number.defaultType` is deprecated. Use `number` instead.')
      }

      // TODO: remove deprecated setting some day (deprecated since version 0.17.0)
      if (options.number && options.number.precision) {
        throw new Error('setting `number.precision` is deprecated. Use `precision` instead.')
      }

      // TODO: remove deprecated setting some day (deprecated since version 0.17.0)
      if (options.matrix && options.matrix.defaultType) {
        throw new Error('setting `matrix.defaultType` is deprecated. Use `matrix` instead.')
      }

      // TODO: remove deprecated setting some day (deprecated since version 0.15.0)
      if (options.matrix && options.matrix['default']) {
        throw new Error('setting `matrix.default` is deprecated. Use `matrix` instead.')
      }

      // TODO: remove deprecated setting some day (deprecated since version 0.20.0)
      if (options.decimals) {
        throw new Error('setting `decimals` is deprecated. Use `precision` instead.')
      }
    }

    // return a clone of the settings
    return object.clone(_config);
  };

  /**
   * math.js factory function. Creates a new instance of math.js
   *
   * @param {Object} [config] Available configuration options:
   *                            {String} matrix
   *                              A string 'matrix' (default) or 'array'.
   *                            {String} number
   *                              A string 'number' (default) or 'bignumber'
   *                            {Number} precision
   *                              The number of significant digits for BigNumbers.
   *                              Not applicable for Numbers.
   */
  math.create = create;

  // create a new BigNumber factory for this instance of math.js
  var BigNumber = require('decimal.js').constructor();

  // extend BigNumber with a function clone
  if (typeof BigNumber.prototype.clone !== 'function') {
    /**
     * Clone a bignumber
     * @return {BigNumber} clone
     */
    BigNumber.prototype.clone = function() {
      return new BigNumber(this);
    };
  }

  // extend BigNumber with a function convert
  if (typeof BigNumber.convert !== 'function') {
    /**
     * Try to convert a Number in to a BigNumber.
     * If the number has 15 or mor significant digits, the Number cannot be
     * converted to BigNumber and will return the original number.
     * @param {Number} number
     * @return {BigNumber | Number} bignumber
     */
    BigNumber.convert = function(number) {
      if (digits(number) > 15) {
        return number;
      }
      else {
        return new BigNumber(number);
      }
    };
  }
  else {
    throw new Error('Cannot add function convert to BigNumber: function already exists');
  }

  // errors
  math.error = require('./error/index');

  // types (Matrix, Complex, Unit, ...)
  math.type = {};
  math.type.Complex = require('./type/Complex');
  math.type.Range = require('./type/Range');
  math.type.Index = require('./type/Index');
  math.type.Matrix = require('./type/Matrix');
  math.type.Unit = require('./type/Unit');
  math.type.Help = require('./type/Help');
  math.type.ResultSet = require('./type/ResultSet');
  math.type.BigNumber = BigNumber;

  math.collection = require('./type/collection');

  // expression (parse, Parser, nodes, docs)
  math.expression = {};
  math.expression.node = require('./expression/node/index');
  math.expression.parse = require('./expression/parse');
  math.expression.Parser = require('./expression/Parser');
  math.expression.docs = require('./expression/docs/index');

  // expression parser
  require('./function/expression/compile')(math, _config);
  require('./function/expression/eval')(math, _config);
  require('./function/expression/help')(math, _config);
  require('./function/expression/parse')(math, _config);

  // functions - arithmetic
  require('./function/arithmetic/abs')(math, _config);
  require('./function/arithmetic/add')(math, _config);
  require('./function/arithmetic/ceil')(math, _config);
  require('./function/arithmetic/cube')(math, _config);
  require('./function/arithmetic/divide')(math, _config);
  require('./function/arithmetic/dotDivide')(math, _config);
  require('./function/arithmetic/dotMultiply')(math, _config);
  require('./function/arithmetic/dotPow')(math, _config);
  require('./function/arithmetic/exp')(math, _config);
  require('./function/arithmetic/fix')(math, _config);
  require('./function/arithmetic/floor')(math, _config);
  require('./function/arithmetic/gcd')(math, _config);
  require('./function/arithmetic/lcm')(math, _config);
  require('./function/arithmetic/log')(math, _config);
  require('./function/arithmetic/log10')(math, _config);
  require('./function/arithmetic/mod')(math, _config);
  require('./function/arithmetic/multiply')(math, _config);
  require('./function/arithmetic/norm')(math, _config);
  require('./function/arithmetic/pow')(math, _config);
  require('./function/arithmetic/round')(math, _config);
  require('./function/arithmetic/sign')(math, _config);
  require('./function/arithmetic/sqrt')(math, _config);
  require('./function/arithmetic/square')(math, _config);
  require('./function/arithmetic/subtract')(math, _config);
  require('./function/arithmetic/unaryMinus')(math, _config);
  require('./function/arithmetic/unaryPlus')(math, _config);
  require('./function/arithmetic/xgcd')(math, _config);

  // functions - relational
  require('./function/relational/compare')(math, _config);
  require('./function/relational/deepEqual')(math, _config);
  require('./function/relational/equal')(math, _config);
  require('./function/relational/larger')(math, _config);
  require('./function/relational/largerEq')(math, _config);
  require('./function/relational/smaller')(math, _config);
  require('./function/relational/smallerEq')(math, _config);
  require('./function/relational/unequal')(math, _config);

  // functions - complex
  require('./function/complex/arg')(math, _config);
  require('./function/complex/conj')(math, _config);
  require('./function/complex/re')(math, _config);
  require('./function/complex/im')(math, _config);

  // functions - construction
  require('./function/construction/bignumber')(math, _config);
  require('./function/construction/boolean')(math, _config);
  require('./function/construction/complex')(math, _config);
  require('./function/construction/index')(math, _config);
  require('./function/construction/matrix')(math, _config);
  require('./function/construction/number')(math, _config);
  require('./function/construction/parser')(math, _config);
  require('./function/construction/select')(math, _config);
  require('./function/construction/string')(math, _config);
  require('./function/construction/unit')(math, _config);

  // functions - matrix
  require('./function/matrix/concat')(math, _config);
  require('./function/matrix/det')(math, _config);
  require('./function/matrix/diag')(math, _config);
  require('./function/matrix/eye')(math, _config);
  require('./function/matrix/flatten')(math, _config);
  require('./function/matrix/inv')(math, _config);
  require('./function/matrix/ones')(math, _config);
  require('./function/matrix/range')(math, _config);
  require('./function/matrix/resize')(math, _config);
  require('./function/matrix/size')(math, _config);
  require('./function/matrix/squeeze')(math, _config);
  require('./function/matrix/subset')(math, _config);
  require('./function/matrix/transpose')(math, _config);
  require('./function/matrix/zeros')(math, _config);

  // functions - probability
  //require('./function/probability/distribution')(math, _config); // TODO: rethink math.distribution
  require('./function/probability/factorial')(math, _config);
  require('./function/probability/random')(math, _config);
  require('./function/probability/randomInt')(math, _config);
  require('./function/probability/pickRandom')(math, _config);
  require('./function/probability/permutations')(math, _config);
  require('./function/probability/combinations')(math, _config);

  // functions - statistics
  require('./function/statistics/min')(math, _config);
  require('./function/statistics/max')(math, _config);
  require('./function/statistics/mean')(math, _config);
  require('./function/statistics/median')(math, _config);
  require('./function/statistics/prod')(math, _config);
  require('./function/statistics/std')(math, _config);
  require('./function/statistics/sum')(math, _config);
  require('./function/statistics/var')(math, _config);

  // functions - trigonometry
  require('./function/trigonometry/acos')(math, _config);
  require('./function/trigonometry/asin')(math, _config);
  require('./function/trigonometry/atan')(math, _config);
  require('./function/trigonometry/atan2')(math, _config);
  require('./function/trigonometry/cos')(math, _config);
  require('./function/trigonometry/cosh')(math, _config);
  require('./function/trigonometry/cot')(math, _config);
  require('./function/trigonometry/coth')(math, _config);
  require('./function/trigonometry/csc')(math, _config);
  require('./function/trigonometry/csch')(math, _config);
  require('./function/trigonometry/sec')(math, _config);
  require('./function/trigonometry/sech')(math, _config);
  require('./function/trigonometry/sin')(math, _config);
  require('./function/trigonometry/sinh')(math, _config);
  require('./function/trigonometry/tan')(math, _config);
  require('./function/trigonometry/tanh')(math, _config);

  // functions - units
  require('./function/units/to')(math, _config);

  // functions - utils
  require('./function/utils/clone')(math, _config);
  require('./function/utils/filter')(math, _config);
  require('./function/utils/format')(math, _config);
  require('./function/utils/import')(math, _config);
  require('./function/utils/map')(math, _config);
  require('./function/utils/print')(math, _config);
  require('./function/utils/sort')(math, _config);
  require('./function/utils/typeof')(math, _config);
  require('./function/utils/forEach')(math, _config);

  // TODO: deprecated since version 0.25.0, remove some day.
  math.ifElse = function () {
    throw new Error('Function ifElse is deprecated. Use the conditional operator instead.');
  };

  // constants
  require('./constants')(math, _config);

  // attach transform functions (for converting one-based indices to zero-based)
  require('./expression/transform/concat.transform')(math, _config);
  require('./expression/transform/filter.transform')(math, _config);
  require('./expression/transform/forEach.transform')(math, _config);
  require('./expression/transform/index.transform')(math, _config);
  require('./expression/transform/map.transform')(math, _config);
  require('./expression/transform/max.transform')(math, _config);
  require('./expression/transform/mean.transform')(math, _config);
  require('./expression/transform/min.transform')(math, _config);
  require('./expression/transform/range.transform')(math, _config);
  require('./expression/transform/subset.transform')(math, _config);

  // selector (we initialize after all functions are loaded)
  math.chaining = {};
  math.chaining.Selector = require('./chaining/Selector')(math, _config);

  // apply provided configuration options
  math.config(_config); // apply the default options
  math.config(config);  // apply custom options

  // return the new instance
  return math;
}

// create a default instance of math.js
var math = create();

if (typeof window !== 'undefined') {
  window.mathjs = math; // TODO: deprecate the mathjs namespace some day (replaced with 'math' since version 0.25.0)
}

// export the default instance
module.exports = math;


},{"./util/object":35,"./util/number":36,"./constants":41,"./error/index":46,"./type/Complex":43,"./type/Range":47,"./type/Index":48,"./type/Matrix":49,"./type/Unit":50,"./type/Help":51,"./type/ResultSet":37,"./type/collection":52,"./expression/node/index":53,"./expression/parse":54,"./expression/Parser":55,"./expression/docs/index":56,"./function/expression/compile":57,"./function/expression/eval":58,"./function/expression/help":59,"./function/expression/parse":60,"./function/arithmetic/abs":61,"./function/arithmetic/add":62,"./function/arithmetic/ceil":63,"./function/arithmetic/cube":64,"./function/arithmetic/divide":65,"./function/arithmetic/dotDivide":66,"./function/arithmetic/dotMultiply":67,"./function/arithmetic/dotPow":68,"./function/arithmetic/exp":69,"./function/arithmetic/fix":70,"./function/arithmetic/floor":71,"./function/arithmetic/gcd":72,"./function/arithmetic/lcm":73,"./function/arithmetic/log":74,"./function/arithmetic/log10":75,"./function/arithmetic/mod":76,"./function/arithmetic/multiply":77,"./function/arithmetic/norm":78,"./function/arithmetic/pow":79,"./function/arithmetic/round":80,"./function/arithmetic/sign":81,"./function/arithmetic/sqrt":82,"./function/arithmetic/square":83,"./function/arithmetic/subtract":84,"./function/arithmetic/unaryMinus":85,"./function/arithmetic/unaryPlus":86,"./function/arithmetic/xgcd":87,"./function/relational/compare":88,"./function/relational/deepEqual":89,"./function/relational/equal":90,"./function/relational/larger":91,"./function/relational/largerEq":92,"./function/relational/smaller":93,"./function/relational/smallerEq":94,"./function/relational/unequal":95,"./function/complex/arg":96,"./function/complex/conj":97,"./function/complex/re":98,"./function/complex/im":99,"./function/construction/bignumber":100,"./function/construction/boolean":101,"./function/construction/complex":102,"./function/construction/index":103,"./function/construction/matrix":104,"./function/construction/number":105,"./function/construction/parser":106,"./function/construction/select":38,"./function/construction/string":107,"./function/construction/unit":108,"./function/matrix/concat":109,"./function/matrix/det":110,"./function/matrix/diag":111,"./function/matrix/eye":112,"./function/matrix/flatten":113,"./function/matrix/inv":114,"./function/matrix/ones":115,"./function/matrix/range":116,"./function/matrix/resize":117,"./function/matrix/size":118,"./function/matrix/squeeze":119,"./function/matrix/subset":120,"./function/matrix/transpose":121,"./function/matrix/zeros":122,"./function/probability/factorial":123,"./function/probability/random":124,"./function/probability/randomInt":125,"./function/probability/pickRandom":126,"./function/probability/permutations":127,"./function/probability/combinations":128,"./function/statistics/min":129,"./function/statistics/max":130,"./function/statistics/mean":131,"./function/statistics/median":132,"./function/statistics/prod":133,"./function/statistics/std":39,"./function/statistics/sum":134,"./function/statistics/var":135,"./function/trigonometry/acos":136,"./function/trigonometry/asin":137,"./function/trigonometry/atan":138,"./function/trigonometry/atan2":139,"./function/trigonometry/cos":140,"./function/trigonometry/cosh":141,"./function/trigonometry/cot":142,"./function/trigonometry/coth":143,"./function/trigonometry/csc":144,"./function/trigonometry/csch":145,"./function/trigonometry/sec":146,"./function/trigonometry/sech":147,"./function/trigonometry/sin":148,"./function/trigonometry/sinh":149,"./function/trigonometry/tan":150,"./function/trigonometry/tanh":151,"./function/units/to":152,"./function/utils/clone":153,"./function/utils/filter":154,"./function/utils/format":155,"./function/utils/import":156,"./function/utils/map":157,"./function/utils/print":158,"./function/utils/sort":159,"./function/utils/typeof":160,"./function/utils/forEach":161,"./expression/transform/concat.transform":162,"./expression/transform/filter.transform":163,"./expression/transform/forEach.transform":164,"./expression/transform/index.transform":165,"./expression/transform/map.transform":166,"./expression/transform/max.transform":167,"./expression/transform/mean.transform":168,"./expression/transform/min.transform":169,"./expression/transform/range.transform":170,"./expression/transform/subset.transform":171,"./chaining/Selector":172,"decimal.js":173}],46:[function(require,module,exports){
'use strict';

exports.ArgumentsError = require('./ArgumentsError');
exports.DimensionError = require('./DimensionError');
exports.IndexError = require('./IndexError');
exports.UnsupportedTypeError = require('./UnsupportedTypeError');

// TODO: implement an InvalidValueError?

},{"./ArgumentsError":174,"./DimensionError":175,"./IndexError":176,"./UnsupportedTypeError":177}],43:[function(require,module,exports){
'use strict';

var util = require('../util/index'),
    Unit = require('./Unit'),
    number = util.number,

    isNumber = util.number.isNumber,
    isUnit = Unit.isUnit,
    isString = util.string.isString;

/**
 * @constructor Complex
 *
 * A complex value can be constructed in the following ways:
 *     var a = new Complex();
 *     var b = new Complex(re, im);
 *     var c = Complex.parse(str);
 *
 * Example usage:
 *     var a = new Complex(3, -4);      // 3 - 4i
 *     a.re = 5;                        // a = 5 - 4i
 *     var i = a.im;                    // -4;
 *     var b = Complex.parse('2 + 6i'); // 2 + 6i
 *     var c = new Complex();           // 0 + 0i
 *     var d = math.add(a, b);          // 5 + 2i
 *
 * @param {Number} re       The real part of the complex value
 * @param {Number} [im]     The imaginary part of the complex value
 */
function Complex(re, im) {
  if (!(this instanceof Complex)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  switch (arguments.length) {
    case 0:
      this.re = 0;
      this.im = 0;
      break;

    case 1:
      var arg = arguments[0];
      if (typeof arg === 'object') {
        if('re' in arg && 'im' in arg) {
          var construct = new Complex(arg.re, arg.im); // pass on input validation
          this.re = construct.re;
          this.im = construct.im;
          break;
        } else if ('r' in arg && 'phi' in arg) {
          var construct = Complex.fromPolar(arg.r, arg.phi);
          this.re = construct.re;
          this.im = construct.im;
          break;
        }
      } 
      throw new SyntaxError('Object with the re and im or r and phi properties expected.');

    case 2:
      if (!isNumber(re) || !isNumber(im)) {
        throw new TypeError('Two numbers expected in Complex constructor');
      }
      this.re = re;
      this.im = im;
      break;

    default:
      throw new SyntaxError('One, two or three arguments expected in Complex constructor');
  }
}

/**
 * Test whether value is a Complex value
 * @param {*} value
 * @return {Boolean} isComplex
 */
Complex.isComplex = function (value) {
  return (value instanceof Complex);
};

// private variables and functions for the parser
var text, index, c;

function skipWhitespace() {
  while (c == ' ' || c == '\t') {
    next();
  }
}

function isDigitDot (c) {
  return ((c >= '0' && c <= '9') || c == '.');
}

function isDigit (c) {
  return ((c >= '0' && c <= '9'));
}

function next() {
  index++;
  c = text.charAt(index);
}

function revert(oldIndex) {
  index = oldIndex;
  c = text.charAt(index);
}

function parseNumber () {
  var number = '';
  var oldIndex;
  oldIndex = index;

  if (c == '+') {
    next();
  }
  else if (c == '-') {
    number += c;
    next();
  }

  if (!isDigitDot(c)) {
    // a + or - must be followed by a digit
    revert(oldIndex);
    return null;
  }

  // get number, can have a single dot
  if (c == '.') {
    number += c;
    next();
    if (!isDigit(c)) {
      // this is no legal number, it is just a dot
      revert(oldIndex);
      return null;
    }
  }
  else {
    while (isDigit(c)) {
      number += c;
      next();
    }
    if (c == '.') {
      number += c;
      next();
    }
  }
  while (isDigit(c)) {
    number += c;
    next();
  }

  // check for exponential notation like "2.3e-4" or "1.23e50"
  if (c == 'E' || c == 'e') {
    number += c;
    next();

    if (c == '+' || c == '-') {
      number += c;
      next();
    }

    // Scientific notation MUST be followed by an exponent
    if (!isDigit(c)) {
      // this is no legal number, exponent is missing.
      revert(oldIndex);
      return null;
    }

    while (isDigit(c)) {
      number += c;
      next();
    }
  }

  return number;
}

function parseComplex () {
  // check for 'i', '-i', '+i'
  var cnext = text.charAt(index + 1);
  if (c == 'I' || c == 'i') {
    next();
    return '1';
  }
  else if ((c == '+' || c == '-') && (cnext == 'I' || cnext == 'i')) {
    var number = (c == '+') ? '1' : '-1';
    next();
    next();
    return number;
  }

  return null;
}

/**
 * Parse a complex number from a string. For example Complex.parse("2 + 3i")
 * will return a Complex value where re = 2, im = 3.
 * Returns null if provided string does not contain a valid complex number.
 * @param {String} str
 * @returns {Complex | null} complex
 */
Complex.parse = function (str) {
  text = str;
  index = -1;
  c = '';

  if (!isString(text)) {
    return null;
  }

  next();
  skipWhitespace();
  var first = parseNumber();
  if (first) {
    if (c == 'I' || c == 'i') {
      // pure imaginary number
      next();
      skipWhitespace();
      if (c) {
        // garbage at the end. not good.
        return null;
      }

      return new Complex(0, Number(first));
    }
    else {
      // complex and real part
      skipWhitespace();
      var separator = c;
      if (separator != '+' && separator != '-') {
        // pure real number
        skipWhitespace();
        if (c) {
          // garbage at the end. not good.
          return null;
        }

        return new Complex(Number(first), 0);
      }
      else {
        // complex and real part
        next();
        skipWhitespace();
        var second = parseNumber();
        if (second) {
          if (c != 'I' && c != 'i') {
            // 'i' missing at the end of the complex number
            return null;
          }
          next();
        }
        else {
          second = parseComplex();
          if (!second) {
            // imaginary number missing after separator
            return null;
          }
        }

        if (separator == '-') {
          if (second[0] == '-') {
            second =  '+' + second.substring(1);
          }
          else {
            second = '-' + second;
          }
        }

        next();
        skipWhitespace();
        if (c) {
          // garbage at the end. not good.
          return null;
        }

        return new Complex(Number(first), Number(second));
      }
    }
  }
  else {
    // check for 'i', '-i', '+i'
    first = parseComplex();
    if (first) {
      skipWhitespace();
      if (c) {
        // garbage at the end. not good.
        return null;
      }

      return new Complex(0, Number(first));
    }
  }

  return null;
};

/**
 * Create a complex number from polar coordinates
 *
 * Usage:
 *
 *     Complex.fromPolar(r: Number, phi: Number) : Complex
 *     Complex.fromPolar({r: Number, phi: Number}) : Complex
 *
 * @param {*} args...
 * @return {Complex}
 */
Complex.fromPolar = function (args) {
  switch (arguments.length) {
    case 1:
      var arg = arguments[0];
      if(typeof arg === 'object') {
        return Complex.fromPolar(arg.r, arg.phi);
      }
      throw new TypeError('Input has to be an object with r and phi keys.');

    case 2:
      var r = arguments[0],
        phi = arguments[1];
      if(isNumber(r)) {
        if (isUnit(phi) && phi.hasBase(Unit.BASE_UNITS.ANGLE)) {
          // convert unit to a number in radians
          phi = phi.toNumber('rad');
        }

        if(isNumber(phi)) {
          return new Complex(r * Math.cos(phi), r * Math.sin(phi));
        }

        throw new TypeError('Phi is not a number nor an angle unit.');
      } else {
        throw new TypeError('Radius r is not a number.');
      }

    default:
      throw new SyntaxError('Wrong number of arguments in function fromPolar');
  }
};

/*
 * Return the value of the complex number in polar notation
 * The angle phi will be set in the interval of [-pi, pi].
 * @return {{r: number, phi: number}} Returns and object with properties r and phi.
 */
Complex.prototype.toPolar = function() {
  return {
    r: Math.sqrt(this.re * this.re + this.im * this.im),
    phi: Math.atan2(this.im, this.re)
  };
};

/**
 * Create a copy of the complex value
 * @return {Complex} clone
 */
Complex.prototype.clone = function () {
  return new Complex(this.re, this.im);
};

/**
 * Test whether this complex number equals an other complex value.
 * Two complex numbers are equal when both their real and imaginary parts
 * are equal.
 * @param {Complex} other
 * @return {boolean} isEqual
 */
Complex.prototype.equals = function (other) {
  return (this.re === other.re) && (this.im === other.im);
};

/**
 * Get a string representation of the complex number,
 * with optional formatting options.
 * @param {Object | Number | Function} [options]  Formatting options. See
 *                                                lib/util/number:format for a
 *                                                description of the available
 *                                                options.
 * @return {String} str
 */
Complex.prototype.format = function (options) {
  var str = '',
      strRe = number.format(this.re, options),
      strIm = number.format(this.im, options);

  if (this.im == 0) {
    // real value
    str = strRe;
  }
  else if (this.re == 0) {
    // purely complex value
    if (this.im == 1) {
      str = 'i';
    }
    else if (this.im == -1) {
      str = '-i';
    }
    else {
      str = strIm + 'i';
    }
  }
  else {
    // complex value
    if (this.im > 0) {
      if (this.im == 1) {
        str = strRe + ' + i';
      }
      else {
        str = strRe + ' + ' + strIm + 'i';
      }
    }
    else {
      if (this.im == -1) {
        str = strRe + ' - i';
      }
      else {
        str = strRe + ' - ' + strIm.substring(1) + 'i';
      }
    }
  }

  return str;
};

/**
 * Get a string representation of the complex number.
 * @return {String} str
 */
Complex.prototype.toString = function () {
  return this.format();
};

/**
 * Returns a string representation of the complex number.
 * @return {String} str
 */
Complex.prototype.valueOf = Complex.prototype.toString;

// exports
module.exports = Complex;

},{"../util/index":178,"./Unit":50}],47:[function(require,module,exports){
'use strict';

var util = require('../util/index');

var number = util.number;
var string = util.string;
var array = util.array;

/**
 * @constructor Range
 * Create a range. A range has a start, step, and end, and contains functions
 * to iterate over the range.
 *
 * A range can be constructed as:
 *     var range = new Range(start, end);
 *     var range = new Range(start, end, step);
 *
 * To get the result of the range:
 *     range.forEach(function (x) {
 *         console.log(x);
 *     });
 *     range.map(function (x) {
 *         return math.sin(x);
 *     });
 *     range.toArray();
 *
 * Example usage:
 *     var c = new Range(2, 6);         // 2:1:5
 *     c.toArray();                     // [2, 3, 4, 5]
 *     var d = new Range(2, -3, -1);    // 2:-1:-2
 *     d.toArray();                     // [2, 1, 0, -1, -2]
 *
 * @param {Number} start  included lower bound
 * @param {Number} end    excluded upper bound
 * @param {Number} [step] step size, default value is 1
 */
function Range(start, end, step) {
  if (!(this instanceof Range)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (start != null && !number.isNumber(start)) {
    throw new TypeError('Parameter start must be a number');
  }
  if (end != null && !number.isNumber(end)) {
    throw new TypeError('Parameter end must be a number');
  }
  if (step != null && !number.isNumber(step)) {
    throw new TypeError('Parameter step must be a number');
  }

  this.start = (start != null) ? parseFloat(start) : 0;
  this.end   = (end != null) ? parseFloat(end) : 0;
  this.step  = (step != null) ? parseFloat(step) : 1;
}

/**
 * Parse a string into a range,
 * The string contains the start, optional step, and end, separated by a colon.
 * If the string does not contain a valid range, null is returned.
 * For example str='0:2:11'.
 * @param {String} str
 * @return {Range | null} range
 */
Range.parse = function (str) {
  if (!string.isString(str)) {
    return null;
  }

  var args = str.split(':');
  var nums = args.map(function (arg) {
    return parseFloat(arg);
  });

  var invalid = nums.some(function (num) {
    return isNaN(num);
  });
  if(invalid) {
    return null;
  }

  switch (nums.length) {
    case 2: return new Range(nums[0], nums[1]);
    case 3: return new Range(nums[0], nums[2], nums[1]);
    default: return null;
  }
};

/**
 * Create a clone of the range
 * @return {Range} clone
 */
Range.prototype.clone = function () {
  return new Range(this.start, this.end, this.step);
};

/**
 * Test whether an object is a Range
 * @param {*} object
 * @return {Boolean} isRange
 */
Range.isRange = function (object) {
  return (object instanceof Range);
};

/**
 * Retrieve the size of the range.
 * Returns an array containing one number, the number of elements in the range.
 * @returns {Number[]} size
 */
Range.prototype.size = function () {
  var len = 0,
      start = this.start,
      step = this.step,
      end = this.end,
      diff = end - start;

  if (number.sign(step) == number.sign(diff)) {
    len = Math.ceil((diff) / step);
  }
  else if (diff == 0) {
    len = 0;
  }

  if (isNaN(len)) {
    len = 0;
  }
  return [len];
};

/**
 * Calculate the minimum value in the range
 * @return {Number | undefined} min
 */
Range.prototype.min = function () {
  var size = this.size()[0];

  if (size > 0) {
    if (this.step > 0) {
      // positive step
      return this.start;
    }
    else {
      // negative step
      return this.start + (size - 1) * this.step;
    }
  }
  else {
    return undefined;
  }
};

/**
 * Calculate the maximum value in the range
 * @return {Number | undefined} max
 */
Range.prototype.max = function () {
  var size = this.size()[0];

  if (size > 0) {
    if (this.step > 0) {
      // positive step
      return this.start + (size - 1) * this.step;
    }
    else {
      // negative step
      return this.start;
    }
  }
  else {
    return undefined;
  }
};


/**
 * Execute a callback function for each value in the range.
 * @param {function} callback   The callback method is invoked with three
 *                              parameters: the value of the element, the index
 *                              of the element, and the Matrix being traversed.
 */
Range.prototype.forEach = function (callback) {
  var x = this.start;
  var step = this.step;
  var end = this.end;
  var i = 0;

  if (step > 0) {
    while (x < end) {
      callback(x, i, this);
      x += step;
      i++;
    }
  }
  else if (step < 0) {
    while (x > end) {
      callback(x, i, this);
      x += step;
      i++;
    }
  }
};

/**
 * Execute a callback function for each value in the Range, and return the
 * results as an array
 * @param {function} callback   The callback method is invoked with three
 *                              parameters: the value of the element, the index
 *                              of the element, and the Matrix being traversed.
 * @returns {Array} array
 */
Range.prototype.map = function (callback) {
  var array = [];
  this.forEach(function (value, index, obj) {
    array[index] = callback(value, index, obj);
  });
  return array;
};

/**
 * Create an Array with a copy of the Ranges data
 * @returns {Array} array
 */
Range.prototype.toArray = function () {
  var array = [];
  this.forEach(function (value, index) {
    array[index] = value;
  });
  return array;
};

/**
 * Get the primitive value of the Range, a one dimensional array
 * @returns {Array} array
 */
Range.prototype.valueOf = function () {
  // TODO: implement a caching mechanism for range.valueOf()
  return this.toArray();
};

/**
 * Get a string representation of the range, with optional formatting options.
 * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'
 * @param {Object | Number | Function} [options]  Formatting options. See
 *                                                lib/util/number:format for a
 *                                                description of the available
 *                                                options.
 * @returns {String} str
 */
Range.prototype.format = function (options) {
  var str = number.format(this.start, options);

  if (this.step != 1) {
    str += ':' + number.format(this.step, options);
  }
  str += ':' + number.format(this.end, options);
  return str;
};

/**
 * Get a string representation of the range.
 * @returns {String}
 */
Range.prototype.toString = function () {
  return this.format();
};

// exports
module.exports = Range;

},{"../util/index":178}],48:[function(require,module,exports){
'use strict';

var util = require('../util/index'),

    Range = require('./Range'),

    number = util.number,

    isNumber = number.isNumber,
    isInteger = number.isInteger,
    isArray = Array.isArray;

/**
 * @Constructor Index
 * Create an index. An Index can store ranges having start, step, and end
 * for multiple dimensions.
 * Matrix.get, Matrix.set, and math.subset accept an Index as input.
 *
 * Usage:
 *     var index = new Index(range1, range2, ...);
 *
 * Where each range can be any of:
 *     An array [start, end]
 *     An array [start, end, step]
 *     A number
 *     An instance of Range
 *
 * The parameters start, end, and step must be integer numbers.
 *
 * @param {...*} ranges
 */
function Index(ranges) {
  if (!(this instanceof Index)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this._ranges = [];
  this._isScalar = true;

  for (var i = 0, ii = arguments.length; i < ii; i++) {
    var arg = arguments[i];

    if (arg instanceof Range) {
      this._ranges.push(arg);
      this._isScalar = false;
    }
    else if (isArray(arg)) {
      this._ranges.push(_createRange(arg));
      this._isScalar = false;
    }
    else if (isNumber(arg)) {
      this._ranges.push(_createRange([arg, arg + 1]));
    }
    // TODO: implement support for wildcard '*'
    else {
      var primitive = arg.valueOf(); // for example turn a Matrix into an Array
      if (isArray(primitive)) {
        this._ranges.push(_createRange(primitive));
        this._isScalar = false;
      }
      else {
        throw new TypeError('Ranges must be an Array, Number, or Range');
      }
    }
  }
}

/**
 * Parse an argument into a range and validate the range
 * @param {Array} arg  An array with [start: Number, end: Number] and
 *                     optional a third element step:Number
 * @return {Range} range
 * @private
 */
function _createRange(arg) {
  // TODO: make function _createRange simpler/faster

  // test whether all arguments are integers
  var num = arg.length;
  for (var i = 0; i < num; i++) {
    if (!isNumber(arg[i]) || !isInteger(arg[i])) {
      throw new TypeError('Index parameters must be integer numbers');
    }
  }

  switch (arg.length) {
    case 2:
      return new Range(arg[0], arg[1]); // start, end
    case 3:
      return new Range(arg[0], arg[1], arg[2]); // start, end, step
    default:
      // TODO: improve error message
      throw new SyntaxError('Wrong number of arguments in Index (2 or 3 expected)');
  }
}

/**
 * Create a clone of the index
 * @return {Index} clone
 */
Index.prototype.clone = function () {
  var index = new Index();
  index._ranges = util.object.clone(this._ranges);
  index._isScalar = this._isScalar;
  return index;
};

/**
 * Test whether an object is an Index
 * @param {*} object
 * @return {Boolean} isIndex
 */
Index.isIndex = function (object) {
  return (object instanceof Index);
};

/**
 * Create an index from an array with ranges/numbers
 * @param {Array.<Array | Number>} ranges
 * @return {Index} index
 * @private
 */
Index.create = function (ranges) {
  var index = new Index();
  Index.apply(index, ranges);
  return index;
};

/**
 * Retrieve the size of the index, the number of elements for each dimension.
 * @returns {Number[]} size
 */
Index.prototype.size = function () {
  var size = [];

  for (var i = 0, ii = this._ranges.length; i < ii; i++) {
    var range = this._ranges[i];

    size[i] = range.size()[0];
  }

  return size;
};

/**
 * Get the maximum value for each of the indexes ranges.
 * @returns {Number[]} max
 */
Index.prototype.max = function () {
  var values = [];

  for (var i = 0, ii = this._ranges.length; i < ii; i++) {
    var range = this._ranges[i];
    values[i] = range.max();
  }

  return values;
};

/**
 * Get the minimum value for each of the indexes ranges.
 * @returns {Number[]} min
 */
Index.prototype.min = function () {
  var values = [];

  for (var i = 0, ii = this._ranges.length; i < ii; i++) {
    var range = this._ranges[i];

    values[i] = range.min();
  }

  return values;
};

/**
 * Loop over each of the ranges of the index
 * @param {function} callback   Called for each range with a Range as first
 *                              argument, the dimension as second, and the
 *                              index object as third.
 */
Index.prototype.forEach = function (callback) {
  for (var i = 0, ii = this._ranges.length; i < ii; i++) {
    callback(this._ranges[i], i, this);
  }
};

/**
 * Retrieve the range for a given dimension number from the index
 * @param {Number} dim                  Number of the dimension
 * @returns {Range | null} range
 */
Index.prototype.range = function(dim) {
  return this._ranges[dim] || null;
};

/**
 * Test whether this index contains only a single value.
 *
 * This is the case when the index is created with only scalar values as ranges,
 * not for ranges resolving into a single value.
 * @return {boolean} isScalar
 */
Index.prototype.isScalar = function () {
  return this._isScalar;
};

/**
 * Expand the Index into an array.
 * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]
 * @returns {Array} array
 */
Index.prototype.toArray = function () {
  var array = [];
  for (var i = 0, ii = this._ranges.length; i < ii; i++) {
    var range = this._ranges[i],
        row = [],
        x = range.start,
        end = range.end,
        step = range.step;

    if (step > 0) {
      while (x < end) {
        row.push(x);
        x += step;
      }
    }
    else if (step < 0) {
      while (x > end) {
        row.push(x);
        x += step;
      }
    }

    array.push(row);
  }

  return array;
};

/**
 * Get the primitive value of the Index, a two dimensional array.
 * Equivalent to Index.toArray().
 * @returns {Array} array
 */
Index.prototype.valueOf = Index.prototype.toArray;

/**
 * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7]'
 * @returns {String} str
 */
Index.prototype.toString = function () {
  var strings = [];

  for (var i = 0, ii = this._ranges.length; i < ii; i++) {
    var range = this._ranges[i];
    var str = number.format(range.start);
    if (range.step != 1) {
      str += ':' + number.format(range.step);
    }
    str += ':' + number.format(range.end);
    strings.push(str);
  }

  return '[' + strings.join(', ') + ']';
};

// exports
module.exports = Index;

},{"../util/index":178,"./Range":47}],49:[function(require,module,exports){
'use strict';

var util = require('../util/index'),
    DimensionError = require('../error/DimensionError'),

    Index = require('./Index'),

    number = util.number,
    string = util.string,
    array = util.array,
    object = util.object,

    isArray = Array.isArray,
    validateIndex = array.validateIndex;

/**
 * @constructor Matrix
 *
 * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional
 * array. A matrix can be constructed as:
 *     var matrix = new Matrix(data)
 *
 * Matrix contains the functions to resize, get and set values, get the size,
 * clone the matrix and to convert the matrix to a vector, array, or scalar.
 * Furthermore, one can iterate over the matrix using map and forEach.
 * The internal Array of the Matrix can be accessed using the function valueOf.
 *
 * Example usage:
 *     var matrix = new Matrix([[1, 2], [3, 4]);
 *     matix.size();              // [2, 2]
 *     matrix.resize([3, 2], 5);
 *     matrix.valueOf();          // [[1, 2], [3, 4], [5, 5]]
 *     matrix.subset([1,2])       // 3 (indexes are zero-based)
 *
 * @param {Array | Matrix} [data]    A multi dimensional array
 */
function Matrix(data) {
  if (!(this instanceof Matrix)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (data instanceof Matrix) {
    // clone data from a Matrix
    this._data = data.clone()._data;
  }
  else if (isArray(data)) {
    // use array
    // replace nested Matrices with Arrays
    this._data = preprocess(data);
  }
  else if (data != null) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._data = [];
  }

  // verify the size of the array
  this._size = array.size(this._data);
}

/**
 * Test whether an object is a Matrix
 * @param {*} object
 * @return {Boolean} isMatrix
 */
Matrix.isMatrix = function (object) {
  return (object instanceof Matrix);
};

/**
 * Get a subset of the matrix, or replace a subset of the matrix.
 *
 * Usage:
 *     var subset = matrix.subset(index)               // retrieve subset
 *     var value = matrix.subset(index, replacement)   // replace subset
 *
 * @param {Index} index
 * @param {Array | Matrix | *} [replacement]
 * @param {*} [defaultValue=0]      Default value, filled in on new entries when
 *                                  the matrix is resized. If not provided,
 *                                  new matrix elements will be filled with zeros.
 */
Matrix.prototype.subset = function (index, replacement, defaultValue) {
  switch (arguments.length) {
    case 1:
      return _get(this, index);

    // intentional fall through
    case 2:
    case 3:
      return _set(this, index, replacement, defaultValue);

    default:
      throw new SyntaxError('Wrong number of arguments');
  }
};

/**
 * Get a single element from the matrix.
 * @param {Number[]} index   Zero-based index
 * @return {*} value
 */
Matrix.prototype.get = function (index) {
  if (!isArray(index)) {
    throw new TypeError('Array expected');
  }
  if (index.length != this._size.length) {
    throw new DimensionError(index.length, this._size.length);
  }

  var data = this._data;
  for (var i = 0, ii = index.length; i < ii; i++) {
    var index_i = index[i];
    validateIndex(index_i, data.length);
    data = data[index_i];
  }

  return object.clone(data);
};

/**
 * Replace a single element in the matrix.
 * @param {Number[]} index   Zero-based index
 * @param {*} value
 * @param {*} [defaultValue]        Default value, filled in on new entries when
 *                                  the matrix is resized. If not provided,
 *                                  new matrix elements will be left undefined.
 * @return {Matrix} self
 */
Matrix.prototype.set = function (index, value, defaultValue) {
  var i, ii;

  // validate input type and dimensions
  if (!isArray(index)) {
    throw new Error('Array expected');
  }
  if (index.length < this._size.length) {
    throw new DimensionError(index.length, this._size.length, '<');
  }

  // enlarge matrix when needed
  var size = index.map(function (i) {
    return i + 1;
  });
  _fit(this, size, defaultValue);

  // traverse over the dimensions
  var data = this._data;
  for (i = 0, ii = index.length - 1; i < ii; i++) {
    var index_i = index[i];
    validateIndex(index_i, data.length);
    data = data[index_i];
  }

  // set new value
  index_i = index[index.length - 1];
  validateIndex(index_i, data.length);
  data[index_i] = value;

  return this;
};

/**
 * Get a submatrix of this matrix
 * @param {Matrix} matrix
 * @param {Index} index   Zero-based index
 * @private
 */
function _get (matrix, index) {
  if (!(index instanceof Index)) {
    throw new TypeError('Invalid index');
  }

  var isScalar = index.isScalar();
  if (isScalar) {
    // return a scalar
    return matrix.get(index.min());
  }
  else {
    // validate dimensions
    var size = index.size();
    if (size.length != matrix._size.length) {
      throw new DimensionError(size.length, matrix._size.length);
    }

    // validate if any of the ranges in the index is out of range
    var min = index.min();
    var max = index.max();
    for (var i = 0, ii = matrix._size.length; i < ii; i++) {
      validateIndex(min[i], matrix._size[i]);
      validateIndex(max[i], matrix._size[i]);
    }

    // retrieve submatrix
    // TODO: more efficient when creating an empty matrix and setting _data and _size manually
    return new Matrix(_getSubmatrix(matrix._data, index, size.length, 0));
  }
}

/**
 * Recursively get a submatrix of a multi dimensional matrix.
 * Index is not checked for correct number or length of dimensions.
 * @param {Array} data
 * @param {Index} index
 * @param {number} dims   Total number of dimensions
 * @param {number} dim    Current dimension
 * @return {Array} submatrix
 * @private
 */
function _getSubmatrix (data, index, dims, dim) {
  var last = (dim == dims - 1);
  var range = index.range(dim);

  if (last) {
    return range.map(function (i) {
      return data[i];
    });
  }
  else {
    return range.map(function (i) {
      var child = data[i];
      return _getSubmatrix(child, index, dims, dim + 1);
    });
  }
}

/**
 * Replace a submatrix in this matrix
 * Indexes are zero-based.
 * @param {Matrix} matrix
 * @param {Index} index
 * @param {Matrix | Array | *} submatrix
 * @param {*} defaultValue          Default value, filled in on new entries when
 *                                  the matrix is resized.
 * @return {Matrix} matrix
 * @private
 */
function _set (matrix, index, submatrix, defaultValue) {
  if (!(index instanceof Index)) {
    throw new TypeError('Invalid index');
  }

  // get index size and check whether the index contains a single value
  var iSize = index.size(),
      isScalar = index.isScalar();

  // calculate the size of the submatrix, and convert it into an Array if needed
  var sSize;
  if (submatrix instanceof Matrix) {
    sSize = submatrix.size();
    submatrix = submatrix.valueOf();
  }
  else {
    sSize = array.size(submatrix);
  }

  if (isScalar) {
    // set a scalar

    // check whether submatrix is a scalar
    if (sSize.length != 0) {
      throw new TypeError('Scalar expected');
    }

    matrix.set(index.min(), submatrix, defaultValue);
  }
  else {
    // set a submatrix

    // validate dimensions
    if (iSize.length < matrix._size.length) {
      throw new DimensionError(iSize.length, matrix._size.length, '<');
    }

    if (sSize.length < iSize.length) {
      // calculate number of missing outer dimensions
      var i = 0;
      var outer = 0;
      while (iSize[i] === 1 && sSize[i] === 1) {
        i++;
      }
      while (iSize[i] === 1) {
        outer++;
        i++;
      }

      // unsqueeze both outer and inner dimensions
      submatrix = array.unsqueeze(submatrix, iSize.length, outer, sSize);
    }

    // check whether the size of the submatrix matches the index size
    if (!object.deepEqual(iSize, sSize)) {
      throw new DimensionError(iSize, sSize, '>');
    }

    // enlarge matrix when needed
    var size = index.max().map(function (i) {
      return i + 1;
    });
    _fit(matrix, size, defaultValue);

    // insert the sub matrix
    var dims = iSize.length,
        dim = 0;
    _setSubmatrix (matrix._data, index, submatrix, dims, dim);
  }

  return matrix;
}

/**
 * Replace a submatrix of a multi dimensional matrix.
 * @param {Array} data
 * @param {Index} index
 * @param {Array} submatrix
 * @param {number} dims   Total number of dimensions
 * @param {number} dim
 * @private
 */
function _setSubmatrix (data, index, submatrix, dims, dim) {
  var last = (dim == dims - 1),
      range = index.range(dim);

  if (last) {
    range.forEach(function (dataIndex, subIndex) {
      validateIndex(dataIndex);
      data[dataIndex] = submatrix[subIndex];
    });
  }
  else {
    range.forEach(function (dataIndex, subIndex) {
      validateIndex(dataIndex);
      _setSubmatrix(data[dataIndex], index, submatrix[subIndex], dims, dim + 1);
    });
  }
}

/**
 * Resize the matrix
 * @param {Number[]} size
 * @param {*} [defaultValue=0]      Default value, filled in on new entries.
 *                                  If not provided, the matrix elements will
 *                                  be filled with zeros.
 * @return {Matrix} self            The matrix itself is returned
 */
Matrix.prototype.resize = function (size, defaultValue) {
  this._size = object.clone(size);
  this._data = array.resize(this._data, this._size, defaultValue);

  // return the matrix itself
  return this;
};

/**
 * Enlarge the matrix when it is smaller than given size.
 * If the matrix is larger or equal sized, nothing is done.
 * @param {Matrix} matrix           The matrix to be resized
 * @param {Number[]} size
 * @param {*} defaultValue          Default value, filled in on new entries.
 * @private
 */
function _fit(matrix, size, defaultValue) {
  var newSize = object.clone(matrix._size),
      changed = false;

  // add dimensions when needed
  while (newSize.length < size.length) {
    newSize.push(0);
    changed = true;
  }

  // enlarge size when needed
  for (var i = 0, ii = size.length; i < ii; i++) {
    if (size[i] > newSize[i]) {
      newSize[i] = size[i];
      changed = true;
    }
  }

  if (changed) {
    // resize only when size is changed
    matrix.resize(newSize, defaultValue);
  }
}

/**
 * Create a clone of the matrix
 * @return {Matrix} clone
 */
Matrix.prototype.clone = function () {
  var matrix = new Matrix();
  matrix._data = object.clone(this._data);
  matrix._size = object.clone(this._size);
  return matrix;
};

/**
 * Retrieve the size of the matrix.
 * @returns {Number[]} size
 */
Matrix.prototype.size = function() {
  return this._size;
};

/**
 * Create a new matrix with the results of the callback function executed on
 * each entry of the matrix.
 * @param {function} callback   The callback function is invoked with three
 *                              parameters: the value of the element, the index
 *                              of the element, and the Matrix being traversed.
 * @return {Matrix} matrix
 */
Matrix.prototype.map = function (callback) {
  var me = this;
  var matrix = new Matrix();
  var index = [];
  var recurse = function (value, dim) {
    if (isArray(value)) {
      return value.map(function (child, i) {
        index[dim] = i;
        return recurse(child, dim + 1);
      });
    }
    else {
      return callback(value, index, me);
    }
  };
  matrix._data = recurse(this._data, 0);
  matrix._size = object.clone(this._size);

  return matrix;
};

/**
 * Execute a callback function on each entry of the matrix.
 * @param {function} callback   The callback function is invoked with three
 *                              parameters: the value of the element, the index
 *                              of the element, and the Matrix being traversed.
 */
Matrix.prototype.forEach = function (callback) {
  var me = this;
  var index = [];
  var recurse = function (value, dim) {
    if (isArray(value)) {
      value.forEach(function (child, i) {
        index[dim] = i;
        recurse(child, dim + 1);
      });
    }
    else {
      callback(value, index, me);
    }
  };
  recurse(this._data, 0);
};

/**
 * Create an Array with a copy of the data of the Matrix
 * @returns {Array} array
 */
Matrix.prototype.toArray = function () {
  return object.clone(this._data);
};

/**
 * Get the primitive value of the Matrix: a multidimensional array
 * @returns {Array} array
 */
Matrix.prototype.valueOf = function () {
  return this._data;
};

/**
 * Get a string representation of the matrix, with optional formatting options.
 * @param {Object | Number | Function} [options]  Formatting options. See
 *                                                lib/util/number:format for a
 *                                                description of the available
 *                                                options.
 * @returns {String} str
 */
Matrix.prototype.format = function (options) {
  return string.format(this._data, options);
};

/**
 * Get a string representation of the matrix
 * @returns {String} str
 */
Matrix.prototype.toString = function () {
  return string.format(this._data);
};

/**
 * Preprocess data, which can be an Array or Matrix with nested Arrays and
 * Matrices. Replaces all nested Matrices with Arrays
 * @param {Array} data
 * @return {Array} data
 */
function preprocess(data) {
  for (var i = 0, ii = data.length; i < ii; i++) {
    var elem = data[i];
    if (isArray(elem)) {
      data[i] = preprocess(elem);
    }
    else if (elem instanceof Matrix) {
      data[i] = preprocess(elem._data);
    }
  }

  return data;
}

// exports
module.exports = Matrix;

},{"../util/index":178,"../error/DimensionError":175,"./Index":48}],50:[function(require,module,exports){
'use strict';

var util = require('../util/index'),

    number = util.number,
    string = util.string,
    isNumber = util.number.isNumber,
    isString = util.string.isString;

/**
 * @constructor Unit
 *
 * A unit can be constructed in the following ways:
 *     var a = new Unit(value, name);
 *     var b = new Unit(null, name);
 *     var c = Unit.parse(str);
 *
 * Example usage:
 *     var a = new Unit(5, 'cm');               // 50 mm
 *     var b = Unit.parse('23 kg');             // 23 kg
 *     var c = math.in(a, new Unit(null, 'm');  // 0.05 m
 *
 * @param {Number} [value]  A value like 5.2
 * @param {String} [name]   A unit name like "cm" or "inch". Can include a prefix
 */
function Unit(value, name) {
  if (!(this instanceof Unit)) {
    throw new Error('Constructor must be called with the new operator');
  }

  if (value != undefined && !isNumber(value)) {
    throw new TypeError('First parameter in Unit constructor must be a number');
  }
  if (name != undefined && (!isString(name) || name == '')) {
    throw new TypeError('Second parameter in Unit constructor must be a string');
  }

  if (name != undefined) {
    // find the unit and prefix from the string
    var res = _findUnit(name);
    if (!res) {
      throw new SyntaxError('Unknown unit "' + name + '"');
    }
    this.unit = res.unit;
    this.prefix = res.prefix;
  }
  else {
    this.unit = UNIT_NONE;
    this.prefix = PREFIX_NONE;  // link to a list with supported prefixes
  }

  this.value = (value != undefined) ? this._normalize(value) : null;
  this.fixPrefix = false; // if true, function format will not search for the
                          // best prefix but leave it as initially provided.
                          // fixPrefix is set true by the method Unit.to
}

// private variables and functions for the Unit parser
var text, index, c;

function skipWhitespace() {
  while (c == ' ' || c == '\t') {
    next();
  }
}

function isDigitDot (c) {
  return ((c >= '0' && c <= '9') || c == '.');
}

function isDigit (c) {
  return ((c >= '0' && c <= '9'));
}

function next() {
  index++;
  c = text.charAt(index);
}

function revert(oldIndex) {
  index = oldIndex;
  c = text.charAt(index);
}

function parseNumber () {
  var number = '';
  var oldIndex;
  oldIndex = index;

  if (c == '+') {
    next();
  }
  else if (c == '-') {
    number += c;
    next();
  }

  if (!isDigitDot(c)) {
    // a + or - must be followed by a digit
    revert(oldIndex);
    return null;
  }

  // get number, can have a single dot
  if (c == '.') {
    number += c;
    next();
    if (!isDigit(c)) {
      // this is no legal number, it is just a dot
      revert(oldIndex);
      return null;
    }
  }
  else {
    while (isDigit(c)) {
      number += c;
      next();
    }
    if (c == '.') {
      number += c;
      next();
    }
  }
  while (isDigit(c)) {
    number += c;
    next();
  }

  // check for exponential notation like "2.3e-4" or "1.23e50"
  if (c == 'E' || c == 'e') {
    number += c;
    next();

    if (c == '+' || c == '-') {
      number += c;
      next();
    }

    // Scientific notation MUST be followed by an exponent
    if (!isDigit(c)) {
      // this is no legal number, exponent is missing.
      revert(oldIndex);
      return null;
    }

    while (isDigit(c)) {
      number += c;
      next();
    }
  }

  return number;
}

function parseUnit() {
  var unitName = '';

  skipWhitespace();
  while (c && c != ' ' && c != '\t') {
    unitName += c;
    next();
  }

  return unitName || null;
}

/**
 * Parse a string into a unit. Returns null if the provided string does not
 * contain a valid unit.
 * @param {String} str        A string like "5.2 inch", "4e2 kg"
 * @return {Unit | null} unit
 */
Unit.parse = function(str) {
  text = str;
  index = -1;
  c = '';

  if (!isString(text)) {
    return null;
  }

  next();
  skipWhitespace();
  var value = parseNumber();
  var name;
  if (value) {
    name = parseUnit();

    next();
    skipWhitespace();
    if (c) {
      // garbage at the end. not good.
      return null;
    }

    if (value && name) {
      try {
        // constructor will throw an error when unit is not found
        return new Unit(Number(value), name);
      }
      catch (err) {}
    }
  }
  else {
    name = parseUnit();

    next();
    skipWhitespace();
    if (c) {
      // garbage at the end. not good.
      return null;
    }

    if (name) {
      try {
        // constructor will throw an error when unit is not found
        return new Unit(null, name);
      }
      catch (err) {}
    }
  }

  return null;
};

/**
 * Test whether value is of type Unit
 * @param {*} value
 * @return {Boolean} isUnit
 */
Unit.isUnit = function(value) {
  return (value instanceof Unit);
};

/**
 * create a copy of this unit
 * @return {Unit} clone
 */
Unit.prototype.clone = function () {
  var clone = new Unit();

  for (var p in this) {
    if (this.hasOwnProperty(p)) {
      clone[p] = this[p];
    }
  }

  return clone;
};

/**
 * Normalize a value, based on its currently set unit
 * @param {Number} value
 * @return {Number} normalized value
 * @private
 */
Unit.prototype._normalize = function(value) {
  return (value + this.unit.offset) * this.unit.value * this.prefix.value;
};

/**
 * Unnormalize a value, based on its currently set unit
 * @param {Number} value
 * @param {Number} [prefixValue]    Optional prefix value to be used
 * @return {Number} unnormalized value
 * @private
 */
Unit.prototype._unnormalize = function (value, prefixValue) {
  if (prefixValue == undefined) {
    return value / this.unit.value / this.prefix.value - this.unit.offset;
  }
  else {
    return value / this.unit.value / prefixValue - this.unit.offset;
  }
};

/**
 * Find a unit from a string
 * @param {String} str              A string like 'cm' or 'inch'
 * @returns {Object | null} result  When found, an object with fields unit and
 *                                  prefix is returned. Else, null is returned.
 * @private
 */
function _findUnit(str) {
  for (var name in UNITS) {
    if (UNITS.hasOwnProperty(name)) {
      if (string.endsWith(str, name) ) {
        var unit = UNITS[name];
        var prefixLen = (str.length - name.length);
        var prefixName = str.substring(0, prefixLen);
        var prefix = unit.prefixes[prefixName];
        if (prefix !== undefined) {
          // store unit, prefix, and value
          return {
            unit: unit,
            prefix: prefix
          };
        }
      }
    }
  }

  return null;
}

/**
 * Test if the given expression is a unit.
 * The unit can have a prefix but cannot have a value.
 * @param {String} name   A string to be tested whether it is a value less unit.
 *                        The unit can have prefix, like "cm"
 * @return {Boolean}      true if the given string is a unit
 */
Unit.isValuelessUnit = function (name) {
  return (_findUnit(name) != null);
};

/**
 * check if this unit has given base unit
 * @param {BASE_UNITS | undefined} base
 */
Unit.prototype.hasBase = function(base) {
  return (this.unit.base === base);
};

/**
 * Check if this unit has a base equal to another base
 * @param {Unit} other
 * @return {Boolean} true if equal base
 */
Unit.prototype.equalBase = function(other) {
  return (this.unit.base === other.unit.base);
};

/**
 * Check if this unit equals another unit
 * @param {Unit} other
 * @return {Boolean} true if both units are equal
 */
Unit.prototype.equals = function(other) {
  return (this.equalBase(other) && this.value == other.value);
};

/**
 * Create a clone of this unit with a representation
 * @param {String | Unit} valuelessUnit   A unit without value. Can have prefix, like "cm"
 * @returns {Unit} unit having fixed, specified unit
 */
Unit.prototype.to = function (valuelessUnit) {
  var other;
  if (isString(valuelessUnit)) {
    other = new Unit(null, valuelessUnit);

    if (!this.equalBase(other)) {
      throw new Error('Units do not match');
    }

    other.value = this.value;
    other.fixPrefix = true;
    return other;
  }
  else if (valuelessUnit instanceof Unit) {
    if (!this.equalBase(valuelessUnit)) {
      throw new Error('Units do not match');
    }
    if (valuelessUnit.value !== null) {
      throw new Error('Cannot convert to a unit with a value');
    }

    other = valuelessUnit.clone();
    other.value = this.value;
    other.fixPrefix = true;
    return other;
  }
  else {
    throw new Error('String or Unit expected as parameter');
  }
};

/**
 * Return the value of the unit when represented with given valueless unit
 * @param {String | Unit} valuelessUnit    For example 'cm' or 'inch'
 * @return {Number} value
 */
Unit.prototype.toNumber = function (valuelessUnit) {
  var other = this.to(valuelessUnit);
  return other._unnormalize(other.value, other.prefix.value);
};


/**
 * Get a string representation of the unit.
 * @return {String}
 */
Unit.prototype.toString = function() {
  return this.format();
};

/**
 * Returns the string representation of the unit.
 * @return {String}
 */
Unit.prototype.valueOf = Unit.prototype.toString;

/**
 * Get a string representation of the Unit, with optional formatting options.
 * @param {Object | Number | Function} [options]  Formatting options. See
 *                                                lib/util/number:format for a
 *                                                description of the available
 *                                                options.
 * @return {String}
 */
Unit.prototype.format = function(options) {
  var value,
      str;

  if (this.value !== null && !this.fixPrefix) {
    var bestPrefix = this._bestPrefix();
    value = this._unnormalize(this.value, bestPrefix.value);
    str = number.format(value, options) + ' ';
    str += bestPrefix.name + this.unit.name;
  }
  else {
    value = this._unnormalize(this.value);
    str = (this.value !== null) ? (number.format(value, options) + ' ') : '';
    str += this.prefix.name + this.unit.name;
  }

  return str;
};

/**
 * Calculate the best prefix using current value.
 * @returns {Object} prefix
 * @private
 */
Unit.prototype._bestPrefix = function () {
  // find the best prefix value (resulting in the value of which
  // the absolute value of the log10 is closest to zero,
  // though with a little offset of 1.2 for nicer values: you get a
  // sequence 1mm 100mm 500mm 0.6m 1m 10m 100m 500m 0.6km 1km ...
  var absValue = Math.abs(this.value / this.unit.value);
  var bestPrefix = PREFIX_NONE;
  var bestDiff = Math.abs(
      Math.log(absValue / bestPrefix.value) / Math.LN10 - 1.2);

  var prefixes = this.unit.prefixes;
  for (var p in prefixes) {
    if (prefixes.hasOwnProperty(p)) {
      var prefix = prefixes[p];
      if (prefix.scientific) {
        var diff = Math.abs(
            Math.log(absValue / prefix.value) / Math.LN10 - 1.2);

        if (diff < bestDiff) {
          bestPrefix = prefix;
          bestDiff = diff;
        }
      }
    }
  }

  return bestPrefix;
};

var PREFIXES = {
  NONE: {
    '': {name: '', value: 1, scientific: true}
  },
  SHORT: {
    '': {name: '', value: 1, scientific: true},

    'da': {name: 'da', value: 1e1, scientific: false},
    'h': {name: 'h', value: 1e2, scientific: false},
    'k': {name: 'k', value: 1e3, scientific: true},
    'M': {name: 'M', value: 1e6, scientific: true},
    'G': {name: 'G', value: 1e9, scientific: true},
    'T': {name: 'T', value: 1e12, scientific: true},
    'P': {name: 'P', value: 1e15, scientific: true},
    'E': {name: 'E', value: 1e18, scientific: true},
    'Z': {name: 'Z', value: 1e21, scientific: true},
    'Y': {name: 'Y', value: 1e24, scientific: true},

    'd': {name: 'd', value: 1e-1, scientific: false},
    'c': {name: 'c', value: 1e-2, scientific: false},
    'm': {name: 'm', value: 1e-3, scientific: true},
    'u': {name: 'u', value: 1e-6, scientific: true},
    'n': {name: 'n', value: 1e-9, scientific: true},
    'p': {name: 'p', value: 1e-12, scientific: true},
    'f': {name: 'f', value: 1e-15, scientific: true},
    'a': {name: 'a', value: 1e-18, scientific: true},
    'z': {name: 'z', value: 1e-21, scientific: true},
    'y': {name: 'y', value: 1e-24, scientific: true}
  },
  LONG: {
    '': {name: '', value: 1, scientific: true},

    'deca': {name: 'deca', value: 1e1, scientific: false},
    'hecto': {name: 'hecto', value: 1e2, scientific: false},
    'kilo': {name: 'kilo', value: 1e3, scientific: true},
    'mega': {name: 'mega', value: 1e6, scientific: true},
    'giga': {name: 'giga', value: 1e9, scientific: true},
    'tera': {name: 'tera', value: 1e12, scientific: true},
    'peta': {name: 'peta', value: 1e15, scientific: true},
    'exa': {name: 'exa', value: 1e18, scientific: true},
    'zetta': {name: 'zetta', value: 1e21, scientific: true},
    'yotta': {name: 'yotta', value: 1e24, scientific: true},

    'deci': {name: 'deci', value: 1e-1, scientific: false},
    'centi': {name: 'centi', value: 1e-2, scientific: false},
    'milli': {name: 'milli', value: 1e-3, scientific: true},
    'micro': {name: 'micro', value: 1e-6, scientific: true},
    'nano': {name: 'nano', value: 1e-9, scientific: true},
    'pico': {name: 'pico', value: 1e-12, scientific: true},
    'femto': {name: 'femto', value: 1e-15, scientific: true},
    'atto': {name: 'atto', value: 1e-18, scientific: true},
    'zepto': {name: 'zepto', value: 1e-21, scientific: true},
    'yocto': {name: 'yocto', value: 1e-24, scientific: true}
  },
  SQUARED: {
    '': {name: '', value: 1, scientific: true},

    'da': {name: 'da', value: 1e2, scientific: false},
    'h': {name: 'h', value: 1e4, scientific: false},
    'k': {name: 'k', value: 1e6, scientific: true},
    'M': {name: 'M', value: 1e12, scientific: true},
    'G': {name: 'G', value: 1e18, scientific: true},
    'T': {name: 'T', value: 1e24, scientific: true},
    'P': {name: 'P', value: 1e30, scientific: true},
    'E': {name: 'E', value: 1e36, scientific: true},
    'Z': {name: 'Z', value: 1e42, scientific: true},
    'Y': {name: 'Y', value: 1e48, scientific: true},

    'd': {name: 'd', value: 1e-2, scientific: false},
    'c': {name: 'c', value: 1e-4, scientific: false},
    'm': {name: 'm', value: 1e-6, scientific: true},
    'u': {name: 'u', value: 1e-12, scientific: true},
    'n': {name: 'n', value: 1e-18, scientific: true},
    'p': {name: 'p', value: 1e-24, scientific: true},
    'f': {name: 'f', value: 1e-30, scientific: true},
    'a': {name: 'a', value: 1e-36, scientific: true},
    'z': {name: 'z', value: 1e-42, scientific: true},
    'y': {name: 'y', value: 1e-42, scientific: true}
  },
  CUBIC: {
    '': {name: '', value: 1, scientific: true},

    'da': {name: 'da', value: 1e3, scientific: false},
    'h': {name: 'h', value: 1e6, scientific: false},
    'k': {name: 'k', value: 1e9, scientific: true},
    'M': {name: 'M', value: 1e18, scientific: true},
    'G': {name: 'G', value: 1e27, scientific: true},
    'T': {name: 'T', value: 1e36, scientific: true},
    'P': {name: 'P', value: 1e45, scientific: true},
    'E': {name: 'E', value: 1e54, scientific: true},
    'Z': {name: 'Z', value: 1e63, scientific: true},
    'Y': {name: 'Y', value: 1e72, scientific: true},

    'd': {name: 'd', value: 1e-3, scientific: false},
    'c': {name: 'c', value: 1e-6, scientific: false},
    'm': {name: 'm', value: 1e-9, scientific: true},
    'u': {name: 'u', value: 1e-18, scientific: true},
    'n': {name: 'n', value: 1e-27, scientific: true},
    'p': {name: 'p', value: 1e-36, scientific: true},
    'f': {name: 'f', value: 1e-45, scientific: true},
    'a': {name: 'a', value: 1e-54, scientific: true},
    'z': {name: 'z', value: 1e-63, scientific: true},
    'y': {name: 'y', value: 1e-72, scientific: true}
  },
  BINARY_SHORT: {
    '': {name: '', value: 1, scientific: true},
    'k': {name: 'k', value: 1024, scientific: true},
    'M': {name: 'M', value: Math.pow(1024, 2), scientific: true},
    'G': {name: 'G', value: Math.pow(1024, 3), scientific: true},
    'T': {name: 'T', value: Math.pow(1024, 4), scientific: true},
    'P': {name: 'P', value: Math.pow(1024, 5), scientific: true},
    'E': {name: 'E', value: Math.pow(1024, 6), scientific: true},
    'Z': {name: 'Z', value: Math.pow(1024, 7), scientific: true},
    'Y': {name: 'Y', value: Math.pow(1024, 8), scientific: true},

    'Ki': {name: 'Ki', value: 1024, scientific: true},
    'Mi': {name: 'Mi', value: Math.pow(1024, 2), scientific: true},
    'Gi': {name: 'Gi', value: Math.pow(1024, 3), scientific: true},
    'Ti': {name: 'Ti', value: Math.pow(1024, 4), scientific: true},
    'Pi': {name: 'Pi', value: Math.pow(1024, 5), scientific: true},
    'Ei': {name: 'Ei', value: Math.pow(1024, 6), scientific: true},
    'Zi': {name: 'Zi', value: Math.pow(1024, 7), scientific: true},
    'Yi': {name: 'Yi', value: Math.pow(1024, 8), scientific: true}
  },
  BINARY_LONG: {
    '': {name: '', value: 1, scientific: true},
    'kilo': {name: 'kilo', value: 1024, scientific: true},
    'mega': {name: 'mega', value: Math.pow(1024, 2), scientific: true},
    'giga': {name: 'giga', value: Math.pow(1024, 3), scientific: true},
    'tera': {name: 'tera', value: Math.pow(1024, 4), scientific: true},
    'peta': {name: 'peta', value: Math.pow(1024, 5), scientific: true},
    'exa': {name: 'exa', value: Math.pow(1024, 6), scientific: true},
    'zetta': {name: 'zetta', value: Math.pow(1024, 7), scientific: true},
    'yotta': {name: 'yotta', value: Math.pow(1024, 8), scientific: true},

    'kibi': {name: 'kibi', value: 1024, scientific: true},
    'mebi': {name: 'mebi', value: Math.pow(1024, 2), scientific: true},
    'gibi': {name: 'gibi', value: Math.pow(1024, 3), scientific: true},
    'tebi': {name: 'tebi', value: Math.pow(1024, 4), scientific: true},
    'pebi': {name: 'pebi', value: Math.pow(1024, 5), scientific: true},
    'exi': {name: 'exi', value: Math.pow(1024, 6), scientific: true},
    'zebi': {name: 'zebi', value: Math.pow(1024, 7), scientific: true},
    'yobi': {name: 'yobi', value: Math.pow(1024, 8), scientific: true}
  }
};

var PREFIX_NONE = {name: '', value: 1, scientific: true};

var BASE_UNITS = {
  NONE: {},

  LENGTH: {},               // meter
  MASS: {},                 // kilogram
  TIME: {},                 // second
  CURRENT: {},              // ampere
  TEMPERATURE: {},          // kelvin
  LUMINOUS_INTENSITY: {},   // candela
  AMOUNT_OF_SUBSTANCE: {},  // mole

  FORCE: {},                // Newton
  SURFACE: {},              // m2
  VOLUME: {},               // m3
  ANGLE: {},                // rad
  BIT: {}                   // bit (digital)
};

var BASE_UNIT_NONE = {};

var UNIT_NONE = {name: '', base: BASE_UNIT_NONE, value: 1, offset: 0};

var UNITS = {
  // length
  meter: {name: 'meter', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.LONG, value: 1, offset: 0},
  inch: {name: 'inch', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 0.0254, offset: 0},
  foot: {name: 'foot', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 0.3048, offset: 0},
  yard: {name: 'yard', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 0.9144, offset: 0},
  mile: {name: 'mile', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 1609.344, offset: 0},
  link: {name: 'link', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 0.201168, offset: 0},
  rod: {name: 'rod', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 5.029210, offset: 0},
  chain: {name: 'chain', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 20.1168, offset: 0},
  angstrom: {name: 'angstrom', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 1e-10, offset: 0},

  m: {name: 'm', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.SHORT, value: 1, offset: 0},
  'in': {name: 'in', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 0.0254, offset: 0},
  ft: {name: 'ft', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 0.3048, offset: 0},
  yd: {name: 'yd', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 0.9144, offset: 0},
  mi: {name: 'mi', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 1609.344, offset: 0},
  li: {name: 'li', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 0.201168, offset: 0},
  rd: {name: 'rd', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 5.029210, offset: 0},
  ch: {name: 'ch', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 20.1168, offset: 0},
  mil: {name: 'mil', base: BASE_UNITS.LENGTH, prefixes: PREFIXES.NONE, value: 0.0000254, offset: 0}, // 1/1000 inch

  // Surface
  m2: {name: 'm2', base: BASE_UNITS.SURFACE, prefixes: PREFIXES.SQUARED, value: 1, offset: 0},
  sqin: {name: 'sqin', base: BASE_UNITS.SURFACE, prefixes: PREFIXES.NONE, value: 0.00064516, offset: 0}, // 645.16 mm2
  sqft: {name: 'sqft', base: BASE_UNITS.SURFACE, prefixes: PREFIXES.NONE, value: 0.09290304, offset: 0}, // 0.09290304 m2
  sqyd: {name: 'sqyd', base: BASE_UNITS.SURFACE, prefixes: PREFIXES.NONE, value: 0.83612736, offset: 0}, // 0.83612736 m2
  sqmi: {name: 'sqmi', base: BASE_UNITS.SURFACE, prefixes: PREFIXES.NONE, value: 2589988.110336, offset: 0}, // 2.589988110336 km2
  sqrd: {name: 'sqrd', base: BASE_UNITS.SURFACE, prefixes: PREFIXES.NONE, value: 25.29295, offset: 0}, // 25.29295 m2
  sqch: {name: 'sqch', base: BASE_UNITS.SURFACE, prefixes: PREFIXES.NONE, value: 404.6873, offset: 0}, // 404.6873 m2
  sqmil: {name: 'sqmil', base: BASE_UNITS.SURFACE, prefixes: PREFIXES.NONE, value: 6.4516e-10, offset: 0}, // 6.4516 * 10^-10 m2

  // Volume
  m3: {name: 'm3', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.CUBIC, value: 1, offset: 0},
  L: {name: 'L', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.SHORT, value: 0.001, offset: 0}, // litre
  l: {name: 'l', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.SHORT, value: 0.001, offset: 0}, // litre
  litre: {name: 'litre', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.LONG, value: 0.001, offset: 0},
  cuin: {name: 'cuin', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 1.6387064e-5, offset: 0}, // 1.6387064e-5 m3
  cuft: {name: 'cuft', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.028316846592, offset: 0}, // 28.316 846 592 L
  cuyd: {name: 'cuyd', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.764554857984, offset: 0}, // 764.554 857 984 L
  teaspoon: {name: 'teaspoon', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000005, offset: 0}, // 5 mL
  tablespoon: {name: 'tablespoon', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000015, offset: 0}, // 15 mL
  //{name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
  drop: {name: 'drop', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 5e-8, offset: 0},  // 0.05 mL = 5e-8 m3
  gtt: {name: 'gtt', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 5e-8, offset: 0},  // 0.05 mL = 5e-8 m3

  // Liquid volume
  minim: {name: 'minim', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL
  fluiddram: {name: 'fluiddram', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.0000036966911, offset: 0},  // 3.696691 mL
  fluidounce: {name: 'fluidounce', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00002957353, offset: 0}, // 29.57353 mL
  gill: {name: 'gill', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.0001182941, offset: 0}, // 118.2941 mL
  cc: {name: 'cc', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 1e-6, offset: 0}, // 1e-6 L
  cup: {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.0002365882, offset: 0}, // 236.5882 mL
  pint: {name: 'pint', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.0004731765, offset: 0}, // 473.1765 mL
  quart: {name: 'quart', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.0009463529, offset: 0}, // 946.3529 mL
  gallon: {name: 'gallon', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.003785412, offset: 0}, // 3.785412 L
  beerbarrel: {name: 'beerbarrel', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.1173478, offset: 0}, // 117.3478 L
  oilbarrel: {name: 'oilbarrel', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.1589873, offset: 0}, // 158.9873 L
  hogshead: {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L

  //{name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
  fldr: {name: 'fldr', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.0000036966911, offset: 0},  // 3.696691 mL
  floz: {name: 'floz', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00002957353, offset: 0}, // 29.57353 mL
  gi: {name: 'gi', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.0001182941, offset: 0}, // 118.2941 mL
  cp: {name: 'cp', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.0002365882, offset: 0}, // 236.5882 mL
  pt: {name: 'pt', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.0004731765, offset: 0}, // 473.1765 mL
  qt: {name: 'qt', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.0009463529, offset: 0}, // 946.3529 mL
  gal: {name: 'gal', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.003785412, offset: 0}, // 3.785412 L
  bbl: {name: 'bbl', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.1173478, offset: 0}, // 117.3478 L
  obl: {name: 'obl', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.1589873, offset: 0}, // 158.9873 L
  //{name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?

  // Mass
  g: {name: 'g', base: BASE_UNITS.MASS, prefixes: PREFIXES.SHORT, value: 0.001, offset: 0},
  gram: {name: 'gram', base: BASE_UNITS.MASS, prefixes: PREFIXES.LONG, value: 0.001, offset: 0},

  ton: {name: 'ton', base: BASE_UNITS.MASS, prefixes: PREFIXES.SHORT, value: 907.18474, offset: 0},
  tonne: {name: 'tonne', base: BASE_UNITS.MASS, prefixes: PREFIXES.SHORT, value: 1000, offset: 0},

  grain: {name: 'grain', base: BASE_UNITS.MASS, prefixes: PREFIXES.NONE, value: 64.79891e-6, offset: 0},
  dram: {name: 'dram', base: BASE_UNITS.MASS, prefixes: PREFIXES.NONE, value: 1.7718451953125e-3, offset: 0},
  ounce: {name: 'ounce', base: BASE_UNITS.MASS, prefixes: PREFIXES.NONE, value: 28.349523125e-3, offset: 0},
  poundmass: {name: 'poundmass', base: BASE_UNITS.MASS, prefixes: PREFIXES.NONE, value: 453.59237e-3, offset: 0},
  hundredweight: {name: 'hundredweight', base: BASE_UNITS.MASS, prefixes: PREFIXES.NONE, value: 45.359237, offset: 0},
  stick: {name: 'stick', base: BASE_UNITS.MASS, prefixes: PREFIXES.NONE, value: 115e-3, offset: 0},

  gr: {name: 'gr', base: BASE_UNITS.MASS, prefixes: PREFIXES.NONE, value: 64.79891e-6, offset: 0},
  dr: {name: 'dr', base: BASE_UNITS.MASS, prefixes: PREFIXES.NONE, value: 1.7718451953125e-3, offset: 0},
  oz: {name: 'oz', base: BASE_UNITS.MASS, prefixes: PREFIXES.NONE, value: 28.349523125e-3, offset: 0},
  lbm: {name: 'lbm', base: BASE_UNITS.MASS, prefixes: PREFIXES.NONE, value: 453.59237e-3, offset: 0},
  cwt: {name: 'cwt', base: BASE_UNITS.MASS, prefixes: PREFIXES.NONE, value: 45.359237, offset: 0},

  // Time
  s: {name: 's', base: BASE_UNITS.TIME, prefixes: PREFIXES.SHORT, value: 1, offset: 0},
  min: {name: 'min', base: BASE_UNITS.TIME, prefixes: PREFIXES.NONE, value: 60, offset: 0},
  h: {name: 'h', base: BASE_UNITS.TIME, prefixes: PREFIXES.NONE, value: 3600, offset: 0},
  second: {name: 'second', base: BASE_UNITS.TIME, prefixes: PREFIXES.LONG, value: 1, offset: 0},
  sec: {name: 'sec', base: BASE_UNITS.TIME, prefixes: PREFIXES.LONG, value: 1, offset: 0},
  minute: {name: 'minute', base: BASE_UNITS.TIME, prefixes: PREFIXES.NONE, value: 60, offset: 0},
  hour: {name: 'hour', base: BASE_UNITS.TIME, prefixes: PREFIXES.NONE, value: 3600, offset: 0},
  day: {name: 'day', base: BASE_UNITS.TIME, prefixes: PREFIXES.NONE, value: 86400, offset: 0},

  // Angle
  rad: {name: 'rad', base: BASE_UNITS.ANGLE, prefixes: PREFIXES.NONE, value: 1, offset: 0},
  // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
  deg: {name: 'deg', base: BASE_UNITS.ANGLE, prefixes: PREFIXES.NONE, value: 0.017453292519943295769236907684888, offset: 0},
  // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
  grad: {name: 'grad', base: BASE_UNITS.ANGLE, prefixes: PREFIXES.NONE, value: 0.015707963267948966192313216916399, offset: 0},
  // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
  cycle: {name: 'cycle', base: BASE_UNITS.ANGLE, prefixes: PREFIXES.NONE, value: 6.2831853071795864769252867665793, offset: 0},

  // Electric current
  A: {name: 'A', base: BASE_UNITS.CURRENT, prefixes: PREFIXES.SHORT, value: 1, offset: 0},
  ampere: {name: 'ampere', base: BASE_UNITS.CURRENT, prefixes: PREFIXES.LONG, value: 1, offset: 0},

  // Temperature
  // K(C) = °C + 273.15
  // K(F) = (°F + 459.67) / 1.8
  // K(R) = °R / 1.8
  K: {name: 'K', base: BASE_UNITS.TEMPERATURE, prefixes: PREFIXES.NONE, value: 1, offset: 0},
  degC: {name: 'degC', base: BASE_UNITS.TEMPERATURE, prefixes: PREFIXES.NONE, value: 1, offset: 273.15},
  degF: {name: 'degF', base: BASE_UNITS.TEMPERATURE, prefixes: PREFIXES.NONE, value: 1/1.8, offset: 459.67},
  degR: {name: 'degR', base: BASE_UNITS.TEMPERATURE, prefixes: PREFIXES.NONE, value: 1/1.8, offset: 0},
  kelvin: {name: 'kelvin', base: BASE_UNITS.TEMPERATURE, prefixes: PREFIXES.NONE, value: 1, offset: 0},
  celsius: {name: 'celsius', base: BASE_UNITS.TEMPERATURE, prefixes: PREFIXES.NONE, value: 1, offset: 273.15},
  fahrenheit: {name: 'fahrenheit', base: BASE_UNITS.TEMPERATURE, prefixes: PREFIXES.NONE, value: 1/1.8, offset: 459.67},
  rankine: {name: 'rankine', base: BASE_UNITS.TEMPERATURE, prefixes: PREFIXES.NONE, value: 1/1.8, offset: 0},

  // amount of substance
  mol: {name: 'mol', base: BASE_UNITS.AMOUNT_OF_SUBSTANCE, prefixes: PREFIXES.NONE, value: 1, offset: 0},
  mole: {name: 'mole', base: BASE_UNITS.AMOUNT_OF_SUBSTANCE, prefixes: PREFIXES.NONE, value: 1, offset: 0},

  // luminous intensity
  cd: {name: 'cd', base: BASE_UNITS.LUMINOUS_INTENSITY, prefixes: PREFIXES.NONE, value: 1, offset: 0},
  candela: {name: 'candela', base: BASE_UNITS.LUMINOUS_INTENSITY, prefixes: PREFIXES.NONE, value: 1, offset: 0},
  // TODO: units STERADIAN
  //{name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
  //{name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},

  // Force
  N: {name: 'N', base: BASE_UNITS.FORCE, prefixes: PREFIXES.SHORT, value: 1, offset: 0},
  newton: {name: 'newton', base: BASE_UNITS.FORCE, prefixes: PREFIXES.LONG, value: 1, offset: 0},
  lbf: {name: 'lbf', base: BASE_UNITS.FORCE, prefixes: PREFIXES.NONE, value: 4.4482216152605, offset: 0},
  poundforce: {name: 'poundforce', base: BASE_UNITS.FORCE, prefixes: PREFIXES.NONE, value: 4.4482216152605, offset: 0},

  // Binary
  b: {name: 'b', base: BASE_UNITS.BIT, prefixes: PREFIXES.BINARY_SHORT, value: 1, offset: 0},
  bits: {name: 'bits', base: BASE_UNITS.BIT, prefixes: PREFIXES.BINARY_LONG, value: 1, offset: 0},
  B: {name: 'B', base: BASE_UNITS.BIT, prefixes: PREFIXES.BINARY_SHORT, value: 8, offset: 0},
  bytes: {name: 'bytes', base: BASE_UNITS.BIT, prefixes: PREFIXES.BINARY_LONG, value: 8, offset: 0}
};

// plurals
var PLURALS = {
  meters: 'meter',
  inches: 'inch',
  feet: 'foot',
  yards: 'yard',
  miles: 'mile',
  links: 'link',
  rods: 'rod',
  chains: 'chain',
  angstroms: 'angstrom',

  litres: 'litre',
  teaspoons: 'teaspoon',
  tablespoons: 'tablespoon',
  minims: 'minim',
  fluiddrams: 'fluiddram',
  fluidounces: 'fluidounce',
  gills: 'gill',
  cups: 'cup',
  pints: 'pint',
  quarts: 'quart',
  gallons: 'gallon',
  beerbarrels: 'beerbarrel',
  oilbarrels: 'oilbarrel',
  hogsheads: 'hogshead',
  gtts: 'gtt',

  grams: 'gram',
  tons: 'ton',
  tonnes: 'tonne',
  grains: 'grain',
  drams: 'dram',
  ounces: 'ounce',
  poundmasses: 'poundmass',
  hundredweights: 'hundredweight',
  sticks: 'stick',

  seconds: 'second',
  minutes: 'minute',
  hours: 'hour',
  days: 'day',

  radians: 'rad',
  degrees: 'deg',
  gradients: 'grad',
  cycles: 'cycle',

  amperes: 'ampere',
  moles: 'mole'
};

for (var name in PLURALS) {
  /* istanbul ignore next (we cannot really test next statement) */
  if (PLURALS.hasOwnProperty(name)) {
    var unit = UNITS[PLURALS[name]];
    var plural = Object.create(unit);
    plural.name = name;
    UNITS[name] = plural;
  }
}

// aliases
UNITS.lt = UNITS.l;
UNITS.liter = UNITS.litre;
UNITS.liters = UNITS.litres;
UNITS.lb = UNITS.lbm;
UNITS.lbs = UNITS.lbm;


Unit.PREFIXES = PREFIXES;
Unit.BASE_UNITS = BASE_UNITS;
Unit.UNITS = UNITS;

// end of unit aliases


// exports
module.exports = Unit;

},{"../util/index":178}],51:[function(require,module,exports){
'use strict';

var util = require('../util/index'),
    object = util.object,
    string = util.string;

/**
 * Documentation object
 * @param {Object} math The math.js namespace
 * @param {Object} doc  Object containing properties:
 *                      {String} name
 *                      {String} category
 *                      {String[]} syntax
 *                      {String[]} examples
 *                      {String[]} seealso
 * @constructor
 */
function Help (math, doc) {
  if (!(this instanceof Help)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // TODO: throw an error when math or doc is not provided

  this.math = math;
  this.doc = doc;
}

/**
 * Test whether a value is an instance of Help
 * @param {*} value
 * @return {Boolean} isHelp
 */
Help.isHelp = function (value) {
  return (value instanceof Help);
};

/**
 * Generate readable description from a Help object
 * @return {String} readableDoc
 * @private
 */
Help.prototype.toString = function () {
  var doc = this.doc || {};
  var desc = '\n';

  if (doc.name) {
    desc += 'Name: ' + doc.name + '\n\n';
  }
  if (doc.category) {
    desc += 'Category: ' + doc.category + '\n\n';
  }
  if (doc.description) {
    desc += 'Description:\n    ' + doc.description + '\n\n';
  }
  if (doc.syntax) {
    desc += 'Syntax:\n    ' + doc.syntax.join('\n    ') + '\n\n';
  }
  if (doc.examples) {
    var parser = this.math.parser();
    desc += 'Examples:\n';
    for (var i = 0; i < doc.examples.length; i++) {
      var expr = doc.examples[i];
      var res;
      try {
        res = parser.eval(expr);
      }
      catch (e) {
        res = e;
      }
      desc += '    ' + expr + '\n';
      if (res && !(res instanceof Help)) {
        desc += '        ' + string.format(res, {precision: 14}) + '\n';
      }
    }
    desc += '\n';
  }
  if (doc.seealso) {
    desc += 'See also: ' + doc.seealso.join(', ') + '\n';
  }

  return desc;
};

// TODO: implement a toHTML function in Help

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  return object.clone(this.doc);
};

/**
 * Returns a string representation of the Help object
 */
Help.prototype.valueOf = Help.prototype.toString;

// exports
module.exports = Help;

},{"../util/index":178}],52:[function(require,module,exports){
// utility methods for arrays and matrices
'use strict';

var util = require('../util/index'),

    IndexError = require('../error/IndexError'),
    DimensionError = require('../error/DimensionError'),

    Matrix = require('./Matrix'),

    array = util.array,
    isArray = util.array.isArray,
    isString = util.string.isString;

/**
 * Convert function arguments to an array. Arguments can have the following
 * signature:
 *     fn()
 *     fn(n)
 *     fn(m, n, p, ...)
 *     fn([m, n, p, ...])
 * @param {...Number | Array | Matrix} args
 * @returns {Array} array
 */
exports.argsToArray = function(args) {
  if (args.length == 0) {
    // fn()
    return [];
  }
  else if (args.length == 1) {
    // fn(n)
    // fn([m, n, p, ...])
    var array = args[0];
    if (array instanceof Matrix) {
      array = array.valueOf();
    }
    if (!isArray(array)) {
      array = [array];
    }
    return array;
  }
  else {
    // fn(m, n, p, ...)
    return util.array.argsToArray(args);
  }
};


/**
 * Test whether a value is a collection: an Array or Matrix
 * @param {*} x
 * @returns {boolean} isCollection
 */
exports.isCollection = function(x) {
  return (isArray(x) || (x instanceof Matrix));
};

/**
 * Execute the callback function element wise for each element in array and any
 * nested array
 * Returns an array with the results
 * @param {Array | Matrix} array
 * @param {function} callback   The callback is called with two parameters:
 *                              value1 and value2, which contain the current
 *                              element of both arrays.
 * @return {Array | Matrix} res
 */
exports.deepMap = function deepMap(array, callback) {
  if (array && (typeof array.map === 'function')) {
    return array.map(function (x) {
      return deepMap(x, callback);
    });
  }
  else {
    return callback(array);
  }
};

/**
 * Execute the callback function element wise for each entry in two given arrays,
 * and for any nested array. Objects can also be scalar objects.
 * Returns an array with the results.
 * @param {Array | Matrix | Object} array1
 * @param {Array | Matrix | Object} array2
 * @param {function} callback   The callback is called with two parameters:
 *                              value1 and value2, which contain the current
 *                              element of both arrays.
 * @return {Array | Matrix} res
 */
exports.deepMap2 = function deepMap2(array1, array2, callback) {
  var res, len, i;

  if (isArray(array1)) {
    if (isArray(array2)) {
      // callback(array, array)
      if (array1.length != array2.length) {
        throw new DimensionError(array1.length, array2.length);
      }

      res = [];
      len = array1.length;
      for (i = 0; i < len; i++) {
        res[i] = deepMap2(array1[i], array2[i], callback);
      }
    }
    else if (array2 instanceof Matrix) {
      // callback(array, matrix)
      res = deepMap2(array1, array2.valueOf(), callback);
      return new Matrix(res);
    }
    else {
      // callback(array, object)
      res = [];
      len = array1.length;
      for (i = 0; i < len; i++) {
        res[i] = deepMap2(array1[i], array2, callback);
      }
    }
  }
  else if (array1 instanceof Matrix) {
    if (array2 instanceof Matrix) {
      // callback(matrix, matrix)
      res = deepMap2(array1.valueOf(), array2.valueOf(), callback);
      return new Matrix(res);
    }
    else {
      // callback(matrix, array)
      // callback(matrix, object)
      res = deepMap2(array1.valueOf(), array2, callback);
      return new Matrix(res);
    }
  }
  else {
    if (isArray(array2)) {
      // callback(object, array)
      res = [];
      len = array2.length;
      for (i = 0; i < len; i++) {
        res[i] = deepMap2(array1, array2[i], callback);
      }
    }
    else if (array2 instanceof Matrix) {
      // callback(object, matrix)
      res = deepMap2(array1, array2.valueOf(), callback);
      return new Matrix(res);
    }
    else {
      // callback(object, object)
      res = callback(array1, array2);
    }
  }

  return res;
};

/**
 * Reduce a given matrix or array to a new matrix or
 * array with one less dimension, applying the given
 * callback in the selected dimension.
 * @param {Array | Matrix} mat
 * @param {Number} dim
 * @param {function} callback
 * @return {Array | Matrix} res
 */
exports.reduce = function(mat, dim, callback) {
  var size = isArray(mat) ? array.size(mat) : mat.size();
  if (dim < 0) {
    // TODO: would be more clear when throwing a DimensionError here
    throw new IndexError(dim);
  }
  if (dim >= size.length) {
    // TODO: would be more clear when throwing a DimensionError here
    throw new IndexError(dim, size.length);
  }

	if (mat instanceof Matrix) {
		return new Matrix(_reduce(mat.valueOf(), dim, callback));
	}else {
		return _reduce(mat, dim, callback);
	}
};

/**
 * Recursively reduce a matrix
 * @param {Array} mat
 * @param {Number} dim
 * @param {Function} callback
 * @returns {Array} ret
 * @private
 */
function _reduce(mat, dim, callback){
  var i, ret, val, tran;

	if(dim<=0){
		if( !isArray(mat[0]) ){
			val = mat[0];
			for(i=1; i<mat.length; i++){
				val = callback(val, mat[i]);
			}
			return val;
		}else{
			tran = _switch(mat);
			ret = [];
			for(i=0; i<tran.length; i++){
				ret[i] = _reduce(tran[i], dim-1, callback);
			}
			return ret
		}
	}else{
		ret = [];
		for(i=0; i<mat.length; i++){
			ret[i] = _reduce(mat[i], dim-1, callback);
		}
		return ret;
	}
}

/**
 * Transpose a matrix
 * @param {Array} mat
 * @returns {Array} ret
 * @private
 */
function _switch(mat){
  var I = mat.length;
  var J = mat[0].length;
  var i, j;
  var ret = [];
  for( j=0; j<J; j++) {
    var tmp = [];
    for( i=0; i<I; i++) {
      tmp.push(mat[i][j]);
    }
    ret.push(tmp);
  }
  return ret;
}

/**
 * Recursively loop over all elements in a given multi dimensional array
 * and invoke the callback on each of the elements.
 * @param {Array | Matrix} array
 * @param {function} callback     The callback method is invoked with one
 *                                parameter: the current element in the array
 */
exports.deepForEach = function deepForEach (array, callback) {
  if (array instanceof Matrix) {
    array = array.valueOf();
  }

  for (var i = 0, ii = array.length; i < ii; i++) {
    var value = array[i];

    if (isArray(value)) {
      deepForEach(value, callback);
    }
    else {
      callback(value);
    }
  }
};

},{"../util/index":178,"../error/IndexError":176,"../error/DimensionError":175,"./Matrix":49}],54:[function(require,module,exports){
(function(){'use strict';

var util = require('../util/index'),

    ArgumentsError = require('../error/ArgumentsError'),

    isString = util.string.isString,
    isArray = Array.isArray,
    type = util.types.type,

    // types
    Complex = require('../type/Complex'),
    Matrix = require('../type/Matrix'),
    Unit = require('../type/Unit'),
    collection = require('../type/collection'),

    // scope and nodes
    ArrayNode = require('./node/ArrayNode'),
    AssignmentNode = require('./node/AssignmentNode'),
    BlockNode = require('./node/BlockNode'),
    ConditionalNode = require('./node/ConditionalNode'),
    ConstantNode = require('./node/ConstantNode'),
    FunctionAssignmentNode = require('./node/FunctionAssignmentNode'),
    IndexNode = require('./node/IndexNode'),
    OperatorNode = require('./node/OperatorNode'),
    FunctionNode = require('./node/FunctionNode'),
    RangeNode = require('./node/RangeNode'),
    SymbolNode = require('./node/SymbolNode'),
    UpdateNode = require('./node/UpdateNode');

/**
 * Parse an expression. Returns a node tree, which can be evaluated by
 * invoking node.eval();
 *
 * Syntax:
 *
 *     parse(expr)
 *     parse(expr, options)
 *     parse([expr1, expr2, expr3, ...])
 *     parse([expr1, expr2, expr3, ...], options)
 *
 * Example:
 *
 *     var node = parse('sqrt(3^2 + 4^2)');
 *     node.compile(math).eval(); // 5
 *
 *     var scope = {a:3, b:4}
 *     var node = parse('a * b'); // 12
 *     var code = node.compile(math);
 *     code.eval(scope); // 12
 *     scope.a = 5;
 *     code.eval(scope); // 20
 *
 *     var nodes = math.parse(['a = 3', 'b = 4', 'a * b']);
 *     nodes[2].compile(math).eval(); // 12
 *
 * @param {String | String[] | Matrix} expr
 * @param {{nodes: Object<String, Node>}} [options]  Available options:
 *                                                   - `nodes` a set of custom nodes
 * @return {Node | Node[]} node
 * @throws {Error}
 */
function parse (expr, options) {
  if (arguments.length != 1 && arguments.length != 2) {
    throw new ArgumentsError('parse', arguments.length, 1, 2);
  }

  // pass extra nodes
  extra_nodes = (options && options.nodes) ? options.nodes : {};

  if (isString(expr)) {
    // parse a single expression
    expression = expr;
    return parseStart();
  }
  else if (isArray(expr) || expr instanceof Matrix) {
    // parse an array or matrix with expressions
    return collection.deepMap(expr, function (elem) {
      if (!isString(elem)) throw new TypeError('String expected');

      expression = elem;
      return parseStart();
    });
  }
  else {
    // oops
    throw new TypeError('String or matrix expected');
  }
}

// token types enumeration
var TOKENTYPE = {
  NULL : 0,
  DELIMITER : 1,
  NUMBER : 2,
  SYMBOL : 3,
  UNKNOWN : 4
};

// map with all delimiters
var DELIMITERS = {
  ',': true,
  '(': true,
  ')': true,
  '[': true,
  ']': true,
  '\"': true,
  ';': true,

  '+': true,
  '-': true,
  '*': true,
  '.*': true,
  '/': true,
  './': true,
  '%': true,
  '^': true,
  '.^': true,
  '!': true,
  '\'': true,
  '=': true,
  ':': true,
  '?': true,

  '==': true,
  '!=': true,
  '<': true,
  '>': true,
  '<=': true,
  '>=': true
};

// map with all named delimiters
var NAMED_DELIMITERS = {
  'mod': true,
  'to': true,
  'in': true
};

var extra_nodes = {};             // current extra nodes
var expression = '';              // current expression
var index = 0;                    // current index in expr
var c = '';                       // current token character in expr
var token = '';                   // current token
var token_type = TOKENTYPE.NULL;  // type of the token
var nesting_level = 0;            // level of nesting inside parameters, used to ignore newline characters
var conditional_level = null;     // when a conditional is being parsed, the level of the conditional is stored here

/**
 * Get the first character from the expression.
 * The character is stored into the char c. If the end of the expression is
 * reached, the function puts an empty string in c.
 * @private
 */
function first() {
  index = 0;
  c = expression.charAt(0);
  nesting_level = 0;
  conditional_level = null;
}

/**
 * Get the next character from the expression.
 * The character is stored into the char c. If the end of the expression is
 * reached, the function puts an empty string in c.
 * @private
 */
function next() {
  index++;
  c = expression.charAt(index);
}

/**
 * Preview the next character from the expression.
 * @return {String} cNext
 * @private
 */
function nextPreview() {
  return expression.charAt(index + 1);
}

/**
 * Get next token in the current string expr.
 * The token and token type are available as token and token_type
 * @private
 */
function getToken() {
  token_type = TOKENTYPE.NULL;
  token = '';

  // skip over whitespaces
  // space, tab, and newline when inside parameters
  while (c == ' ' || c == '\t' || (c == '\n' && nesting_level)) {
    // TODO: also take '\r' carriage return as newline? Or does that give problems on mac?
    next();
  }

  // skip comment
  if (c == '#') {
    while (c != '\n' && c != '') {
      next();
    }
  }

  // check for end of expression
  if (c == '') {
    // token is still empty
    token_type = TOKENTYPE.DELIMITER;
    return;
  }

  // check for new line character
  if (c == '\n' && !nesting_level) {
    token_type = TOKENTYPE.DELIMITER;
    token = c;
    next();
    return;
  }

  // check for delimiters consisting of 2 characters
  var c2 = c + nextPreview();
  if (c2.length == 2 && DELIMITERS[c2]) {
    token_type = TOKENTYPE.DELIMITER;
    token = c2;
    next();
    next();
    return;
  }

  // check for delimiters consisting of 1 character
  if (DELIMITERS[c]) {
    token_type = TOKENTYPE.DELIMITER;
    token = c;
    next();
    return;
  }

  // check for a number
  if (isDigitDot(c)) {
    token_type = TOKENTYPE.NUMBER;

    // get number, can have a single dot
    if (c == '.') {
      token += c;
      next();

      if (!isDigit(c)) {
        // this is no legal number, it is just a dot
        token_type = TOKENTYPE.UNKNOWN;
      }
    }
    else {
      while (isDigit(c)) {
        token += c;
        next();
      }
      if (c == '.') {
        token += c;
        next();
      }
    }
    while (isDigit(c)) {
      token += c;
      next();
    }

    // check for exponential notation like "2.3e-4" or "1.23e50"
    if (c == 'E' || c == 'e') {
      token += c;
      next();

      if (c == '+' || c == '-') {
        token += c;
        next();
      }

      // Scientific notation MUST be followed by an exponent
      if (!isDigit(c)) {
        // this is no legal number, exponent is missing.
        token_type = TOKENTYPE.UNKNOWN;
      }

      while (isDigit(c)) {
        token += c;
        next();
      }
    }

    return;
  }

  // check for variables, functions, named operators
  if (isAlpha(c)) {
    while (isAlpha(c) || isDigit(c)) {
      token += c;
      next();
    }

    if (NAMED_DELIMITERS[token]) {
      token_type = TOKENTYPE.DELIMITER;
    }
    else {
      token_type = TOKENTYPE.SYMBOL;
    }

    return;
  }

  // something unknown is found, wrong characters -> a syntax error
  token_type = TOKENTYPE.UNKNOWN;
  while (c != '') {
    token += c;
    next();
  }
  throw createSyntaxError('Syntax error in part "' + token + '"');
}

/**
 * Get next token and skip newline tokens
 */
function getTokenSkipNewline () {
  do {
    getToken();
  }
  while (token == '\n');
}

/**
 * Open parameters.
 * New line characters will be ignored until closeParams() is called
 */
function openParams() {
  nesting_level++;
}

/**
 * Close parameters.
 * New line characters will no longer be ignored
 */
function closeParams() {
  nesting_level--;
}

/**
 * checks if the given char c is a letter (upper or lower case)
 * or underscore
 * @param {String} c   a string with one character
 * @return {Boolean}
 * @private
 */
function isAlpha (c) {
  return ((c >= 'a' && c <= 'z') ||
      (c >= 'A' && c <= 'Z') ||
      c == '_');
}

/**
 * checks if the given char c is a digit or dot
 * @param {String} c   a string with one character
 * @return {Boolean}
 * @private
 */
function isDigitDot (c) {
  return ((c >= '0' && c <= '9') ||
      c == '.');
}

/**
 * checks if the given char c is a digit
 * @param {String} c   a string with one character
 * @return {Boolean}
 * @private
 */
function isDigit (c) {
  return ((c >= '0' && c <= '9'));
}

/**
 * Start of the parse levels below, in order of precedence
 * @return {Node} node
 * @private
 */
function parseStart () {
  // get the first character in expression
  first();

  getToken();

  var node = parseBlock();

  // check for garbage at the end of the expression
  // an expression ends with a empty character '' and token_type DELIMITER
  if (token != '') {
    if (token_type == TOKENTYPE.DELIMITER) {
      // user entered a not existing operator like "//"

      // TODO: give hints for aliases, for example with "<>" give as hint " did you mean != ?"
      throw createError('Unexpected operator ' + token);
    }
    else {
      throw createSyntaxError('Unexpected part "' + token + '"');
    }
  }

  return node;
}

/**
 * Parse a block with expressions. Expressions can be separated by a newline
 * character '\n', or by a semicolon ';'. In case of a semicolon, no output
 * of the preceding line is returned.
 * @return {Node} node
 * @private
 */
function parseBlock () {
  var node, block, visible;

  if (token == '') {
    // empty expression
    return new ConstantNode('undefined', 'undefined');
  }

  if (token != '\n' && token != ';') {
    node = parseFunctionAssignment();
  }

  while (token == '\n' || token == ';') {
    if (!block) {
      // initialize the block
      block = new BlockNode();
      if (node) {
        visible = (token != ';');
        block.add(node, visible);
      }
    }

    getToken();
    if (token != '\n' && token != ';' && token != '') {
      node = parseFunctionAssignment();

      visible = (token != ';');
      block.add(node, visible);
    }
  }

  if (block) {
    return block;
  }

  return node;
}

/**
 * Parse a function assignment like "function f(a,b) = a*b"
 * @return {Node} node
 * @private
 */
function parseFunctionAssignment () {
  // TODO: function assignment using keyword 'function' is deprecated since version 0.18.0, cleanup some day
  if (token_type == TOKENTYPE.SYMBOL && token == 'function') {
    throw createSyntaxError('Deprecated keyword "function". ' +
        'Functions can now be assigned without it, like "f(x) = x^2".');
  }

  return parseAssignment();
}

/**
 * Assignment of a variable, can be a variable like "a=2.3" or a updating an
 * existing variable like "matrix(2,3:5)=[6,7,8]"
 * @return {Node} node
 * @private
 */
function parseAssignment () {
  var name, args, expr, valid;

  var node = parseConditional();

  if (token == '=') {
    if (node instanceof SymbolNode) {
      // parse a variable assignment like 'a = 2/3'
      name = node.name;
      getTokenSkipNewline();
      expr = parseAssignment();
      return new AssignmentNode(name, expr);
    }
    else if (node instanceof IndexNode) {
      // parse a matrix subset assignment like 'A[1,2] = 4'
      getTokenSkipNewline();
      expr = parseAssignment();
      return new UpdateNode(node, expr);
    }
    else if (node instanceof FunctionNode) {
      // parse function assignment like 'f(x) = x^2'
      valid = true;
      args = [];

      name = node.symbol.name;
      node.params.forEach(function (param, index) {
        if (param instanceof SymbolNode) {
          args[index] = param.name;
        }
        else {
          valid = false;
        }
      });

      if (valid) {
        getTokenSkipNewline();
        expr = parseAssignment();
        return new FunctionAssignmentNode(name, args, expr);
      }
    }

    throw createSyntaxError('Invalid left hand side of assignment operator =');
  }

  return node;
}

/**
 * conditional operation
 *
 *     condition ? truePart : falsePart
 *
 * Note: conditional operator is right-associative
 *
 * @return {Node} node
 * @private
 */
function parseConditional () {
  var node = parseRelational();

  while (token == '?') {
    // set a conditional level, the range operator will be ignored as long
    // as conditional_level == nesting_level.
    var prev = conditional_level;
    conditional_level = nesting_level;
    getTokenSkipNewline();

    var condition = node;
    var trueExpr = parseRelational();

    if (token != ':') throw createSyntaxError('False part of conditional expression expected');

    conditional_level = null;
    getTokenSkipNewline();

    var falseExpr = parseConditional(); // Note: we don't do parseRelational() here

    node = new ConditionalNode(condition, trueExpr, falseExpr);

    // restore the previous conditional level
    conditional_level = prev;
  }

  return node;
}

/**
 * conditional operators and bitshift
 * @return {Node} node
 * @private
 */
/* TODO: implement bitwise conditions. put on right place for precedence
function parseBitwiseConditions () {
  var node = parseRange();

   var operators = {
   '&' : 'bitwiseand',
   '|' : 'bitwiseor',
   // todo: bitwise xor?
   '<<': 'bitshiftleft',
   '>>': 'bitshiftright'
   };
   while (token in operators) {
   var name = token;

   getTokenSkipNewline();
   var params = [node, parseRelational()];
   node = new OperatorNode(name, fn, params);
   }

  return node;
}
*/

/**
 * conditions like and, or, in
 * @return {Node} node
 * @private
 */
/* TODO: conditional and, or, in, etc.
function parseConditions () {
  var node, operators, name, fn, params;

  node = parseRelational();

  // TODO: precedence of And above Or?
  // TODO: implement a method for unit to number conversion
  operators = {
     'and' : 'and',
     '&&' : 'and',
     'or': 'or',
     '||': 'or',
     'xor': 'xor'
  };

  while (token in operators) {
    name = token;
    fn = operators[name];

    getTokenSkipNewline();
    params = [node, parseRelational()];
    node = new OperatorNode(name, fn, params);
  }

  return node;
}
*/

/**
 * relational operators
 * @return {Node} node
 * @private
 */
function parseRelational () {
  var node, operators, name, fn, params;

  node = parseConversion();

  operators = {
    '==': 'equal',
    '!=': 'unequal',
    '<': 'smaller',
    '>': 'larger',
    '<=': 'smallerEq',
    '>=': 'largerEq'
  };
  while (token in operators) {
    name = token;
    fn = operators[name];

    getTokenSkipNewline();
    params = [node, parseConversion()];
    node = new OperatorNode(name, fn, params);
  }

  return node;
}

/**
 * conversion operators 'to' and 'in'
 * @return {Node} node
 * @private
 */
function parseConversion () {
  var node, operators, name, fn, params;

  node = parseRange();

  operators = {
    'to' : 'to',
    'in' : 'to'   // alias of 'to'
  };

  while (token in operators) {
    name = token;
    fn = operators[name];

    getTokenSkipNewline();
    params = [node, parseRange()];
    node = new OperatorNode(name, fn, params);
  }

  return node;
}

/**
 * parse range, "start:end", "start:step:end", ":", "start:", ":end", etc
 * @return {Node} node
 * @private
 */
function parseRange () {
  var node, params = [];

  if (token == ':') {
    // implicit start=1 (one-based)
    node = new ConstantNode('1', 'number');
  }
  else {
    // explicit start
    node = parseAddSubtract();
  }

  if (token == ':' && (conditional_level !== nesting_level)) {
    // we ignore the range operator when a conditional operator is being processed on the same level
    params.push(node);

    // parse step and end
    while (token == ':') {
      getTokenSkipNewline();

      if (token == ')' || token == ']' || token == ',' || token == '') {
        // implicit end
        params.push(new SymbolNode('end'));
      }
      else {
        // explicit end
        params.push(parseAddSubtract());
      }
    }

    // swap step and end
    if (params.length == 3) {
      var step = params[2];
      params[2] = params[1];
      params[1] = step;
    }
    node = new RangeNode(params);
  }

  return node;
}

/**
 * add or subtract
 * @return {Node} node
 * @private
 */
function parseAddSubtract ()  {
  var node, operators, name, fn, params;

  node = parseMultiplyDivide();

  operators = {
    '+': 'add',
    '-': 'subtract'
  };
  while (token in operators) {
    name = token;
    fn = operators[name];

    getTokenSkipNewline();
    params = [node, parseMultiplyDivide()];
    node = new OperatorNode(name, fn, params);
  }

  return node;
}

/**
 * multiply, divide, modulus
 * @return {Node} node
 * @private
 */
function parseMultiplyDivide () {
  var node, operators, name, fn, params;

  node = parseUnary();

  operators = {
    '*': 'multiply',
    '.*': 'dotMultiply',
    '/': 'divide',
    './': 'dotDivide',
    '%': 'mod',
    'mod': 'mod'
  };

  if (token in operators) {
    while (token in operators) {
      name = token;
      fn = operators[name];

      getTokenSkipNewline();
      params = [node, parseUnary()];
      node = new OperatorNode(name, fn, params);
    }
  }

  // parse implicit multiplication
  if ((token_type == TOKENTYPE.SYMBOL) ||
      (token == 'in' && (node instanceof ConstantNode)) ||
      (token_type == TOKENTYPE.NUMBER && !(node instanceof ConstantNode)) ||
      (token == '(' || token == '[')) {
    // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'
    // number:      implicit multiplication like '(2+3)2'
    //              Note: we don't allow implicit multiplication between numbers,
    //              like '2 3'. I'm not sure whether that is a good idea.
    // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)', '2[1,2,3]'
    node = new OperatorNode('*', 'multiply', [node, parseMultiplyDivide()]);
  }

  return node;
}

/**
 * Unary plus and minus
 * @return {Node} node
 * @private
 */
function parseUnary () {
  var name, fn, params;

  if (token == '-' || token == '+') {
    name = token;
    fn = name == '+' ? 'unaryPlus' : 'unaryMinus';

    getTokenSkipNewline();
    params = [parseUnary()];

    return new OperatorNode(name, fn, params);
  }

  return parsePow();
}

/**
 * power
 * Note: power operator is right associative
 * @return {Node} node
 * @private
 */
function parsePow () {
  var node, name, fn, params;

  node = parseLeftHandOperators();

  if (token == '^' || token == '.^') {
    name = token;
    fn = (name == '^') ? 'pow' : 'dotPow';

    getTokenSkipNewline();
    params = [node, parseUnary()]; // Go back to unary, we can have '2^-3'
    node = new OperatorNode(name, fn, params);
  }

  return node;
}

/**
 * Left hand operators: factorial x!, transpose x'
 * @return {Node} node
 * @private
 */
function parseLeftHandOperators ()  {
  var node, operators, name, fn, params;

  node = parseCustomNodes();

  operators = {
    '!': 'factorial',
    '\'': 'transpose'
  };

  while (token in operators) {
    name = token;
    fn = operators[name];

    getToken();
    params = [node];

    node = new OperatorNode(name, fn, params);
  }

  return node;
}

/**
 * Parse a custom node handler. A node handler can be used to process
 * nodes in a custom way, for example for handling a plot.
 *
 * A handler must be passed as second argument of the parse function.
 * - must extend math.expression.node.Node
 * - must contain a function _compile(defs: Object) : String
 * - must contain a function find(filter: Object) : Node[]
 * - must contain a function toString() : String
 * - the constructor is called with a single argument containing all parameters
 *
 * For example:
 *
 *     nodes = {
 *       'plot': PlotHandler
 *     };
 *
 * The constructor of the handler is called as:
 *
 *     node = new PlotHandler(params);
 *
 * The handler will be invoked when evaluating an expression like:
 *
 *     node = math.parse('plot(sin(x), x)', nodes);
 *
 * @return {Node} node
 * @private
 */
function parseCustomNodes () {
  var params = [], handler;

  if (token_type == TOKENTYPE.SYMBOL && extra_nodes[token]) {
    handler = extra_nodes[token];

    getToken();

    // parse parameters
    if (token == '(') {
      params = [];

      openParams();
      getToken();

      if (token != ')') {
        params.push(parseConditional());

        // parse a list with parameters
        while (token == ',') {
          getToken();
          params.push(parseConditional());
        }
      }

      if (token != ')') {
        throw createSyntaxError('Parenthesis ) expected');
      }
      closeParams();
      getToken();
    }

    // create a new node handler
    //noinspection JSValidateTypes
    return new handler(params);
  }

  return parseSymbol();
}

/**
 * parse symbols: functions, variables, constants, units
 * @return {Node} node
 * @private
 */
function parseSymbol () {
  var node, name;

  if (token_type == TOKENTYPE.SYMBOL ||
      (token_type == TOKENTYPE.DELIMITER && token in NAMED_DELIMITERS)) {
    name = token;

    getToken();

    // create a symbol
    node = new SymbolNode(name);

    // parse function parameters and matrix index
    node = parseFunctions(node);
    node = parseIndex(node);
    return node;
  }

  return parseString();
}

/**
 * parse a function call like fn(a, b, c)
 * @param {SymbolNode} symbol   SymbolNode on which to apply the parameters.
 *                              If there are no parameters in the expression,
 *                              the node itself is returned
 * @return {Node} node
 * @private
 */
function parseFunctions (symbol) {
  var params;

  if (token == '(') {
    params = [];

    openParams();
    getToken();

    if (token != ')') {
      params.push(parseConditional());

      // parse a list with parameters
      while (token == ',') {
        getToken();
        params.push(parseConditional());
      }
    }

    if (token != ')') {
      throw createSyntaxError('Parenthesis ) expected');
    }
    closeParams();
    getToken();

    return new FunctionNode(symbol, params);
  }

  return symbol;
}

/**
 * parse index parameters, enclosed in square brackets [...], for example A[2,3]
 * @param {Node} node    Node on which to apply the parameters. If there
 *                       are no parameters in the expression, the node
 *                       itself is returned
 * @return {Node} node
 * @private
 */
function parseIndex (node) {
  var params;

  while (token == '[') {
    params = [];

    openParams();
    getToken();

    if (token != ']') {
      params.push(parseConditional());

      // parse a list with parameters
      while (token == ',') {
        getToken();
        params.push(parseConditional());
      }
    }

    if (token != ']') {
      throw createSyntaxError('Parenthesis ] expected');
    }
    closeParams();
    getToken();

    node = new IndexNode(node, params);
  }

  return node;
}

/**
 * parse a string.
 * A string is enclosed by double quotes
 * @return {Node} node
 * @private
 */
function parseString () {
  var node, str, tPrev;

  if (token == '"') {
    // string "..."
    str = '';
    tPrev = '';
    while (c != '' && (c != '\"' || tPrev == '\\')) { // also handle escape character
      str += c;
      tPrev = c;
      next();
    }

    getToken();
    if (token != '"') {
      throw createSyntaxError('End of string " expected');
    }
    getToken();

    // create constant
    node = new ConstantNode(str, 'string');

    // parse index parameters
    node = parseIndex(node);

    return node;
  }

  return parseMatrix();
}

/**
 * parse the matrix
 * @return {Node} node
 * @private
 */
function parseMatrix () {
  var array, params, rows, cols;

  if (token == '[') {
    // matrix [...]
    openParams();
    getToken();

    if (token != ']') {
      // this is a non-empty matrix
      var row = parseRow();

      if (token == ';') {
        // 2 dimensional array
        rows = 1;
        params = [row];

        // the rows of the matrix are separated by dot-comma's
        while (token == ';') {
          getToken();

          params[rows] = parseRow();
          rows++;
        }

        if (token != ']') {
          throw createSyntaxError('End of matrix ] expected');
        }
        closeParams();
        getToken();

        // check if the number of columns matches in all rows
        cols = params[0].nodes.length;
        for (var r = 1; r < rows; r++) {
          if (params[r].nodes.length != cols) {
            throw createError('Column dimensions mismatch ' +
                '(' + params[r].nodes.length + ' != ' + cols + ')');
          }
        }

        array = new ArrayNode(params);
      }
      else {
        // 1 dimensional vector
        if (token != ']') {
          throw createSyntaxError('End of matrix ] expected');
        }
        closeParams();
        getToken();

        array = row;
      }
    }
    else {
      // this is an empty matrix "[ ]"
      closeParams();
      getToken();
      array = new ArrayNode([]);
    }

    return array;
  }

  return parseNumber();
}

/**
 * Parse a single comma-separated row from a matrix, like 'a, b, c'
 * @return {ArrayNode} node
 */
function parseRow () {
  var params = [parseAssignment()];
  var len = 1;

  while (token == ',') {
    getToken();

    // parse expression
    params[len] = parseAssignment();
    len++;
  }

  return new ArrayNode(params);
}

/**
 * parse a number
 * @return {Node} node
 * @private
 */
function parseNumber () {
  var number;

  if (token_type == TOKENTYPE.NUMBER) {
    // this is a number
    number = token;
    getToken();

    return new ConstantNode(number, 'number');
  }

  return parseParentheses();
}

/**
 * parentheses
 * @return {Node} node
 * @private
 */
function parseParentheses () {
  var node;

  // check if it is a parenthesized expression
  if (token == '(') {
    // parentheses (...)
    openParams();
    getToken();

    node = parseAssignment(); // start again

    if (token != ')') {
      throw createSyntaxError('Parenthesis ) expected');
    }
    closeParams();
    getToken();

    return node;
  }

  return parseEnd();
}

/**
 * Evaluated when the expression is not yet ended but expected to end
 * @return {Node} res
 * @private
 */
function parseEnd () {
  if (token == '') {
    // syntax error or unexpected end of expression
    throw createSyntaxError('Unexpected end of expression');
  } else {
    throw createSyntaxError('Value expected');
  }
}

/**
 * Shortcut for getting the current row value (one based)
 * Returns the line of the currently handled expression
 * @private
 */
/* TODO: implement keeping track on the row number
function row () {
  return null;
}
*/

/**
 * Shortcut for getting the current col value (one based)
 * Returns the column (position) where the last token starts
 * @private
 */
function col () {
  return index - token.length + 1;
}

/**
 * Create an error
 * @param {String} message
 * @return {SyntaxError} instantiated error
 * @private
 */
function createSyntaxError (message) {
  var c = col();
  var error = new SyntaxError(message + ' (char ' + c + ')');
  error['char'] = c;

  return error;
}

/**
 * Create an error
 * @param {String} message
 * @return {Error} instantiated error
 * @private
 */
function createError (message) {
  var c = col();
  var error = new Error(message + ' (char ' + c + ')');
  error['char'] = c;

  return error;
}

module.exports = parse;

})()
},{"../util/index":178,"../error/ArgumentsError":174,"../type/Complex":43,"../type/Matrix":49,"../type/Unit":50,"../type/collection":52,"./node/ArrayNode":179,"./node/AssignmentNode":180,"./node/BlockNode":181,"./node/ConditionalNode":182,"./node/ConstantNode":183,"./node/FunctionAssignmentNode":184,"./node/IndexNode":185,"./node/OperatorNode":186,"./node/FunctionNode":187,"./node/RangeNode":188,"./node/SymbolNode":189,"./node/UpdateNode":190}],55:[function(require,module,exports){
'use strict';

var _parse = require('./parse');

/**
 * @constructor Parser
 * Parser contains methods to evaluate or parse expressions, and has a number
 * of convenience methods to get, set, and remove variables from memory. Parser
 * keeps a scope containing variables in memory, which is used for all
 * evaluations.
 *
 * Methods:
 *    var result = parser.eval(expr);    // evaluate an expression
 *    var value = parser.get(name);      // retrieve a variable from the parser
 *    parser.set(name, value);           // set a variable in the parser
 *    parser.remove(name);               // clear a variable from the
 *                                       // parsers scope
 *    parser.clear();                    // clear the parsers scope
 *
 * Example usage:
 *    var parser = new Parser(math);
 *    // Note: there is a convenience method which can be used instead:
 *    // var parser = new math.parser();
 *
 *    // evaluate expressions
 *    parser.eval('sqrt(3^2 + 4^2)');         // 5
 *    parser.eval('sqrt(-4)');                // 2i
 *    parser.eval('2 inch in cm');            // 5.08 cm
 *    parser.eval('cos(45 deg)');             // 0.7071067811865476
 *
 *    // define variables and functions
 *    parser.eval('x = 7 / 2');               // 3.5
 *    parser.eval('x + 3');                   // 6.5
 *    parser.eval('function f(x, y) = x^y');  // f(x, y)
 *    parser.eval('f(2, 3)');                 // 8
 *
 *    // get and set variables and functions
 *    var x = parser.get('x');                // 7
 *    var f = parser.get('f');                // function
 *    var g = f(3, 2);                        // 9
 *    parser.set('h', 500);
 *    var i = parser.eval('h / 2');           // 250
 *    parser.set('hello', function (name) {
 *        return 'hello, ' + name + '!';
 *    });
 *    parser.eval('hello("user")');           // "hello, user!"
 *
 *    // clear defined functions and variables
 *    parser.clear();
 *
 *
 * @param {Object} math     Link to the math.js namespace
 */
function Parser(math) {
  if (!(this instanceof Parser)) {
    throw new SyntaxError(
        'Constructor must be called with the new operator');
  }

  if (!(math instanceof Object)) {
    throw new TypeError('Object expected as parameter math');
  }

  this.math = math;
  this.scope = {};
}

/**
 * Parse an expression and return the parsed function node.
 * The node tree can be compiled via `code = node.compile(math)`,
 * and the compiled code can be executed as `code.eval([scope])`
 * @param {String} expr
 * @return {Node} node
 * @throws {Error}
 */
Parser.prototype.parse = function (expr) {
  throw new Error('Parser.parse is deprecated. Use math.parse instead.');
};

/**
 * Parse and compile an expression, return the compiled javascript code.
 * The node can be evaluated via code.eval([scope])
 * @param {String} expr
 * @return {{eval: function}} code
 * @throws {Error}
 */
Parser.prototype.compile = function (expr) {
  throw new Error('Parser.compile is deprecated. Use math.compile instead.');
};

/**
 * Parse and evaluate the given expression
 * @param {String} expr   A string containing an expression, for example "2+3"
 * @return {*} result     The result, or undefined when the expression was empty
 * @throws {Error}
 */
Parser.prototype.eval = function (expr) {
  // TODO: validate arguments
  return _parse(expr)
      .compile(this.math)
      .eval(this.scope);
};

/**
 * Get a variable (a function or variable) by name from the parsers scope.
 * Returns undefined when not found
 * @param {String} name
 * @return {* | undefined} value
 */
Parser.prototype.get = function (name) {
  // TODO: validate arguments
  return this.scope[name];
};

/**
 * Set a symbol (a function or variable) by name from the parsers scope.
 * @param {String} name
 * @param {* | undefined} value
 */
Parser.prototype.set = function (name, value) {
  // TODO: validate arguments
  return this.scope[name] = value;
};

/**
 * Remove a variable from the parsers scope
 * @param {String} name
 */
Parser.prototype.remove = function (name) {
  // TODO: validate arguments
  delete this.scope[name];
};

/**
 * Clear the scope with variables and functions
 */
Parser.prototype.clear = function () {
  for (var name in this.scope) {
    if (this.scope.hasOwnProperty(name)) {
      delete this.scope[name];
    }
  }
};

module.exports = Parser;

},{"./parse":54}],172:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var string = require('../util/string');

  /**
   * @constructor Selector
   * Wrap any value in a Selector, allowing to perform chained operations on
   * the value.
   *
   * All methods available in the math.js library can be called upon the selector,
   * and then will be evaluated with the value itself as first argument.
   * The selector can be closed by executing selector.done(), which will return
   * the final value.
   *
   * The Selector has a number of special functions:
   * - done()             Finalize the chained operation and return the
   *                      selectors value.
   * - valueOf()          The same as done()
   * - toString()         Returns a string representation of the selectors value.
   *
   * @param {*} [value]
   */
  function Selector (value) {
    if (!(this instanceof Selector)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (value instanceof Selector) {
      this.value = value.value;
    }
    else {
      this.value = value;
    }
  }

  /**
   * Close the selector. Returns the final value.
   * Does the same as method valueOf()
   * @returns {*} value
   */
  Selector.prototype.done = function () {
    return this.value;
  };

  /**
   * Close the selector. Returns the final value.
   * Does the same as method done()
   * @returns {*} value
   */
  Selector.prototype.valueOf = function () {
    return this.value;
  };

  /**
   * Get a string representation of the value in the selector
   * @returns {String}
   */
  Selector.prototype.toString = function () {
    return string.format(this.value);
  };

  /**
   * Create a proxy method for the selector
   * @param {String} name
   * @param {*} value       The value or function to be proxied
   */
  function createProxy(name, value) {
    var slice = Array.prototype.slice;
    if (typeof value === 'function') {
      // a function
      Selector.prototype[name] = function () {
        var args = [this.value].concat(slice.call(arguments, 0));
        return new Selector(value.apply(this, args));
      }
    }
    else {
      // a constant
      Selector.prototype[name] = new Selector(value);
    }
  }

  Selector.createProxy = createProxy;

  /**
   * initialise the Chain prototype with all functions and constants in math
   */
  for (var prop in math) {
    if (math.hasOwnProperty(prop)) {
      createProxy(prop, math[prop]);
    }
  }

  return Selector;
};

},{"../util/string":191}],53:[function(require,module,exports){
'use strict';

exports.ArrayNode = require('./ArrayNode');
exports.AssignmentNode = require('./AssignmentNode');
exports.BlockNode = require('./BlockNode');
exports.ConditionalNode = require('./ConditionalNode');
exports.ConstantNode = require('./ConstantNode');
exports.IndexNode = require('./IndexNode');
exports.FunctionAssignmentNode = require('./FunctionAssignmentNode');
exports.FunctionNode = require('./FunctionNode');
exports.Node = require('./Node');
exports.OperatorNode = require('./OperatorNode');
exports.RangeNode = require('./RangeNode');
exports.SymbolNode = require('./SymbolNode');
exports.UpdateNode = require('./UpdateNode');

},{"./ArrayNode":179,"./AssignmentNode":180,"./BlockNode":181,"./ConditionalNode":182,"./ConstantNode":183,"./IndexNode":185,"./FunctionAssignmentNode":184,"./FunctionNode":187,"./Node":192,"./OperatorNode":186,"./RangeNode":188,"./SymbolNode":189,"./UpdateNode":190}],56:[function(require,module,exports){
// constants
exports.e = require('./constants/e');
exports.E = require('./constants/e');
exports['false'] = require('./constants/false');
exports.i = require('./constants/i');
exports['Infinity'] = require('./constants/Infinity');
exports.LN2 = require('./constants/LN2');
exports.LN10 = require('./constants/LN10');
exports.LOG2E = require('./constants/LOG2E');
exports.LOG10E = require('./constants/LOG10E');
exports.NaN = require('./constants/NaN');
exports['null'] = require('./constants/null');
exports.pi = require('./constants/pi');
exports.PI = require('./constants/pi');
exports.phi = require('./constants/phi');
exports.SQRT1_2 = require('./constants/SQRT1_2');
exports.SQRT2 = require('./constants/SQRT2');
exports.tau = require('./constants/tau');
exports['true'] = require('./constants/true');
exports.version = require('./constants/version');

// functions - arithmetic
exports.abs = require('./function/arithmetic/abs');
exports.add = require('./function/arithmetic/add');
exports.ceil = require('./function/arithmetic/ceil');
exports.cube = require('./function/arithmetic/cube');
exports.divide = require('./function/arithmetic/divide');
exports.dotDivide = require('./function/arithmetic/dotDivide');
exports.dotMultiply = require('./function/arithmetic/dotMultiply');
exports.dotPow = require('./function/arithmetic/dotPow');
exports.exp = require('./function/arithmetic/exp');
exports.fix = require('./function/arithmetic/fix');
exports.floor = require('./function/arithmetic/floor');
exports.gcd = require('./function/arithmetic/gcd');
exports.lcm = require('./function/arithmetic/lcm');
exports.log = require('./function/arithmetic/log');
exports.log10 = require('./function/arithmetic/log10');
exports.mod = require('./function/arithmetic/mod');
exports.multiply = require('./function/arithmetic/multiply');
exports.norm = require('./function/arithmetic/norm');
exports.pow = require('./function/arithmetic/pow');
exports.round = require('./function/arithmetic/round');
exports.sign = require('./function/arithmetic/sign');
exports.sqrt = require('./function/arithmetic/sqrt');
exports.square = require('./function/arithmetic/square');
exports.subtract = require('./function/arithmetic/subtract');
exports.unaryMinus = require('./function/arithmetic/unaryMinus');
exports.unaryPlus = require('./function/arithmetic/unaryPlus');
exports.xgcd = require('./function/arithmetic/xgcd');

// functions - relational
exports.compare = require('./function/relational/compare');
exports.deepEqual = require('./function/relational/deepEqual');
exports['equal'] = require('./function/relational/equal');
exports.larger = require('./function/relational/larger');
exports.largerEq = require('./function/relational/largerEq');
exports.smaller = require('./function/relational/smaller');
exports.smallerEq = require('./function/relational/smallerEq');
exports.unequal = require('./function/relational/unequal');

// functions - complex
exports.arg = require('./function/complex/arg');
exports.conj = require('./function/complex/conj');
exports.re = require('./function/complex/re');
exports.im = require('./function/complex/im');

// functions - construction
exports.bignumber = require('./function/construction/bignumber');
exports['boolean'] = require('./function/construction/boolean');
exports.complex = require('./function/construction/complex');
exports.index = require('./function/construction/index');
exports.matrix = require('./function/construction/matrix');
exports.number = require('./function/construction/number');
exports.string = require('./function/construction/string');
exports.unit = require('./function/construction/unit');

// functions - epxression
exports['eval'] =  require('./function/expression/eval');
exports.help =  require('./function/expression/help');

// functions - matrix
exports['concat'] = require('./function/matrix/concat');
exports.det = require('./function/matrix/det');
exports.diag = require('./function/matrix/diag');
exports.eye = require('./function/matrix/eye');
exports.flatten = require('./function/matrix/flatten');
exports.inv = require('./function/matrix/inv');
exports.ones = require('./function/matrix/ones');
exports.range = require('./function/matrix/range');
exports.resize = require('./function/matrix/resize');
exports.size = require('./function/matrix/size');
exports.squeeze = require('./function/matrix/squeeze');
exports.subset = require('./function/matrix/subset');
exports.transpose = require('./function/matrix/transpose');
exports.zeros = require('./function/matrix/zeros');

// functions - probability
exports.combinations = require('./function/probability/combinations');
//exports.distribution = require('./function/probability/distribution');
exports.factorial = require('./function/probability/factorial');
exports.permutations = require('./function/probability/permutations');
exports.pickRandom = require('./function/probability/pickRandom');
exports.random = require('./function/probability/random');
exports.randomInt = require('./function/probability/randomInt');

// functions - statistics
exports.max = require('./function/statistics/max');
exports.mean = require('./function/statistics/mean');
exports.median = require('./function/statistics/median');
exports.min = require('./function/statistics/min');
exports.prod = require('./function/statistics/prod');
exports.std = require('./function/statistics/std');
exports.sum = require('./function/statistics/sum');
exports['var'] = require('./function/statistics/var');

// functions - trigonometry
exports.acos = require('./function/trigonometry/acos');
exports.asin = require('./function/trigonometry/asin');
exports.atan = require('./function/trigonometry/atan');
exports.atan2 = require('./function/trigonometry/atan2');
exports.cos = require('./function/trigonometry/cos');
exports.cosh = require('./function/trigonometry/cosh');
exports.cot = require('./function/trigonometry/cot');
exports.coth = require('./function/trigonometry/coth');
exports.csc = require('./function/trigonometry/csc');
exports.csch = require('./function/trigonometry/csch');
exports.sec = require('./function/trigonometry/sec');
exports.sech = require('./function/trigonometry/sech');
exports.sin = require('./function/trigonometry/sin');
exports.sinh = require('./function/trigonometry/sinh');
exports.tan = require('./function/trigonometry/tan');
exports.tanh = require('./function/trigonometry/tanh');

// functions - units
exports.to = require('./function/units/to');

// functions - utils
exports.clone =  require('./function/utils/clone');
exports.map =  require('./function/utils/map');
exports.filter =  require('./function/utils/filter');
exports.forEach =  require('./function/utils/forEach');
exports.format =  require('./function/utils/format');
// exports.print =  require('./function/utils/print'); // TODO: add documentation for print as soon as the parser supports objects.
exports['import'] =  require('./function/utils/import');
exports.sort =  require('./function/utils/sort');
exports['typeof'] =  require('./function/utils/typeof');

},{"./constants/e":193,"./constants/false":194,"./constants/i":195,"./constants/Infinity":196,"./constants/LN2":197,"./constants/LN10":198,"./constants/LOG2E":199,"./constants/LOG10E":200,"./constants/NaN":201,"./constants/null":202,"./constants/pi":203,"./constants/phi":204,"./constants/SQRT1_2":205,"./constants/SQRT2":206,"./constants/tau":207,"./constants/true":208,"./constants/version":209,"./function/arithmetic/abs":210,"./function/arithmetic/add":211,"./function/arithmetic/ceil":212,"./function/arithmetic/cube":213,"./function/arithmetic/divide":214,"./function/arithmetic/dotDivide":215,"./function/arithmetic/dotMultiply":216,"./function/arithmetic/dotPow":217,"./function/arithmetic/exp":218,"./function/arithmetic/fix":219,"./function/arithmetic/floor":220,"./function/arithmetic/gcd":221,"./function/arithmetic/lcm":222,"./function/arithmetic/log":223,"./function/arithmetic/log10":224,"./function/arithmetic/mod":225,"./function/arithmetic/multiply":226,"./function/arithmetic/norm":227,"./function/arithmetic/pow":228,"./function/arithmetic/round":229,"./function/arithmetic/sign":230,"./function/arithmetic/sqrt":231,"./function/arithmetic/square":232,"./function/arithmetic/subtract":233,"./function/arithmetic/unaryMinus":234,"./function/arithmetic/unaryPlus":235,"./function/arithmetic/xgcd":236,"./function/relational/compare":237,"./function/relational/deepEqual":238,"./function/relational/equal":239,"./function/relational/larger":240,"./function/relational/largerEq":241,"./function/relational/smaller":242,"./function/relational/smallerEq":243,"./function/relational/unequal":244,"./function/complex/arg":245,"./function/complex/conj":246,"./function/complex/re":247,"./function/complex/im":248,"./function/construction/bignumber":249,"./function/construction/boolean":250,"./function/construction/complex":251,"./function/construction/index":252,"./function/construction/matrix":253,"./function/construction/number":254,"./function/construction/string":255,"./function/construction/unit":256,"./function/expression/eval":257,"./function/expression/help":258,"./function/matrix/concat":259,"./function/matrix/det":260,"./function/matrix/diag":261,"./function/matrix/eye":262,"./function/matrix/flatten":263,"./function/matrix/inv":264,"./function/matrix/ones":265,"./function/matrix/range":266,"./function/matrix/resize":267,"./function/matrix/size":268,"./function/matrix/squeeze":269,"./function/matrix/subset":270,"./function/matrix/transpose":271,"./function/matrix/zeros":272,"./function/probability/combinations":273,"./function/probability/factorial":274,"./function/probability/permutations":275,"./function/probability/pickRandom":276,"./function/probability/random":277,"./function/probability/randomInt":278,"./function/statistics/max":279,"./function/statistics/mean":280,"./function/statistics/median":281,"./function/statistics/min":282,"./function/statistics/prod":283,"./function/statistics/std":284,"./function/statistics/sum":285,"./function/statistics/var":286,"./function/trigonometry/acos":287,"./function/trigonometry/asin":288,"./function/trigonometry/atan":289,"./function/trigonometry/atan2":290,"./function/trigonometry/cos":291,"./function/trigonometry/cosh":292,"./function/trigonometry/cot":293,"./function/trigonometry/coth":294,"./function/trigonometry/csc":295,"./function/trigonometry/csch":296,"./function/trigonometry/sec":297,"./function/trigonometry/sech":298,"./function/trigonometry/sin":299,"./function/trigonometry/sinh":300,"./function/trigonometry/tan":301,"./function/trigonometry/tanh":302,"./function/units/to":303,"./function/utils/clone":304,"./function/utils/map":305,"./function/utils/filter":306,"./function/utils/forEach":307,"./function/utils/format":308,"./function/utils/import":309,"./function/utils/sort":310,"./function/utils/typeof":311}],57:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),
      _parse = require('../../expression/parse'),

      collection = require('../../type/collection'),

      isString = util.string.isString,
      isCollection = collection.isCollection;

  /**
   * Parse and compile an expression.
   * Returns a an object with a function `eval([scope])` to evaluate the
   * compiled expression.
   *
   * Syntax:
   *
   *     math.compile(expr)                       // returns one node
   *     math.compile([expr1, expr2, expr3, ...]) // returns an array with nodes
   *
   * Examples:
   *
   *     var code = math.compile('sqrt(3^2 + 4^2)');
   *     code.eval(); // 5
   *
   *     var scope = {a: 3, b: 4}
   *     var code = math.compile('a * b'); // 12
   *     code.eval(scope); // 12
   *     scope.a = 5;
   *     code.eval(scope); // 20
   *
   *     var nodes = math.compile(['a = 3', 'b = 4', 'a * b']);
   *     nodes[2].eval(); // 12
   *
   * See also:
   *
   *    parse, eval
   *
   * @param {String | String[] | Matrix} expr
   *            The expression to be compiled
   * @return {{eval: Function} | Array.<{eval: Function}>} code
   *            An object with the compiled expression
   * @throws {Error}
   */
  math.compile = function compile (expr) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('compile', arguments.length, 1);
    }

    if (isString(expr)) {
      // evaluate a single expression
      return _parse(expr).compile(math);
    }
    else if (isCollection(expr)) {
      // evaluate an array or matrix with expressions
      return collection.deepMap(expr, function (elem) {
        return _parse(elem).compile(math);
      });
    }
    else {
      // oops
      throw new TypeError('String, array, or matrix expected');
    }
  }
};

},{"../../util/index":178,"../../expression/parse":54,"../../type/collection":52}],58:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),
      _parse = require('../../expression/parse'),

      collection = require('../../type/collection'),

      isString = util.string.isString,
      isCollection = collection.isCollection;

  /**
   * Evaluate an expression.
   *
   * Syntax:
   *
   *     math.eval(expr)
   *     math.eval(expr, scope)
   *     math.eval([expr1, expr2, expr3, ...])
   *     math.eval([expr1, expr2, expr3, ...], scope)
   *
   * Example:
   *
   *     math.eval('(2+3)/4');                // 1.25
   *     math.eval('sqrt(3^2 + 4^2)');        // 5
   *     math.eval('sqrt(-4)');               // 2i
   *     math.eval(['a=3', 'b=4', 'a*b']);,   // [3, 4, 12]
   *
   *     var scope = {a:3, b:4};
   *     math.eval('a * b', scope);           // 12
   *
   * See also:
   *
   *    parse, compile
   *
   * @param {String | String[] | Matrix} expr   The expression to be evaluated
   * @param {Object} [scope]                    Scope to read/write variables
   * @return {*} The result of the expression
   * @throws {Error}
   */
  math.eval = function _eval (expr, scope) {
    if (arguments.length != 1 && arguments.length != 2) {
      throw new math.error.ArgumentsError('eval', arguments.length, 1, 2);
    }

    // instantiate a scope
    scope = scope || {};

    if (isString(expr)) {
      // evaluate a single expression
      return _parse(expr)
          .compile(math)
          .eval(scope);
    }
    else if (isCollection(expr)) {
      // evaluate an array or matrix with expressions
      return collection.deepMap(expr, function (elem) {
        return _parse(elem)
            .compile(math).eval(scope);
      });
    }
    else {
      // oops
      throw new TypeError('String, array, or matrix expected');
    }
  };
};

},{"../../util/index":178,"../../expression/parse":54,"../../type/collection":52}],59:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var Help = require('../../type/Help');

  /**
   * Retrieve help on a function or data type.
   * Help files are retrieved from the documentation in math.expression.docs.
   *
   * Syntax:
   *
   *    math.help(search)
   *
   * Examples:
   *
   *    console.log(math.help('sin').toString());
   *    console.log(math.help(math.add).toString());
   *    console.log(math.help(math.add).toJSON());
   *
   * @param {function | string | Object} search   A function or function name
   *                                              for which to get help
   * @return {Help} A help object
   */
  math.help = function help(search) {
    if (arguments.length != 1) {
      throw new SyntaxError('Wrong number of arguments in function help ' +
          '(' + arguments.length + ' provided, 1 expected)');
    }

    var text = null;
    if ((search instanceof String) || (typeof(search) === 'string')) {
      text = search;
    }
    else {
      var prop;
      for (prop in math) {
        // search in functions and constants
        if (math.hasOwnProperty(prop) && (search === math[prop])) {
          text = prop;
          break;
        }
      }

      /* TODO: implement help for data types
      if (!text) {
        // search data type
        for (prop in math.type) {
          if (math.type.hasOwnProperty(prop)) {
            if (search === math.type[prop]) {
              text = prop;
              break;
            }
          }
        }
      }
      */
    }

    var doc = math.expression.docs[text];
    if (!text || !doc) {
      throw new Error('No documentation found on "' + text + '"');
    }
    return new Help(math, doc);
  };
};

},{"../../type/Help":51}],60:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var _parse = require('../../expression/parse');

  /**
   * Parse an expression. Returns a node tree, which can be evaluated by
   * invoking node.eval();
   *
   * Syntax:
   *
   *     parse(expr)
   *     parse(expr, options)
   *     parse([expr1, expr2, expr3, ...])
   *     parse([expr1, expr2, expr3, ...], options)
   *
   * Example:
   *
   *     var node = parse('sqrt(3^2 + 4^2)');
   *     node.compile(math).eval(); // 5
   *
   *     var scope = {a:3, b:4}
   *     var node = parse('a * b'); // 12
   *     var code = node.compile(math);
   *     code.eval(scope); // 12
   *     scope.a = 5;
   *     code.eval(scope); // 20
   *
   *     var nodes = math.parse(['a = 3', 'b = 4', 'a * b']);
   *     nodes[2].compile(math).eval(); // 12
   *
   * @param {String | String[] | Matrix} expr          Expression to be parsed
   * @param {{nodes: Object<String, Node>}} [options]  Available options:
   *                                                   - `nodes` a set of custom nodes
   * @return {Node | Node[]} node
   * @throws {Error}
   */
  math.parse = function parse (expr, options) {
    return _parse.apply(_parse, arguments);
  }

};

},{"../../expression/parse":54}],61:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Calculate the absolute value of a number. For matrices, the function is
   * evaluated element wise.
   *
   * Syntax:
   *
   *    math.abs(x)
   *
   * Examples:
   *
   *    math.abs(3.5);                // returns Number 3.5
   *    math.abs(-4.2);               // returns Number 4.2
   *
   *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
   *
   * See also:
   *
   *    sign
   *
   * @param  {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x
   *            A number or matrix for which to get the absolute value
   * @return {Number | BigNumber | Complex | Array | Matrix}
   *            Absolute value of `x`
   */
  math.abs = function abs(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('abs', arguments.length, 1);
    }

    if (isNumber(x)) {
      return Math.abs(x);
    }

    if (isComplex(x)) {
      return Math.sqrt(x.re * x.re + x.im * x.im);
    }

    if (x instanceof BigNumber) {
      return x.abs();
    }

    if (isCollection(x)) {
      return collection.deepMap(x, abs);
    }

    if (isBoolean(x) || x === null) {
      return Math.abs(x);
    }

    throw new math.error.UnsupportedTypeError('abs', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Matrix":49,"../../type/collection":52}],62:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Matrix = require('../../type/Matrix'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isBoolean = util['boolean'].isBoolean,
      isNumber = util.number.isNumber,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Add two values, `x + y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.add(x, y)
   *
   * Examples:
   *
   *    math.add(2, 3);               // returns Number 5
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(-4, 1);
   *    math.add(a, b);               // returns Complex -2 + 4i
   *
   *    math.add([1, 2, 3], 4);       // returns Array [5, 6, 7]
   *
   *    var c = math.unit('5 cm');
   *    var d = math.unit('2.1 mm');
   *    math.add(c, d);               // returns Unit 52.1 mm
   *
   * See also:
   *
   *    subtract
   *
   * @param  {Number | BigNumber | Boolean | Complex | Unit | String | Array | Matrix | null} x First value to add
   * @param  {Number | BigNumber | Boolean | Complex | Unit | String | Array | Matrix | null} y Second value to add
   * @return {Number | BigNumber | Complex | Unit | String | Array | Matrix} Sum of `x` and `y`
   */
  math.add = function add(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('add', arguments.length, 2);
    }

    if (isNumber(x)) {
      if (isNumber(y)) {
        // number + number
        return x + y;
      }
      else if (isComplex(y)) {
        // number + complex
        return new Complex(
            x + y.re,
            y.im
        )
      }
    }

    if (isComplex(x)) {
      if (isComplex(y)) {
        // complex + complex
        return new Complex(
            x.re + y.re,
            x.im + y.im
        );
      }
      else if (isNumber(y)) {
        // complex + number
        return new Complex(
            x.re + y,
            x.im
        )
      }
    }

    if (isUnit(x)) {
      if (isUnit(y)) {
        if (x.value == null) {
          throw new Error('Parameter x contains a unit with undefined value');
        }

        if (y.value == null) {
          throw new Error('Parameter y contains a unit with undefined value');
        }

        if (!x.equalBase(y)) {
          throw new Error('Units do not match');
        }

        var res = x.clone();
        res.value += y.value;
        res.fixPrefix = false;
        return res;
      }
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y) || y === null) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return x.plus(y);
      }

      // downgrade to Number
      return add(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x) || x === null) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return x.plus(y)
      }

      // downgrade to Number
      return add(x, y.toNumber());
    }

    if (isCollection(x) || isCollection(y)) {
      return collection.deepMap2(x, y, add);
    }

    if (isString(x) || isString(y)) {
      return x + y;
    }

    if (isBoolean(x) || x === null) {
      return add(+x, y);
    }
    if (isBoolean(y) || y === null) {
      return add(x, +y);
    }

    throw new math.error.UnsupportedTypeError('add', math['typeof'](x), math['typeof'](y));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Matrix":49,"../../type/Unit":50,"../../type/collection":52}],63:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isCollection =collection.isCollection,
      isComplex = Complex.isComplex;

  /**
   * Round a value towards plus infinity
   * If `x` is complex, both real and imaginary part are rounded towards plus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.ceil(x)
   *
   * Examples:
   *
   *    math.ceil(3.2);               // returns Number 4
   *    math.ceil(3.8);               // returns Number 4
   *    math.ceil(-4.2);              // returns Number -4
   *    math.ceil(-4.7);              // returns Number -4
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.ceil(c);                 // returns Complex 4 - 2i
   *
   *    math.ceil([3.2, 3.8, -4.7]);  // returns Array [4, 4, -4]
   *
   * See also:
   *
   *    floor, fix, round
   *
   * @param  {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x  Number to be rounded
   * @return {Number | BigNumber | Complex | Array | Matrix} Rounded value
   */
  math.ceil = function ceil(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('ceil', arguments.length, 1);
    }

    if (isNumber(x)) {
      return Math.ceil(x);
    }

    if (isComplex(x)) {
      return new Complex (
          Math.ceil(x.re),
          Math.ceil(x.im)
      );
    }

    if (x instanceof BigNumber) {
      return x.ceil();
    }

    if (isCollection(x)) {
      return collection.deepMap(x, ceil);
    }

    if (isBoolean(x) || x === null) {
      return Math.ceil(x);
    }

    throw new math.error.UnsupportedTypeError('ceil', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],64:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Compute the cube of a value, `x * x * x`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cube(x)
   *
   * Examples:
   *
   *    math.cube(2);            // returns Number 8
   *    math.pow(2, 3);          // returns Number 8
   *    math.cube(4);            // returns Number 64
   *    4 * 4 * 4;               // returns Number 64
   *
   *    math.cube([1, 2, 3, 4]); // returns Array [1, 8, 27, 64]
   *
   * See also:
   *
   *    multiply, square, pow
   *
   * @param  {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x  Number for which to calculate the cube
   * @return {Number | BigNumber | Complex | Array | Matrix} Cube of x
   */
  math.cube = function cube(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('cube', arguments.length, 1);
    }

    if (isNumber(x)) {
      return x * x * x;
    }

    if (isComplex(x)) {
      return math.multiply(math.multiply(x, x), x);
    }

    if (x instanceof BigNumber) {
      return x.times(x).times(x);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, cube);
    }

    if (isBoolean(x) || x === null) {
      return cube(+x);
    }

    throw new math.error.UnsupportedTypeError('cube', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],65:[function(require,module,exports){
'use strict';

module.exports = function(math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Matrix = require('../../type/Matrix'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Divide two values, `x / y`.
   * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
   *
   * Syntax:
   *
   *    math.divide(x, y)
   *
   * Examples:
   *
   *    math.divide(2, 3);            // returns Number 0.6666666666666666
   *
   *    var a = math.complex(5, 14);
   *    var b = math.complex(4, 1);
   *    math.divide(a, b);            // returns Complex 2 + 3i
   *
   *    var c = [[7, -6], [13, -4]];
   *    var d = [[1, 2], [4, 3]];
   *    math.divide(c, d);            // returns Array [[-9, 4], [-11, 6]]
   *
   *    var e = math.unit('18 km');
   *    math.divide(e, 4.5);          // returns Unit 4 km
   *
   * See also:
   *
   *    multiply
   *
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} x   Numerator
   * @param  {Number | BigNumber | Boolean | Complex | Array | Matrix | null} y          Denominator
   * @return {Number | BigNumber | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
   */
  math.divide = function divide(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('divide', arguments.length, 2);
    }

    if (isNumber(x)) {
      if (isNumber(y)) {
        // number / number
        return x / y;
      }
      else if (isComplex(y)) {
        // number / complex
        return _divideComplex(new Complex(x, 0), y);
      }
    }

    if (isComplex(x)) {
      if (isComplex(y)) {
        // complex / complex
        return _divideComplex(x, y);
      }
      else if (isNumber(y)) {
        // complex / number
        return _divideComplex(x, new Complex(y, 0));
      }
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y) || y === null) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return x.div(y);
      }

      // downgrade to Number
      return divide(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x) || x === null) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return x.div(y)
      }

      // downgrade to Number
      return divide(x, y.toNumber());
    }

    if (isUnit(x)) {
      if (isNumber(y)) {
        var res = x.clone();
        res.value /= y;
        return res;
      }
    }

    if (isCollection(x)) {
      if (isCollection(y)) {
        // TODO: implement matrix right division using pseudo inverse
        // http://www.mathworks.nl/help/matlab/ref/mrdivide.html
        // http://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
        // http://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
        return math.multiply(x, math.inv(y));
      }
      else {
        // matrix / scalar
        return collection.deepMap2(x, y, divide);
      }
    }

    if (isCollection(y)) {
      // TODO: implement matrix right division using pseudo inverse
      return math.multiply(x, math.inv(y));
    }

    if (isBoolean(x) || x === null) {
      return divide(+x, y);
    }
    if (isBoolean(y) || y === null) {
      return divide(x, +y);
    }

    throw new math.error.UnsupportedTypeError('divide', math['typeof'](x), math['typeof'](y));
  };

  /**
   * Divide two complex numbers. x / y or divide(x, y)
   * @param {Complex} x
   * @param {Complex} y
   * @return {Complex} res
   * @private
   */
  function _divideComplex (x, y) {
    var den = y.re * y.re + y.im * y.im;
    if (den != 0) {
      return new Complex(
          (x.re * y.re + x.im * y.im) / den,
          (x.im * y.re - x.re * y.im) / den
      );
    }
    else {
      // both y.re and y.im are zero
      return new Complex(
          (x.re != 0) ? (x.re / 0) : 0,
          (x.im != 0) ? (x.im / 0) : 0
      );
    }
  }
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Matrix":49,"../../type/Unit":50,"../../type/collection":52}],66:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var collection = require('../../type/collection');

  /**
   * Divide two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotDivide(x, y)
   *
   * Examples:
   *
   *    math.dotDivide(2, 4);   // returns 0.5
   *
   *    a = [[9, 5], [6, 1]];
   *    b = [[3, 2], [5, 2]];
   *
   *    math.dotDivide(a, b);   // returns [[3, 2.5], [1.2, 0.5]]
   *    math.divide(a, b);      // returns [[1.75, 0.75], [-1.75, 2.25]]
   *
   * See also:
   *
   *    divide, multiply, dotMultiply
   *
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} x Numerator
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} y Denominator
   * @return {Number | BigNumber | Complex | Unit | Array | Matrix}                    Quotient, `x ./ y`
   */
  math.dotDivide = function dotDivide(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('dotDivide', arguments.length, 2);
    }

    return collection.deepMap2(x, y, math.divide);
  };

  // TODO: deprecated since version 0.23.0, clean up some day
  math.edivide = function () {
    throw new Error('Function edivide is renamed to dotDivide');
  }
};

},{"../../type/collection":52}],67:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),
      collection = require('../../type/collection');

  /**
   * Multiply two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotMultiply(x, y)
   *
   * Examples:
   *
   *    math.dotMultiply(2, 4); // returns 8
   *
   *    a = [[9, 5], [6, 1]];
   *    b = [[3, 2], [5, 2]];
   *
   *    math.dotMultiply(a, b); // returns [[27, 10], [30, 2]]
   *    math.multiply(a, b);    // returns [[52, 28], [23, 14]]
   *
   * See also:
   *
   *    multiply, divide, dotDivide
   *
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} x Left hand value
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} y Right hand value
   * @return {Number | BigNumber | Complex | Unit | Array | Matrix}                    Multiplication of `x` and `y`
   */
  math.dotMultiply = function dotMultiply(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('dotMultiply', arguments.length, 2);
    }

    return collection.deepMap2(x, y, math.multiply);
  };

  // TODO: deprecated since version 0.23.0, clean up some day
  math.emultiply = function () {
    throw new Error('Function emultiply is renamed to dotMultiply');
  }
};

},{"../../util/index":178,"../../type/collection":52}],68:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),
      collection = require('../../type/collection');

  /**
   * Calculates the power of x to y element wise.
   *
   * Syntax:
   *
   *    math.dotPow(x, y)
   *
   * Examples:
   *
   *    math.dotPow(2, 3);            // returns Number 8
   *
   *    var a = [[1, 2], [4, 3]];
   *    math.dotPow(a, 2);            // returns Array [[1, 4], [16, 9]]
   *    math.pow(a, 2);               // returns Array [[9, 8], [16, 17]]
   *
   * See also:
   *
   *    pow, sqrt, multiply
   *
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} x  The base
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} y  The exponent
   * @return {Number | BigNumber | Complex | Unit | Array | Matrix}                     The value of `x` to the power `y`
   */
  math.dotPow = function dotPow(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('dotPow', arguments.length, 2);
    }

    return collection.deepMap2(x, y, math.pow);
  };

  // TODO: deprecated since version 0.23.0, clean up some day
  math.epow = function () {
    throw new Error('Function epow is renamed to dotPow');
  }
};

},{"../../util/index":178,"../../type/collection":52}],69:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Calculate the exponent of a value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.exp(x)
   *
   * Examples:
   *
   *    math.exp(2);                  // returns Number 7.3890560989306495
   *    math.pow(math.e, 2);          // returns Number 7.3890560989306495
   *    math.log(math.exp(2));        // returns Number 2
   *
   *    math.exp([1, 2, 3]);
   *    // returns Array [
   *    //   2.718281828459045,
   *    //   7.3890560989306495,
   *    //   20.085536923187668
   *    // ]
   *
   * See also:
   *
   *    log, pow
   *
   * @param {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x  A number or matrix to exponentiate
   * @return {Number | BigNumber | Complex | Array | Matrix} Exponent of `x`
   */
  math.exp = function exp (x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('exp', arguments.length, 1);
    }

    if (isNumber(x)) {
      return Math.exp(x);
    }

    if (isComplex(x)) {
      var r = Math.exp(x.re);
      return new Complex(
          r * Math.cos(x.im),
          r * Math.sin(x.im)
      );
    }

    if (x instanceof BigNumber) {
      return x.exp();
    }

    if (isCollection(x)) {
      return collection.deepMap(x, exp);
    }

    if (isBoolean(x) || x === null) {
      return Math.exp(x);
    }

    throw new math.error.UnsupportedTypeError('exp', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Matrix":49,"../../type/collection":52}],70:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Round a value towards zero.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.fix(x)
   *
   * Examples:
   *
   *    math.fix(3.2);                // returns Number 3
   *    math.fix(3.8);                // returns Number 3
   *    math.fix(-4.2);               // returns Number -4
   *    math.fix(-4.7);               // returns Number -4
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.fix(c);                  // returns Complex 3 - 2i
   *
   *    math.fix([3.2, 3.8, -4.7]);   // returns Array [3, 3, -4]
   *
   * See also:
   *
   *    ceil, floor, round
   *
   * @param {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x Number to be rounded
   * @return {Number | BigNumber | Complex | Array | Matrix}            Rounded value
   */
  math.fix = function fix(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('fix', arguments.length, 1);
    }

    if (isNumber(x)) {
      return (x > 0) ? Math.floor(x) : Math.ceil(x);
    }

    if (isComplex(x)) {
      return new Complex(
          (x.re > 0) ? Math.floor(x.re) : Math.ceil(x.re),
          (x.im > 0) ? Math.floor(x.im) : Math.ceil(x.im)
      );
    }

    if (x instanceof BigNumber) {
      return x.isNegative() ? x.ceil() : x.floor();
    }

    if (isCollection(x)) {
      return collection.deepMap(x, fix);
    }

    if (isBoolean(x) || x === null) {
      return fix(+x);
    }

    throw new math.error.UnsupportedTypeError('fix', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],71:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Round a value towards minus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.floor(x)
   *
   * Examples:
   *
   *    math.floor(3.2);              // returns Number 3
   *    math.floor(3.8);              // returns Number 3
   *    math.floor(-4.2);             // returns Number -5
   *    math.floor(-4.7);             // returns Number -5
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.floor(c);                // returns Complex 3 - 3i
   *
   *    math.floor([3.2, 3.8, -4.7]); // returns Array [3, 3, -5]
   *
   * See also:
   *
   *    ceil, fix, round
   *
   * @param  {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x  Number to be rounded
   * @return {Number | BigNumber | Complex | Array | Matrix} Rounded value
   */
  math.floor = function floor(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('floor', arguments.length, 1);
    }

    if (isNumber(x)) {
      return Math.floor(x);
    }

    if (isComplex(x)) {
      return new Complex (
          Math.floor(x.re),
          Math.floor(x.im)
      );
    }

    if (x instanceof BigNumber) {
      return x.floor();
    }

    if (isCollection(x)) {
      return collection.deepMap(x, floor);
    }

    if (isBoolean(x) || x === null) {
      return floor(+x);
    }

    throw new math.error.UnsupportedTypeError('floor', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],72:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isInteger = util.number.isInteger,
      isCollection = collection.isCollection;

  /**
   * Calculate the greatest common divisor for two or more values or arrays.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.gcd(a, b)
   *    math.gcd(a, b, c, ...)
   *
   * Examples:
   *
   *    math.gcd(8, 12);              // returns 4
   *    math.gcd(-4, 6);              // returns 2
   *    math.gcd(25, 15, -10);        // returns 5
   *
   *    math.gcd([8, -4], [12, 6]);   // returns [4, 2]
   *
   * See also:
   *
   *    lcm, xgcd
   *
   * @param {... Number | BigNumber | Boolean | Array | Matrix | null} args  Two or more integer numbers
   * @return {Number | BigNumber | Array | Matrix}                           The greatest common divisor
   */
  math.gcd = function gcd(args) {
    var a = arguments[0],
        b = arguments[1],
        r; // remainder

    if (arguments.length == 2) {
      // two arguments
      if (isNumber(a) && isNumber(b)) {
        if (!isInteger(a) || !isInteger(b)) {
          throw new Error('Parameters in function gcd must be integer numbers');
        }

        // http://en.wikipedia.org/wiki/Euclidean_algorithm
        while (b != 0) {
          r = a % b;
          a = b;
          b = r;
        }
        return (a < 0) ? -a : a;
      }

      // evaluate gcd element wise
      if (isCollection(a) || isCollection(b)) {
        return collection.deepMap2(a, b, gcd);
      }

      if (a instanceof BigNumber) {
        // try to convert to big number
        if (isNumber(b)) {
          b = BigNumber.convert(b);
        }
        else if (isBoolean(b) || b === null) {
          b = new BigNumber(b ? 1 : 0);
        }

        if (b instanceof BigNumber) {
          return _bigGcd(a, b);
        }

        // downgrade to Number
        return gcd(a.toNumber(), b);
      }
      if (b instanceof BigNumber) {
        // try to convert to big number
        if (isNumber(a)) {
          a = BigNumber.convert(a);
        }
        else if (isBoolean(a) || a === null) {
          a = new BigNumber(a ? 1 : 0);
        }

        if (a instanceof BigNumber) {
          return _bigGcd(a, b);
        }

        // downgrade to Number
        return gcd(a.toNumber(), b);
      }

      if (isBoolean(a) || a === null) {
        return gcd(+a, b);
      }
      if (isBoolean(b) || b === null) {
        return gcd(a, +b);
      }

      throw new math.error.UnsupportedTypeError('gcd', math['typeof'](a), math['typeof'](b));
    }

    if (arguments.length > 2) {
      // multiple arguments. Evaluate them iteratively
      for (var i = 1; i < arguments.length; i++) {
        a = gcd(a, arguments[i]);
      }
      return a;
    }

    // zero or one argument
    throw new SyntaxError('Function gcd expects two or more arguments');
  };

  /**
   * Calculate gcd for BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} greatest common denominator of a and b
   * @private
   */
  function _bigGcd(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function gcd must be integer numbers');
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    var zero = new BigNumber(0);
    while (!b.isZero()) {
      var r = a.mod(b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
};

},{"../../util/index":178,"../../type/collection":52}],73:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isInteger = util.number.isInteger,
      isCollection = collection.isCollection;

  /**
   * Calculate the least common multiple for two or more values or arrays.
   *
   * lcm is defined as:
   *
   *     lcm(a, b) = abs(a * b) / gcd(a, b)
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.lcm(a, b)
   *    math.lcm(a, b, c, ...)
   *
   * Examples:
   *
   *    math.lcm(4, 6);               // returns 12
   *    math.lcm(6, 21);              // returns 42
   *    math.lcm(6, 21, 5);           // returns 210
   *
   *    math.lcm([4, 6], [6, 21]);    // returns [12, 42]
   *
   * See also:
   *
   *    gcd, xgcd
   *
   * @param {... Number | BigNumber | Boolean | Array | Matrix | null} args  Two or more integer numbers
   * @return {Number | BigNumber | Array | Matrix}                           The least common multiple
   */
  math.lcm = function lcm(args) {
    var a = arguments[0],
        b = arguments[1],
        t;

    if (arguments.length == 2) {
      // two arguments
      if (isNumber(a) && isNumber(b)) {
        if (!isInteger(a) || !isInteger(b)) {
          throw new Error('Parameters in function lcm must be integer numbers');
        }

        if (a == 0 || b == 0) {
          return 0;
        }

        // http://en.wikipedia.org/wiki/Euclidean_algorithm
        // evaluate lcm here inline to reduce overhead
        var prod = a * b;
        while (b != 0) {
          t = b;
          b = a % t;
          a = t;
        }
        return Math.abs(prod / a);
      }

      // evaluate lcm element wise
      if (isCollection(a) || isCollection(b)) {
        return collection.deepMap2(a, b, lcm);
      }

      if (a instanceof BigNumber) {
        // try to convert to big number
        if (isNumber(b)) {
          b = BigNumber.convert(b);
        }
        else if (isBoolean(b) || b === null) {
          b = new BigNumber(b ? 1 : 0);
        }

        if (b instanceof BigNumber) {
          return _bigLcm(a, b);
        }

        // downgrade to Number
        return lcm(a.toNumber(), b);
      }
      if (b instanceof BigNumber) {
        // try to convert to big number
        if (isNumber(a)) {
          a = BigNumber.convert(a);
        }
        else if (isBoolean(a) || a === null) {
          a = new BigNumber(a ? 1 : 0);
        }

        if (a instanceof BigNumber) {
          return _bigLcm(a, b);
        }

        // downgrade to Number
        return lcm(a.toNumber(), b);
      }

      if (isBoolean(a) || a === null) {
        return lcm(+a, b);
      }
      if (isBoolean(b) || b === null) {
        return lcm(a, +b);
      }

      throw new math.error.UnsupportedTypeError('lcm', math['typeof'](a), math['typeof'](b));
    }

    if (arguments.length > 2) {
      // multiple arguments. Evaluate them iteratively
      for (var i = 1; i < arguments.length; i++) {
        a = lcm(a, arguments[i]);
      }
      return a;
    }

    // zero or one argument
    throw new SyntaxError('Function lcm expects two or more arguments');
  };

  /**
   * Calculate lcm for BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} the least common multiple of a and b
   * @private
   */
  function _bigLcm(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function lcm must be integer numbers');
    }

    if (a.isZero() || b.isZero()) {
      return new BigNumber(0);
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    // evaluate lcm here inline to reduce overhead
    var prod = a.times(b);
    while (!b.isZero()) {
      var t = b;
      b = a.mod(t);
      a = t;
    }
    return prod.div(a).abs();
  }
};

},{"../../util/index":178,"../../type/collection":52}],74:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Calculate the logarithm of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log(x)
   *    math.log(x, base)
   *
   * Examples:
   *
   *    math.log(3.5);                  // returns 1.252762968495368
   *    math.exp(math.log(2.4));        // returns 2.4
   *
   *    math.pow(10, 4);                // returns 10000
   *    math.log(10000, 10);            // returns 4
   *    math.log(10000) / math.log(10); // returns 4
   *
   *    math.log(1024, 2);              // returns 10
   *    math.pow(2, 10);                // returns 1024
   *
   * See also:
   *
   *    exp, log10
   *
   * @param {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x
   *            Value for which to calculate the logarithm.
   * @param {Number | BigNumber | Boolean | Complex | null} [base=e]
   *            Optional base for the logarithm. If not provided, the natural
   *            logarithm of `x` is calculated.
   * @return {Number | BigNumber | Complex | Array | Matrix}
   *            Returns the logarithm of `x`
   */
  math.log = function log(x, base) {
    if (arguments.length == 1) {
      // calculate natural logarithm, log(x)
      if (isNumber(x)) {
        if (x >= 0) {
          return Math.log(x);
        }
        else {
          // negative value -> complex value computation
          return log(new Complex(x, 0));
        }
      }

      if (isComplex(x)) {
        return new Complex (
            Math.log(Math.sqrt(x.re * x.re + x.im * x.im)),
            Math.atan2(x.im, x.re)
        );
      }

      if (x instanceof BigNumber) {
        if (x.isNegative()) {
          // negative value -> downgrade to number to do complex value computation
          return log(x.toNumber());
        }
        else {
          return x.ln();
        }
      }

      if (isCollection(x)) {
        return collection.deepMap(x, log);
      }

      if (isBoolean(x) || x === null) {
        return log(+x);
      }

      throw new math.error.UnsupportedTypeError('log', math['typeof'](x));
    }
    else if (arguments.length == 2) {
      // calculate logarithm for a specified base, log(x, base)
      return math.divide(log(x), log(base));
    }
    else {
      throw new math.error.ArgumentsError('log', arguments.length, 1, 2);
    }
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],75:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Calculate the 10-base of a value. This is the same as calculating `log(x, 10)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log10(x)
   *
   * Examples:
   *
   *    math.log10(0.00001);            // returns -5
   *    math.log10(10000);              // returns 4
   *    math.log(10000) / math.log(10); // returns 4
   *    math.pow(10, 4);                // returns 10000
   *
   * See also:
   *
   *    exp, log
   *
   * @param {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x
   *            Value for which to calculate the logarithm.
   * @return {Number | BigNumber | Complex | Array | Matrix}
   *            Returns the 10-base logarithm of `x`
   */
  math.log10 = function log10(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('log10', arguments.length, 1);
    }

    if (isNumber(x)) {
      if (x >= 0) {
        return Math.log(x) / Math.LN10;
      }
      else {
        // negative value -> complex value computation
        return log10(new Complex(x, 0));
      }
    }

    if (x instanceof BigNumber) {
      if (x.isNegative()) {
        // negative value -> downgrade to number to do complex value computation
        return log10(x.toNumber());
      }
      else {
        return x.log();
      }
    }

    if (isComplex(x)) {
      return new Complex (
          Math.log(Math.sqrt(x.re * x.re + x.im * x.im)) / Math.LN10,
          Math.atan2(x.im, x.re) / Math.LN10
      );
    }

    if (isCollection(x)) {
      return collection.deepMap(x, log10);
    }

    if (isBoolean(x) || x === null) {
      return log10(+x);
    }

    throw new math.error.UnsupportedTypeError('log10', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],76:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isCollection = collection.isCollection;

  /**
   * Calculates the modulus, the remainder of an integer division.
   *
   * For matrices, the function is evaluated element wise.
   *
   * The modulus is defined as:
   *
   *     x - y * floor(x / y)
   *
   * See http://en.wikipedia.org/wiki/Modulo_operation.
   *
   * Syntax:
   *
   *    math.mod(x, y)
   *
   * Examples:
   *
   *    math.mod(8, 3);                // returns 2
   *    math.mod(11, 2);               // returns 1
   *
   *    function isOdd(x) {
   *      return math.mod(x, 2) != 0;
   *    }
   *
   *    isOdd(2);                      // returns false
   *    isOdd(3);                      // returns true
   *
   * See also:
   *
   *    divide
   *
   * @param  {Number | BigNumber | Boolean | Array | Matrix | null} x Dividend
   * @param  {Number | BigNumber | Boolean | Array | Matrix | null} y Divisor
   * @return {Number | BigNumber | Array | Matrix} Returns the remainder of `x` divided by `y`.
   */
  math.mod = function mod(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('mod', arguments.length, 2);
    }

    // see http://functions.wolfram.com/IntegerFunctions/Mod/

    if (isNumber(x)) {
      if (isNumber(y)) {
        // number % number
        return _mod(x, y);
      }
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y) || y === null) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return y.isZero() ? x : x.mod(y);
      }

      // downgrade x to Number
      return mod(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x) || x === null) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return y.isZero() ? x : x.mod(y);
      }

      // downgrade y to Number
      return mod(x, y.toNumber());
    }

    // TODO: implement mod for complex values

    if (isCollection(x) || isCollection(y)) {
      return collection.deepMap2(x, y, mod);
    }

    if (isBoolean(x) || x === null) {
      return mod(+x, y);
    }
    if (isBoolean(y) || y === null) {
      return mod(x, +y);
    }

    throw new math.error.UnsupportedTypeError('mod', math['typeof'](x), math['typeof'](y));
  };

  /**
   * Calculate the modulus of two numbers
   * @param {Number} x
   * @param {Number} y
   * @returns {number} res
   * @private
   */
  function _mod(x, y) {
    if (y > 0) {
      // We don't use JavaScript's % operator here as this doesn't work
      // correctly for x < 0 and x == 0
      // see http://en.wikipedia.org/wiki/Modulo_operation
      return x - y * Math.floor(x / y);
    }
    else if (y == 0) {
      return x;
    }
    else { // y < 0
      // TODO: implement mod for a negative divisor
      throw new Error('Cannot calculate mod for a negative divisor');
    }
  }
};

},{"../../util/index":178,"../../type/collection":52}],77:[function(require,module,exports){
'use strict';

module.exports = function(math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Matrix = require('../../type/Matrix'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      array = util.array,
      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isArray = Array.isArray,
      isUnit = Unit.isUnit;

  /**
   * Multiply two values, `x * y`. The result is squeezed.
   * For matrices, the matrix product is calculated.
   *
   * Syntax:
   *
   *    math.multiply(x, y)
   *
   * Examples:
   *
   *    math.multiply(4, 5.2);        // returns Number 20.8
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(4, 1);
   *    math.multiply(a, b);          // returns Complex 5 + 14i
   *
   *    var c = [[1, 2], [4, 3]];
   *    var d = [[1, 2, 3], [3, -4, 7]];
   *    math.multiply(c, d);          // returns Array [[7, -6, 17], [13, -4, 33]]
   *
   *    var e = math.unit('2.1 km');
   *    math.multiply(3, e);          // returns Unit 6.3 km
   *
   * See also:
   *
   *    divide
   *
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} x First value to multiply
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} y Second value to multiply
   * @return {Number | BigNumber | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
   */
  math.multiply = function multiply(x, y) {
    var res;

    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('multiply', arguments.length, 2);
    }

    if (isNumber(x)) {
      if (isNumber(y)) {
        // number * number
        return x * y;
      }
      else if (isComplex(y)) {
        // number * complex
        return _multiplyComplex (new Complex(x, 0), y);
      }
      else if (isUnit(y)) {
        res = y.clone();
        res.value = (res.value === null) ? res._normalize(x) : (res.value * x);
        return res;
      }
    }

    if (isComplex(x)) {
      if (isNumber(y)) {
        // complex * number
        return _multiplyComplex (x, new Complex(y, 0));
      }
      else if (isComplex(y)) {
        // complex * complex
        return _multiplyComplex (x, y);
      }
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y) || y === null) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return x.times(y);
      }

      // downgrade to Number
      return multiply(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x) || x === null) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return x.times(y)
      }

      // downgrade to Number
      return multiply(x, y.toNumber());
    }

    if (isUnit(x)) {
      if (isNumber(y)) {
        res = x.clone();
        res.value = (res.value === null) ? res._normalize(y) : (res.value * y);
        return res;
      }
    }

    if (isArray(x)) {
      if (isArray(y)) {
        // array * array
        var sizeX = array.size(x);
        var sizeY = array.size(y);

        if (sizeX.length == 1) {
          if (sizeY.length == 1) {
            // vector * vector
            if (sizeX[0] != sizeY[0]) {
              throw new RangeError('Dimension mismatch in multiplication. ' +
                  'Length of A must match length of B ' +
                  '(A is ' + sizeX[0] +
                  ', B is ' + sizeY[0] +
                  sizeX[0] + ' != ' + sizeY[0] + ')');
            }

            return _multiplyVectorVector(x, y);
          }
          else if (sizeY.length == 2) {
            // vector * matrix
            if (sizeX[0] != sizeY[0]) {
              throw new RangeError('Dimension mismatch in multiplication. ' +
                  'Length of A must match rows of B ' +
                  '(A is ' + sizeX[0] +
                  ', B is ' + sizeY[0] + 'x' + sizeY[1] + ', ' +
                  sizeX[0] + ' != ' + sizeY[0] + ')');
            }

            return _multiplyVectorMatrix(x, y);
          }
          else {
            throw new Error('Can only multiply a 1 or 2 dimensional matrix ' +
                '(B has ' + sizeY.length + ' dimensions)');
          }
        }
        else if (sizeX.length == 2) {
          if (sizeY.length == 1) {
            // matrix * vector
            if (sizeX[1] != sizeY[0]) {
              throw new RangeError('Dimension mismatch in multiplication. ' +
                  'Columns of A must match length of B ' +
                  '(A is ' + sizeX[0] + 'x' + sizeX[0] +
                  ', B is ' + sizeY[0] + ', ' +
                  sizeX[1] + ' != ' + sizeY[0] + ')');
            }

            return _multiplyMatrixVector(x, y);
          }
          else if (sizeY.length == 2) {
            // matrix * matrix
            if (sizeX[1] != sizeY[0]) {
              throw new RangeError('Dimension mismatch in multiplication. ' +
                  'Columns of A must match rows of B ' +
                  '(A is ' + sizeX[0] + 'x' + sizeX[1] +
                  ', B is ' + sizeY[0] + 'x' + sizeY[1] + ', ' +
                  sizeX[1] + ' != ' + sizeY[0] + ')');
            }

            return _multiplyMatrixMatrix(x, y);
          }
          else {
            throw new Error('Can only multiply a 1 or 2 dimensional matrix ' +
                '(B has ' + sizeY.length + ' dimensions)');
          }
        }
        else {
          throw new Error('Can only multiply a 1 or 2 dimensional matrix ' +
              '(A has ' + sizeX.length + ' dimensions)');
        }
      }
      else if (y instanceof Matrix) {
        // array * matrix
        res = multiply(x, y.valueOf());
        return isArray(res) ? new Matrix(res) : res;
      }
      else {
        // array * scalar
        return collection.deepMap2(x, y, multiply);
      }
    }

    if (x instanceof Matrix) {
      if (y instanceof Matrix) {
        // matrix * matrix
        res = multiply(x.valueOf(), y.valueOf());
        return isArray(res) ? new Matrix(res) : res;
      }
      else {
        // matrix * array
        // matrix * scalar
        res = multiply(x.valueOf(), y);
        return isArray(res) ? new Matrix(res) : res;
      }
    }

    if (isArray(y)) {
      // scalar * array
      return collection.deepMap2(x, y, multiply);
    }
    else if (y instanceof Matrix) {
      // scalar * matrix
      return new Matrix(collection.deepMap2(x, y.valueOf(), multiply));
    }

    if (isBoolean(x) || x === null) {
      return multiply(+x, y);
    }
    if (isBoolean(y) || y === null) {
      return multiply(x, +y);
    }

    throw new math.error.UnsupportedTypeError('multiply', math['typeof'](x), math['typeof'](y));
  };

  /**
   * Multiply two 2-dimensional matrices.
   * The size of the matrices is not validated.
   * @param {Array} x   A 2d matrix
   * @param {Array} y   A 2d matrix
   * @return {Array | Number} result
   * @private
   */
  function _multiplyMatrixMatrix(x, y) {
    // TODO: performance of matrix multiplication can be improved
    var res = [],
        rows = x.length,
        cols = y[0].length,
        num = x[0].length;

    for (var r = 0; r < rows; r++) {
      res[r] = [];
      for (var c = 0; c < cols; c++) {
        var result = null;
        for (var n = 0; n < num; n++) {
          var p = math.multiply(x[r][n], y[n][c]);
          result = (result === null) ? p : math.add(result, p);
        }
        res[r][c] = result;
      }
    }

    var isScalar = rows === 1 && cols === 1;
    return isScalar ? res[0][0] : res;
  }

  /**
   * Multiply a vector with a 2-dimensional matrix
   * The size of the matrices is not validated.
   * @param {Array} x   A vector
   * @param {Array} y   A 2d matrix
   * @return {Array | Number} result
   * @private
   */
  function _multiplyVectorMatrix(x, y) {
    // TODO: performance of matrix multiplication can be improved
    var res = [],
        rows = y.length,
        cols = y[0].length;

    for (var c = 0; c < cols; c++) {
      var result = null;
      for (var r = 0; r < rows; r++) {
        var p = math.multiply(x[r], y[r][c]);
        result = (r === 0) ? p : math.add(result, p);
      }
      res[c] = result;
    }

    return res.length === 1 ? res[0] : res;
  }

  /**
   * Multiply a 2-dimensional matrix with a vector
   * The size of the matrices is not validated.
   * @param {Array} x   A 2d matrix
   * @param {Array} y   A vector
   * @return {Array | Number} result
   * @private
   */
  function _multiplyMatrixVector(x, y) {
    // TODO: performance of matrix multiplication can be improved
    var res = [],
        rows = x.length,
        cols = x[0].length;

    for (var r = 0; r < rows; r++) {
      var result = null;
      for (var c = 0; c < cols; c++) {
        var p = math.multiply(x[r][c], y[c]);
        result = (c === 0) ? p : math.add(result, p);
      }
      res[r] = result;
    }

    return res.length === 1 ? res[0] : res;
  }

  /**
   * Multiply two vectors, calculate the dot product
   * The size of the matrices is not validated.
   * @param {Array} x   A vector
   * @param {Array} y   A vector
   * @return {Number} dotProduct
   * @private
   */
  function _multiplyVectorVector(x, y) {
    // TODO: performance of matrix multiplication can be improved
    var len = x.length;

    if (!len) {
      throw new Error('Cannot multiply two empty vectors');
    }

    var dot = 0;
    for (var i = 0; i < len; i++) {
      dot = math.add(dot, math.multiply(x[i], y[i]));
    }
    return dot;
  }

  /**
   * Multiply two complex numbers. x * y or multiply(x, y)
   * @param {Complex} x
   * @param {Complex} y
   * @return {Complex | Number} res
   * @private
   */
  function _multiplyComplex (x, y) {
    // Note: we test whether x or y are pure real or pure complex,
    // to prevent unnecessary NaN values. For example, Infinity*i should
    // result in Infinity*i, and not in NaN+Infinity*i

    if (x.im == 0) {
      // x is pure real
      if (y.im == 0) {
        // y is pure real
        return new Complex(x.re * y.re, 0);
      }
      else if (y.re == 0) {
        // y is pure complex
        return new Complex(
            0,
            x.re * y.im
        );
      }
      else {
        // y has a real and complex part
        return new Complex(
            x.re * y.re,
            x.re * y.im
        );
      }
    }
    else if (x.re == 0) {
      // x is pure complex
      if (y.im == 0) {
        // y is pure real
        return new Complex(
            0,
            x.im * y.re
        );
      }
      else if (y.re == 0) {
        // y is pure complex
        return new Complex(-x.im * y.im, 0);
      }
      else {
        // y has a real and complex part
        return new Complex(
            -x.im * y.im,
            x.im * y.re
        );
      }
    }
    else {
      // x has a real and complex part
      if (y.im == 0) {
        // y is pure real
        return new Complex(
            x.re * y.re,
            x.im * y.re
        );
      }
      else if (y.re == 0) {
        // y is pure complex
        return new Complex(
            -x.im * y.im,
            x.re * y.im
        );
      }
      else {
        // y has a real and complex part
        return new Complex(
            x.re * y.re - x.im * y.im,
            x.re * y.im + x.im * y.re
        );
      }
    }
  }
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Matrix":49,"../../type/Unit":50,"../../type/collection":52}],78:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

    array = require('../../../lib/util/array'),
          
    BigNumber = math.type.BigNumber,
    Complex = require('../../type/Complex'),
    Matrix = require('../../type/Matrix'),
    collection = require('../../type/collection'),

    isNumber = util.number.isNumber,
    isBoolean = util['boolean'].isBoolean,
    isComplex = Complex.isComplex,
    isArray = Array.isArray;

  /**
   * Calculate the norm of a number, vector or matrix.
   *
   * The second parameter p is optional. If not provided, it defaults to 2.
   *
   * Syntax:
   *
   *    math.norm(x)
   *    math.norm(x, p)
   *
   * Examples:
   *
   *    math.abs(-3.5);                         // returns 3.5
   *    math.norm(-3.5);                        // returns 3.5
   *
   *    math.norm(math.complex(3, -4));         // returns 5
   *
   *    math.norm([1, 2, -3], Infinity);        // returns 3
   *    math.norm([1, 2, -3], -Infinity);       // returns 1
   *
   *    math.norm([3, 4], 2);                   // returns 5
   *
   *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
   *    math.norm([[1, 2], [3, 4]], 'inf');     // returns 7
   *    math.norm([[1, 2], [3, 4]], 'fro');     // returns 5.477225575051661
   *
   * See also:
   *
   *    abs
   *
   * @param  {Number | BigNumber | Complex | Boolean | Array | Matrix | null} x
   *            Value for which to calculate the norm
   * @param  {Number | String} [p=2]
   *            Vector space.
   *            Supported numbers include Infinity and -Infinity.
   *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
   * @return {Number} the p-norm
   */
  math.norm = function norm(x, p) {
    if (arguments.length < 1 || arguments.length > 2) {
      throw new math.error.ArgumentsError('abs', arguments.length, 1, 2);
    }

    if (isNumber(x)) {
      // norm(x) = abs(x)
      return Math.abs(x);
    }

    if (isComplex(x)) {
      // ignore p, complex numbers
      return Math.sqrt(x.re * x.re + x.im * x.im);
    }

    if (x instanceof BigNumber) {
      // norm(x) = abs(x)
      return x.abs();
    }

    if (isBoolean(x) || x === null) {
      // norm(x) = abs(x)
      return Math.abs(x);
    }

    if (isArray(x)) {
      // size
      var sizeX = array.size(x);
      // missing p
      if (p == null)
        p = 2;
      // check it is a Vector
      if (sizeX.length == 1) {
        // check p
        if (p === Number.POSITIVE_INFINITY || p === 'inf') {
          // norm(x, Infinity) = max(abs(x))
          var n;
          math.forEach(x, function (value) {
            var v = math.abs(value);
            if (!n || math.larger(v, n))
              n = v;
          });
          return n;
        }
        if (p === Number.NEGATIVE_INFINITY || p === '-inf') {
          // norm(x, -Infinity) = min(abs(x))
          var n;
          math.forEach(x, function (value) {
            var v = math.abs(value);
            if (!n || math.smaller(v, n))
              n = v;
          });
          return n;
        }
        if (p === 'fro')
            return norm(x);
        if (isNumber(p) && !isNaN(p)) {
          // check p != 0
          if (!math.equal(p, 0)) {
            // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p
            var n = 0;
            math.forEach(x, function (value) {
              n = math.add(math.pow(math.abs(value), p), n);
            });
            return math.pow(n, 1 / p);
          }
          return Number.POSITIVE_INFINITY;
        }
        // invalid parameter value
        throw new Error('Unsupported parameter value');
      }
      else if (sizeX.length == 2) {
        // check p
        if (p == 1) {
          // norm(x) = the largest column sum
          var c = [];
          // loop rows
          for (var i = 0; i < x.length; i++) {
            var r = x[i];
            // loop columns
            for (var j = 0; j < r.length; j++) {
              c[j] = math.add(c[j] || 0, math.abs(r[j]));
            }
          }
          return math.max(c);
        }
        if (p == Number.POSITIVE_INFINITY || p === 'inf') {
          // norm(x) = the largest row sum
          var n = 0;
          // loop rows
          for (var i = 0; i < x.length; i++) {
            var rs = 0;
            var r = x[i];
            // loop columns
            for (var j = 0; j < r.length; j++) {
              rs = math.add(rs, math.abs(r[j]));
            }
            if (math.larger(rs, n))
              n = rs;
          }
          return n;
        }
        if (p === 'fro') {
          // norm(x) = sqrt(sum(diag(x'x)))
          var d = math.diag(math.multiply(math.transpose(x), x));
          var s = 0;
          math.forEach(d, function (value) {
            s = math.add(value, s);
          });
          return math.sqrt(s);
        }
        if (p == 2) {
          // not implemented
          throw new Error('Unsupported parameter value, missing implementation of matrix singular value decomposition');
        }
        // invalid parameter value
        throw new Error('Unsupported parameter value');
      }
    }

    if (x instanceof Matrix) {
      return norm(x.valueOf(), p);
    }

    throw new math.error.UnsupportedTypeError('norm', x);
  };
};

},{"../../util/index":178,"../../../lib/util/array":44,"../../type/Complex":43,"../../type/Matrix":49,"../../type/collection":52}],79:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      array = util.array,
      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isArray = Array.isArray,
      isInteger = util.number.isInteger,
      isComplex = Complex.isComplex;

  /**
   * Calculates the power of x to y, `x ^ y`.
   * Matrix exponentiation is supported for square matrices `x`, and positive
   * integer exponents `y`.
   *
   * Syntax:
   *
   *    math.pow(x, y)
   *
   * Examples:
   *
   *    math.pow(2, 3);               // returns Number 8
   *
   *    var a = math.complex(2, 3);
   *    math.pow(a, 2)                // returns Complex -5 + 12i
   *
   *    var b = [[1, 2], [4, 3]];
   *    math.pow(b, 2);               // returns Array [[9, 8], [16, 17]]
   *
   * See also:
   *
   *    multiply, sqrt
   *
   * @param  {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x  The base
   * @param  {Number | BigNumber | Boolean | Complex | null} y                   The exponent
   * @return {Number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`
   */
  math.pow = function pow(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('pow', arguments.length, 2);
    }

    if (isNumber(x)) {
      if (isNumber(y)) {
        if (isInteger(y) || x >= 0) {
          // real value computation
          return Math.pow(x, y);
        }
        else {
          return powComplex(new Complex(x, 0), new Complex(y, 0));
        }
      }
      else if (isComplex(y)) {
        return powComplex(new Complex(x, 0), y);
      }
    }

    if (isComplex(x)) {
      if (isNumber(y)) {
        return powComplex(x, new Complex(y, 0));
      }
      else if (isComplex(y)) {
        return powComplex(x, y);
      }
    }

    if (x instanceof BigNumber) {
      // try to upgrade y to to bignumber
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y) || y === null) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        if (y.isInteger() && !x.isNegative()) {
          return x.pow(y);
        }
        else {
          // downgrade to number to do complex valued computation
          return pow(x.toNumber(), y.toNumber())
        }
      }
      else {
        // failed to upgrade y to bignumber, lets downgrade x to number
        return pow(x.toNumber(), y);
      }
    }

    if (y instanceof BigNumber) {
      // try to convert x to bignumber
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x) || x === null) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        if (y.isInteger() && !x.isNegative()) {
          return x.pow(y);
        }
        else {
          // downgrade to number to do complex valued computation
          return pow(x.toNumber(), y.toNumber())
        }
      }
      else {
        // failed to upgrade x to bignumber, lets downgrade y to number
        return pow(x, y.toNumber());
      }
    }

    if (isArray(x)) {
      if (!isNumber(y) || !isInteger(y) || y < 0) {
        throw new TypeError('For A^b, b must be a positive integer ' +
            '(value is ' + y + ')');
      }
      // verify that A is a 2 dimensional square matrix
      var s = array.size(x);
      if (s.length != 2) {
        throw new Error('For A^b, A must be 2 dimensional ' +
            '(A has ' + s.length + ' dimensions)');
      }
      if (s[0] != s[1]) {
        throw new Error('For A^b, A must be square ' +
            '(size is ' + s[0] + 'x' + s[1] + ')');
      }

      // compute power of matrix
      var res = math.eye(s[0]).valueOf();
      var px = x;
      while (y >= 1) {
        if ((y & 1) == 1) {
          res = math.multiply(px, res);
        }
        y >>= 1;
        px = math.multiply(px, px);
      }
      return res;
    }
    else if (x instanceof Matrix) {
      return new Matrix(pow(x.valueOf(), y));
    }

    if (isBoolean(x) || x === null) {
      return pow(+x, y);
    }
    if (isBoolean(y) || y === null) {
      return pow(x, +y);
    }

    throw new math.error.UnsupportedTypeError('pow', math['typeof'](x), math['typeof'](y));
  };

  /**
   * Calculates the power of x to y, x^y, for two complex numbers.
   * @param {Complex} x
   * @param {Complex} y
   * @return {Complex} res
   * @private
   */
  function powComplex (x, y) {
    // complex computation
    // x^y = exp(log(x)*y) = exp((abs(x)+i*arg(x))*y)
    var temp1 = math.log(x);
    var temp2 = math.multiply(temp1, y);
    return math.exp(temp2);
  }
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Matrix":49,"../../type/collection":52}],80:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isInteger = util.number.isInteger,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Round a value towards the nearest integer.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.round(x)
   *    math.round(x, n)
   *
   * Examples:
   *
   *    math.round(3.2);              // returns Number 3
   *    math.round(3.8);              // returns Number 4
   *    math.round(-4.2);             // returns Number -4
   *    math.round(-4.7);             // returns Number -5
   *    math.round(math.pi, 3);       // returns Number 3.14
   *    math.round(123.45678, 2);     // returns Number 123.46
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.round(c);                // returns Complex 3 - 3i
   *
   *    math.round([3.2, 3.8, -4.7]); // returns Array [3, 4, -5]
   *
   * See also:
   *
   *    ceil, fix, floor
   *
   * @param  {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x   Number to be rounded
   * @param  {Number | BigNumber | Boolean | Array | null} [n=0]                 Number of decimals
   * @return {Number | BigNumber | Complex | Array | Matrix} Rounded value
   */
  math.round = function round(x, n) {
    if (arguments.length != 1 && arguments.length != 2) {
      throw new math.error.ArgumentsError('round', arguments.length, 1, 2);
    }

    if (n == undefined) {
      // round (x)
      if (isNumber(x)) {
        return Math.round(x);
      }

      if (isComplex(x)) {
        return new Complex (
            Math.round(x.re),
            Math.round(x.im)
        );
      }

      if (x instanceof BigNumber) {
        return x.toDecimalPlaces(0);
      }

      if (isCollection(x)) {
        return collection.deepMap(x, round);
      }

      if (isBoolean(x) || x === null) {
        return Math.round(x);
      }

      throw new math.error.UnsupportedTypeError('round', math['typeof'](x));
    }
    else {
      // round (x, n)
      if (!isNumber(n) || !isInteger(n)) {
        if (n instanceof BigNumber) {
          n = parseFloat(n.valueOf());
        }
        else if (isBoolean(n) || x === null) {
          return round(x, +n);
        }
        else {
          throw new TypeError('Number of decimals in function round must be an integer');
        }
      }
      if (n < 0 || n > 15) {
        throw new Error ('Number of decimals in function round must be in te range of 0-15');
      }

      if (isNumber(x)) {
        return roundNumber(x, n);
      }

      if (isComplex(x)) {
        return new Complex (
            roundNumber(x.re, n),
            roundNumber(x.im, n)
        );
      }

      if (x instanceof BigNumber) {
        return x.toDecimalPlaces(n);
      }

      if (isCollection(x) || isCollection(n)) {
        return collection.deepMap2(x, n, round);
      }

      if (isBoolean(x) || x === null) {
        return round(+x, n);
      }

      throw new math.error.UnsupportedTypeError('round', math['typeof'](x), math['typeof'](n));
    }
  };

  /**
   * round a number to the given number of decimals, or to zero if decimals is
   * not provided
   * @param {Number} value
   * @param {Number} decimals       number of decimals, between 0 and 15 (0 by default)
   * @return {Number} roundedValue
   */
  function roundNumber (value, decimals) {
    var p = Math.pow(10, decimals);
    return Math.round(value * p) / p;
  }
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],81:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      number = util.number,
      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Compute the sign of a value. The sign of a value x is:
   *
   * -  1 when x > 1
   * - -1 when x < 0
   * -  0 when x == 0
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sign(x)
   *
   * Examples:
   *
   *    math.sign(3.5);               // returns 1
   *    math.sign(-4.2);              // returns -1
   *    math.sign(0);                 // returns 0
   *
   *    math.sign([3, 5, -2, 0, 2]);  // returns [1, 1, -1, 0, 1]
   *
   * See also:
   *
   *    abs
   *
   * @param  {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x
   *            The number for which to determine the sign
   * @return {Number | BigNumber | Complex | Array | Matrix}e
   *            The sign of `x`
   */
  math.sign = function sign(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('sign', arguments.length, 1);
    }

    if (isNumber(x)) {
      return number.sign(x);
    }

    if (isComplex(x)) {
      var abs = Math.sqrt(x.re * x.re + x.im * x.im);
      return new Complex(x.re / abs, x.im / abs);
    }

    if (x instanceof BigNumber) {
      return new BigNumber(x.cmp(0));
    }

    if (isCollection(x)) {
      return collection.deepMap(x, sign);
    }

    if (isBoolean(x) || x === null) {
      return number.sign(x);
    }

    throw new math.error.UnsupportedTypeError('sign', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],82:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Calculate the square root of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sqrt(x)
   *
   * Examples:
   *
   *    math.sqrt(25);                // returns 5
   *    math.square(5);               // returns 25
   *    math.sqrt(-4);                // returns Complex -2i
   *
   * See also:
   *
   *    square, multiply
   *
   * @param {Number | Boolean | Complex | Array | Matrix | null} x
   *            Value for which to calculate the square root.
   * @return {Number | Complex | Array | Matrix}
   *            Returns the square root of `x`
   */
  math.sqrt = function sqrt (x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('sqrt', arguments.length, 1);
    }

    if (isNumber(x)) {
      if (x >= 0) {
        return Math.sqrt(x);
      }
      else {
        return sqrt(new Complex(x, 0));
      }
    }

    if (isComplex(x)) {
      var r = Math.sqrt(x.re * x.re + x.im * x.im);

      var re, im;

      if (x.re >= 0) {
        re = 0.5 * Math.sqrt(2.0 * (r + x.re));
      }
      else {
        re = Math.abs(x.im) / Math.sqrt(2 * (r - x.re));
      }

      if (x.re <= 0) {
        im = 0.5 * Math.sqrt(2.0 * (r - x.re));
      }
      else {
        im = Math.abs(x.im) / Math.sqrt(2 * (r + x.re));
      }

      if (x.im >= 0) {
        return new Complex(re, im);
      }
      else {
        return new Complex(re, -im);
      }
    }

    if (x instanceof BigNumber) {
      if (x.isNegative()) {
        // negative value -> downgrade to number to do complex value computation
        return sqrt(x.toNumber());
      }
      else {
        return x.sqrt();
      }
    }

    if (isCollection(x)) {
      return collection.deepMap(x, sqrt);
    }

    if (isBoolean(x) || x === null) {
      return sqrt(+x);
    }

    throw new math.error.UnsupportedTypeError('sqrt', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],83:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Compute the square of a value, `x * x`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.square(x)
   *
   * Examples:
   *
   *    math.square(2);           // returns Number 4
   *    math.square(3);           // returns Number 9
   *    math.pow(3, 2);           // returns Number 9
   *    math.multiply(3, 3);      // returns Number 9
   *
   *    math.square([1, 2, 3, 4]);  // returns Array [1, 4, 9, 16]
   *
   * See also:
   *
   *    multiply, cube, sqrt, pow
   *
   * @param  {Number | BigNumber | Boolean | Complex | Array | Matrix | null} x
   *            Number for which to calculate the square
   * @return {Number | BigNumber | Complex | Array | Matrix}
   *            Squared value
   */
  math.square = function square(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('square', arguments.length, 1);
    }

    if (isNumber(x)) {
      return x * x;
    }

    if (isComplex(x)) {
      return math.multiply(x, x);
    }

    if (x instanceof BigNumber) {
      return x.times(x);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, square);
    }

    if (isBoolean(x) || x === null) {
      return x * x;
    }

    throw new math.error.UnsupportedTypeError('square', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],84:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Matrix = require('../../type/Matrix'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isBoolean = util['boolean'].isBoolean,
      isNumber = util.number.isNumber,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Subtract two values, `x - y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.subtract(x, y)
   *
   * Examples:
   *
   *    math.subtract(5.3, 2);        // returns Number 3.3
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(4, 1);
   *    math.subtract(a, b);          // returns Complex -2 + 2i
   *
   *    math.subtract([5, 7, 4], 4);  // returns Array [1, 3, 0]
   *
   *    var c = math.unit('2.1 km');
   *    var d = math.unit('500m');
   *    math.subtract(c, d);          // returns Unit 1.6 km
   *
   * See also:
   *
   *    add
   *
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} x
   *            Initial value
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} y
   *            Value to subtract from `x`
   * @return {Number | BigNumber | Complex | Unit | Array | Matrix}
   *            Subtraction of `x` and `y`
   */
  math.subtract = function subtract(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('subtract', arguments.length, 2);
    }

    if (isNumber(x)) {
      if (isNumber(y)) {
        // number - number
        return x - y;
      }
      else if (isComplex(y)) {
        // number - complex
        return new Complex (
            x - y.re,
            - y.im
        );
      }
    }
    else if (isComplex(x)) {
      if (isNumber(y)) {
        // complex - number
        return new Complex (
            x.re - y,
            x.im
        )
      }
      else if (isComplex(y)) {
        // complex - complex
        return new Complex (
            x.re - y.re,
            x.im - y.im
        )
      }
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y) || y === null) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return x.minus(y);
      }

      // downgrade to Number
      return subtract(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x) || x === null) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return x.minus(y)
      }

      // downgrade to Number
      return subtract(x, y.toNumber());
    }

    if (isUnit(x)) {
      if (isUnit(y)) {
        if (x.value == null) {
          throw new Error('Parameter x contains a unit with undefined value');
        }

        if (y.value == null) {
          throw new Error('Parameter y contains a unit with undefined value');
        }

        if (!x.equalBase(y)) {
          throw new Error('Units do not match');
        }

        var res = x.clone();
        res.value -= y.value;
        res.fixPrefix = false;

        return res;
      }
    }

    if (isCollection(x) || isCollection(y)) {
      return collection.deepMap2(x, y, subtract);
    }

    if (isBoolean(x) || x === null) {
      return subtract(+x, y);
    }
    if (isBoolean(y) || y === null) {
      return subtract(x, +y);
    }

    throw new math.error.UnsupportedTypeError('subtract', math['typeof'](x), math['typeof'](y));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Matrix":49,"../../type/Unit":50,"../../type/collection":52}],85:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Inverse the sign of a value, apply a unary minus operation.
   *
   * For matrices, the function is evaluated element wise. Boolean values and
   * strings will be converted to a number. For complex numbers, both real and
   * complex value are inverted.
   *
   * Syntax:
   *
   *    math.unaryMinus(x)
   *
   * Examples:
   *
   *    math.unaryMinus(3.5);      // returns -3.5
   *    math.unaryMinus(-4.2);     // returns 4.2
   *
   * See also:
   *
   *    add, subtract, unaryPlus
   *
   * @param  {Number | BigNumber | Boolean | String | Complex | Unit | Array | Matrix | null} x Number to be inverted.
   * @return {Number | BigNumber | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
   */
  math.unaryMinus = function unaryMinus(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('unaryMinus', arguments.length, 1);
    }

    if (isNumber(x)) {
      return -x;
    }

    if (isComplex(x)) {
      return new Complex(
          -x.re,
          -x.im
      );
    }

    if (x instanceof BigNumber) {
      return x.neg();
    }

    if (isUnit(x)) {
      var res = x.clone();
      res.value = -x.value;
      return res;
    }

    if (isCollection(x)) {
      return collection.deepMap(x, unaryMinus);
    }

    if (isBoolean(x) || isString(x) || x === null) {
      // convert to a number or bignumber
      return (config.number == 'bignumber') ? new BigNumber(-x): -x;
    }

    throw new math.error.UnsupportedTypeError('unaryMinus', math['typeof'](x));
  };

  // TODO: function unary is renamed to unaryMinus since version 0.23.0. Cleanup some day
  math.unary = function unary() {
    throw new Error('Function unary is deprecated. Use unaryMinus instead.');
  }
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],86:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Unary plus operation.
   * Boolean values and strings will be converted to a number, numeric values will be returned as is.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.unaryPlus(x)
   *
   * Examples:
   *
   *    math.unaryPlus(3.5);      // returns 3.5
   *    math.unaryPlus(1);     // returns 1
   *
   * See also:
   *
   *    unaryMinus, add, subtract
   *
   * @param  {Number | BigNumber | Boolean | String | Complex | Unit | Array | Matrix | null} x
   *            Input value
   * @return {Number | BigNumber | Complex | Unit | Array | Matrix}
   *            Returns the input value when numeric, converts to a number when input is non-numeric.
   */
  math.unaryPlus = function unaryPlus(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('unaryPlus', arguments.length, 1);
    }

    if (isNumber(x)) {
      return x;
    }

    if (isComplex(x)) {
      return x.clone();
    }

    if (x instanceof BigNumber) {
      return x;
    }

    if (isUnit(x)) {
      return x.clone();
    }

    if (isCollection(x)) {
      return collection.deepMap(x, unaryPlus);
    }

    if (isBoolean(x) || isString(x) || x === null) {
      // convert to a number or bignumber
      return (config.number == 'bignumber') ? new BigNumber(+x): +x;
    }

    throw new math.error.UnsupportedTypeError('unaryPlus', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],87:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      Matrix = require('../../type/Matrix'),
      BigNumber = math.type.BigNumber,

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isInteger = util.number.isInteger;

  /**
   * Calculate the extended greatest common divisor for two values.
   * See http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
   *
   * Syntax:
   *
   *    math.xgcd(a, b)
   *
   * Examples:
   *
   *    math.xgcd(8, 12);             // returns [4, -1, 1]
   *    math.gcd(8, 12);              // returns 4
   *    math.xgcd(36163, 21199);      // returns [1247, -7, 12]
   *
   * See also:
   *
   *    gcd, lcm
   *
   * @param {Number | BigNumber | Boolean} a  An integer number
   * @param {Number | BigNumber | Boolean} b  An integer number
   * @return {Array}              Returns an array containing 3 integers `[div, m, n]`
   *                              where `div = gcd(a, b)` and `a*m + b*n = div`
   */
  math.xgcd = function xgcd(a, b) {
    if (arguments.length == 2) {
      // two arguments
      if (isNumber(a) && isNumber(b)) {
        if (!isInteger(a) || !isInteger(b)) {
          throw new Error('Parameters in function xgcd must be integer numbers');
        }

        return _xgcd(a, b);
      }

      if (a instanceof BigNumber) {
        // try to convert to big number
        if (isNumber(b)) {
          b = BigNumber.convert(b);
        }
        else if (isBoolean(b) || b === null) {
          b = new BigNumber(b ? 1 : 0);
        }

        if (b instanceof BigNumber) {
          return _bigXgcd(a, b);
        }

        // downgrade to Number
        return xgcd(a.toNumber(), b);
      }
      if (b instanceof BigNumber) {
        // try to convert to big number
        if (isNumber(a)) {
          a = BigNumber.convert(a);
        }
        else if (isBoolean(a) || a === null) {
          a = new BigNumber(a ? 1 : 0);
        }

        if (a instanceof BigNumber) {
          return _bigXgcd(a, b);
        }

        // downgrade to Number
        return xgcd(a.toNumber(), b);
      }

      if (isBoolean(a) || a === null) {
        return xgcd(+a, b);
      }
      if (isBoolean(b) || b === null) {
        return xgcd(a, +b);
      }

      throw new math.error.UnsupportedTypeError('xgcd', math['typeof'](a), math['typeof'](b));
    }

    // zero or one argument
    throw new SyntaxError('Function xgcd expects two arguments');
  };

  /**
   * Calculate xgcd for two numbers
   * @param {Number} a
   * @param {Number} b
   * @return {Number} result
   * @private
   */
  function _xgcd(a, b) {
    // source: http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
    var t, // used to swap two variables
        q, // quotient
        r, // remainder
        x = 0, lastx = 1,
        y = 1, lasty = 0;

    while (b) {
      q = Math.floor(a / b);
      r = a % b;

      t = x;
      x = lastx - q * x;
      lastx = t;

      t = y;
      y = lasty - q * y;
      lasty = t;

      a = b;
      b = r;
    }

    var res;
    if (a < 0) {
      res = [-a, -lastx, -lasty];
    }
    else {
      res = [a, a ? lastx : 0, lasty];
    }
    return (config.matrix === 'array') ? res : new Matrix(res);
  }

  /**
   * Calculate xgcd for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @return {BigNumber[]} result
   * @private
   */
  function _bigXgcd(a, b) {
    // source: http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
    var t, // used to swap two variables
        q, // quotient
        r, // remainder
        zero = new BigNumber(0),
        x = new BigNumber(0), lastx = new BigNumber(1),
        y = new BigNumber(1), lasty = new BigNumber(0);

    while (!b.isZero()) {
      q = a.div(b).floor();
      r = a.mod(b);

      t = x;
      x = lastx.minus(q.times(x));
      lastx = t;

      t = y;
      y = lasty.minus(q.times(y));
      lasty = t;

      a = b;
      b = r;
    }

    var res;
    if (a.lt(zero)) {
      res = [a.neg(), lastx.neg(), lasty.neg()];
    }
    else {
      res = [a, !a.isZero() ? lastx : 0, lasty];
    }
    return (config.matrix === 'array') ? res : new Matrix(res);
  }
};

},{"../../util/index":178,"../../type/Matrix":49}],88:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      nearlyEqual = util.number.nearlyEqual,
      isBoolean = util['boolean'].isBoolean,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.
   *
   * x and y are considered equal when the relative difference between x and y
   * is smaller than the configured epsilon. The function cannot be used to
   * compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.compare(x, y)
   *
   * Examples:
   *
   *    math.compare(6, 1);           // returns 1
   *    math.compare(2, 3);           // returns -1
   *    math.compare(7, 7);           // returns 0
   *
   *    var a = math.unit('5 cm');
   *    var b = math.unit('40 mm');
   *    math.compare(a, b);           // returns 1
   *
   *    math.compare(2, [1, 2, 3]);   // returns [1, 0, -1]
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, larger, largerEq
   *
   * @param  {Number | BigNumber | Boolean | Unit | String | Array | Matrix | null} x First value to compare
   * @param  {Number | BigNumber | Boolean | Unit | String | Array | Matrix | null} y Second value to compare
   * @return {Number | BigNumber | Array | Matrix} Returns the result of the comparison: 1, 0 or -1.
   */
  math.compare = function compare(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('compare', arguments.length, 2);
    }

    if (isNumber(x) && isNumber(y)) {
      return nearlyEqual(x, y, config.epsilon) ? 0 : (x > y ? 1 : -1);
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y) || y === null) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return new BigNumber(x.cmp(y));
      }

      // downgrade to Number
      return compare(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x) || x === null) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return new BigNumber(x.cmp(y));
      }

      // downgrade to Number
      return compare(x, y.toNumber());
    }

    if ((isUnit(x)) && (isUnit(y))) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return (x.value > y.value) ? 1 : ((x.value < y.value) ? -1 : 0);
    }

    if (isCollection(x) || isCollection(y)) {
      return collection.deepMap2(x, y, compare);
    }

    // Note: test strings after testing collections,
    // else we can't compare a string with a matrix
    if (isString(x) || isString(y)) {
      return (x > y) ? 1 : ((x < y) ? -1 : 0);
    }

    if (isBoolean(x) || x === null) {
      return compare(+x, y);
    }
    if (isBoolean(y) || y === null) {
      return compare(x, +y);
    }

    if (isComplex(x) || isComplex(y)) {
      throw new TypeError('No ordering relation is defined for complex numbers');
    }

    throw new math.error.UnsupportedTypeError('compare', math['typeof'](x), math['typeof'](y));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],89:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var collection = require('../../type/collection'),

      isCollection = collection.isCollection,
      isArray = Array.isArray;

  /**
   * Test element wise whether two matrices are equal.
   * The function accepts both matrices and scalar values.
   *
   * Syntax:
   *
   *    math.deepEqual(x, y)
   *
   * Examples:
   *
   *    math.deepEqual(2, 4);   // returns false
   *
   *    a = [2, 5, 1];
   *    b = [2, 7, 1];
   *
   *    math.deepEqual(a, b);   // returns false
   *    math.equal(a, b);       // returns [true, false, true]
   *
   * See also:
   *
   *    equal, unequal
   *
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} x First matrix to compare
   * @param  {Number | BigNumber | Boolean | Complex | Unit | Array | Matrix | null} y Second matrix to compare
   * @return {Number | BigNumber | Complex | Unit | Array | Matrix}
   *            Returns true when the input matrices have the same size and each of their elements is equal.
   */
  math.deepEqual = function deepEqual(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('deepEqual', arguments.length, 2);
    }

    if (isCollection(x) || isCollection(y)) {
      return _deepEqual(x.valueOf(), y.valueOf());
    }

    return math.equal(x, y);
  };

  /**
   * Test whether two arrays have the same size and all elements are equal
   * @param {Array | *} x
   * @param {Array | *} y
   * @return {boolean} Returns true if both arrays are deep equal
   */
  function _deepEqual(x, y) {
    if (isArray(x)) {
      if (isArray(y)) {
        var len = x.length;
        if (len !== y.length) return false;

        for (var i = 0; i < len; i++) {
          if (!_deepEqual(x[i], y[i])) return false;
        }

        return true;
      }
      else {
        return false;
      }
    }
    else {
      if (isArray(y)) {
        return false;
      }
      else {
        return math.equal(x, y);
      }
    }
  }
};

},{"../../type/collection":52}],90:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      nearlyEqual = util.number.nearlyEqual,
      isBoolean = util['boolean'].isBoolean,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Test whether two values are equal.
   *
   * The function tests whether the relative difference between x and y is
   * smaller than the configured epsilon. The function cannot be used to
   * compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
   *
   * Values `null` and `undefined` are compared strictly, thus `null` is only
   * equal to `null` and nothing else, and `undefined` is only equal to
   * `undefined` and nothing else.
   *
   * Syntax:
   *
   *    math.equal(x, y)
   *
   * Examples:
   *
   *    math.equal(2 + 2, 3);         // returns false
   *    math.equal(2 + 2, 4);         // returns true
   *
   *    var a = math.unit('50 cm');
   *    var b = math.unit('5 m');
   *    math.equal(a, b);             // returns true
   *
   *    var c = [2, 5, 1];
   *    var d = [2, 7, 1];
   *
   *    math.equal(c, d);             // returns [true, false, true]
   *    math.deepEqual(c, d);         // returns false
   *
   *    math.equal(0, null);          // returns false
   *
   * See also:
   *
   *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual
   *
   * @param  {Number | BigNumber | Boolean | Complex | Unit | String | Array | Matrix | null | undefined} x First value to compare
   * @param  {Number | BigNumber | Boolean | Complex | Unit | String | Array | Matrix | null | undefined} y Second value to compare
   * @return {Boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
   */
  math.equal = function equal(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('equal', arguments.length, 2);
    }

    if (isNumber(x)) {
      if (isNumber(y)) {
        return nearlyEqual(x, y, config.epsilon);
      }
      else if (isComplex(y)) {
        return nearlyEqual(x, y.re, config.epsilon) && nearlyEqual(y.im, 0, config.epsilon);
      }
    }

    if (isComplex(x)) {
      if (isNumber(y)) {
        return nearlyEqual(x.re, y, config.epsilon) && nearlyEqual(x.im, 0, config.epsilon);
      }
      else if (isComplex(y)) {
        return nearlyEqual(x.re, y.re, config.epsilon) && nearlyEqual(x.im, y.im, config.epsilon);
      }
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y)) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return x.eq(y);
      }

      // downgrade to Number
      return equal(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x)) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return x.eq(y);
      }

      // downgrade to Number
      return equal(x, y.toNumber());
    }

    if ((isUnit(x)) && (isUnit(y))) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return x.value == y.value;
    }

    if (isCollection(x) || isCollection(y)) {
      return collection.deepMap2(x, y, equal);
    }

    // Note: test strings after testing collections,
    // else we can accidentally compare a stringified array with a string
    if (isString(x) || isString(y)) {
      return x == y;
    }

    if (isBoolean(x)) {
      return equal(+x, y);
    }
    if (isBoolean(y)) {
      return equal(x, +y);
    }

    if (x === null) {
      return y === null;
    }
    if (y === null) {
      return x === null;
    }

    if (x === undefined) {
      return y === undefined;
    }
    if (y === undefined) {
      return x === undefined;
    }

    throw new math.error.UnsupportedTypeError('equal', math['typeof'](x), math['typeof'](y));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],91:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      nearlyEqual = util.number.nearlyEqual,
      isBoolean = util['boolean'].isBoolean,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Test whether value x is larger than y.
   *
   * The function returns true when x is larger than y and the relative
   * difference between x and y is larger than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.larger(x, y)
   *
   * Examples:
   *
   *    math.larger(2, 3);             // returns false
   *    math.larger(5, 2 + 2);         // returns true
   *
   *    var a = math.unit('5 cm');
   *    var b = math.unit('2 inch');
   *    math.larger(a, b);             // returns false
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, largerEq, compare
   *
   * @param  {Number | BigNumber | Boolean | Unit | String | Array | Matrix | null} x First value to compare
   * @param  {Number | BigNumber | Boolean | Unit | String | Array | Matrix | null} y Second value to compare
   * @return {Boolean | Array | Matrix} Returns true when the x is larger than y, else returns false
   */
  math.larger = function larger(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('larger', arguments.length, 2);
    }

    if (isNumber(x) && isNumber(y)) {
      return !nearlyEqual(x, y, config.epsilon) && x > y;
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y) || y === null) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return x.gt(y);
      }

      // downgrade to Number
      return larger(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x) || x === null) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return x.gt(y)
      }

      // downgrade to Number
      return larger(x, y.toNumber());
    }

    if ((isUnit(x)) && (isUnit(y))) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return x.value > y.value;
    }

    if (isCollection(x) || isCollection(y)) {
      return collection.deepMap2(x, y, larger);
    }

    // Note: test strings after testing collections,
    // else we can't compare a string with a matrix
    if (isString(x) || isString(y)) {
      return x > y;
    }

    if (isBoolean(x) || x === null) {
      return larger(+x, y);
    }
    if (isBoolean(y) || y === null) {
      return larger(x, +y);
    }

    if (isComplex(x) || isComplex(y)) {
      throw new TypeError('No ordering relation is defined for complex numbers');
    }

    throw new math.error.UnsupportedTypeError('larger', math['typeof'](x), math['typeof'](y));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],92:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      nearlyEqual = util.number.nearlyEqual,
      isBoolean = util['boolean'].isBoolean,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Test whether value x is larger or equal to y.
   *
   * The function returns true when x is larger than y or the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.largerEq(x, y)
   *
   * Examples:
   *
   *    math.larger(2, 1 + 1);         // returns false
   *    math.largerEq(2, 1 + 1);       // returns true
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, larger, compare
   *
   * @param  {Number | BigNumber | Boolean | Unit | String | Array | Matrix | null} x First value to compare
   * @param  {Number | BigNumber | Boolean | Unit | String | Array | Matrix | null} y Second value to compare
   * @return {Boolean | Array | Matrix} Returns true when the x is larger or equal to y, else returns false
   */
  math.largerEq = function largerEq(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('largerEq', arguments.length, 2);
    }

    if (isNumber(x) && isNumber(y)) {
      return nearlyEqual(x, y, config.epsilon) || x > y;
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y) || y === null) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return x.gte(y);
      }

      // downgrade to Number
      return largerEq(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x) || x === null) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return x.gte(y)
      }

      // downgrade to Number
      return largerEq(x, y.toNumber());
    }

    if ((isUnit(x)) && (isUnit(y))) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return x.value >= y.value;
    }

    if (isCollection(x) || isCollection(y)) {
      return collection.deepMap2(x, y, largerEq);
    }

    // Note: test strings after testing collections,
    // else we can't compare a string with a matrix
    if (isString(x) || isString(y)) {
      return x >= y;
    }

    if (isBoolean(x) || x === null) {
      return largerEq(+x, y);
    }
    if (isBoolean(y) || y === null) {
      return largerEq(x, +y);
    }

    if (isComplex(x) || isComplex(y)) {
      throw new TypeError('No ordering relation is defined for complex numbers');
    }

    throw new math.error.UnsupportedTypeError('largerEq', math['typeof'](x), math['typeof'](y));
  };

  // TODO: deprecated since version 0.23.0, cleanup some day
  math.largereq = function () {
    throw new Error('Function largereq is renamed to largerEq');
  }
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],93:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      nearlyEqual = util.number.nearlyEqual,
      isBoolean = util['boolean'].isBoolean,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Test whether value x is smaller than y.
   *
   * The function returns true when x is smaller than y and the relative
   * difference between x and y is larger than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.smaller(x, y)
   *
   * Examples:
   *
   *    math.smaller(2, 3);            // returns true
   *    math.smaller(5, 2 * 2);        // returns false
   *
   *    var a = math.unit('5 cm');
   *    var b = math.unit('2 inch');
   *    math.smaller(a, b);            // returns true
   *
   * See also:
   *
   *    equal, unequal, smallerEq, larger, largerEq, compare
   *
   * @param  {Number | BigNumber | Boolean | Unit | String | Array | Matrix | null} x First value to compare
   * @param  {Number | BigNumber | Boolean | Unit | String | Array | Matrix | null} y Second value to compare
   * @return {Boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
   */
  math.smaller = function smaller(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('smaller', arguments.length, 2);
    }

    if (isNumber(x) && isNumber(y)) {
      return !nearlyEqual(x, y, config.epsilon) && x < y;
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y) || y === null) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return x.lt(y);
      }

      // downgrade to Number
      return smaller(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x) || x === null) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return x.lt(y)
      }

      // downgrade to Number
      return smaller(x, y.toNumber());
    }

    if ((isUnit(x)) && (isUnit(y))) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return x.value < y.value;
    }

    if (isCollection(x) || isCollection(y)) {
      return collection.deepMap2(x, y, smaller);
    }

    // Note: test strings after testing collections,
    // else we can't compare a string with a matrix
    if (isString(x) || isString(y)) {
      return x < y;
    }

    if (isBoolean(x) || x === null) {
      return smaller(+x, y);
    }
    if (isBoolean(y) || y === null) {
      return smaller(x, +y);
    }

    if (isComplex(x) || isComplex(y)) {
      throw new TypeError('No ordering relation is defined for complex numbers');
    }

    throw new math.error.UnsupportedTypeError('smaller', math['typeof'](x), math['typeof'](y));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],94:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      nearlyEqual = util.number.nearlyEqual,
      isBoolean = util['boolean'].isBoolean,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Test whether value x is smaller or equal to y.
   *
   * The function returns true when x is smaller than y or the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.smallerEq(x, y)
   *
   * Examples:
   *
   *    math.smaller(1 + 2, 3);        // returns false
   *    math.smallerEq(1 + 2, 3);      // returns true
   *
   * See also:
   *
   *    equal, unequal, smaller, larger, largerEq, compare
   *
   * @param  {Number | BigNumber | Boolean | Unit | String | Array | Matrix | null} x First value to compare
   * @param  {Number | BigNumber | Boolean | Unit | String | Array | Matrix | null} y Second value to compare
   * @return {Boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
   */
  math.smallerEq = function smallerEq(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('smallerEq', arguments.length, 2);
    }

    if (isNumber(x) && isNumber(y)) {
      return nearlyEqual(x, y, config.epsilon) || x < y;
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y) || y === null) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return x.lte(y);
      }

      // downgrade to Number
      return smallerEq(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x) || x === null) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return x.lte(y)
      }

      // downgrade to Number
      return smallerEq(x, y.toNumber());
    }

    if ((isUnit(x)) && (isUnit(y))) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return x.value <= y.value;
    }

    if (isCollection(x) || isCollection(y)) {
      return collection.deepMap2(x, y, smallerEq);
    }

    // Note: test strings after testing collections,
    // else we can't compare a string with a matrix
    if (isString(x) || isString(y)) {
      return x <= y;
    }

    if (isBoolean(x) || x === null) {
      return smallerEq(+x, y);
    }
    if (isBoolean(y) || y === null) {
      return smallerEq(x, +y);
    }

    if (isComplex(x) || isComplex(y)) {
      throw new TypeError('No ordering relation is defined for complex numbers');
    }

    throw new math.error.UnsupportedTypeError('smallerEq', math['typeof'](x), math['typeof'](y));
  };

  // TODO: deprecated since version 0.23.0, cleanup some day
  math.smallereq = function () {
    throw new Error('Function smallereq is renamed to smallerEq');
  }
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],95:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      nearlyEqual = util.number.nearlyEqual,
      isBoolean = util['boolean'].isBoolean,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Test whether two values are unequal.
   *
   * The function tests whether the relative difference between x and y is
   * larger than the configured epsilon. The function cannot be used to compare
   * values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * In case of complex numbers, x.re must unequal y.re, or x.im must unequal y.im.
   *
   * Values `null` and `undefined` are compared strictly, thus `null` is unequal
   * with everything except `null`, and `undefined` is unequal with everying
   * except. `undefined`.
   *
   * Syntax:
   *
   *    math.unequal(x, y)
   *
   * Examples:
   *
   *    math.unequal(2 + 2, 3);       // returns true
   *    math.unequal(2 + 2, 4);       // returns false
   *
   *    var a = math.unit('50 cm');
   *    var b = math.unit('5 m');
   *    math.unequal(a, b);           // returns false
   *
   *    var c = [2, 5, 1];
   *    var d = [2, 7, 1];
   *
   *    math.unequal(c, d);           // returns [false, true, false]
   *    math.deepEqual(c, d);         // returns false
   *
   *    math.unequal(0, null);        // returns true
   * See also:
   *
   *    equal, deepEqual, smaller, smallerEq, larger, largerEq, compare
   *
   * @param  {Number | BigNumber | Boolean | Complex | Unit | String | Array | Matrix | null | undefined} x First value to compare
   * @param  {Number | BigNumber | Boolean | Complex | Unit | String | Array | Matrix | null | undefined} y Second value to compare
   * @return {Boolean | Array | Matrix} Returns true when the compared values are unequal, else returns false
   */
  math.unequal = function unequal(x, y) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('unequal', arguments.length, 2);
    }

    if (isNumber(x)) {
      if (isNumber(y)) {
        return !nearlyEqual(x, y, config.epsilon);
      }
      else if (isComplex(y)) {
        return !nearlyEqual(x, y.re, config.epsilon) || !nearlyEqual(y.im, 0, config.epsilon);
      }
    }

    if (isComplex(x)) {
      if (isNumber(y)) {
        return !nearlyEqual(x.re, y, config.epsilon) || !nearlyEqual(x.im, 0, config.epsilon);
      }
      else if (isComplex(y)) {
        return !nearlyEqual(x.re, y.re, config.epsilon) || !nearlyEqual(x.im, y.im, config.epsilon);
      }
    }

    if (x instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(y)) {
        y = BigNumber.convert(y);
      }
      else if (isBoolean(y)) {
        y = new BigNumber(y ? 1 : 0);
      }

      if (y instanceof BigNumber) {
        return !x.eq(y);
      }

      // downgrade to Number
      return unequal(x.toNumber(), y);
    }
    if (y instanceof BigNumber) {
      // try to convert to big number
      if (isNumber(x)) {
        x = BigNumber.convert(x);
      }
      else if (isBoolean(x)) {
        x = new BigNumber(x ? 1 : 0);
      }

      if (x instanceof BigNumber) {
        return !x.eq(y)
      }

      // downgrade to Number
      return unequal(x, y.toNumber());
    }

    if ((isUnit(x)) && (isUnit(y))) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return x.value != y.value;
    }

    if (isCollection(x) || isCollection(y)) {
      return collection.deepMap2(x, y, unequal);
    }

    // Note: test strings after testing collections,
    // else we can accidentally compare a stringified array with a string
    if (isString(x) || isString(y)) {
      return x != y;
    }

    if (isBoolean(x)) {
      return unequal(+x, y);
    }
    if (isBoolean(y)) {
      return unequal(x, +y);
    }

    if (x === null) {
      return y !== null;
    }
    if (y === null) {
      return x !== null;
    }

    if (x === undefined) {
      return y !== undefined;
    }
    if (y === undefined) {
      return x !== undefined;
    }

    throw new math.error.UnsupportedTypeError('unequal', math['typeof'](x), math['typeof'](y));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],96:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isCollection = collection.isCollection,
      isComplex = Complex.isComplex;

  /**
   * Compute the argument of a complex value.
   * For a complex number `a + bi`, the argument is computed as `atan2(b, a)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.arg(x)
   *
   * Examples:
   *
   *    var a = math.complex(2, 2);
   *    math.arg(a) / math.pi;          // returns Number 0.25
   *
   *    var b = math.complex('2 + 3i');
   *    math.arg(b);                    // returns Number 0.982793723247329
   *    math.atan2(3, 2);               // returns Number 0.982793723247329
   *
   * See also:
   *
   *    re, im, conj, abs
   *
   * @param {Number | Complex | Array | Matrix | Boolean | null} x
   *            A complex number or array with complex numbers
   * @return {Number | Array | Matrix} The argument of x
   */
  math.arg = function arg(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('arg', arguments.length, 1);
    }

    if (isNumber(x)) {
      return Math.atan2(0, x);
    }

    if (isComplex(x)) {
      return Math.atan2(x.im, x.re);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, arg);
    }

    if (isBoolean(x) || x === null) {
      return arg(+x);
    }

    if (x instanceof BigNumber) {
      // downgrade to Number
      // TODO: implement BigNumber support
      return arg(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('arg', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],97:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      object = util.object,
      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isCollection =collection.isCollection,
      isComplex = Complex.isComplex;

  /**
   * Compute the complex conjugate of a complex value.
   * If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.conj(x)
   *
   * Examples:
   *
   *    math.conj(math.complex('2 + 3i'));  // returns Complex 2 - 3i
   *    math.conj(math.complex('2 - 3i'));  // returns Complex 2 + 3i
   *    math.conj(math.complex('-5.2i'));  // returns Complex 5.2i
   *
   * See also:
   *
   *    re, im, arg, abs
   *
   * @param {Number | BigNumber | Complex | Array | Matrix | Boolean | null} x
   *            A complex number or array with complex numbers
   * @return {Number | BigNumber | Complex | Array | Matrix}
   *            The complex conjugate of x
   */
  math.conj = function conj(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('conj', arguments.length, 1);
    }

    if (isNumber(x)) {
      return x;
    }

    if (x instanceof BigNumber) {
      return new BigNumber(x);
    }

    if (isComplex(x)) {
      return new Complex(x.re, -x.im);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, conj);
    }

    if (isBoolean(x) || x === null) {
      return +x;
    }

    // return a clone of the value for non-complex values
    return object.clone(x);
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],98:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      object = util.object,
      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isCollection = collection.isCollection,
      isComplex = Complex.isComplex;

  /**
   * Get the real part of a complex number.
   * For a complex number `a + bi`, the function returns `a`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.re(x)
   *
   * Examples:
   *
   *    var a = math.complex(2, 3);
   *    math.re(a);                     // returns Number 2
   *    math.im(a);                     // returns Number 3
   *
   *    math.re(math.complex('-5.2i')); // returns Number 0
   *    math.re(math.complex(2.4));     // returns Number 2.4
   *
   * See also:
   *
   *    im, conj, abs, arg
   *
   * @param {Number | BigNumber | Complex | Array | Matrix | Boolean | null} x
   *            A complex number or array with complex numbers
   * @return {Number | BigNumber | Array | Matrix} The real part of x
   */
  math.re = function re(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('re', arguments.length, 1);
    }

    if (isNumber(x)) {
      return x;
    }

    if (x instanceof BigNumber) {
      return new BigNumber(x);
    }

    if (isComplex(x)) {
      return x.re;
    }

    if (isCollection(x)) {
      return collection.deepMap(x, re);
    }

    if (isBoolean(x) || x === null) {
      return +x;
    }

    // return a clone of the value itself for all non-complex values
    return object.clone(x);
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],99:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isCollection =collection.isCollection,
      isComplex = Complex.isComplex;

  /**
   * Get the imaginary part of a complex number.
   * For a complex number `a + bi`, the function returns `b`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.im(x)
   *
   * Examples:
   *
   *    var a = math.complex(2, 3);
   *    math.re(a);                     // returns Number 2
   *    math.im(a);                     // returns Number 3
   *
   *    math.re(math.complex('-5.2i')); // returns Number -5.2
   *    math.re(math.complex(2.4));     // returns Number 0
   *
   * See also:
   *
   *    re, conj, abs, arg
   *
   * @param {Number | BigNumber | Complex | Array | Matrix | Boolean | null} x
   *            A complex number or array with complex numbers
   * @return {Number | BigNumber | Array | Matrix} The imaginary part of x
   */
  math.im = function im(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('im', arguments.length, 1);
    }

    if (isNumber(x)) {
      return 0;
    }

    if (x instanceof BigNumber) {
      return new BigNumber(0);
    }

    if (isComplex(x)) {
      return x.im;
    }

    if (isCollection(x)) {
      return collection.deepMap(x, im);
    }

    if (isBoolean(x) || x === null) {
      return 0;
    }

    // return 0 for all non-complex values
    return 0;
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],100:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      // take the BigNumber instance the provided math.js instance
      BigNumber = math.type.BigNumber,
      collection = require('../../type/collection'),

      isCollection = collection.isCollection,
      isNumber = util.number.isNumber,
      isString = util.string.isString,
      isBoolean = util['boolean'].isBoolean;

  /**
   * Create a BigNumber, which can store numbers with arbitrary precision.
   * When a matrix is provided, all elements will be converted to BigNumber.
   *
   * Syntax:
   *
   *    math.bignumber(x)
   *
   * Examples:
   *
   *    0.1 + 0.2;                                  // returns Number 0.30000000000000004
   *    math.bignumber(0.1) + math.bignumber(0.2);  // returns BigNumber 0.3
   *
   *
   *    7.2e500;                                    // returns Number Infinity
   *    math.bignumber('7.2e500');                  // returns BigNumber 7.2e500
   *
   * See also:
   *
   *    boolean, complex, index, matrix, string, unit
   *
   * @param {Number | String | Array | Matrix | Boolean | null} [value]  Value for the big number,
   *                                                    0 by default.
   * @returns {BigNumber} The created bignumber
   */
  math.bignumber = function bignumber(value) {
    if (arguments.length > 1) {
      throw new math.error.ArgumentsError('bignumber', arguments.length, 0, 1);
    }

    if ((value instanceof BigNumber) || isNumber(value) || isString(value)) {
      return new BigNumber(value);
    }

    if (isBoolean(value) || value === null) {
      return new BigNumber(+value);
    }

    if (isCollection(value)) {
      return collection.deepMap(value, bignumber);
    }

    if (arguments.length == 0) {
      return new BigNumber(0);
    }

    throw new math.error.UnsupportedTypeError('bignumber', math['typeof'](value));
  };
};

},{"../../util/index":178,"../../type/collection":52}],101:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      collection = require('../../type/collection'),

      isCollection = collection.isCollection,
      isNumber = util.number.isNumber,
      isString = util.string.isString;

  /**
   * Create a boolean or convert a string or number to a boolean.
   * In case of a number, `true` is returned for non-zero numbers, and `false` in
   * case of zero.
   * Strings can be `'true'` or `'false'`, or can contain a number.
   * When value is a matrix, all elements will be converted to boolean.
   *
   * Syntax:
   *
   *    math.boolean(x)
   *
   * Examples:
   *
   *    math.boolean(0);     // returns false
   *    math.boolean(1);     // returns true
   *    math.boolean(-3);     // returns true
   *    math.boolean('true');     // returns true
   *    math.boolean('false');     // returns false
   *    math.boolean([1, 0, 1, 1]);     // returns [true, false, true, true]
   *
   * See also:
   *
   *    bignumber, complex, index, matrix, string, unit
   *
   * @param {String | Number | Boolean | Array | Matrix | null} value  A value of any type
   * @return {Boolean | Array | Matrix} The boolean value
   */
  math['boolean'] = function bool (value) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('boolean', arguments.length, 0, 1);
    }

    if (value === 'true' || value === true) {
      return true;
    }

    if (value === 'false' || value === false || value === null) {
      return false;
    }

    if (value instanceof Boolean) {
      return value == true;
    }

    if (isNumber(value)) {
      return (value !== 0);
    }

    if (value instanceof BigNumber) {
      return !value.isZero();
    }

    if (isString(value)) {
      // try case insensitive
      var lcase = value.toLowerCase();
      if (lcase === 'true') {
        return true;
      }
      else if (lcase === 'false') {
        return false;
      }

      // test whether value is a valid number
      var num = Number(value);
      if (value != '' && !isNaN(num)) {
        return (num !== 0);
      }
    }

    if (isCollection(value)) {
      return collection.deepMap(value, bool);
    }

    throw new SyntaxError(value.toString() + ' is no valid boolean');
  };
};

},{"../../util/index":178,"../../type/collection":52}],102:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isCollection = collection.isCollection,
      isNumber = util.number.isNumber,
      isString = util.string.isString,
      isComplex = Complex.isComplex;

  /**
   * Create a complex value or convert a value to a complex value.
   *
   * Syntax:
   *
   *     math.complex()                           // creates a complex value with zero
   *                                              // as real and imaginary part.
   *     math.complex(re : number, im : string)   // creates a complex value with provided
   *                                              // values for real and imaginary part.
   *     math.complex(re : number)                // creates a complex value with provided
   *                                              // real value and zero imaginary part.
   *     math.complex(complex : Complex)          // clones the provided complex value.
   *     math.complex(arg : string)               // parses a string into a complex value.
   *     math.complex(array : Array)              // converts the elements of the array
   *                                              // or matrix element wise into a
   *                                              // complex value.
   *     math.complex({re: number, im: number})   // creates a complex value with provided
   *                                              // values for real an imaginary part.
   *     math.complex({r: number, phi: number})   // creates a complex value with provided
   *                                              // polar coordinates
   *
   * Examples:
   *
   *    var a = math.complex(3, -4);     // a = Complex 3 - 4i
   *    a.re = 5;                        // a = Complex 5 - 4i
   *    var i = a.im;                    // Number -4;
   *    var b = math.complex('2 + 6i');  // Complex 2 + 6i
   *    var c = math.complex();          // Complex 0 + 0i
   *    var d = math.add(a, b);          // Complex 5 + 2i
   *
   * See also:
   *
   *    bignumber, boolean, index, matrix, number, string, unit
   *
   * @param {* | Array | Matrix} [args]
   *            Arguments specifying the real and imaginary part of the complex number
   * @return {Complex | Array | Matrix} Returns a complex value
   */
  math.complex = function complex(args) {
    switch (arguments.length) {
      case 0:
        // no parameters. Set re and im zero
        return new Complex(0, 0);

      case 1:
        // parse string into a complex number
        var arg = arguments[0];

        if (isNumber(arg)) {
          return new Complex(arg, 0);
        }

        if (arg instanceof BigNumber) {
          // convert to Number
          return new Complex(arg.toNumber(), 0);
        }

        if (isComplex(arg)) {
          // create a clone
          return arg.clone();
        }

        if (isString(arg)) {
          var c = Complex.parse(arg);
          if (c) {
            return c;
          }
          else {
            throw new SyntaxError('String "' + arg + '" is no valid complex number');
          }
        }

        if (isCollection(arg)) {
          return collection.deepMap(arg, complex);
        }

        if (typeof arg === 'object') {
          if('re' in arg && 'im' in arg) {
            return new Complex(arg.re, arg.im);
          } else if ('r' in arg && 'phi' in arg) {
            return Complex.fromPolar(arg.r, arg.phi);
          }
        } 

        throw new TypeError('Two numbers, single string or an fitting object expected in function complex');

      case 2:
        // re and im provided
        var re = arguments[0],
            im = arguments[1];

        // convert re to number
        if (re instanceof BigNumber) {
          re = re.toNumber();
        }

        // convert im to number
        if (im instanceof BigNumber) {
          im = im.toNumber();
        }

        if (isNumber(re) && isNumber(im)) {
          return new Complex(re, im);
        }
        else {
          throw new TypeError('Two numbers or a single string expected in function complex');
        }

      default:
        throw new math.error.ArgumentsError('complex', arguments.length, 0, 2);
    }
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],103:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Index = require('../../type/Index');

  /**
   * Create an index. An Index can store ranges having start, step, and end
   * for multiple dimensions.
   * Matrix.get, Matrix.set, and math.subset accept an Index as input.
   *
   * Syntax:
   *
   *     math.index(range1, range2, ...)
   *
   * Where:
   *
   * Each range can be any of:
   *
   * - An array [start, end]
   * - An array [start, end, step]
   * - A number
   * - An instance of `Range`
   *
   * The parameters start, end, and step must be integer numbers. Start and end
   * are zero based. The start of a range is included, the end is excluded.
   *
   * Examples:
   *
   *    var math = math.js
   *
   *    var b = [1, 2, 3, 4, 5];
   *    math.subset(b, math.index([1, 3]));     // returns [2, 3]
   *
   *    var a = math.matrix([[1, 2], [3, 4]]);
   *    a.subset(math.index(0, 1));             // returns 2
   *    a.subset(math.index(1, null));          // returns [3, 4]
   *
   * See also:
   *
   *    bignumber, boolean, complex, matrix, number, string, unit
   *
   * @param {...*} ranges   Zero or more ranges or numbers.
   * @return {Index}        Returns the created index
   */
  math.index = function(ranges) {
    // downgrade BigNumber to Number
    var args = Array.prototype.slice.apply(arguments).map(function (arg) {
      if (arg instanceof BigNumber) {
        return arg.toNumber();
      }
      else if (Array.isArray(arg)) {
        return arg.map(function (elem) {
          return (elem instanceof BigNumber) ? elem.toNumber() : elem;
        });
      }
      else {
        return arg;
      }
    });

    var res = new Index();
    Index.apply(res, args);
    return res;
  };
};

},{"../../util/index":178,"../../type/Index":48}],104:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),
      Matrix = require('../../type/Matrix');

  /**
   * Create a Matrix. The function creates a new `math.type.Matrix` object from
   * an `Array`. A Matrix has utility functions to manipulate the data in the
   * matrix, like getting the size and getting or setting values in the matrix.
   *
   * Syntax:
   *
   *    math.matrix()      // creates an empty matrix
   *    math.matrix(data)  // creates a matrix with initial data.
   *
   * Examples:
   *
   *    var m = math.matrix([[1, 2], [3, 4]);
   *    m.size();                        // Array [2, 2]
   *    m.resize([3, 2], 5);
   *    m.valueOf();                     // Array [[1, 2], [3, 4], [5, 5]]
   *    m.get([1, 0])                    // number 3
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, number, string, unit
   *
   * @param {Array | Matrix} [data]    A multi dimensional array
   * @return {Matrix} The created matrix
   */
  math.matrix = function matrix(data) {
    if (arguments.length > 1) {
      throw new math.error.ArgumentsError('matrix', arguments.length, 0, 1);
    }

    return new Matrix(data);
  };
};

},{"../../util/index":178,"../../type/Matrix":49}],105:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index');

  var BigNumber = math.type.BigNumber;
  var Unit = math.type.Unit;
  var collection = require('../../type/collection');

  var isCollection = collection.isCollection;
  var isNumber = util.number.isNumber;
  var isBoolean = util['boolean'].isBoolean;
  var isString = util.string.isString;

  /**
   * Create a number or convert a string, boolean, or unit to a number.
   * When value is a matrix, all elements will be converted to number.
   *
   * Syntax:
   *
   *    math.number(value)
   *    math.number(unit, valuelessUnit)
   *
   * Examples:
   *
   *    math.number(2);                         // returns number 2
   *    math.number('7.2');                     // returns number 7.2
   *    math.number(true);                      // returns number 1
   *    math.number([true, false, true, true]); // returns [1, 0, 1, 1]
   *    math.number(math.unit('52cm'), 'm');    // returns 0.52
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, string, unit
   *
   * @param {String | Number | Boolean | Array | Matrix | Unit | null} [value]  Value to be converted
   * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
   * @return {Number | Array | Matrix} The created number
   */
  math.number = function number (value, valuelessUnit) {
    switch (arguments.length) {
      case 0:
        return 0;

      case 1:
        if (isCollection(value)) {
          return collection.deepMap(value, number);
        }

        if (value instanceof BigNumber) {
          return value.toNumber();
        }

        if (isString(value)) {
          var num = Number(value);
          if (isNaN(num)) {
            num = Number(value.valueOf());
          }
          if (isNaN(num)) {
            throw new SyntaxError(value.toString() + ' is no valid number');
          }
          return num;
        }

        if (isBoolean(value) || value === null) {
          return +value;
        }

        if (isNumber(value)) {
          return value;
        }

        if (value instanceof Unit) {
          throw new Error('Second argument with valueless unit expected');
        }

        throw new math.error.UnsupportedTypeError('number', math['typeof'](value));

      case 2:
        if (value instanceof Unit && isString(valuelessUnit) || valuelessUnit instanceof Unit) {
          return value.toNumber(valuelessUnit);
        }

        throw new math.error.UnsupportedTypeError('number', math['typeof'](value), math['typeof'](valuelessUnit));


      default:
        throw new math.error.ArgumentsError('number', arguments.length, 0, 1);
    }
  };
};

},{"../../util/index":178,"../../type/collection":52}],106:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var Parser = require('../../expression/Parser');

  /**
   * Create a parser. The function creates a new `math.expression.Parser` object.
   *
   * Syntax:
   *
   *    math.parser()
   *
   * Examples:
   *
   *     var parser = new math.parser();
   *
   *     // evaluate expressions
   *     var a = parser.eval('sqrt(3^2 + 4^2)'); // 5
   *     var b = parser.eval('sqrt(-4)');        // 2i
   *     var c = parser.eval('2 inch in cm');    // 5.08 cm
   *     var d = parser.eval('cos(45 deg)');     // 0.7071067811865476
   *
   *     // define variables and functions
   *     parser.eval('x = 7 / 2');               // 3.5
   *     parser.eval('x + 3');                   // 6.5
   *     parser.eval('function f(x, y) = x^y');  // f(x, y)
   *     parser.eval('f(2, 3)');                 // 8
   *
   *     // get and set variables and functions
   *     var x = parser.get('x');                // 7
   *     var f = parser.get('f');                // function
   *     var g = f(3, 2);                        // 9
   *     parser.set('h', 500);
   *     var i = parser.eval('h / 2');           // 250
   *     parser.set('hello', function (name) {
   *       return 'hello, ' + name + '!';
   *     });
   *     parser.eval('hello("user")');           // "hello, user!"
   *
   *     // clear defined functions and variables
   *     parser.clear();
   *
   * See also:
   *
   *    eval, compile, parse
   *
   * @return {Parser} Parser
   */
  math.parser = function parser() {
    return new Parser(math);
  };
};

},{"../../expression/Parser":55}],107:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      collection = require('../../type/collection'),

      number = util.number,
      isNumber = util.number.isNumber,
      isCollection = collection.isCollection;

  /**
   * Create a string or convert any object into a string.
   * Elements of Arrays and Matrices are processed element wise.
   *
   * Syntax:
   *
   *    math.string(value)
   *
   * Examples:
   *
   *    math.string(4.2);               // returns string '4.2'
   *    math.string(math.complex(3, 2); // returns string '3 + 2i'
   *
   *    var u = math.unit(5, 'km');
   *    math.string(u.to('m'));         // returns string '5000 m'
   *
   *    math.string([true, false]);     // returns ['true', 'false']
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, number, unit
   *
   * @param {* | Array | Matrix | null} [value]  A value to convert to a string
   * @return {String | Array | Matrix} The created string
   */
  math.string = function string (value) {
    switch (arguments.length) {
      case 0:
        return '';

      case 1:
        if (isNumber(value)) {
          return number.format(value);
        }

        if (isCollection(value)) {
          return collection.deepMap(value, string);
        }

        if (value === null) {
          return 'null';
        }

        return value.toString();

      default:
        throw new math.error.ArgumentsError('string', arguments.length, 0, 1);
    }
  };
};

},{"../../util/index":178,"../../type/collection":52}],108:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isCollection = collection.isCollection,
      isString = util.string.isString;

  /**
   * Create a unit. Depending on the passed arguments, the function
   * will create and return a new math.type.Unit object.
   * When a matrix is provided, all elements will be converted to units.
   *
   * Syntax:
   *
   *     math.unit(unit : string)
   *     math.unit(value : number, unit : string)
   *
   * Examples:
   *
   *    var a = math.unit(5, 'cm');    // returns Unit 50 mm
   *    var b = math.unit('23 kg');    // returns Unit 23 kg
   *    a.to('m');                     // returns Unit 0.05 m
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, number, string
   *
   * @param {* | Array | Matrix} args   A number and unit.
   * @return {Unit | Array | Matrix}    The created unit
   */
  math.unit = function unit(args) {
    switch(arguments.length) {
      case 1:
        // parse a string
        var arg = arguments[0];

        if (arg instanceof Unit) {
          // create a clone of the unit
          return arg.clone();
        }

        if (isString(arg)) {
          if (Unit.isValuelessUnit(arg)) {
            return new Unit(null, arg); // a pure unit
          }

          var u = Unit.parse(arg);        // a unit with value, like '5cm'
          if (u) {
            return u;
          }

          throw new SyntaxError('String "' + arg + '" is no valid unit');
        }

        if (isCollection(args)) {
          return collection.deepMap(args, unit);
        }

        throw new TypeError('A string or a number and string expected in function unit');

      case 2:
        // a number and a unit

        if (arguments[0] instanceof BigNumber) {
          // convert value to number
          return new Unit(arguments[0].toNumber(), arguments[1]);
        }
        else {
          return new Unit(arguments[0], arguments[1]);
        }

      default:
        throw new math.error.ArgumentsError('unit', arguments.length, 1, 2);
    }
  };
};

},{"../../util/index":178,"../../type/Unit":50,"../../type/collection":52}],110:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      Matrix = require('../../type/Matrix'),

      object = util.object,
      string = util.string;

  /**
   * Calculate the determinant of a matrix.
   *
   * Syntax:
   *
   *    math.det(x)
   *
   * Examples:
   *
   *    math.det([[1, 2], [3, 4]]); // returns -2
   *
   *    var A = [
   *      [-2, 2, 3],
   *      [-1, 1, 3],
   *      [2, 0, -1]
   *    ]
   *    math.det(A); // returns 6
   *
   * See also:
   *
   *    inv
   *
   * @param {Array | Matrix} x  A matrix
   * @return {Number} The determinant of `x`
   */
  math.det = function det (x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('det', arguments.length, 1);
    }

    var size;
    if (x instanceof Matrix) {
      size = x.size();
    }
    else if (x instanceof Array) {
      x = new Matrix(x);
      size = x.size();
    }
    else {
      // a scalar
      size = [];
    }

    switch (size.length) {
      case 0:
        // scalar
        return object.clone(x);

      case 1:
        // vector
        if (size[0] == 1) {
          return object.clone(x.valueOf()[0]);
        }
        else {
          throw new RangeError('Matrix must be square ' +
              '(size: ' + string.format(size) + ')');
        }

      case 2:
        // two dimensional array
        var rows = size[0];
        var cols = size[1];
        if (rows == cols) {
          return _det(x.clone().valueOf(), rows, cols);
        }
        else {
          throw new RangeError('Matrix must be square ' +
              '(size: ' + string.format(size) + ')');
        }

      default:
        // multi dimensional array
        throw new RangeError('Matrix must be two dimensional ' +
            '(size: ' + string.format(size) + ')');
    }
  };

  /**
   * Calculate the determinant of a matrix
   * @param {Array[]} matrix  A square, two dimensional matrix
   * @param {Number} rows     Number of rows of the matrix (zero-based)
   * @param {Number} cols     Number of columns of the matrix (zero-based)
   * @returns {Number} det
   * @private
   */
  function _det (matrix, rows, cols) {
    if (rows == 1) {
      // this is a 1 x 1 matrix
      return object.clone(matrix[0][0]);
    }
    else if (rows == 2) {
      // this is a 2 x 2 matrix
      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12
      return math.subtract(
          math.multiply(matrix[0][0], matrix[1][1]),
          math.multiply(matrix[1][0], matrix[0][1])
      );
    }
    else {
      // this is an n x n matrix
      var compute_mu = function (matrix) {
        var i, j;

        // Compute the matrix with zero lower triangle, same upper triangle,
        // and diagonals given by the negated sum of the below diagonal
        // elements.
        var mu = new Array(matrix.length);
        var sum = 0;
        for (i = 1; i < matrix.length; i++) {
          sum = math.add(sum, matrix[i][i]);
        }

        for (i = 0; i < matrix.length; i++) {
          mu[i] = new Array(matrix.length);
          mu[i][i] = math.unaryMinus(sum);

          for (j = 0; j < i; j++) {
            mu[i][j] = 0; // TODO: make bignumber 0 in case of bignumber computation
          }

          for (j = i + 1; j < matrix.length; j++) {
            mu[i][j] = matrix[i][j];
          }

          if (i+1 < matrix.length) {
            sum = math.subtract(sum, matrix[i + 1][i + 1]);
          }
        }

        return mu;
      };

      var fa = matrix;
      for (var i = 0; i < rows - 1; i++) {
        fa = math.multiply(compute_mu(fa), matrix);
      }

      if (rows % 2 == 0) {
        return math.unaryMinus(fa[0][0]);
      } else {
        return fa[0][0];
      }
    }
  }
};

},{"../../util/index":178,"../../type/Matrix":49}],111:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Matrix = require('../../type/Matrix'),

      object = util.object,
      isArray = util.array.isArray,
      isNumber = util.number.isNumber,
      isInteger = util.number.isInteger;

  /**
   * Create a diagonal matrix or retrieve the diagonal of a matrix
   *
   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
   * When k is positive, the values are placed on the super diagonal.
   * When k is negative, the values are placed on the sub diagonal.
   *
   * Syntax:
   *
   *     math.diag(X)
   *     math.diag(X, k)
   *
   * Examples:
   *
   *     // create a diagonal matrix
   *     math.diag([1, 2, 3]);      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
   *     math.diag([1, 2, 3], 1);   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]
   *     math.diag([1, 2, 3], -1);  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]
   *
   *    // retrieve the diagonal from a matrix
   *    var a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
   *    math.diag(a);   // returns [1, 5, 9]
   *
   * See also:
   *
   *     ones, zeros, eye
   *
   * @param {Matrix | Array} x          A two dimensional matrix or a vector
   * @param {Number | BigNumber} [k=0]  The diagonal where the vector will be filled
   *                                    in or retrieved.
   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.
   */
  math.diag = function diag (x, k) {
    var data, vector, i, iMax;

    if (arguments.length != 1 && arguments.length != 2) {
      throw new math.error.ArgumentsError('diag', arguments.length, 1, 2);
    }

    if (k) {
      // convert BigNumber to a number
      if (k instanceof BigNumber) k = k.toNumber();

      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError ('Second parameter in function diag must be an integer');
      }
    }
    else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;

    // check type of input
    var asArray;
    if (x instanceof Matrix) {
      asArray = false;
    }
    else if (isArray(x)) {
      // convert to matrix
      x = new Matrix(x);
      asArray = true;
    }
    else {
      throw new TypeError ('First parameter in function diag must be a Matrix or Array');
    }

    var s = x.size();
    switch (s.length) {
      case 1:
        // x is a vector. create diagonal matrix
        vector = x.valueOf();
        var matrix = new Matrix();
        var defaultValue = (vector[0] instanceof BigNumber) ? new BigNumber(0) : 0;
        matrix.resize([vector.length + kSub, vector.length + kSuper], defaultValue);
        data = matrix.valueOf();
        iMax = vector.length;
        for (i = 0; i < iMax; i++) {
          data[i + kSub][i + kSuper] = object.clone(vector[i]);
        }
        return asArray ? matrix.valueOf() : matrix;

      case 2:
        // x is a matrix get diagonal from matrix
        vector = [];
        data = x.valueOf();
        iMax = Math.min(s[0] - kSub, s[1] - kSuper);
        for (i = 0; i < iMax; i++) {
          vector[i] = object.clone(data[i + kSub][i + kSuper]);
        }
        return asArray ? vector : new Matrix(vector);

      default:
        throw new RangeError('Matrix for function diag must be 2 dimensional');
    }
  };
};

},{"../../util/index":178,"../../type/Matrix":49}],112:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isInteger = util.number.isInteger,
      isArray = Array.isArray;

  /**
   * Create a 2-dimensional identity matrix with size m x n or n x n.
   * The matrix has ones on the diagonal and zeros elsewhere.
   *
   * Syntax:
   *
   *    math.eye(n)
   *    math.eye(m, n)
   *    math.eye([m, n])
   *
   * Examples:
   *
   *    math.eye(3);                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
   *    math.eye(3, 2);                 // returns [[1, 0], [0, 1], [0, 0]]
   *
   *    var A = [[1, 2, 3], [4, 5, 6]];
   *    math.eye(math.size(b));         // returns [[1, 0, 0], [0, 1, 0]]
   *
   * See also:
   *
   *    diag, ones, zeros, size, range
   *
   * @param {...Number | Matrix | Array} size   The size for the matrix
   * @return {Matrix | Array | Number} A matrix with ones on the diagonal.
   */
  math.eye = function eye (size) {
    var args = collection.argsToArray(arguments),
        asMatrix = (size instanceof Matrix) ? true :
        (isArray(size) ? false : (config.matrix === 'matrix'));


    if (args.length == 0) {
      // return an empty array
      return asMatrix ? new Matrix() : [];
    }
    else if (args.length == 1) {
      // change to a 2-dimensional square
      args[1] = args[0];
    }
    else if (args.length > 2) {
      // error in case of an n-dimensional size
      throw new math.error.ArgumentsError('eye', args.length, 0, 2);
    }

    var rows = args[0],
        cols = args[1];

    if (rows instanceof BigNumber) rows = rows.toNumber();
    if (cols instanceof BigNumber) cols = cols.toNumber();

    if (!isNumber(rows) || !isInteger(rows) || rows < 1) {
      throw new Error('Parameters in function eye must be positive integers');
    }
    if (!isNumber(cols) || !isInteger(cols) || cols < 1) {
      throw new Error('Parameters in function eye must be positive integers');
    }

    // convert arguments from bignumber to numbers if needed
    var asBigNumber = false;
    args = args.map(function (value) {
      if (value instanceof BigNumber) {
        asBigNumber = true;
        return value.toNumber();
      } else {
        return value;
      }
    });

    // create the matrix
    var matrix = new Matrix();
    var one = asBigNumber ? new BigNumber(1) : 1;
    var defaultValue = asBigNumber ? new BigNumber(0) : 0;
    matrix.resize(args, defaultValue);

    // fill in ones on the diagonal
    var minimum = math.min(args);
    var data = matrix.valueOf();
    for (var d = 0; d < minimum; d++) {
      data[d][d] = one;
    }

    return asMatrix ? matrix : matrix.valueOf();
  };
};

},{"../../util/index":178,"../../type/Matrix":49,"../../type/collection":52}],113:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index');

  var Matrix = require('../../type/Matrix');

  var object = util.object;
  var array = util.array;
  var isArray = Array.isArray;

  /**
   * Flatten a multi dimensional matrix into a single dimensional matrix.
   *
   * Syntax:
   *
   *    math.flatten(x)
   *
   * Examples:
   *
   *    math.flatten([[1,2], [3,4]]);   // returns [1, 2, 3, 4]
   *
   * See also:
   *
   *    concat, resize, size, squeeze
   *
   * @param {Matrix | Array} x   Matrix to be flattened
   * @return {Matrix | Array} Returns the flattened matrix
   */
  math.flatten = function flatten (x) {
    if (arguments.length !== 1) {
      throw new math.error.ArgumentsError('flatten', arguments.length, 1);
    }

    if (x instanceof Matrix) {
      var clone = object.clone(x.toArray());
      var flat = array.flatten(clone);
      return new Matrix(flat);
    }

    if (isArray(x)) {
      return array.flatten(object.clone(x));
    }

    throw new math.error.UnsupportedTypeError('flatten', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Matrix":49}],114:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),
      string = util.string,

      Matrix = require('../../type/Matrix');

  /**
   * Calculate the inverse of a square matrix.
   *
   * Syntax:
   *
   *     math.inv(x)
   *
   * Examples:
   *
   *     math.inv([[1, 2], [3, 4]]);  // returns [[-2, 1], [1.5, -0.5]]
   *     math.inv(4);                 // returns 0.25
   *     1 / 4;                       // returns 0.25
   *
   * See also:
   *
   *     det, transpose
   *
   * @param {Number | Complex | Array | Matrix} x     Matrix to be inversed
   * @return {Number | Complex | Array | Matrix} The inverse of `x`.
   */
  math.inv = function inv (x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('inv', arguments.length, 1);
    }
    var size = math.size(x).valueOf();
    switch (size.length) {
      case 0:
        // scalar
        return math.divide(1, x);

      case 1:
        // vector
        if (size[0] == 1) {
          if (x instanceof Matrix) {
            return new Matrix([
              math.divide(1, x.valueOf()[0])
            ]);
          }
          else {
            return [
              math.divide(1, x[0])
            ];
          }
        }
        else {
          throw new RangeError('Matrix must be square ' +
              '(size: ' + string.format(size) + ')');
        }

      case 2:
        // two dimensional array
        var rows = size[0];
        var cols = size[1];
        if (rows == cols) {
          if (x instanceof Matrix) {
            return new Matrix(
                _inv(x.valueOf(), rows, cols)
            );
          }
          else {
            // return an Array
            return _inv(x, rows, cols);
          }
        }
        else {
          throw new RangeError('Matrix must be square ' +
              '(size: ' + string.format(size) + ')');
        }

      default:
        // multi dimensional array
        throw new RangeError('Matrix must be two dimensional ' +
            '(size: ' + string.format(size) + ')');
    }
  };

  /**
   * Calculate the inverse of a square matrix
   * @param {Array[]} matrix  A square matrix
   * @param {Number} rows     Number of rows
   * @param {Number} cols     Number of columns, must equal rows
   * @return {Array[]} inv    Inverse matrix
   * @private
   */
  function _inv (matrix, rows, cols){
    var r, s, f, value, temp;

    if (rows == 1) {
      // this is a 1 x 1 matrix
      value = matrix[0][0];
      if (value == 0) {
        throw Error('Cannot calculate inverse, determinant is zero');
      }
      return [[
        math.divide(1, value)
      ]];
    }
    else if (rows == 2) {
      // this is a 2 x 2 matrix
      var d = math.det(matrix);
      if (d == 0) {
        throw Error('Cannot calculate inverse, determinant is zero');
      }
      return [
        [
          math.divide(matrix[1][1], d),
          math.divide(math.unaryMinus(matrix[0][1]), d)
        ],
        [
          math.divide(math.unaryMinus(matrix[1][0]), d),
          math.divide(matrix[0][0], d)
        ]
      ];
    }
    else {
      // this is a matrix of 3 x 3 or larger
      // calculate inverse using gauss-jordan elimination
      //      http://en.wikipedia.org/wiki/Gaussian_elimination
      //      http://mathworld.wolfram.com/MatrixInverse.html
      //      http://math.uww.edu/~mcfarlat/inverse.htm

      // make a copy of the matrix (only the arrays, not of the elements)
      var A = matrix.concat();
      for (r = 0; r < rows; r++) {
        A[r] = A[r].concat();
      }

      // create an identity matrix which in the end will contain the
      // matrix inverse
      var B = math.eye(rows).valueOf();

      // loop over all columns, and perform row reductions
      for (var c = 0; c < cols; c++) {
        // element Acc should be non zero. if not, swap content
        // with one of the lower rows
        r = c;
        while (r < rows && A[r][c] == 0) {
          r++;
        }
        if (r == rows || A[r][c] == 0) {
          // TODO: in case of zero det, just return a matrix wih Infinity values? (like octave)
          throw Error('Cannot calculate inverse, determinant is zero');
        }
        if (r != c) {
          temp = A[c]; A[c] = A[r]; A[r] = temp;
          temp = B[c]; B[c] = B[r]; B[r] = temp;
        }

        // eliminate non-zero values on the other rows at column c
        var Ac = A[c],
            Bc = B[c];
        for (r = 0; r < rows; r++) {
          var Ar = A[r],
              Br = B[r];
          if(r != c) {
            // eliminate value at column c and row r
            if (Ar[c] != 0) {
              f = math.divide(math.unaryMinus(Ar[c]), Ac[c]);

              // add (f * row c) to row r to eliminate the value
              // at column c
              for (s = c; s < cols; s++) {
                Ar[s] = math.add(Ar[s], math.multiply(f, Ac[s]));
              }
              for (s = 0; s < cols; s++) {
                Br[s] = math.add(Br[s],  math.multiply(f, Bc[s]));
              }
            }
          }
          else {
            // normalize value at Acc to 1,
            // divide each value on row r with the value at Acc
            f = Ac[c];
            for (s = c; s < cols; s++) {
              Ar[s] = math.divide(Ar[s], f);
            }
            for (s = 0; s < cols; s++) {
              Br[s] = math.divide(Br[s], f);
            }
          }
        }
      }
      return B;
    }
  }
};

},{"../../util/index":178,"../../type/Matrix":49}],115:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      array = util.array,

      isArray = Array.isArray;

  /**
   * Create a matrix filled with ones. The created matrix can have one or
   * multiple dimensions.
   *
   * Syntax:
   *
   *    math.ones(m)
   *    math.ones(m, n)
   *    math.ones([m, n])
   *    math.ones([m, n, p, ...])
   *
   * Examples:
   *
   *    math.ones(3);                   // returns [1, 1, 1]
   *    math.ones(3, 2);                // returns [[1, 1], [1, 1], [1, 1]]
   *
   *    var A = [[1, 2, 3], [4, 5, 6]];
   *    math.zeros(math.size(A));       // returns [[1, 1, 1], [1, 1, 1]]
   *
   * See also:
   *
   *    zeros, eye, size, range
   *
   * @param {...Number | Array} size    The size of each dimension of the matrix
   * @return {Array | Matrix | Number}  A matrix filled with ones
   */
  math.ones = function ones (size) {
    var args = collection.argsToArray(arguments);
    var asMatrix = (size instanceof Matrix) ? true :
        (isArray(size) ? false : (config.matrix === 'matrix'));

    if (args.length == 0) {
      // output an empty matrix
      return asMatrix ? new Matrix() : [];
    }
    else {
      // output an array or matrix

      // convert arguments from bignumber to numbers if needed
      var asBigNumber = false;
      args = args.map(function (value) {
        if (value instanceof BigNumber) {
          asBigNumber = true;
          return value.toNumber();
        } else {
          return value;
        }
      });

      // resize the matrix
      var res = [];
      var defaultValue = asBigNumber ? new BigNumber(1) : 1;
      res = array.resize(res, args, defaultValue);

      return asMatrix ? new Matrix(res) : res;
    }
  };
};

},{"../../util/index":178,"../../type/Matrix":49,"../../type/collection":52}],116:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      isBoolean = util['boolean'].isBoolean,
      isString = util.string.isString,
      isNumber = util.number.isNumber;

  /**
   * Create an array from a range.
   * By default, the range end is excluded. This can be customized by providing
   * an extra parameter `includeEnd`.
   *
   * Syntax:
   *
   *     math.range(str [, includeEnd])               // Create a range from a string,
   *                                                  // where the string contains the
   *                                                  // start, optional step, and end,
   *                                                  // separated by a colon.
   *     math.range(start, end [, includeEnd])        // Create a range with start and
   *                                                  // end and a step size of 1.
   *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,
   *                                                  // and end.
   *
   * Where:
   *
   * - `str: String`
   *   A string 'start:end' or 'start:step:end'
   * - `start: {Number | BigNumber}`
   *   Start of the range
   * - `end: Number | BigNumber`
   *   End of the range, excluded by default, included when parameter includeEnd=true
   * - `step: Number | BigNumber`
   *   Step size. Default value is 1.
   * - `includeEnd: boolean`
   *   Option to specify whether to include the end or not. False by default.
   *
   * Examples:
   *
   *     math.range(2, 6);        // [2, 3, 4, 5]
   *     math.range(2, -3, -1);   // [2, 1, 0, -1, -2]
   *     math.range('2:1:6');     // [2, 3, 4, 5]
   *     math.range(2, 6, true);  // [2, 3, 4, 5, 6]
   *
   * See also:
   *
   *     ones, zeros, size, subset
   *
   * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.
   * @return {Array | Matrix} range
   */
  math.range = function range(args) {
    var params = Array.prototype.slice.call(arguments),
        start,
        end,
        step,
        includeEnd = false;

    // read the includeEnd parameter
    if (isBoolean(params[params.length - 1])) {
      includeEnd = params.pop() ? true : false;
    }

    switch (params.length) {
      case 1:
        // range(str)
        // parse string into a range
        if (isString(params[0])) {
          var r = _parse(params[0]);
          if (!r){
            throw new SyntaxError('String "' + params[0] + '" is no valid range');
          }

          start = r.start;
          end = r.end;
          step = r.step;
        }
        else {
          throw new TypeError('Two or three numbers or a single string expected in function range');
        }
        break;

      case 2:
        // range(str, end)
        // range(start, end)
        start = params[0];
        end = params[1];
        step = 1;
        break;

      case 3:
        // range(start, end, step)
        start = params[0];
        end = params[1];
        step = params[2];
        break;

      case 4:
        throw new TypeError('Parameter includeEnd must be a boolean');

      default:
        throw new math.error.ArgumentsError('range', arguments.length, 2, 4);
    }

    // verify type of parameters
    if (!isNumber(start) && !(start instanceof BigNumber)) {
      throw new TypeError('Parameter start must be a number');
    }
    if (!isNumber(end) && !(end instanceof BigNumber)) {
      throw new TypeError('Parameter end must be a number');
    }
    if (!isNumber(step) && !(step instanceof BigNumber)) {
      throw new TypeError('Parameter step must be a number');
    }

    // go big
    if (start instanceof BigNumber || end instanceof BigNumber || step instanceof BigNumber) {
      // create a range with big numbers
      var asBigNumber = true;

      // convert start, end, step to BigNumber
      if (!(start instanceof BigNumber)) start = BigNumber.convert(start);
      if (!(end instanceof BigNumber))   end   = BigNumber.convert(end);
      if (!(step instanceof BigNumber))  step  = BigNumber.convert(step);

      if (!(start instanceof BigNumber) || !(end instanceof BigNumber) || !(step instanceof BigNumber)) {
        // not all values can be converted to big number :(
        // fall back to numbers
        asBigNumber = false;
        if (start instanceof BigNumber) start = start.toNumber();
        if (end instanceof BigNumber)   end   = end.toNumber();
        if (step instanceof BigNumber)  step  = step.toNumber();
      }
    }

    // generate the range
    var fn = asBigNumber ?
        (includeEnd ? _bigRangeInc : _bigRange) :
        (includeEnd ? _rangeInc    : _range);
    var array = fn(start, end, step);

    // return as array or matrix
    return (config.matrix === 'array') ? array : new Matrix(array);
  };

  /**
   * Create a range with numbers. End is excluded
   * @param {Number} start
   * @param {Number} end
   * @param {Number} step
   * @returns {Array} range
   * @private
   */
  function _range (start, end, step) {
    var array = [],
        x = start;
    if (step > 0) {
      while (x < end) {
        array.push(x);
        x += step;
      }
    }
    else if (step < 0) {
      while (x > end) {
        array.push(x);
        x += step;
      }
    }

    return array;
  }

  /**
   * Create a range with numbers. End is included
   * @param {Number} start
   * @param {Number} end
   * @param {Number} step
   * @returns {Array} range
   * @private
   */
  function _rangeInc (start, end, step) {
    var array = [],
        x = start;
    if (step > 0) {
      while (x <= end) {
        array.push(x);
        x += step;
      }
    }
    else if (step < 0) {
      while (x >= end) {
        array.push(x);
        x += step;
      }
    }

    return array;
  }

  /**
   * Create a range with big numbers. End is excluded
   * @param {BigNumber} start
   * @param {BigNumber} end
   * @param {BigNumber} step
   * @returns {Array} range
   * @private
   */
  function _bigRange (start, end, step) {
    var array = [],
        x = start.clone(),
        zero = new BigNumber(0);
    if (step.gt(zero)) {
      while (x.lt(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }
    else if (step.lt(zero)) {
      while (x.gt(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }

    return array;
  }

  /**
   * Create a range with big numbers. End is included
   * @param {BigNumber} start
   * @param {BigNumber} end
   * @param {BigNumber} step
   * @returns {Array} range
   * @private
   */
  function _bigRangeInc (start, end, step) {
    var array = [],
        x = start.clone(),
        zero = new BigNumber(0);
    if (step.gt(zero)) {
      while (x.lte(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }
    else if (step.lt(zero)) {
      while (x.gte(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }

    return array;
  }

  /**
   * Parse a string into a range,
   * The string contains the start, optional step, and end, separated by a colon.
   * If the string does not contain a valid range, null is returned.
   * For example str='0:2:11'.
   * @param {String} str
   * @return {Object | null} range Object containing properties start, end, step
   * @private
   */
  function _parse (str) {
    var args = str.split(':'),
        nums = null;

    if (config.number === 'bignumber') {
      // bignumber
      try {
        nums = args.map(function (arg) {
          return new BigNumber(arg);
        });
      }
      catch (err) {
        return null;
      }
    }
    else {
      // number
      nums = args.map(function (arg) {
        // use Number and not parseFloat as Number returns NaN on invalid garbage in the string
        return Number(arg);
      });

      var invalid = nums.some(function (num) {
        return isNaN(num);
      });
      if(invalid) {
        return null;
      }
    }

    switch (nums.length) {
      case 2:
        return {
          start: nums[0],
          end: nums[1],
          step: 1
        };

      case 3:
        return {
          start: nums[0],
          end: nums[2],
          step: nums[1]
        };

      default:
        return null;
    }
  }

};

},{"../../util/index":178,"../../type/Matrix":49,"../../type/collection":52}],117:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Matrix = require('../../type/Matrix'),

      array = util.array,
      clone = util.object.clone,
      string = util.string,
      isString = util.string.isString,
      isNumber = util.number.isNumber,
      isInteger = util.number.isInteger,
      isArray = array.isArray;

  /**
   * Resize a matrix
   *
   * Syntax:
   *
   *     math.resize(x, size)
   *     math.resize(x, size, defaultValue)
   *
   * Examples:
   *
   *     math.resize([1, 2, 3, 4, 5], [3]); // returns Array  [1, 2, 3]
   *     math.resize([1, 2, 3], [5], 0);    // returns Array  [1, 2, 3, 0, 0]
   *     math.resize(2, [2, 3], 0);         // returns Matrix [[2, 0, 0], [0, 0, 0]]
   *     math.resize("hello", [8], "!");    // returns String 'hello!!!'
   *
   * See also:
   *
   *     size, squeeze, subset
   *
   * @param {* | Array | Matrix} x             Matrix to be resized
   * @param {Array | Matrix} size              One dimensional array with numbers
   * @param {Number | String} [defaultValue=0] Zero by default, except in
   *                                           case of a string, in that case
   *                                           defaultValue = ' '
   * @return {* | Array | Matrix} A resized clone of matrix `x`
   */
  math.resize = function resize (x, size, defaultValue) {
    if (arguments.length != 2 && arguments.length != 3) {
      throw new math.error.ArgumentsError('resize', arguments.length, 2, 3);
    }

    var asMatrix = (x instanceof Matrix) ? true : isArray(x) ? false : (config.matrix !== 'array');

    if (x instanceof Matrix) {
      x = x.valueOf(); // get Array
    }
    if (size instanceof Matrix) {
      size = size.valueOf(); // get Array
    }

    if (size.length && size[0] instanceof BigNumber) {
      // convert bignumbers to numbers
      size = size.map(function (value) {
        return (value instanceof BigNumber) ? value.toNumber() : value;
      });
    }

    if (isString(x)) {
      return _resizeString(x, size, defaultValue);
    }
    else {
      if (size.length == 0) {
        // output a scalar
        while (isArray(x)) {
          x = x[0];
        }

        return clone(x);
      }
      else {
        // output an array/matrix
        if (!isArray(x)) {
          x = [x];
        }
        x = clone(x);

        var res = array.resize(x, size, defaultValue);
        return asMatrix ? new Matrix(res) : res;
      }
    }
  };

  /**
   * Resize a string
   * @param {String} str
   * @param {Number[]} size
   * @param {string} [defaultChar=' ']
   * @private
   */
  function _resizeString(str, size, defaultChar) {
    if (defaultChar !== undefined) {
      if (!isString(defaultChar) || defaultChar.length !== 1) {
        throw new TypeError('Single character expected as defaultValue');
      }
    }
    else {
      defaultChar = ' ';
    }

    if (size.length !== 1) {
      throw new math.error.DimensionError(size.length, 1);
    }
    var len = size[0];
    if (!isNumber(len) || !isInteger(len)) {
      throw new TypeError('Invalid size, must contain positive integers ' +
          '(size: ' + string.format(size) + ')');
    }

    if (str.length > len) {
      return str.substring(0, len);
    }
    else if (str.length < len) {
      var res = str;
      for (var i = 0, ii = len - str.length; i < ii; i++) {
        res += defaultChar;
      }
      return res;
    }
    else {
      return str;
    }
  }
};

},{"../../util/index":178,"../../type/Matrix":49}],118:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      Matrix = require('../../type/Matrix'),

      array = util.array,
      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit;

  /**
   * Calculate the size of a matrix or scalar.
   *
   * Syntax:
   *
   *     math.size(x)
   *
   * Examples:
   *
   *     math.size(2.3);                  // returns []
   *     math.size('hello world');        // returns [11]
   *
   *     var A = [[1, 2, 3], [4, 5, 6]];
   *     math.size(A);                    // returns [2, 3]
   *     math.size(math.range(1,6));      // returns [5]
   *
   * See also:
   *
   *     resize, squeeze, subset
   *
   * @param {Boolean | Number | Complex | Unit | String | Array | Matrix} x  A matrix
   * @return {Array | Matrix} A vector with size of `x`.
   */
  math.size = function size (x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('size', arguments.length, 1);
    }

    var asArray = (config.matrix === 'array');

    if (isNumber(x) || isComplex(x) || isUnit(x) || isBoolean(x) ||
        x == null || x instanceof BigNumber) {
      return asArray ? [] : new Matrix([]);
    }

    if (isString(x)) {
      return asArray ? [x.length] : new Matrix([x.length]);
    }

    if (Array.isArray(x)) {
      return array.size(x);
    }

    if (x instanceof Matrix) {
      return new Matrix(x.size());
    }

    throw new math.error.UnsupportedTypeError('size', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/Matrix":49}],119:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      Matrix = require('../../type/Matrix'),

      object = util.object,
      array = util.array,
      isArray = Array.isArray;

  /**
   * Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
   *
   * Syntax:
   *
   *     math.squeeze(x)
   *
   * Examples:
   *
   *     math.squeeze([3]);           // returns 3
   *     math.squeeze([[3]]);         // returns 3
   *
   *     var A = math.zeros(3, 1);    // returns [[0], [0], [0]] (size 3x1)
   *     math.squeeze(A);             // returns [0, 0, 0] (size 3)
   *
   *     var B = math.zeros(1, 3);    // returns [[0, 0, 0]] (size 1x3)
   *     math.squeeze(B);             // returns [0, 0, 0] (size 3)
   *
   *     // only inner and outer dimensions are removed
   *     var C = math.zeros(2, 1, 3); // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
   *     math.squeeze(C);             // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
   *
   * See also:
   *
   *     subset
   *
   * @param {Matrix | Array} x      Matrix to be squeezed
   * @return {Matrix | Array} Squeezed matrix
   */
  math.squeeze = function squeeze (x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('squeeze', arguments.length, 1);
    }

    if (isArray(x)) {
      return array.squeeze(object.clone(x));
    }
    else if (x instanceof Matrix) {
      var res = array.squeeze(x.toArray());
      return isArray(res) ? new Matrix(res) : res;
    }
    else {
      // scalar
      return object.clone(x);
    }
  };
};

},{"../../util/index":178,"../../type/Matrix":49}],120:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      Matrix = require('../../type/Matrix'),
      Index = require('../../type/Index'),

      array = util.array,
      isString = util.string.isString,
      isArray = Array.isArray;

  /**
   * Get or set a subset of a matrix or string.
   *
   * Syntax:
   *     math.subset(value, index)                                // retrieve a subset
   *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
   *
   * Examples:
   *
   *     // get a subset
   *     var d = [[1, 2], [3, 4]];
   *     math.subset(d, math.index(1, 0));        // returns 3
   *     math.subset(d, math.index([0, 2], 1));   // returns [[2], [4]]
   *
   *     // replace a subset
   *     var e = [];
   *     var f = math.subset(e, math.index(0, [0, 2]), [5, 6]);  // f = [[5, 6]]
   *     var g = math.subset(f, math.index(1, 1), 7, 0);         // g = [[5, 6], [0, 7]]
   *
   * See also:
   *
   *     size, resize, squeeze, index
   *
   * @param {Array | Matrix | String} matrix  An array, matrix, or string
   * @param {Index} index                     An index containing ranges for each
   *                                          dimension
   * @param {*} [replacement]                 An array, matrix, or scalar.
   *                                          If provided, the subset is replaced with replacement.
   *                                          If not provided, the subset is returned
   * @param {*} [defaultValue=undefined]      Default value, filled in on new entries when
   *                                          the matrix is resized. If not provided,
   *                                          new matrix elements will be left undefined.
   * @return {Array | Matrix | String} Either the retrieved subset or the updated matrix.
   */
  math.subset = function subset (matrix, index, replacement, defaultValue) {
    switch (arguments.length) {
      case 2: // get subset
        return _getSubset(arguments[0], arguments[1]);

      // intentional fall through
      case 3: // set subset
      case 4: // set subset with default value
        return _setSubset(arguments[0], arguments[1], arguments[2], arguments[3]);

      default: // wrong number of arguments
        throw new math.error.ArgumentsError('subset', arguments.length, 2, 4);
    }
  };

  /**
   * Retrieve a subset of an value such as an Array, Matrix, or String
   * @param {Array | Matrix | String} value Object from which to get a subset
   * @param {Index} index                   An index containing ranges for each
   *                                        dimension
   * @returns {Array | Matrix | *} subset
   * @private
   */
  function _getSubset(value, index) {
    var m, subset;

    if (isArray(value)) {
      m = new Matrix(value);
      subset = m.subset(index);           // returns a Matrix
      return subset && subset.valueOf();  // return an Array (like the input)
    }
    else if (value instanceof Matrix) {
      return value.subset(index);
    }
    else if (isString(value)) {
      return _getSubstring(value, index);
    }
    else {
      throw new math.error.UnsupportedTypeError('subset', math['typeof'](value));
    }
  }

  /**
   * Retrieve a subset of a string
   * @param {String} str            String from which to get a substring
   * @param {Index} index           An index containing ranges for each dimension
   * @returns {string} substring
   * @private
   */
  function _getSubstring(str, index) {
    if (!(index instanceof Index)) {
      // TODO: better error message
      throw new TypeError('Index expected');
    }
    if (index.size().length != 1) {
      throw new math.error.DimensionError(index.size().length, 1);
    }

    // validate whether the range is out of range
    var strLen = str.length;
    array.validateIndex(index.min()[0], strLen);
    array.validateIndex(index.max()[0], strLen);

    var range = index.range(0);

    var substr = '';
    range.forEach(function (v) {
      substr += str.charAt(v);
    });

    return substr;
  }

  /**
   * Replace a subset in an value such as an Array, Matrix, or String
   * @param {Array | Matrix | String} value Object to be replaced
   * @param {Index} index                   An index containing ranges for each
   *                                        dimension
   * @param {Array | Matrix | *} replacement
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   * @returns {*} result
   * @private
   */
  function _setSubset(value, index, replacement, defaultValue) {
    var m;

    if (isArray(value)) {
      m = new Matrix(math.clone(value));
      m.subset(index, replacement, defaultValue);
      return m.valueOf();
    }
    else if (value instanceof Matrix) {
      return value.clone().subset(index, replacement, defaultValue);
    }
    else if (isString(value)) {
      return _setSubstring(value, index, replacement, defaultValue);
    }
    else {
      throw new math.error.UnsupportedTypeError('subset', math['typeof'](value));
    }
  }

  /**
   * Replace a substring in a string
   * @param {String} str            String to be replaced
   * @param {Index} index           An index containing ranges for each dimension
   * @param {String} replacement    Replacement string
   * @param {String} [defaultValue] Default value to be uses when resizing
   *                                the string. is ' ' by default
   * @returns {string} result
   * @private
   */
  function _setSubstring(str, index, replacement, defaultValue) {
    if (!(index instanceof Index)) {
      // TODO: better error message
      throw new TypeError('Index expected');
    }
    if (index.size().length != 1) {
      throw new math.error.DimensionError(index.size().length, 1);
    }
    if (defaultValue !== undefined) {
      if (!isString(defaultValue) || defaultValue.length !== 1) {
        throw new TypeError('Single character expected as defaultValue');
      }
    }
    else {
      defaultValue = ' ';
    }

    var range = index.range(0);
    var len = range.size()[0];

    if (len != replacement.length) {
      throw new math.error.DimensionError(range.size()[0], replacement.length);
    }

    // validate whether the range is out of range
    var strLen = str.length;
    array.validateIndex(index.min()[0]);
    array.validateIndex(index.max()[0]);

    // copy the string into an array with characters
    var chars = [];
    for (var i = 0; i < strLen; i++) {
      chars[i] = str.charAt(i);
    }

    range.forEach(function (v, i) {
      chars[v] = replacement.charAt(i);
    });

    // initialize undefined characters with a space
    if (chars.length > strLen) {
      for (i = strLen - 1, len = chars.length; i < len; i++) {
        if (!chars[i]) {
          chars[i] = defaultValue;
        }
      }
    }

    return chars.join('');
  }
};

},{"../../util/index":178,"../../type/Matrix":49,"../../type/Index":48}],121:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      Matrix = require('../../type/Matrix'),

      object = util.object,
      string = util.string;

  /**
   * Transpose a matrix. All values of the matrix are reflected over its
   * main diagonal. Only two dimensional matrices are supported.
   *
   * Syntax:
   *
   *     math.transpose(x)
   *
   * Examples:
   *
   *     var A = [[1, 2, 3], [4, 5, 6]];
   *     math.transpose(A);               // returns [[1, 4], [2, 5], [3, 6]]
   *
   * See also:
   *
   *     diag, inv, subset, squeeze
   *
   * @param {Array | Matrix} x  Matrix to be transposed
   * @return {Array | Matrix}   The transposed matrix
   */
  math.transpose = function transpose (x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('transpose', arguments.length, 1);
    }

    var size = math.size(x).valueOf();
    switch (size.length) {
      case 0:
        // scalar
        return object.clone(x);

      case 1:
        // vector
        return object.clone(x);

      case 2:
        // two dimensional array
        var rows = size[1],
            cols = size[0],
            asMatrix = (x instanceof Matrix),
            data = x.valueOf(),
            transposed = [],
            transposedRow,
            clone = object.clone;

        if (rows === 0) {
          // whoops
          throw new RangeError('Cannot transpose a 2D matrix with no rows' +
              '(size: ' + string.format(size) + ')');
        }

        for (var r = 0; r < rows; r++) {
          transposedRow = transposed[r] = [];
          for (var c = 0; c < cols; c++) {
            transposedRow[c] = clone(data[c][r]);
          }
        }

        return asMatrix ? new Matrix(transposed) : transposed;

      default:
        // multi dimensional array
        throw new RangeError('Matrix must be two dimensional ' +
            '(size: ' + string.format(size) + ')');
    }
  };
};

},{"../../util/index":178,"../../type/Matrix":49}],122:[function(require,module,exports){
'use strict';

module.exports = function (math, config) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      array = util.array,
      isArray = Array.isArray;

  /**
   * Create a matrix filled with zeros. The created matrix can have one or
   * multiple dimensions.
   *
   * Syntax:
   *
   *    math.zeros(m)
   *    math.zeros(m, n)
   *    math.zeros([m, n])
   *    math.zeros([m, n, p, ...])
   *
   * Examples:
   *
   *    math.zeros(3);                  // returns [0, 0, 0]
   *    math.zeros(3, 2);               // returns [[0, 0], [0, 0], [0, 0]]
   *
   *    var A = [[1, 2, 3], [4, 5, 6]];
   *    math.zeros(math.size(A));       // returns [[0, 0, 0], [0, 0, 0]]
   *
   * See also:
   *
   *    ones, eye, size, range
   *
   * @param {...Number | Array} size    The size of each dimension of the matrix
   * @return {Array | Matrix | Number}  A matrix filled with zeros
   */
  math.zeros = function zeros (size) {
    var args = collection.argsToArray(arguments);
    var asMatrix = (size instanceof Matrix) ? true :
        (isArray(size) ? false : (config.matrix === 'matrix'));

    if (args.length == 0) {
      // output an empty matrix
      return asMatrix ? new Matrix() : [];
    }
    else {
      // output an array or matrix

      // convert arguments from bignumber to numbers if needed
      var asBigNumber = false;
      args = args.map(function (value) {
        if (value instanceof BigNumber) {
          asBigNumber = true;
          return value.toNumber();
        } else {
          return value;
        }
      });

      // resize the matrix
      var res = [];
      var defaultValue = asBigNumber ? new BigNumber(0) : 0;
      res = array.resize(res, args, defaultValue);

      return asMatrix ? new Matrix(res) : res;
    }
  };
};

},{"../../util/index":178,"../../type/Matrix":49,"../../type/collection":52}],123:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isInteger = util.number.isInteger,
      isCollection = collection.isCollection;

  /**
   * Compute the factorial of a value
   *
   * Factorial only supports an integer value as argument.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.factorial(n)
   *
   * Examples:
   *
   *    math.factorial(5);    // returns 120
   *    math.factorial(3);    // returns 6
   *
   * See also:
   *
   *    combinations, permutations
   *
   * @param {Number | BigNumber | Array | Matrix | Boolean | null} n   An integer number
   * @return {Number | BigNumber | Array | Matrix}    The factorial of `n`
   */
  math.factorial = function factorial (n) {
    var value, res;

    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('factorial', arguments.length, 1);
    }

    if (isNumber(n)) {
      if (!isInteger(n) || n < 0) {
        throw new TypeError('Positive integer value expected in function factorial');
      }

      value = n - 1;
      res = n;
      while (value > 1) {
        res *= value;
        value--;
      }

      if (res == 0) {
        res = 1;        // 0! is per definition 1
      }

      return res;
    }

    if (n instanceof BigNumber) {
      if (!(isPositiveInteger(n))) {
        throw new TypeError('Positive integer value expected in function factorial');
      }

      var one = new BigNumber(1);

      value = n.minus(one);
      res = n;
      while (value.gt(one)) {
        res = res.times(value);
        value = value.minus(one);
      }

      if (res.equals(0)) {
        res = one;        // 0! is per definition 1
      }

      return res;
    }

    if (isBoolean(n) || n === null) {
      return 1; // factorial(1) = 1, factorial(0) = 1
    }

    if (isCollection(n)) {
      return collection.deepMap(n, factorial);
    }

    throw new math.error.UnsupportedTypeError('factorial', math['typeof'](n));
  };

  /**
   * Test whether BigNumber n is a positive integer
   * @param {BigNumber} n
   * @returns {boolean} isPositiveInteger
   */
  var isPositiveInteger = function(n) {
    return n.isInteger() && n.gte(0);
  };
};

},{"../../util/index":178,"../../type/collection":52}],124:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var distribution = require('./distribution')(math);

  /**
   * Return a random number between `min` and `max` using a uniform distribution.
   *
   * Syntax:
   *
   *     math.random()                // generate a random number between 0 and 1
   *     math.random(max)             // generate a random number between 0 and max
   *     math.random(min, max)        // generate a random number between min and max
   *     math.random(size)            // generate a matrix with random numbers between 0 and 1
   *     math.random(size, max)       // generate a matrix with random numbers between 0 and max
   *     math.random(size, min, max)  // generate a matrix with random numbers between min and max
   *
   * Examples:
   *
   *     math.random();       // returns a random number between 0 and 1
   *     math.random(100);    // returns a random number between 0 and 100
   *     math.random(30, 40); // returns a random number between 30 and 40
   *     math.random([2, 3]); // returns a 2x3 matrix with random numbers between 0 and 1
   *
   * See also:
   *
   *     randomInt, pickRandom
   *
   * @param {Number} [size] If provided, an array with `size` number of random values is returned
   * @param {Number} [min]  Minimum boundary for the random value
   * @param {Number} [max]  Maximum boundary for the random value
   * @return {Number | Array | Matrix} A random number
   */
  math.random = distribution('uniform').random;
};

},{"./distribution":312}],125:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var distribution = require('./distribution')(math);

  /**
   * Return a random integer number between `min` and `max` using a uniform distribution.
   *
   * Syntax:
   *
   *     math.randomInt()                // generate a random integer between 0 and 1
   *     math.randomInt(max)             // generate a random integer between 0 and max
   *     math.randomInt(min, max)        // generate a random integer between min and max
   *     math.randomInt(size)            // generate a matrix with random integer between 0 and 1
   *     math.randomInt(size, max)       // generate a matrix with random integer between 0 and max
   *     math.randomInt(size, min, max)  // generate a matrix with random integer between min and max
   *
   * Examples:
   *
   *     math.randomInt();       // returns a random integer between 0 and 1
   *     math.randomInt(100);    // returns a random integer between 0 and 100
   *     math.randomInt(30, 40); // returns a random integer between 30 and 40
   *     math.randomInt([2, 3]); // returns a 2x3 matrix with random integers between 0 and 1
   *
   * See also:
   *
   *     randomInt, pickRandom
   *
   * @param {Number} [size] If provided, an array with `size` number of random values is returned
   * @param {Number} [min]  Minimum boundary for the random value
   * @param {Number} [max]  Maximum boundary for the random value
   * @return {Number | Array | Matrix} A random integer value
   */
  math.randomInt = distribution('uniform').randomInt;
};

},{"./distribution":312}],126:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var distribution = require('./distribution')(math);

  /**
   * Random pick a value from a one dimensional array.
   * Array element is picked using a random function with uniform distribution.
   *
   * Syntax:
   *
   *     math.pickRandom(array)
   *
   * Examples:
   *
   *     math.pickRandom([3, 6, 12, 2]);       // returns one of the values in the array
   *
   * See also:
   *
   *     random, randomInt
   *
   * @param {Array} array     A one dimensional array
   * @return {Number} One of the elements of the provided input array
   */
  math.pickRandom = distribution('uniform').pickRandom;
};

},{"./distribution":312}],127:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,

      isNumber = util.number.isNumber,
      isInteger = util.number.isInteger;

  /**
   * Compute the number of ways of obtaining an ordered subset of `k` elements
   * from a set of `n` elements.
   *
   * Permutations only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   * Syntax:
   *
   *     math.permutations(n)
   *     math.permutations(n, k)
   *
   * Examples:
   *
   *    math.permutations(5);     // 120
   *    math.permutations(5, 3);  // 60
   *
   * See also:
   *
   *    combinations, factorial
   *
   * @param {Number | BigNumber} n  The number of objects in total
   * @param {Number | BigNumber} k  The number of objects in the subset
   * @return {Number | BigNumber}   The number of permutations
   */
  math.permutations = function permutations (n, k) {
    var result, i;

    var arity = arguments.length;
    if (arity > 2) {
      throw new math.error.ArgumentsError('permutations', arguments.length, 2);
    }

    if (isNumber(n)) {
      if (!isInteger(n) || n < 0) {
        throw new TypeError('Positive integer value expected in function permutations');
      }
      
      // Permute n objects
      if (arity == 1) {
        return math.factorial(n);
      }
      
      // Permute n objects, k at a time
      if (arity == 2) {
        if (isNumber(k)) {
          if (!isInteger(k) || k < 0) {
            throw new TypeError('Positive integer value expected in function permutations');
          }
          if (k > n) {
            throw new TypeError('second argument k must be less than or equal to first argument n');
          }

          result = 1;
          for (i = n - k + 1; i <= n; i++) {
            result = result * i;
          }
          return result;
        }
      }
    }

    if (n instanceof BigNumber) {
      if (k === undefined && isPositiveInteger(n)) {
        return math.factorial(n);
      }

      // make sure k is a BigNumber as well
      // not all numbers can be converted to BigNumber
      k = BigNumber.convert(k);

      if (!(k instanceof BigNumber) || !isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError('Positive integer value expected in function permutations');
      }
      if (k.gt(n)) {
        throw new TypeError('second argument k must be less than or equal to first argument n');
      }

      result = new BigNumber(1);
      for (i = n.minus(k).plus(1); i.lte(n); i = i.plus(1)) {
        result = result.times(i);
      }
      return result;
    }

    throw new math.error.UnsupportedTypeError('permutations', math['typeof'](n));
  };

  /**
   * Test whether BigNumber n is a positive integer
   * @param {BigNumber} n
   * @returns {boolean} isPositiveInteger
   */
  var isPositiveInteger = function(n) {
    return n.isInteger() && n.gte(0);
  };
};

},{"../../util/index":178}],128:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isInteger = util.number.isInteger;

  /**
   * Compute the number of ways of picking `k` unordered outcomes from `n`
   * possibilities.
   *
   * Combinations only takes integer arguments.
   * The following condition must be enforced: k <= n.
   *
   * Syntax:
   *
   *     math.combinations(n, k)
   *
   * Examples:
   *
   *    math.combinations(7, 5); // returns 21
   *
   * See also:
   *
   *    permutations, factorial
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @param {Number | BigNumber} k    Number of objects in the subset
   * @return {Number | BigNumber}     Number of possible combinations.
   */
  math.combinations = function combinations (n, k) {
    var max, result, i,ii;

    var arity = arguments.length;
    if (arity != 2) {
      throw new math.error.ArgumentsError('combinations', arguments.length, 2);
    }

    if (isNumber(n)) {
      if (!isInteger(n) || n < 0) {
        throw new TypeError('Positive integer value enpected in function combinations');
      }
      if (k > n) {
        throw new TypeError('k must be less than or equal to n');
      }

      max = Math.max(k, n - k);
      result = 1;
      for (i = 1; i <= n - max; i++) {
        result = result * (max + i) / i;
      }
      return result;
    }

    if (n instanceof BigNumber) {
      // make sure k is a BigNumber as well
      // not all numbers can be converted to BigNumber
      k = BigNumber.convert(k);

      if (!(k instanceof BigNumber) || !isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError('Positive integer value expected in function combinations');
      }
      if (k.gt(n)) {
        throw new TypeError('k must be less than n in function combinations');
      }

      max = n.minus(k);
      if (k.lt(max)) max = k;
      result = new BigNumber(1);
      for (i = new BigNumber(1), ii = n.minus(max); i.lte(ii); i = i.plus(1)) {
        result = result.times(max.plus(i)).dividedBy(i);
      }
      return result;
    }

    throw new math.error.UnsupportedTypeError('combinations', math['typeof'](n));
  };

  /**
   * Test whether BigNumber n is a positive integer
   * @param {BigNumber} n
   * @returns {boolean} isPositiveInteger
   */
  var isPositiveInteger = function(n) {
    return n.isInteger() && n.gte(0);
  };
};

},{"../../util/index":178,"../../type/collection":52}],129:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      isCollection = collection.isCollection;

  /**
   * Compute the maximum value of a matrix or a  list of values.
   * In case of a multi dimensional array, the maximum of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.min(a, b, c, ...)
   *     math.min(A)
   *     math.min(A, dim)
   *
   * Examples:
   *
   *     math.min(2, 1, 4, 3);                  // returns 1
   *     math.min([2, 1, 4, 3]);                // returns 1
   *
   *     // maximum over a specified dimension (zero-based)
   *     math.min([[2, 5], [4, 3], [1, 7]], 0); // returns [1, 3]
   *     math.min([[2, 5], [4, 3], [1, 7]], 1); // returns [2, 3, 1]
   *
   *     math.max(2.7, 7.1, -4.5, 2.0, 4.1);    // returns 7.1
   *     math.min(2.7, 7.1, -4.5, 2.0, 4.1);    // returns -4.5
   *
   * See also:
   *
   *    mean, median, max, prod, std, sum, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The minimum value
   */
  math.min = function min(args) {
    if (arguments.length == 0) {
      throw new SyntaxError('Function min requires one or more parameters (0 provided)');
    }

    if (isCollection(args)) {
      if (arguments.length == 1) {
        // min([a, b, c, d, ...])
        return _min(args);
      }
      else if (arguments.length == 2) {
        // min([a, b, c, d, ...], dim)
        return collection.reduce(arguments[0], arguments[1], _getSmaller);
      }
      else {
        throw new SyntaxError('Wrong number of parameters');
      }
    }
    else {
      // min(a, b, c, d, ...)
      return _min(arguments);
    }
  };

  function _getSmaller(x, y){
	  return math.smaller(x, y)  ? x : y;
  }

  /**
   * Recursively calculate the minimum value in an n-dimensional array
   * @param {Array} array
   * @return {Number} min
   * @private
   */
  function _min(array) {
    var min = undefined;

    collection.deepForEach(array, function (value) {
      if (min === undefined || math.smaller(value, min)) {
        min = value;
      }
    });

    if (min === undefined) {
      throw new Error('Cannot calculate min of an empty array');
    }

    return min;
  }
};

},{"../../type/Matrix":49,"../../type/collection":52}],130:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      isCollection = collection.isCollection;

  /**
   * Compute the maximum value of a matrix or a  list with values.
   * In case of a multi dimensional array, the maximum of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.max(a, b, c, ...)
   *     math.max(A)
   *     math.max(A, dim)
   *
   * Examples:
   *
   *     math.max(2, 1, 4, 3);                  // returns 4
   *     math.max([2, 1, 4, 3]);                // returns 4
   *
   *     // maximum over a specified dimension (zero-based)
   *     math.max([[2, 5], [4, 3], [1, 7]], 0); // returns [4, 7]
   *     math.max([[2, 5], [4, 3]], [1, 7], 1); // returns [5, 4, 7]
   *
   *     math.max(2.7, 7.1, -4.5, 2.0, 4.1);    // returns 7.1
   *     math.min(2.7, 7.1, -4.5, 2.0, 4.1);    // returns -4.5
   *
   * See also:
   *
   *    mean, median, min, prod, std, sum, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The maximum value
   */
  math.max = function max(args) {
    if (arguments.length == 0) {
      throw new SyntaxError('Function max requires one or more parameters (0 provided)');
    }

    if (isCollection(args)) {
      if (arguments.length == 1) {
        // max([a, b, c, d, ...])
        return _max(args);
      }
      else if (arguments.length == 2) {
        // max([a, b, c, d, ...], dim)
        return collection.reduce(arguments[0], arguments[1], _getLarger);
      }
      else {
        throw new SyntaxError('Wrong number of parameters');
      }
    }
    else {
      // max(a, b, c, d, ...)
      return _max(arguments);
    }
  };

  function _getLarger(x, y){
	  return math.larger(x, y) ? x : y;
  }

  /**
   * Recursively calculate the maximum value in an n-dimensional array
   * @param {Array} array
   * @return {Number} max
   * @private
   */
  function _max(array) {
    var max = undefined;

    collection.deepForEach(array, function (value) {
      if (max === undefined || math.larger(value, max)) {
        max = value;
      }
    });

    if (max === undefined) {
      throw new Error('Cannot calculate max of an empty array');
    }

    return max;
  }
};

},{"../../type/Matrix":49,"../../type/collection":52}],131:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      isCollection = collection.isCollection,

      size = require('../../util/array').size,
      isArray = Array.isArray;

  /**
   * Compute the mean value of matrix or a list with values.
   * In case of a multi dimensional array, the mean of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     mean.mean(a, b, c, ...)
   *     mean.mean(A)
   *     mean.mean(A, dim)
   *
   * Examples:
   *
   *     math.mean(2, 1, 4, 3);                     // returns 2.5
   *     math.mean([1, 2.7, 3.2, 4]);               // returns 2.725
   *
   *     math.mean([[2, 5], [6, 3], [1, 7]], 0);    // returns [3, 5]
   *     math.mean([[2, 5], [6, 3], [1, 7]], 1);    // returns [3.5, 4.5, 4]
   *
   * See also:
   *
   *     median, min, max, sum, prod, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The mean of all values
   */
  math.mean = function mean(args) {
    if (arguments.length == 0) {
      throw new SyntaxError('Function mean requires one or more parameters (0 provided)');
    }

    if (isCollection(args)) {
      if (arguments.length == 1) {
        // mean([a, b, c, d, ...])
        return _mean(args);
      }
      else if (arguments.length == 2) {
        // mean([a, b, c, d, ...], dim)
        return _nmean(arguments[0], arguments[1]);
      }
      else {
        throw new SyntaxError('Wrong number of parameters');
      }
    }
    else {
      // mean(a, b, c, d, ...)
      return _mean(arguments);
    }
  };

  /**
   * Calculate the mean value in an n-dimensional array, returning a
   * n-1 dimensional array
   * @param {Array} array
   * @param {Number} dim
   * @return {Number} mean
   * @private
   */
  function _nmean(array, dim){
	  var sum = collection.reduce(array, dim, math.add);
    var s = isArray(array) ? size(array) : array.size();
    return math.divide(sum, s[dim]);
  }

  /**
   * Recursively calculate the mean value in an n-dimensional array
   * @param {Array} array
   * @return {Number} mean
   * @private
   */
  function _mean(array) {
    var sum = 0;
    var num = 0;

    collection.deepForEach(array, function (value) {
      sum = math.add(sum, value);
      num++;
    });

    if (num === 0) {
      throw new Error('Cannot calculate mean of an empty array');
    }

    return math.divide(sum, num);
  }
};

},{"../../type/Matrix":49,"../../type/collection":52,"../../util/array":44}],132:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var Matrix = require('../../type/Matrix'),
      Unit = require('../../type/Unit'),
      BigNumber = math.type.BigNumber,
      collection = require('../../type/collection'),

      isNumber = require('../../util/number').isNumber,
      isCollection = collection.isCollection,

      flatten = require('../../util/array').flatten;

  /**
   * Compute the median of a matrix or a list with values. The values are
   * sorted and the middle value is returned. In case of an even number of
   * values, the average of the two middle values is returned.
   * Supported types of values are: Number, BigNumber, Unit
   *
   * In case of a (multi dimensional) array or matrix, the median of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     mean.median(a, b, c, ...)
   *     mean.median(A)
   *
   * Examples:
   *
   *     math.median(5, 2, 7);        // returns 5
   *     math.median([3, -1, 5, 7]);  // returns 4
   *
   * See also:
   *
   *     mean, min, max, sum, prod, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The median
   */
  math.median = function median(args) {
    if (arguments.length == 0) {
      throw new SyntaxError('Function median requires one or more parameters (0 provided)');
    }

    if (isCollection(args)) {
      if (arguments.length == 1) {
        // median([a, b, c, d, ...])
        return _median(args.valueOf());
      }
      else if (arguments.length == 2) {
        // median([a, b, c, d, ...], dim)
        // TODO: implement median(A, dim)
        throw new Error('median(A, dim) is not yet supported');
        //return collection.reduce(arguments[0], arguments[1], ...);
      }
      else {
        throw new SyntaxError('Wrong number of parameters');
      }
    }
    else {
      // median(a, b, c, d, ...)
      return _median(Array.prototype.slice.call(arguments));
    }
  };

  /**
   * Recursively calculate the median of an n-dimensional array
   * @param {Array} array
   * @return {Number} median
   * @private
   */
  function _median(array) {
    var flat = flatten(array);

    flat.sort(math.compare);

    var num = flat.length;

    if (num == 0) {
      throw new Error('Cannot calculate median of an empty array');
    }

    if (num % 2 == 0) {
      // even: return the average of the two middle values
      var left = flat[num / 2 - 1];
      var right = flat[num / 2];

      if (!isNumber(left) && !(left instanceof BigNumber) && !(left instanceof Unit)) {
        throw new math.error.UnsupportedTypeError('median', math['typeof'](left));
      }
      if (!isNumber(right) && !(right instanceof BigNumber) && !(right instanceof Unit)) {
        throw new math.error.UnsupportedTypeError('median', math['typeof'](right));
      }

      return math.divide(math.add(left, right), 2);
    }
    else {
      // odd: return the middle value
      var middle = flat[(num - 1) / 2];

      if (!isNumber(middle) && !(middle instanceof BigNumber) && !(middle instanceof Unit)) {
        throw new math.error.UnsupportedTypeError('median', math['typeof'](middle));
      }

      return middle;
    }
  }
};

},{"../../type/Matrix":49,"../../type/Unit":50,"../../type/collection":52,"../../util/number":36,"../../util/array":44}],133:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      isCollection = collection.isCollection;

  /**
   * Compute the product of a matrix or a list with values.
   * In case of a (multi dimensional) array or matrix, the sum of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.prod(a, b, c, ...)
   *     math.prod(A)
   *
   * Examples:
   *
   *     math.multiply(2, 3);           // returns 6
   *     math.prod(2, 3);               // returns 6
   *     math.prod(2, 3, 4);            // returns 24
   *     math.prod([2, 3, 4]);          // returns 24
   *     math.prod([[2, 5], [4, 3]]);   // returns 120
   *
   * See also:
   *
   *    mean, median, min, max, sum, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The product of all values
   */
  math.prod = function prod(args) {
    if (arguments.length == 0) {
      throw new SyntaxError('Function prod requires one or more parameters (0 provided)');
    }

    if (isCollection(args)) {
      if (arguments.length == 1) {
        // prod([a, b, c, d, ...])
        return _prod(args);
      }
      else if (arguments.length == 2) {
        // prod([a, b, c, d, ...], dim)
        // TODO: implement prod(A, dim)
        throw new Error('prod(A, dim) is not yet supported');
        //return collection.reduce(arguments[0], arguments[1], math.prod);
      }
      else {
        throw new SyntaxError('Wrong number of parameters');
      }
    }
    else {
      // prod(a, b, c, d, ...)
      return _prod(arguments);
    }
  };

  /**
   * Recursively calculate the product of an n-dimensional array
   * @param {Array} array
   * @return {Number} prod
   * @private
   */
  function _prod(array) {
    var prod = undefined;

    collection.deepForEach(array, function (value) {
      prod = (prod === undefined) ? value : math.multiply(prod, value);
    });

    if (prod === undefined) {
      throw new Error('Cannot calculate prod of an empty array');
    }

    return prod;
  }
};

},{"../../type/Matrix":49,"../../type/collection":52}],134:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      isCollection = collection.isCollection;

  /**
   * Compute the sum of a matrix or a list with values.
   * In case of a (multi dimensional) array or matrix, the sum of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.sum(a, b, c, ...)
   *     math.sum(A)
   *
   * Examples:
   *
   *     math.sum(2, 1, 4, 3);               // returns 10
   *     math.sum([2, 1, 4, 3]);             // returns 10
   *     math.sum([[2, 5], [4, 3], [1, 7]]); // returns 22
   *
   * See also:
   *
   *    mean, median, min, max, prod, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The sum of all values
   */
  math.sum = function sum(args) {
    if (arguments.length == 0) {
      throw new SyntaxError('Function sum requires one or more parameters (0 provided)');
    }

    if (isCollection(args)) {
      if (arguments.length == 1) {
        // sum([a, b, c, d, ...])
        return _sum(args);
      }
      else if (arguments.length == 2) {
        // sum([a, b, c, d, ...], dim)
        // TODO: implement sum(A, dim)
        throw new Error('sum(A, dim) is not yet supported');
        //return collection.reduce(arguments[0], arguments[1], math.add);
      }
      else {
        throw new SyntaxError('Wrong number of parameters');
      }
    }
    else {
      // sum(a, b, c, d, ...)
      return _sum(arguments);
    }
  };

  /**
   * Recursively calculate the sum of an n-dimensional array
   * @param {Array} array
   * @return {Number} sum
   * @private
   */
  function _sum(array) {
    var sum = undefined;

    collection.deepForEach(array, function (value) {
      sum = (sum === undefined) ? value : math.add(sum, value);
    });

    if (sum === undefined) {
      throw new Error('Cannot calculate sum of an empty array');
    }

    return sum;
  }
};

},{"../../type/Matrix":49,"../../type/collection":52}],135:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var Matrix = require('../../type/Matrix'),
      BigNumber = math.type.BigNumber,
      collection = require('../../type/collection'),

      isCollection = collection.isCollection,
      isString = require('../../util/string').isString,

      DEFAULT_NORMALIZATION = 'unbiased';

  /**
   * Compute the variance of a matrix or a  list with values.
   * In case of a (multi dimensional) array or matrix, the variance over all
   * elements will be calculated.
   *
   * Optionally, the type of normalization can be specified as second
   * parameter. The parameter `normalization` can be one of the following values:
   *
   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
   * - 'uncorrected'        The sum of squared errors is divided by n
   * - 'biased'             The sum of squared errors is divided by (n + 1)

   * Note that older browser may not like the variable name `var`. In that
   * case, the function can be called as `math['var'](...)` instead of
   * `math.var(...)`.
   *
   * Syntax:
   *
   *     math.var(a, b, c, ...)
   *     math.var(A)
   *     math.var(A, normalization)
   *
   * Examples:
   *
   *     math.var(2, 4, 6);                     // returns 4
   *     math.var([2, 4, 6, 8]);                // returns 6.666666666666667
   *     math.var([2, 4, 6, 8], 'uncorrected'); // returns 5
   *     math.var([2, 4, 6, 8], 'biased');      // returns 4
   *
   *     math.var([[1, 2, 3], [4, 5, 6]]);      // returns 3.5
   *
   * See also:
   *
   *    mean, median, max, min, prod, std, sum
   *
   * @param {Array | Matrix} array
   *                        A single matrix or or multiple scalar values
   * @param {String} [normalization='unbiased']
   *                        Determines how to normalize the variance.
   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
   * @return {*} The variance
   */
  math['var'] = function variance(array, normalization) {
    if (arguments.length == 0) {
      throw new SyntaxError('Function var requires one or more parameters (0 provided)');
    }

    if (isCollection(array)) {
      if (arguments.length == 1) {
        // var([a, b, c, d, ...])
        return _var(array, DEFAULT_NORMALIZATION);
      }
      else if (arguments.length == 2) {
        // var([a, b, c, d, ...], normalization)

        if (!isString(normalization)) {
          throw new Error('String expected for parameter normalization');
        }

        return _var(array, normalization);
      }
      /* TODO: implement var(A [, normalization], dim)
      else if (arguments.length == 3) {
        // var([a, b, c, d, ...], dim)
        // var([a, b, c, d, ...], normalization, dim)
        //return collection.reduce(arguments[0], arguments[1], ...);
      }
      */
      else {
        throw new SyntaxError('Wrong number of parameters');
      }
    }
    else {
      // var(a, b, c, d, ...)
      return _var(arguments, DEFAULT_NORMALIZATION);
    }
  };

  /**
   * Recursively calculate the variance of an n-dimensional array
   * @param {Array} array
   * @param {String} normalization
   *                        Determines how to normalize the variance:
   *                        - 'unbiased'    The sum of squared errors is divided by (n - 1)
   *                        - 'uncorrected' The sum of squared errors is divided by n
   *                        - 'biased'      The sum of squared errors is divided by (n + 1)
   * @return {Number | BigNumber} variance
   * @private
   */
  function _var(array, normalization) {
    var sum = 0;
    var num = 0;

    // calculate the mean and number of elements
    collection.deepForEach(array, function (value) {
      sum = math.add(sum, value);
      num++;
    });
    if (num === 0) throw new Error('Cannot calculate var of an empty array');

    var mean = math.divide(sum, num);

    // calculate the variance
    sum = 0;
    collection.deepForEach(array, function (value) {
      var diff = math.subtract(value, mean);
      sum = math.add(sum, math.multiply(diff, diff));
    });

    switch (normalization) {
      case 'uncorrected':
        return math.divide(sum, num);

      case 'biased':
        return math.divide(sum, num + 1);

      case 'unbiased':
        var zero = (sum instanceof BigNumber) ? new BigNumber(0) : 0;
        return (num == 1) ? zero : math.divide(sum, num - 1);

      default:
        throw new Error('Unknown normalization "' + normalization + '". ' +
            'Choose "unbiased" (default), "uncorrected", or "biased".');
    }
  }
};

},{"../../type/Matrix":49,"../../type/collection":52,"../../util/string":191}],136:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Calculate the inverse cosine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acos(x)
   *
   * Examples:
   *
   *    math.acos(0.5);           // returns Number 1.0471975511965979
   *    math.acos(math.cos(1.5)); // returns Number 1.5
   *
   *    math.acos(2);             // returns Complex 0 + 1.3169578969248166 i
   *
   * See also:
   *
   *    cos, atan, asin
   *
   * @param {Number | Boolean | Complex | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} The arc cosine of x
   */
  math.acos = function acos(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('acos', arguments.length, 1);
    }

    if (isNumber(x)) {
      if (x >= -1 && x <= 1) {
        return Math.acos(x);
      }
      else {
        return acos(new Complex(x, 0));
      }
    }

    if (isComplex(x)) {
      // acos(z) = 0.5*pi + i*log(iz + sqrt(1-z^2))
      var temp1 = new Complex(
          x.im * x.im - x.re * x.re + 1.0,
          -2.0 * x.re * x.im
      );
      var temp2 = math.sqrt(temp1);
      var temp3 = new Complex(
          temp2.re - x.im,
          temp2.im + x.re
      );
      var temp4 = math.log(temp3);

      // 0.5*pi = 1.5707963267948966192313216916398
      return new Complex(
          1.57079632679489661923 - temp4.im,
          temp4.re
      );
    }

    if (isCollection(x)) {
      return collection.deepMap(x, acos);
    }

    if (isBoolean(x) || x === null) {
      return Math.acos(x);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return acos(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('acos', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],137:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Calculate the inverse sine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asin(x)
   *
   * Examples:
   *
   *    math.asin(0.5);           // returns Number 0.5235987755982989
   *    math.asin(math.sin(1.5)); // returns Number ~1.5
   *
   *    math.asin(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    sin, atan, acos
   *
   * @param {Number | Boolean | Complex | Array | Matrix | null} x   Function input
   * @return {Number | Complex | Array | Matrix} The arc sine of x
   */
  math.asin = function asin(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('asin', arguments.length, 1);
    }

    if (isNumber(x)) {
      if (x >= -1 && x <= 1) {
        return Math.asin(x);
      }
      else {
        return asin(new Complex(x, 0));
      }
    }

    if (isComplex(x)) {
      // asin(z) = -i*log(iz + sqrt(1-z^2))
      var re = x.re;
      var im = x.im;
      var temp1 = new Complex(
          im * im - re * re + 1.0,
          -2.0 * re * im
      );
      var temp2 = math.sqrt(temp1);
      var temp3 = new Complex(
          temp2.re - im,
          temp2.im + re
      );
      var temp4 = math.log(temp3);

      return new Complex(temp4.im, -temp4.re);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, asin);
    }

    if (isBoolean(x) || x === null) {
      return Math.asin(x);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return asin(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('asin', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],138:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Calculate the inverse tangent of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atan(x)
   *
   * Examples:
   *
   *    math.atan(0.5);           // returns Number 0.4636476090008061
   *    math.atan(math.tan(1.5)); // returns Number 1.5
   *
   *    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    tan, asin, acos
   *
   * @param {Number | Boolean | Complex | Array | Matrix | null} x   Function input
   * @return {Number | Complex | Array | Matrix} The arc tangent of x
   */
  math.atan = function atan(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('atan', arguments.length, 1);
    }

    if (isNumber(x)) {
      return Math.atan(x);
    }

    if (isComplex(x)) {
      // atan(z) = 1/2 * i * (ln(1-iz) - ln(1+iz))
      var re = x.re;
      var im = x.im;
      var den = re * re + (1.0 - im) * (1.0 - im);

      var temp1 = new Complex(
          (1.0 - im * im - re * re) / den,
          (-2.0 * re) / den
      );
      var temp2 = math.log(temp1);

      return new Complex(
          -0.5 * temp2.im,
          0.5 * temp2.re
      );
    }

    if (isCollection(x)) {
      return collection.deepMap(x, atan);
    }

    if (isBoolean(x) || x === null) {
      return Math.atan(x);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return atan(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('atan', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],139:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isCollection = collection.isCollection;

  /**
   * Calculate the inverse tangent function with two arguments, y/x.
   * By providing two arguments, the right quadrant of the computed angle can be
   * determined.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atan2(y, x)
   *
   * Examples:
   *
   *    math.atan2(2, 2) / math.pi;       // returns number 0.25
   *
   *    var angle = math.unit(60, 'deg'); // returns Unit 60 deg
   *    var x = math.cos(angle);
   *    var y = math.sin(angle);
   *
   *    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    tan, atan, sin, cos
   *
   * @param {Number | Boolean | Complex | Array | Matrix | null} y  Second dimension
   * @param {Number | Boolean | Complex | Array | Matrix | null} x  First dimension
   * @return {Number | Complex | Array | Matrix} Four-quadrant inverse tangent
   */
  math.atan2 = function atan2(y, x) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('atan2', arguments.length, 2);
    }

    if (isNumber(y)) {
      if (isNumber(x)) {
        return Math.atan2(y, x);
      }
    }

    // TODO: support for complex computation of atan2

    if (isCollection(y) || isCollection(x)) {
      return collection.deepMap2(y, x, atan2);
    }

    if (isBoolean(y) || y === null) {
      return atan2(+y, x);
    }
    if (isBoolean(x) || x === null) {
      return atan2(y, +x);
    }

    // TODO: implement bignumber support
    if (y instanceof BigNumber) {
      return atan2(y.toNumber(), x);
    }
    if (x instanceof BigNumber) {
      return atan2(y, x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('atan2', math['typeof'](y), math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/collection":52}],140:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the cosine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cos(x)
   *
   * Examples:
   *
   *    math.cos(2);                      // returns Number -0.4161468365471422
   *    math.cos(math.pi / 4);            // returns Number  0.7071067811865475
   *    math.cos(math.unit(180, 'deg'));  // returns Number -1
   *    math.cos(math.unit(60, 'deg'));   // returns Number  0.5
   *
   *    var angle = 0.2;
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2); // returns Number ~1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Cosine of x
   */
  math.cos = function cos(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('cos', arguments.length, 1);
    }

    if (isNumber(x)) {
      return Math.cos(x);
    }

    if (isComplex(x)) {
      // cos(z) = (exp(iz) + exp(-iz)) / 2
      return new Complex(
          0.5 * Math.cos(x.re) * (Math.exp(-x.im) + Math.exp(x.im)),
          0.5 * Math.sin(x.re) * (Math.exp(-x.im) - Math.exp(x.im))
      );
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cos is no angle');
      }
      return Math.cos(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, cos);
    }

    if (isBoolean(x) || x === null) {
      return Math.cos(x);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return cos(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('cos', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],141:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the hyperbolic cosine of a value,
   * defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cosh(x)
   *
   * Examples:
   *
   *    math.cosh(0.5);       // returns Number 1.1276259652063807
   *
   * See also:
   *
   *    sinh, tanh
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Hyperbolic cosine of x
   */
  math.cosh = function cosh(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('cosh', arguments.length, 1);
    }

    if (isNumber(x)) {
      return (Math.exp(x) + Math.exp(-x)) / 2;
    }

    if (isComplex(x)) {
      var ep = Math.exp(x.re);
      var en = Math.exp(-x.re);
      return new Complex(Math.cos(x.im) * (ep + en) / 2, Math.sin(x.im) * (ep - en) / 2);
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cosh is no angle');
      }
      return cosh(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, cosh);
    }

    if (isBoolean(x) || x === null) {
      return cosh(x ? 1 : 0);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return cosh(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('cosh', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],142:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the cotangent of a value. `cot(x)` is defined as `1 / tan(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cot(x)
   *
   * Examples:
   *
   *    math.cot(2);      // returns Number -0.45765755436028577
   *    1 / math.tan(2);  // returns Number -0.45765755436028577
   *
   * See also:
   *
   *    tan, sec, csc
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Cotangent of x
   */
  math.cot = function cot(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('cot', arguments.length, 1);
    }

    if (isNumber(x)) {
      return 1 / Math.tan(x);
    }

    if (isComplex(x)) {
      var den = Math.exp(-4.0 * x.im) -
          2.0 * Math.exp(-2.0 * x.im) * Math.cos(2.0 * x.re) + 1.0;

      return new Complex(
          2.0 * Math.exp(-2.0 * x.im) * Math.sin(2.0 * x.re) / den,
          (Math.exp(-4.0 * x.im) - 1.0) / den
      );
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cot is no angle');
      }
      return 1 / Math.tan(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, cot);
    }

    if (isBoolean(x) || x === null) {
      return cot(+x);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return cot(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('cot', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],143:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the hyperbolic cotangent of a value,
   * defined as `coth(x) = 1 / tanh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.coth(x)
   *
   * Examples:
   *
   *    // coth(x) = 1 / tanh(x)
   *    math.coth(2);         // returns 1.0373147207275482
   *    1 / math.tanh(2);     // returns 1.0373147207275482
   *
   * See also:
   *
   *    sinh, tanh, cosh
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Hyperbolic cotangent of x
   */
  math.coth = function coth(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('coth', arguments.length, 1);
    }

    if (isNumber(x)) {
      var e = Math.exp(2 * x);
      return (e + 1) / (e - 1);
    }

    if (isComplex(x)) {
      var r = Math.exp(2 * x.re);
      var re = r * Math.cos(2 * x.im);
      var im = r * Math.sin(2 * x.im);
      var den = (re - 1) * (re - 1) + im * im;
      return new Complex(
        ((re + 1) * (re - 1) + im * im) / den,
        -2 * im / den
      );
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function coth is no angle');
      }
      return coth(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, coth);
    }

    if (isBoolean(x) || x === null) {
      return coth(x ? 1 : 0);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return coth(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('coth', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],144:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the cosecant of a value, defined as `csc(x) = 1/sin(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.csc(x)
   *
   * Examples:
   *
   *    math.csc(2);      // returns Number 1.099750170294617
   *    1 / math.sin(2);  // returns Number 1.099750170294617
   *
   * See also:
   *
   *    sin, sec, cot
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Cosecant of x
   */
  math.csc = function csc(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('csc', arguments.length, 1);
    }

    if (isNumber(x)) {
      return 1 / Math.sin(x);
    }

    if (isComplex(x)) {
      // csc(z) = 1/sin(z) = (2i) / (exp(iz) - exp(-iz))
      var den = 0.25 * (Math.exp(-2.0 * x.im) + Math.exp(2.0 * x.im)) -
          0.5 * Math.cos(2.0 * x.re);

      return new Complex (
          0.5 * Math.sin(x.re) * (Math.exp(-x.im) + Math.exp(x.im)) / den,
          0.5 * Math.cos(x.re) * (Math.exp(-x.im) - Math.exp(x.im)) / den
      );
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function csc is no angle');
      }
      return 1 / Math.sin(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, csc);
    }

    if (isBoolean(x) || x === null) {
      return csc(+x);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return csc(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('csc', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],145:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),
      number = util.number,
      
      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the hyperbolic cosecant of a value,
   * defined as `csch(x) = 1 / sinh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.csch(x)
   *
   * Examples:
   *
   *    // csch(x) = 1/ sinh(x)
   *    math.csch(0.5);       // returns 1.9190347513349437
   *    1 / math.sinh(0.5);   // returns 1.9190347513349437
   *
   * See also:
   *
   *    sinh, sech, coth
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Hyperbolic cosecant of x
   */
  math.csch = function csch(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('csch', arguments.length, 1);
    }

    if (isNumber(x)) {
      // x == 0
      if (x == 0) return Number.NaN;
      // consider values close to zero (+/-)
      return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * number.sign(x);
    }

    if (isComplex(x)) {
      var ep = Math.exp(x.re);
      var en = Math.exp(-x.re);
      var re = Math.cos(x.im) * (ep - en);
      var im = Math.sin(x.im) * (ep + en);
      var den = re * re + im * im;
      return new Complex(2 * re / den, -2 * im /den);
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function csch is no angle');
      }
      return csch(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, csch);
    }

    if (isBoolean(x) || x === null) {
      return csch(x ? 1 : 0);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return csch(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('csch', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],146:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the secant of a value, defined as `sec(x) = 1/cos(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sec(x)
   *
   * Examples:
   *
   *    math.sec(2);      // returns Number -2.4029979617223822
   *    1 / math.cos(2);  // returns Number -2.4029979617223822
   *
   * See also:
   *
   *    cos, csc, cot
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Secant of x
   */
  math.sec = function sec(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('sec', arguments.length, 1);
    }

    if (isNumber(x)) {
      return 1 / Math.cos(x);
    }

    if (isComplex(x)) {
      // sec(z) = 1/cos(z) = 2 / (exp(iz) + exp(-iz))
      var den = 0.25 * (Math.exp(-2.0 * x.im) + Math.exp(2.0 * x.im)) +
          0.5 * Math.cos(2.0 * x.re);

      return new Complex(
          0.5 * Math.cos(x.re) * (Math.exp(-x.im) + Math.exp( x.im)) / den,
          0.5 * Math.sin(x.re) * (Math.exp( x.im) - Math.exp(-x.im)) / den
      );
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sec is no angle');
      }
      return 1 / Math.cos(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, sec);
    }

    if (isBoolean(x) || x === null) {
      return sec(+x);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return sec(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('sec', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],147:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the hyperbolic secant of a value,
   * defined as `sech(x) = 1 / cosh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sech(x)
   *
   * Examples:
   *
   *    // sech(x) = 1/ cosh(x)
   *    math.sech(0.5);       // returns 0.886818883970074
   *    1 / math.cosh(0.5);   // returns 1.9190347513349437
   *
   * See also:
   *
   *    cosh, csch, coth
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Hyperbolic secant of x
   */
  math.sech = function sech(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('sech', arguments.length, 1);
    }

    if (isNumber(x)) {
      return 2 / (Math.exp(x) + Math.exp(-x));
    }

    if (isComplex(x)) {
      var ep = Math.exp(x.re);
      var en = Math.exp(-x.re);
      var re = Math.cos(x.im) * (ep + en);
      var im = Math.sin(x.im) * (ep - en);
      var den = re * re + im * im;
      return new Complex(2 * re / den, -2 * im / den);
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sech is no angle');
      }
      return sech(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, sech);
    }

    if (isBoolean(x) || x === null) {
      return sech(x ? 1 : 0);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return sech(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('sech', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],148:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the sine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sin(x)
   *
   * Examples:
   *
   *    math.sin(2);                      // returns Number 0.9092974268256813
   *    math.sin(math.pi / 4);            // returns Number 0.7071067811865475
   *    math.sin(math.unit(90, 'deg'));   // returns Number 1
   *    math.sin(math.unit(30, 'deg'));   // returns Number 0.5
   *
   *    var angle = 0.2;
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2); // returns Number ~1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Sine of x
   */
  math.sin = function sin(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('sin', arguments.length, 1);
    }

    if (isNumber(x)) {
      return Math.sin(x);
    }

    if (isComplex(x)) {
      return new Complex(
          0.5 * Math.sin(x.re) * (Math.exp(-x.im) + Math.exp( x.im)),
          0.5 * Math.cos(x.re) * (Math.exp( x.im) - Math.exp(-x.im))
      );
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sin is no angle');
      }
      return Math.sin(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, sin);
    }

    if (isBoolean(x) || x === null) {
      return Math.sin(x);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return sin(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('sin', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],149:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the hyperbolic sine of a value,
   * defined as `sinh(x) = 1/2 * (exp(x) - exp(-x))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sinh(x)
   *
   * Examples:
   *
   *    math.sinh(0.5);       // returns Number 0.5210953054937474
   *
   * See also:
   *
   *    cosh, tanh
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Hyperbolic sine of x
   */
  math.sinh = function sinh(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('sinh', arguments.length, 1);
    }

    if (isNumber(x)) {
      return (Math.exp(x) - Math.exp(-x)) / 2;
    }

    if (isComplex(x)) {
      var cim = Math.cos(x.im);
      var sim = Math.sin(x.im);
      var ep = Math.exp(x.re);
      var en = Math.exp(-x.re);
      return new Complex(cim * (ep - en) / 2, sim * (ep + en) / 2);
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sinh is no angle');
      }
      return sinh(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, sinh);
    }

    if (isBoolean(x) || x === null) {
      return sinh(x ? 1 : 0);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return sinh(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('sinh', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],150:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the tangent of a value. `tan(x)` is equal to `sin(x) / cos(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.tan(x)
   *
   * Examples:
   *
   *    math.tan(0.5);                    // returns Number 0.5463024898437905
   *    math.sin(0.5) / math.cos(0.5);    // returns Number 0.5463024898437905
   *    math.tan(math.pi / 4);            // returns Number 1
   *    math.tan(math.unit(45, 'deg'));   // returns Number 1
   *
   * See also:
   *
   *    atan, sin, cos
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Tangent of x
   */
  math.tan = function tan(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('tan', arguments.length, 1);
    }

    if (isNumber(x)) {
      return Math.tan(x);
    }

    if (isComplex(x)) {
      var den = Math.exp(-4.0 * x.im) +
          2.0 * Math.exp(-2.0 * x.im) * Math.cos(2.0 * x.re) +
          1.0;

      return new Complex(
          2.0 * Math.exp(-2.0 * x.im) * Math.sin(2.0 * x.re) / den,
          (1.0 - Math.exp(-4.0 * x.im)) / den
      );
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function tan is no angle');
      }
      return Math.tan(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, tan);
    }

    if (isBoolean(x) || x === null) {
      return Math.tan(x);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return tan(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('tan', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],151:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = math.type.BigNumber,
      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isNumber = util.number.isNumber,
      isBoolean = util['boolean'].isBoolean,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Calculate the hyperbolic tangent of a value,
   * defined as `tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.tanh(x)
   *
   * Examples:
   *
   *    // tanh(x) = sinh(x) / cosh(x) = 1 / coth(x)
   *    math.tanh(0.5);                   // returns 0.46211715726000974
   *    math.sinh(0.5) / math.cosh(0.5);  // returns 0.46211715726000974
   *    1 / math.coth(0.5);               // returns 0.46211715726000974
   *
   * See also:
   *
   *    sinh, cosh, coth
   *
   * @param {Number | Boolean | Complex | Unit | Array | Matrix | null} x  Function input
   * @return {Number | Complex | Array | Matrix} Hyperbolic tangent of x
   */
  math.tanh = function tanh(x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('tanh', arguments.length, 1);
    }

    if (isNumber(x)) {
      var e = Math.exp(2 * x);
      return (e - 1) / (e + 1);
    }

    if (isComplex(x)) {
      var r = Math.exp(2 * x.re);
      var re = r * Math.cos(2 * x.im);
      var im = r * Math.sin(2 * x.im);
      var den = (re + 1) * (re + 1) + im * im;
      return new Complex(
        ((re - 1) * (re + 1) + im * im) / den,
        im * 2 / den
      );
    }

    if (isUnit(x)) {
      if (!x.hasBase(Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function tanh is no angle');
      }
      return tanh(x.value);
    }

    if (isCollection(x)) {
      return collection.deepMap(x, tanh);
    }

    if (isBoolean(x) || x === null) {
      return tanh(x ? 1 : 0);
    }

    if (x instanceof BigNumber) {
      // TODO: implement BigNumber support
      // downgrade to Number
      return tanh(x.toNumber());
    }

    throw new math.error.UnsupportedTypeError('tanh', math['typeof'](x));
  };
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50,"../../type/collection":52}],152:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      Unit = require('../../type/Unit'),
      collection = require('../../type/collection'),

      isString = util.string.isString,
      isUnit = Unit.isUnit,
      isCollection = collection.isCollection;

  /**
   * Change the unit of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.to(x, unit)
   *
   * Examples:
   *
   *    math.to(math.unit('2 inch'), 'cm');                   // returns Unit 5.08 cm
   *    math.to(math.unit('2 inch'), math.unit(null, 'cm'));  // returns Unit 5.08 cm
   *    math.to(math.unit(16, 'bytes'), 'bits');              // returns Unit 128 bits
   *
   * See also:
   *
   *    unit
   *
   * @param {Unit | Array | Matrix} x     The unit to be converted.
   * @param {Unit | Array | Matrix} unit  New unit. Can be a string like "cm"
   *                                      or a unit without value.
   * @return {Unit | Array | Matrix} value with changed, fixed unit.
   */
  math.to = function to(x, unit) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('to', arguments.length, 2);
    }

    if (isUnit(x)) {
      if (isUnit(unit) || isString(unit)) {
        return x.to(unit);
      }
    }

    // TODO: add support for string, in that case, convert to unit

    if (isCollection(x) || isCollection(unit)) {
      return collection.deepMap2(x, unit, to);
    }

    throw new math.error.UnsupportedTypeError('to', math['typeof'](x), math['typeof'](unit));
  };
};

},{"../../util/index":178,"../../type/Unit":50,"../../type/collection":52}],153:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),
      object = util.object;

  /**
   * Clone an object.
   *
   * Syntax:
   *
   *     math.clone(x)
   *
   * Examples:
   *
   *    math.clone(3.5);              // returns number 3.5
   *    math.clone(2 - 4i);           // returns Complex 2 - 4i
   *    math.clone(45 deg);           // returns Unit 45 deg
   *    math.clone([[1, 2], [3, 4]]); // returns Array [[1, 2], [3, 4]]
   *    math.clone("hello world");    // returns string "hello world"
   *
   * @param {*} x   Object to be cloned
   * @return {*} A clone of object x
   */
  math.clone = function clone (x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('clone', arguments.length, 1);
    }

    return object.clone(x);
  };
};

},{"../../util/index":178}],154:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var Matrix = require('../../type/Matrix');

  /**
   * Sort the items in a matrix.
   *
   * Syntax:
   *
   *    math.filter(x, test)
   *
   * Examples:
   *
   *    function isPositive (x) {
   *      return x > 0;
   *    }
   *    math.filter([6, -2, -1, 4, 3], isPositive); // returns [6, 4, 3]
   *
   *    math.filter(["23", "foo", "100", "55", "bar"], /[0-9]+/); // returns ["23", "100", "55"]
   *
   * See also:
   *
   *    forEach, map, sort
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to filter
   * @param {Function | RegExp} test
   *        A function or regular expression to test items.
   *        When `test` is a function, it must return a boolean.
   *        All entries for which `test` returns true are returned.
   * @return {Matrix | Array} Returns the filtered matrix.
   */
  math.filter = function (x, test) {
    if (arguments.length !== 2) {
      throw new math.error.ArgumentsError('filter', arguments.length, 2);
    }

    if (x instanceof Matrix) {
      var size = x.size();
      if (size.length > 1) {
        throw new Error('Only one dimensional matrices supported');
      }
      return new Matrix(_filter(x.toArray(), test));
    }
    else if (Array.isArray(x)) {
      return _filter(x, test);
    }
    else {
      throw new math.error.UnsupportedTypeError('filter', math['typeof'](x), math['typeof'](compare));
    }
  };

  /**
   *
   * @param {Array} x
   * @param {function | RegExp} test
   * @return {Array} Returns the filtered array
   * @private
   */
  function _filter(x, test) {
    if (typeof test === 'function') {
      return x.filter(function (entry) {
        return test(entry);
      });
    }
    else if (test instanceof RegExp) {
      return x.filter(function (entry) {
        return test.test(entry);
      });
    }
    else {
      throw new TypeError('Function or RegExp expected');
    }
  }
};
},{"../../type/Matrix":49}],155:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),
      string = util.string;

  /**
   * Format a value of any type into a string.
   *
   * Syntax:
   *
   *    math.format(value)
   *    math.format(value, options)
   *    math.format(value, precision)
   *    math.format(value, fn)
   *
   * Where:
   *
   *  - `value: *`
   *    The value to be formatted
   *  - `options: Object`
   *    An object with formatting options. Available options:
   *    - `notation: String`
   *      Number notation. Choose from:
   *      - 'fixed'
   *        Always use regular number notation.
   *        For example '123.40' and '14000000'
   *      - 'exponential'
   *        Always use exponential notation.
   *        For example '1.234e+2' and '1.4e+7'
   *      - 'auto' (default)
   *        Regular number notation for numbers having an absolute value between
   *        `lower` and `upper` bounds, and uses exponential notation elsewhere.
   *        Lower bound is included, upper bound is excluded.
   *        For example '123.4' and '1.4e7'.
   *    - `precision: Number`
   *      A number between 0 and 16 to round the digits of the number. In case
   *      of notations 'exponential' and 'auto', `precision` defines the total
   *      number of significant digits returned and is undefined by default.
   *      In case of notation 'fixed', `precision` defines the number of
   *      significant digits after the decimal point, and is 0 by default.
   *    - `exponential: Object`
   *      An object containing two parameters, {Number} lower and {Number} upper,
   *      used by notation 'auto' to determine when to return exponential
   *      notation. Default values are `lower=1e-3` and `upper=1e5`. Only
   *      applicable for notation `auto`.
   * - `fn: Function`
   *   A custom formatting function. Can be used to override the built-in notations.
   *   Function `fn` is called with `value` as parameter and must return a string.
   *   Is useful for example to format all values inside a matrix in a particular way.
   *
   * Examples:
   *
   *    math.format(6.4);                                        // returns '6.4'
   *    math.format(1240000);                                    // returns '1.24e6'
   *    math.format(1/3);                                        // returns '0.3333333333333333'
   *    math.format(1/3, 3);                                     // returns '0.333'
   *    math.format(21385, 2);                                   // returns '21000'
   *    math.format(12.071, {notation: 'fixed'});                // returns '12'
   *    math.format(2.3,    {notation: 'fixed', precision: 2});  // returns '2.30'
   *    math.format(52.8,   {notation: 'exponential'});          // returns '5.28e+1'
   *
   * See also:
   *
   *    print
   *
   * @param {*} value                               Value to be stringified
   * @param {Object | Function | Number} [options]  Formatting options
   * @return {String} The formatted value
   */
  math.format = function format (value, options) {
    var num = arguments.length;
    if (num !== 1 && num !== 2) {
      throw new math.error.ArgumentsError('format', num, 1, 2);
    }

    return string.format(value, options);
  };
};

},{"../../util/index":178}],156:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      Complex = require('../../type/Complex'),
      Unit = require('../../type/Unit'),

      isNumber = util.number.isNumber,
      isString = util.string.isString,
      isComplex = Complex.isComplex,
      isUnit = Unit.isUnit;

  /**
   * Import functions from an object or a module
   *
   * Syntax:
   *
   *    math.import(object)
   *    math.import(object, options)
   *
   * Where:
   *
   * - `object: Object`
   *   An object with functions to be imported.
   * - `options: Object` An object with import options. Available options:
   *   - `override: boolean`
   *     If true, existing functions will be overwritten. False by default.
   *   - `wrap: boolean`
   *     If true, the functions will be wrapped in a wrapper function
   *     which converts data types like Matrix to primitive data types like Array.
   *     The wrapper is needed when extending math.js with libraries which do not
   *     support these data types. False by default.
   *
   * Examples:
   *
   *    // define new functions and variables
   *    math.import({
   *      myvalue: 42,
   *      hello: function (name) {
   *        return 'hello, ' + name + '!';
   *      }
   *    });
   *
   *    // use the imported function and variable
   *    math.myvalue * 2;               // 84
   *    math.hello('user');             // 'hello, user!'
   *
   *    // import the npm module numbers
   *    // (must be installed first with `npm install numbers`)
   *    math.import('numbers', {wrap: true});
   *
   *    math.fibonacci(7); // returns 13
   *
   * @param {String | Object} object  Object with functions to be imported.
   * @param {Object} [options]        Import options.
   */
  // TODO: return status information
  math['import'] = function math_import(object, options) {
    var num = arguments.length;
    if (num != 1 && num != 2) {
      throw new math.error.ArgumentsError('import', num, 1, 2);
    }

    var name;
    var opts = {
      override: options && options.override || false,
      wrap:     options && options.wrap || false
    };

    if (isString(object)) {
      // a string with a filename

      // istanbul ignore else (we cannot unit test the else case in a node.js environment)
      if (typeof (require) !== 'undefined') {
        // load the file using require
        var _module = require(object);
        math_import(_module, options);
      }
      else {
        throw new Error('Cannot load module: require not available.');
      }
    }
    else if (typeof object === 'object') {
      // a map with functions
      for (name in object) {
        if (object.hasOwnProperty(name)) {
          var value = object[name];
          if (isSupportedType(value)) {
            _import(name, value, opts);
          }
          else {
            math_import(value, options);
          }
        }
      }
    }
    else {
      throw new TypeError('Object or module name expected');
    }
  };

  /**
   * Add a property to the math namespace and create a chain proxy for it.
   * @param {String} name
   * @param {*} value
   * @param {Object} options  See import for a description of the options
   * @private
   */
  function _import(name, value, options) {
    if (options.override || math[name] === undefined) {
      // add to math namespace
      if (options.wrap && typeof value === 'function') {
        // create a wrapper around the function
        math[name] = function () {
          var args = [];
          for (var i = 0, len = arguments.length; i < len; i++) {
            var arg = arguments[i];
            args[i] = arg && arg.valueOf();
          }
          return value.apply(math, args);
        };
      }
      else {
        // just create a link to the function or value
        math[name] = value;
      }

      // create a proxy for the Selector
      math.chaining.Selector.createProxy(name, value);
    }
  }

  /**
   * Check whether given object is a supported type
   * @param object
   * @return {Boolean}
   * @private
   */
  function isSupportedType(object) {
    return (typeof object == 'function') ||
        isNumber(object) || isString(object) ||
        isComplex(object) || isUnit(object);
    // TODO: add boolean?
  }
};

},{"../../util/index":178,"../../type/Complex":43,"../../type/Unit":50}],157:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var isMatrix = require('../../type/Matrix').isMatrix;


  /**
   * Create a new matrix or array with the results of the callback function executed on
   * each entry of the matrix/array.
   *
   * Syntax:
   *
   *    math.map(x, callback)
   *
   * Examples:
   *
   *    math.map([1, 2, 3], function(value) {
   *      return value * value;
   *    });  // returns [1, 4, 9]
   *
   * See also:
   *
   *    filter, forEach, sort
   *
   * @param {Matrix | Array} x    The matrix to iterate on.
   * @param {Function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the matrix being traversed.
   * @return {Matrix | array}     Transformed map of x
   */
  math.map = function (x, callback) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('map', arguments.length, 2);
    }

    if (Array.isArray(x)) {
      return _mapArray(x, callback);
    } else if (isMatrix(x)) {
      return x.map(callback);
    } else {
      throw new math.error.UnsupportedTypeError('map', math['typeof'](x));
    }
  };

  function _mapArray (arrayIn, callback) {
    var index = [];
    var recurse = function (value, dim) {
      if (Array.isArray(value)) {
        return value.map(function (child, i) {
          index[dim] = i;
          return recurse(child, dim + 1);
        });
      }
      else {
        return callback(value, index, arrayIn);
      }
    };

    return recurse(arrayIn, 0);
  }
};

},{"../../type/Matrix":49}],158:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      isString = util.string.isString;

  /**
   * Interpolate values into a string template.
   *
   * Syntax:
   *
   *     math.print(template, values)
   *     math.print(template, values, precision)
   *
   * Example usage:
   *
   *     // the following outputs: 'Lucy is 5 years old'
   *     math.print('Lucy is $age years old', {age: 5});
   *
   *     // the following outputs: 'The value of pi is 3.141592654'
   *     math.print('The value of pi is $pi', {pi: math.pi}, 10);
   *
   *     // the following outputs: 'hello Mary! The date is 2013-03-23'
   *     math.print('Hello $user.name! The date is $date', {
   *       user: {
   *         name: 'Mary',
   *       },
   *       date: new Date(2013, 2, 23).toISOString().substring(0, 10)
   *     });
   *
   * See also:
   *
   *     format
   *
   * @param {String} template     A string containing variable placeholders.
   * @param {Object} values       An object containing variables which will
   *                              be filled in in the template.
   * @param {Number} [precision]  Number of digits to format numbers.
   *                              If not provided, the value will not be rounded.
   * @return {String} Interpolated string
   */
  math.print = function print (template, values, precision) {
    var num = arguments.length;
    if (num != 2 && num != 3) {
      throw new math.error.ArgumentsError('print', num, 2, 3);
    }

    if (!isString(template)) {
      throw new TypeError('String expected as first parameter in function format');
    }
    if (!(values instanceof Object)) {
      throw new TypeError('Object expected as second parameter in function format');
    }

    // format values into a string
    return template.replace(/\$([\w\.]+)/g, function (original, key) {
          var keys = key.split('.');
          var value = values[keys.shift()];
          while (keys.length && value !== undefined) {
            var k = keys.shift();
            value = k ? value[k] : value + '.';
          }

          if (value !== undefined) {
            if (!isString(value)) {
              return math.format(value, precision);
            }
            else {
              return value;
            }
          }

          return original;
        }
    );
  };
};

},{"../../util/index":178}],159:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var Matrix = require('../../type/Matrix');

  /**
   * Sort the items in a matrix.
   *
   * Syntax:
   *
   *    math.sort(x)
   *    math.sort(x, compare)
   *
   * Examples:
   *
   *    math.sort([5, 10, 1]); // returns [1, 5, 10]
   *    math.sort(['C', 'B', 'A', 'D']); // returns ['A', 'B', 'C', 'D']
   *
   *    function sortByLength (a, b) {
   *      return a.length - b.length;
   *    }
   *    math.sort(['Langdon', 'Tom', 'Sara'], sortByLength); // returns ['Tom', 'Sara', 'Langdon']
   *
   * See also:
   *
   *    filter, forEach, map
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to sort
   * @param {Function | 'asc' | 'desc'} [compare='asc']
   *        An optional comparator function. The function is called as
   *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,
   *        and 0 when a == b.
   * @return {Matrix | Array} Returns the sorted matrix.
   */
  math.sort = function (x, compare) {
    var _compare = null;

    if (arguments.length === 1) {
      _compare = math.compare;
    }
    else if (arguments.length === 2) {
      if (typeof compare === 'function') {
        _compare = compare;
      }
      else if (compare === 'asc') {
        _compare = math.compare;
      }
      else if (compare === 'desc') {
        _compare = function (a, b) {
          return -math.compare(a, b);
        }
      }
      else {
        throw new math.error.UnsupportedTypeError('sort', math['typeof'](x), math['typeof'](compare));
      }
    }
    else {
      throw new math.error.ArgumentsError('sort', arguments.length, 1, 2);
    }

    if (x instanceof Matrix) {
      var size = x.size();
      if (size.length > 1) {
        throw new Error('Only one dimensional matrices supported');
      }
      return new Matrix(x.toArray().sort(_compare));
    }
    else if (Array.isArray(x)) {
      return x.sort(_compare);
    }
    else {
      throw new math.error.UnsupportedTypeError('sort', math['typeof'](x), math['typeof'](compare));
    }
  };
};
},{"../../type/Matrix":49}],160:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var types = require('../../util/types'),

      Complex = require('../../type/Complex'),
      Matrix = require('../../type/Matrix'),
      Unit = require('../../type/Unit'),
      Index = require('../../type/Index'),
      Range = require('../../type/Range'),
      Help = require('../../type/Help');

  /**
   * Determine the type of a variable.
   *
   * Function `typeof` recognizes the following types of objects:
   *
   * Object                 | Returns       | Example
   * ---------------------- | ------------- | ------------------------------------------
   * Array                  | `'array'`     | `math.typeof ([1, 2, 3])`
   * boolean                | `'boolean'`   | `math.typeof (true)`
   * Date                   | `'date'`      | `math.typeof (new Date())`
   * null                   | `'null'`      | `math.typeof(null)`
   * number                 | `'number'`    | `math.typeof(3.5)`
   * Object                 | `'object'`    | `math.typeof ({a: 2, b: 3})`
   * RegExp                 | `'regexp'`    | `math.typeof (/a regexp/)`
   * string                 | `'string'`    | `math.typeof ('hello world')`
   * undefined              | `'undefined'` | `math.typeof(undefined)`
   * math.chaining.Selector | `'selector'`  | `math.typeof (math.select(2))`
   * math.type.BigNumber    | `'bignumber'` | `math.typeof (math.bignumber('2.3e500'))`
   * math.type.Complex      | `'complex'`   | `math.typeof (math.complex(2, 3))`
   * math.type.Help         | `'help'`      | `math.typeof (math.help('sqrt'))`
   * math.type.Index        | `'index'`     | `math.typeof (math.index(1, 3))`
   * math.type.Matrix       | `'matrix'`    | `math.typeof (math.matrix([[1,2], [3, 4]]))`
   * math.type.Range        | `'range'`     | `math.typeof (math.range(0, 10))`
   * math.type.Unit         | `'unit'`      | `math.typeof (math.unit('45 deg'))`
   *
   * Syntax:
   *
   *    math.typeof(x)
   *
   * Examples:
   *
   *    math.typeof(3.5);                     // returns 'number'
   *    math.typeof(math.complex('2 - 4i'));  // returns 'complex'
   *    math.typeof(math.unit('45 deg'));     // returns 'unit'
   *    math.typeof('hello world');           // returns 'string'
   *
   * @param {*} x  The variable for which to test the type.
   * @return {String} Lower case type, for example 'number', 'string', 'array'.
   */
  math['typeof'] = function _typeof (x) {
    if (arguments.length != 1) {
      throw new math.error.ArgumentsError('typeof', arguments.length, 1);
    }

    // JavaScript types
    var type = types.type(x);

    // math.js types
    if (type === 'object') {
      if (x instanceof Complex) return 'complex';
      if (x instanceof Matrix) return 'matrix';
      if (x instanceof Unit) return 'unit';
      if (x instanceof Index) return 'index';
      if (x instanceof Range) return 'range';
      if (x instanceof Help) return 'help';

      // the following types are different instances per math.js instance
      if (x instanceof math.type.BigNumber) return 'bignumber';
      if (x instanceof math.chaining.Selector) return 'selector';
    }

    return type;
  };
};

},{"../../util/types":313,"../../type/Complex":43,"../../type/Matrix":49,"../../type/Unit":50,"../../type/Index":48,"../../type/Range":47,"../../type/Help":51}],161:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var isMatrix = require('../../type/Matrix').isMatrix;

  /**
   * Iterate over all elements of a matrix/array, and executes the given callback function.
   *
   * Syntax:
   *
   *    math.forEach(x, callback)
   *
   * Examples:
   *
   *    math.forEach([1, 2, 3], function(value) {
   *      console.log(value);
   *    });
   *    // outputs 1, 2, 3
   *
   * See also:
   *
   *    filter, map, sort
   *
   * @param {Matrix | Array} x    The matrix to iterate on.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix/array being traversed.
   */
  math.forEach = function (x, callback) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('forEach', arguments.length, 2);
    }

    if (Array.isArray(x)) {
      return _forEachArray(x, callback);
    } else if (isMatrix(x)) {
      return x.forEach(callback);
    } else {
      throw new math.error.UnsupportedTypeError('forEach', math['typeof'](x));
    }
  };

  function _forEachArray (array, callback) {
    var index = [];
    var recurse = function (value, dim) {
      if (Array.isArray(value)) {
        value.forEach(function (child, i) {
          index[dim] = i; // zero-based index
          recurse(child, dim + 1);
        });
      }
      else {
        callback(value, index, array);
      }
    };
    recurse(array, 0);
  }

};
},{"../../type/Matrix":49}],163:[function(require,module,exports){
'use strict';

var SymbolNode = require('../../expression/node/SymbolNode');
var isBoolean = require('../../util/boolean').isBoolean;
var argsToArray = require('../../util/array').argsToArray;
var ArgumentsError = require('../../error/ArgumentsError');

/**
 * Attach a transform function to math.filter
 * Adds a property transform containing the transform function.
 *
 * This transform adds support for equations as test function for math.filter,
 * so you can do something like 'filter([3, -2, 5], x > 0)'.
 * @param {Object} math
 */
module.exports = function (math) {
  var _filter = math.filter;

  _filter.transform = function (args, math, scope) {
    if (args.length !== 2) {
      throw new ArgumentsError('filter', arguments.length, 2);
    }

    var x = args[0].compile(math).eval(scope);
    var test;
    if (args[1] instanceof SymbolNode) {
      // a function pointer, like filter([3, -2, 5], myTestFunction);
      test = args[1].compile(math).eval(scope);
    }
    else {
      // an equation like filter([3, -2, 5], x > 0)

      // find an undefined symbol
      var _scope = scope || {};
      var symbol = args[1]
          .find({
            type: SymbolNode
          })
          .filter(function (symbol) {
            return !(symbol.name in math) && !(symbol.name in _scope);
          })[0];

      // create a test function for this equation
      var sub = Object.create(_scope);
      var eq = args[1].compile(math);
      if (symbol) {
        var name = symbol.name;
        test = function (x) {
          sub[name] = x;
          return eq.eval(sub);
        }
      }
      else {
        throw new Error('No undefined variable found in filter equation');
      }
    }

    return _filter(x, test);
  };

  math.filter.transform.rawArgs = true;
};

},{"../../expression/node/SymbolNode":189,"../../util/boolean":314,"../../util/array":44,"../../error/ArgumentsError":174}],170:[function(require,module,exports){
'use strict';

var isBoolean = require('../../util/boolean').isBoolean;
var argsToArray = require('../../util/array').argsToArray;

/**
 * Attach a transform function to math.range
 * Adds a property transform containing the transform function.
 *
 * This transform creates a range which includes the end value
 * @param {Object} math
 */
module.exports = function (math) {
  math.range.transform = function () {
    var args = argsToArray(arguments);

    var lastIndex = args.length - 1;
    var last = args[lastIndex];
    if (!isBoolean(last)) {
      args.push(true); // append a parameter includeEnd=true
    }

    return math.range.apply(math, args);
  };
};

},{"../../util/boolean":314,"../../util/array":44}],171:[function(require,module,exports){
'use strict';

var errorTransform = require('./error.transform').transform;
var isBoolean = require('../../util/boolean').isBoolean;
var argsToArray = require('../../util/array').argsToArray;

/**
 * Attach a transform function to math.subset
 * Adds a property transform containing the transform function.
 *
 * This transform creates a range which includes the end value
 * @param {Object} math
 */
module.exports = function (math) {
  math.subset.transform = function () {
    try {
      return math.subset.apply(math, argsToArray(arguments));
    }
    catch (err) {
      throw errorTransform(err);
    }
  };
};

},{"./error.transform":315,"../../util/boolean":314,"../../util/array":44}],40:[function(require,module,exports){
(function(process){
// Use the fastest possible means to execute a task in a future turn
// of the event loop.

// linked list of tasks (single, with head node)
var head = {task: void 0, next: null};
var tail = head;
var flushing = false;
var requestFlush = void 0;
var isNodeJS = false;

function flush() {
    /* jshint loopfunc: true */

    while (head.next) {
        head = head.next;
        var task = head.task;
        head.task = void 0;
        var domain = head.domain;

        if (domain) {
            head.domain = void 0;
            domain.enter();
        }

        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function() {
                   throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    flushing = false;
}

if (typeof process !== "undefined" && process.nextTick) {
    // Node.js before 0.9. Note that some fake-Node environments, like the
    // Mocha test runner, introduce a `process` global without a `nextTick`.
    isNodeJS = true;

    requestFlush = function () {
        process.nextTick(flush);
    };

} else if (typeof setImmediate === "function") {
    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
        requestFlush = setImmediate.bind(window, flush);
    } else {
        requestFlush = function () {
            setImmediate(flush);
        };
    }

} else if (typeof MessageChannel !== "undefined") {
    // modern browsers
    // http://www.nonblocking.io/2011/06/windownexttick.html
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    requestFlush = function () {
        channel.port2.postMessage(0);
    };

} else {
    // old browsers
    requestFlush = function () {
        setTimeout(flush, 0);
    };
}

function asap(task) {
    tail = tail.next = {
        task: task,
        domain: isNodeJS && process.domain,
        next: null
    };

    if (!flushing) {
        flushing = true;
        requestFlush();
    }
};

module.exports = asap;


})(require("__browserify_process"))
},{"__browserify_process":18}],45:[function(require,module,exports){
module.exports = '1.0.1';
// Note: This file is automatically generated when building math.js.
// Changes made in this file will be overwritten.

},{}],174:[function(require,module,exports){
'use strict';

/**
 * Create a syntax error with the message:
 *     'Wrong number of arguments in function <fn> (<count> provided, <min>-<max> expected)'
 * @param {String} fn     Function name
 * @param {Number} count  Actual argument count
 * @param {Number} min    Minimum required argument count
 * @param {Number} [max]  Maximum required argument count
 * @extends Error
 */
function ArgumentsError(fn, count, min, max) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.fn = fn;
  this.count = count;
  this.min = min;
  this.max = max;

  this.message = 'Wrong number of arguments in function ' + fn +
      ' (' + count + ' provided, ' +
      min + ((max != undefined) ? ('-' + max) : '') + ' expected)';

  this.stack = (new Error()).stack;
}

ArgumentsError.prototype = new Error();
ArgumentsError.prototype.constructor = Error;
ArgumentsError.prototype.name = 'ArgumentsError';

module.exports = ArgumentsError;

},{}],173:[function(require,module,exports){
(function(){/*! decimal.js v3.0.1 https://github.com/MikeMcl/decimal.js/LICENCE */
;(function (global) {
    'use strict';


    /*
     *  decimal.js v3.0.1
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2014 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Expat Licence
     */


    var convertBase, DecimalConstructor, noConflict,
        crypto = global['crypto'],
        external = true,
        id = 0,
        mathfloor = Math.floor,
        mathpow = Math.pow,
        outOfRange,
        toString = Object.prototype.toString,
        BASE = 1e7,
        LOGBASE = 7,
        NUMERALS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
        P = {},

        /*
         The maximum exponent magnitude.
         The limit on the value of toExpNeg, toExpPos, minE and maxE.
         */
        EXP_LIMIT = 9e15,                      // 0 to 9e15

        /*
         The limit on the value of precision, and on the argument to toDecimalPlaces,
         toExponential, toFixed, toFormat, toPrecision and toSignificantDigits.
         */
        MAX_DIGITS = 1E9,                      // 0 to 1e+9

        /*
         To decide whether or not to calculate x.pow(integer y) using the 'exponentiation by
         squaring' algorithm or by exp(y*ln(x)), the number of significant digits of x is multiplied
         by y. If this number is less than INT_POW_LIMIT then the former algorithm is used.
         */
        INT_POW_LIMIT = 3000,                  // 0 to 5000

        // The natural logarithm of 10 (1025 digits).
        LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058';


    // Decimal prototype methods


    /*
     * Return a new Decimal whose value is the absolute value of this Decimal.
     *
     */
    P['absoluteValue'] = P['abs'] = function () {
        var x = new this['constructor'](this);

        if ( x['s'] < 0 ) {
            x['s'] = 1;
        }

        return rnd(x);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in
     * the direction of positive Infinity.
     *
     */
    P['ceil'] = function () {

        return rnd( new this['constructor'](this), this['e'] + 1, 2 );
    };


    /*
     * Return
     *   1    if the value of this Decimal is greater than the value of Decimal(y, b),
     *  -1    if the value of this Decimal is less than the value of Decimal(y, b),
     *   0    if they have the same value,
     *  null  if the value of either Decimal is NaN.
     *
     */
    P['comparedTo'] = P['cmp'] = function ( y, b ) {
        var a,
            x = this,
            xc = x['c'],
            yc = ( id = -id, y = new x['constructor']( y, b ), y['c'] ),
            i = x['s'],
            j = y['s'],
            k = x['e'],
            l = y['e'];

        // Either NaN?
        if ( !i || !j ) {
            return null;
        }

        a = xc && !xc[0];
        b = yc && !yc[0];

        // Either zero?
        if ( a || b ) {
            return a ? b ? 0 : -j : i;
        }

        // Signs differ?
        if ( i != j ) {
            return i;
        }

        a = i < 0;

        // Either Infinity?
        if ( !xc || !yc ) {
            return k == l ? 0 : !xc ^ a ? 1 : -1;
        }

        // Compare exponents.
        if ( k != l ) {
            return k > l ^ a ? 1 : -1;
        }

        // Compare digit by digit.
        for ( i = -1,
              j = ( k = xc.length ) < ( l = yc.length ) ? k : l;
              ++i < j; ) {

            if ( xc[i] != yc[i] ) {
                return xc[i] > yc[i] ^ a ? 1 : -1;
            }
        }

        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    };


    /*
     * Return the number of decimal places of the value of this Decimal.
     *
     */
     P['decimalPlaces'] = P['dp'] = function () {
        var c, v,
            n = null;

        if ( c = this['c'] ) {
            n = ( ( v = c.length - 1 ) - mathfloor( this['e'] / LOGBASE ) ) * LOGBASE;

            if ( v = c[v] ) {

                // Subtract the number of trailing zeros of the last number.
                for ( ; v % 10 == 0; v /= 10, n-- );
            }

            if ( n < 0 ) {
                n = 0;
            }
        }

        return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new Decimal whose value is the value of this Decimal divided by Decimal(y, b),
     * rounded to precision significant digits using rounding mode rounding.
     *
     */
    P['dividedBy'] = P['div'] = function ( y, b ) {
        id = 2;

        return div( this, new this['constructor']( y, b ) );
    };


    /*
     * Return a new Decimal whose value is the integer part of dividing the value of this Decimal by
     * the value of Decimal(y, b), rounded to precision significant digits using rounding mode
     * rounding.
     *
     */
    P['dividedToIntegerBy'] = P['divToInt'] = function ( y, b ) {
        var x = this,
            Decimal = x['constructor'];
        id = 18;

        return rnd(
          div( x, new Decimal( y, b ), 0, 1, 1 ), Decimal['precision'], Decimal['rounding']
        );
    };


    /*
     * Return true if the value of this Decimal is equal to the value of Decimal(n, b), otherwise
     * return false.
     *
     */
    P['equals'] = P['eq'] = function ( n, b ) {
        id = 3;

        return this['cmp']( n, b ) === 0;
    };


    /*
     * Return a new Decimal whose value is the exponential of the value of this Decimal, i.e. the
     * base e raised to the power the value of this Decimal, rounded to precision significant digits
     * using rounding mode rounding.
     *
     */
    P['exponential'] = P['exp'] = function () {

        return exp(this);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in
     * the direction of negative Infinity.
     *
     */
    P['floor'] = function () {

        return rnd( new this['constructor'](this), this['e'] + 1, 3 );
    };


    /*
     * Return true if the value of this Decimal is greater than the value of Decimal(n, b), otherwise
     * return false.
     *
     */
    P['greaterThan'] = P['gt'] = function ( n, b ) {
        id = 4;

        return this['cmp']( n, b ) > 0;
    };


    /*
     * Return true if the value of this Decimal is greater than or equal to the value of
     * Decimal(n, b), otherwise return false.
     *
     */
    P['greaterThanOrEqualTo'] = P['gte'] = function ( n, b ) {
        id = 5;
        b = this['cmp']( n, b );

        return b == 1 || b === 0;
    };


    /*
     * Return true if the value of this Decimal is a finite number, otherwise return false.
     *
     */
    P['isFinite'] = function () {

        return !!this['c'];
    };


    /*
     * Return true if the value of this Decimal is an integer, otherwise return false.
     *
     */
    P['isInteger'] = P['isInt'] = function () {

        return !!this['c'] && mathfloor( this['e'] / LOGBASE ) > this['c'].length - 2;
    };


    /*
     * Return true if the value of this Decimal is NaN, otherwise return false.
     *
     */
    P['isNaN'] = function () {

        return !this['s'];
    };


    /*
     * Return true if the value of this Decimal is negative, otherwise return false.
     *
     */
    P['isNegative'] = P['isNeg'] = function () {

        return this['s'] < 0;
    };


    /*
     * Return true if the value of this Decimal is 0 or -0, otherwise return false.
     *
     */
    P['isZero'] = function () {

        return !!this['c'] && this['c'][0] == 0;
    };


    /*
     * Return true if the value of this Decimal is less than Decimal(n, b), otherwise return false.
     *
     */
    P['lessThan'] = P['lt'] = function ( n, b ) {
        id = 6;

        return this['cmp']( n, b ) < 0;
    };


    /*
     * Return true if the value of this Decimal is less than or equal to Decimal(n, b), otherwise
     * return false.
     *
     */
    P['lessThanOrEqualTo'] = P['lte'] = function ( n, b ) {
        id = 7;
        b = this['cmp']( n, b );

        return b == -1 || b === 0;
    };


    /*
     * Return the logarithm of the value of this Decimal to the specified base, rounded
     * to precision significant digits using rounding mode rounding.
     *
     * If no base is specified, return log[10](arg).
     *
     * log[base](arg) = ln(arg) / ln(base)
     *
     * The result will always be correctly rounded if the base of the log is 2 or 10, and
     * 'almost always' if not:
     *
     * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
     * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
     * between the result and the correctly rounded result will be one ulp (unit in the last place).
     *
     * log[-b](a)       = NaN
     * log[0](a)        = NaN
     * log[1](a)        = NaN
     * log[NaN](a)      = NaN
     * log[Infinity](a) = NaN
     * log[b](0)        = -Infinity
     * log[b](-0)       = -Infinity
     * log[b](-a)       = NaN
     * log[b](1)        = 0
     * log[b](Infinity) = Infinity
     * log[b](NaN)      = NaN
     *
     * [base] {number|string|Decimal} The base of the logarithm.
     * [b] {number} The base of base.
     *
     */
    P['logarithm'] = P['log'] = function ( base, b ) {
        var base10, c, denom, i, inf, num, sd, sd10, r,
            arg = this,
            Decimal = arg['constructor'],
            pr = Decimal['precision'],
            rm = Decimal['rounding'],
            guard = 5;

        // Default base is 10.
        if ( base == null ) {
            base = new Decimal(10);
            base10 = true;
        } else {
            id = 15;
            base = new Decimal( base, b );
            c = base['c'];

            // If base < 0 or +-Infinity/NaN or 0 or 1.
            if ( base['s'] < 0 || !c || !c[0] || !base['e'] && c[0] == 1 && c.length == 1 ) {

                return new Decimal(NaN);
            }
            base10 = base['eq'](10);
        }
        c = arg['c'];

        // If arg < 0 or +-Infinity/NaN or 0 or 1.
        if ( arg['s'] < 0 || !c || !c[0] || !arg['e'] && c[0] == 1 && c.length == 1 ) {

            return new Decimal( c && !c[0] ? -1 / 0 : arg['s'] != 1 ? NaN : c ? 0 : 1 / 0 );
        }

        /*
          The result will have an infinite decimal expansion if base is 10 and arg is not an
          integer power of 10...
         */
        inf = base10 && ( i = c[0], c.length > 1 || i != 1 && i != 10 &&
          i != 1e2 && i != 1e3 && i != 1e4 && i != 1e5 && i != 1e6 );
            /*
            // or if base last digit's evenness is not the same as arg last digit's evenness...
            // (FAILS when e.g. base.c[0] = 10 and c[0] = 1)
            || ( base['c'][ base['c'].length - 1 ] & 1 ) != ( c[ c.length - 1 ] & 1 )
              // or if base is 2 and there is more than one 1 in arg in base 2.
              // (SLOWS the method down significantly)
              || base['eq'](2) && arg.toString(2).replace( /[^1]+/g, '' ) != '1';
             */

        external = false;
        sd = pr + guard;
        sd10 = sd + 10;

        num = ln( arg, sd );

        if (base10) {

            if ( sd10 > LN10.length ) {
                ifExceptionsThrow( Decimal, 1, sd10, 'log' );
            }
            denom = new Decimal( LN10.slice( 0, sd10 ) );
        } else {
            denom = ln( base, sd );
        }

        // The result will have 5 rounding digits.
        r = div( num, denom, sd, 1 );

        /*
         If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
         calculate 10 further digits.

         If the result is known to have an infinite decimal expansion, repeat this until it is
         clear that the result is above or below the boundary. Otherwise, if after calculating
         the 10 further digits, the last 14 are nines, round up and assume the result is exact.
         Also assume the result is exact if the last 14 are zero.

         Example of a result that will be incorrectly rounded:
         log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
         The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7,
         but it will be given as 2.6 as there are 15 zeros immediately after the requested
         decimal place, so the exact result would be assumed to be 2.6, which rounded using
         ROUND_CEIL to 1 decimal place is still 2.6.
         */
        if ( checkRoundingDigits( r['c'], i = pr, rm ) ) {

            do {
                sd += 10;
                num = ln( arg, sd );

                if (base10) {
                    sd10 = sd + 10;

                    if ( sd10 > LN10.length ) {
                        ifExceptionsThrow( Decimal, 1, sd10, 'log' );
                    }
                    denom = new Decimal( LN10.slice( 0, sd10 ) );
                } else {
                    denom = ln( base, sd );
                }

                r = div( num, denom, sd, 1 );

                if ( !inf ) {

                    // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
                    if ( +coefficientToString( r['c'] ).slice( i + 1, i + 15 ) + 1 == 1e14 ) {
                        r = rnd( r, pr + 1, 0 );
                    }

                    break;
                }
            } while ( checkRoundingDigits( r['c'], i += 10, rm ) );
        }
        external = true;

        return rnd( r, pr, rm );
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new Decimal whose value is the value of this Decimal minus Decimal(y, b), rounded
     * to precision significant digits using rounding mode rounding.
     *
     */
    P['minus'] = function ( y, b ) {
        var t, i, j, xLTy,
            x = this,
            Decimal = x['constructor'],
            a = x['s'];

        id = 8;
        y = new Decimal( y, b );
        b = y['s'];

        // Either NaN?
        if ( !a || !b ) {

            return new Decimal(NaN);
        }

        // Signs differ?
        if ( a != b ) {
            y['s'] = -b;

            return x['plus'](y);
        }

        var xc = x['c'],
            yc = y['c'],
            e = mathfloor( y['e'] / LOGBASE ),
            k = mathfloor( x['e'] / LOGBASE ),
            pr = Decimal['precision'],
            rm = Decimal['rounding'];

        if ( !k || !e ) {

            // Either Infinity?
            if ( !xc || !yc ) {

                return xc ? ( y['s'] = -b, y ) : new Decimal( yc ? x : NaN );
            }

            // Either zero?
            if ( !xc[0] || !yc[0] ) {

                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                x = yc[0] ? ( y['s'] = -b, y ) : new Decimal( xc[0] ? x :

                  // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                  rm == 3 ? -0 : 0 );

                return external ? rnd( x, pr, rm ) : x;
            }
        }

        xc = xc.slice();
        i = xc.length;

        // Determine which is the bigger number. Prepend zeros to equalise exponents.
        if ( a = k - e ) {

            if ( xLTy = a < 0 ) {
                a = -a;
                t = xc;
                i = yc.length;
            } else {
                e = k;
                t = yc;
            }

            if ( ( k = Math.ceil( pr / LOGBASE ) ) > i ) {
                i = k;
            }

            /*
             Numbers with massively different exponents would result in a massive number of
             zeros needing to be prepended, but this can be avoided while still ensuring correct
             rounding by limiting the number of zeros to max( precision, i ) + 2, where pr is
             precision and i is the length of the coefficient of whichever is greater x or y.
             */
            if ( a > ( i += 2 ) ) {
                a = i;
                t.length = 1;
            }

            for ( t.reverse(), b = a; b--; t.push(0) );
            t.reverse();
        } else {
            // Exponents equal. Check digits.

            if ( xLTy = i < ( j = yc.length ) ) {
                j = i;
            }

            for ( a = b = 0; b < j; b++ ) {

                if ( xc[b] != yc[b] ) {
                    xLTy = xc[b] < yc[b];

                    break;
                }
            }
        }

        // x < y? Point xc to the array of the bigger number.
        if ( xLTy ) {
            t = xc, xc = yc, yc = t;
            y['s'] = -y['s'];
        }

        /*
         Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
         needs to start at yc length.
         */
        if ( ( b = -( ( j = xc.length ) - yc.length ) ) > 0 ) {

            for ( ; b--; xc[j++] = 0 );
        }

        // Subtract yc from xc.
        for ( k = BASE - 1, b = yc.length; b > a; ) {

            if ( xc[--b] < yc[b] ) {

                for ( i = b; i && !xc[--i]; xc[i] = k );
                --xc[i];
                xc[b] += BASE;
            }
            xc[b] -= yc[b];
        }

        // Remove trailing zeros.
        for ( ; xc[--j] == 0; xc.pop() );

        // Remove leading zeros and adjust exponent accordingly.
        for ( ; xc[0] == 0; xc.shift(), --e );

        if ( !xc[0] ) {

            // Zero.
            xc = [ e = 0 ];

            // Following IEEE 754 (2008) 6.3, n - n = -0 when rounding towards -Infinity.
            y['s'] = rm == 3 ? -1 : 1;
        }

        y['c'] = xc;

        // Get the number of digits of xc[0].
        for ( a = 1, b = xc[0]; b >= 10; b /= 10, a++ );
        y['e'] = a + e * LOGBASE - 1;

        return external ? rnd( y, pr, rm ) : y;
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new Decimal whose value is the value of this Decimal modulo Decimal(y, b), rounded
     * to precision significant digits using rounding mode rounding.
     *
     * The result depends on the modulo mode.
     *
     */
    P['modulo'] = P['mod'] = function ( y, b ) {
        var n, q,
            x = this,
            Decimal = x['constructor'],
            m = Decimal['modulo'];

        id = 9;
        y = new Decimal( y, b );
        b = y['s'];
        n = !x['c'] || !b || y['c'] && !y['c'][0];

        /*
         Return NaN if x is Infinity or NaN, or y is NaN or zero, else return x if y is Infinity
         or x is zero.
         */
        if ( n || !y['c'] || x['c'] && !x['c'][0] ) {

            return n
              ? new Decimal(NaN)
              : rnd( new Decimal(x), Decimal['precision'], Decimal['rounding'] );
        }

        external = false;

        if ( m == 9 ) {

            // Euclidian division: q = sign(y) * floor(x / abs(y))
            // r = x - qy    where  0 <= r < abs(y)
            y['s'] = 1;
            q = div( x, y, 0, 3, 1 );
            y['s'] = b;
            q['s'] *= b;
        } else {
            q = div( x, y, 0, m, 1 );
        }

        q = q['times'](y);
        external = true;

        return x['minus'](q);
    };


    /*
     * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
     * rounded to precision significant digits using rounding mode rounding.
     *
     */
    P['naturalLogarithm'] = P['ln'] = function () {

        return ln(this);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if
     * multiplied by -1.
     *
     */
    P['negated'] = P['neg'] = function () {
        var x = new this['constructor'](this);
        x['s'] = -x['s'] || null;

        return rnd(x);
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new Decimal whose value is the value of this Decimal plus Decimal(y, b), rounded
     * to precision significant digits using rounding mode rounding.
     *
     */
    P['plus'] = function ( y, b ) {
        var t,
            x = this,
            Decimal = x['constructor'],
            a = x['s'];

        id = 10;
        y = new Decimal( y, b );
        b = y['s'];

        // Either NaN?
        if ( !a || !b ) {

            return new Decimal(NaN);
        }

        // Signs differ?
        if ( a != b ) {
            y['s'] = -b;

            return x['minus'](y);
        }

        var xc = x['c'],
            yc = y['c'],
            e = mathfloor( y['e'] / LOGBASE ),
            k = mathfloor( x['e'] / LOGBASE ),
            pr = Decimal['precision'],
            rm = Decimal['rounding'];

        if ( !k || !e ) {

            // Either Infinity?
            if ( !xc || !yc ) {

                // Return +-Infinity.
                return new Decimal( a / 0 );
            }

            // Either zero?
            if ( !xc[0] || !yc[0] ) {

                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                x = yc[0] ? y: new Decimal( xc[0] ? x : a * 0 );

                return external ? rnd( x, pr, rm ) : x;
            }
        }

        xc = xc.slice();

        // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
        if ( a = k - e ) {

            if ( a < 0 ) {
                a = -a;
                t = xc;
                b = yc.length;
            } else {
                e = k;
                t = yc;
                b = xc.length;
            }

            if ( ( k = Math.ceil( pr / LOGBASE ) ) > b ) {
                b = k;
            }

            // Limit number of zeros prepended to max( pr, b ) + 1.
            if ( a > ++b ) {
                a = b;
                t.length = 1;
            }

            for ( t.reverse(); a--; t.push(0) );
            t.reverse();
        }

        // Point xc to the longer array.
        if ( xc.length - yc.length < 0 ) {
            t = yc, yc = xc, xc = t;
        }

        // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
        for ( a = yc.length, b = 0, k = BASE; a; xc[a] %= k ) {
            b = ( xc[--a] = xc[a] + yc[a] + b ) / k | 0;
        }

        if (b) {
            xc.unshift(b);
            ++e;
        }

        // Remove trailing zeros.
        for ( a = xc.length; xc[--a] == 0; xc.pop() );

        // No need to check for zero, as +x + +y != 0 && -x + -y != 0

        y['c'] = xc;

        // Get the number of digits of xc[0].
        for ( a = 1, b = xc[0]; b >= 10; b /= 10, a++ );
        y['e'] = a + e * LOGBASE - 1;

        return external ? rnd( y, pr, rm ) : y;
    };


    /*
     * Return the number of significant digits of this Decimal.
     *
     * z {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
     *
     */
    P['precision'] = P['sd'] = function (z) {
        var n = null,
            x = this;

        if ( z != n ) {

            if ( z !== !!z && z !== 1 && z !== 0 ) {

                // 'precision() argument not a boolean or binary digit: {z}'
                ifExceptionsThrow( x['constructor'], 'argument', z, 'precision', 1 );
            }
        }

        if ( x['c'] ) {
            n = getCoeffLength( x['c'] );

            if ( z && x['e'] + 1 > n ) {
                n = x['e'] + 1;
            }
        }

        return n;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
     * rounding mode rounding.
     *
     */
    P['round'] = function () {
        var x = this,
            Decimal = x['constructor'];

        return rnd( new Decimal(x), x['e'] + 1, Decimal['rounding'] );
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt( N) =  N
     *  sqrt(-I) =  N
     *  sqrt( I) =  I
     *  sqrt( 0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new Decimal whose value is the square root of this Decimal, rounded to precision
     * significant digits using rounding mode rounding.
     *
     */
    P['squareRoot'] = P['sqrt'] = function () {
        var m, n, sd, r, rep, t,
            x = this,
            c = x['c'],
            s = x['s'],
            e = x['e'],
            Decimal = x['constructor'],
            half = new Decimal(0.5);

        // Negative/NaN/Infinity/zero?
        if ( s !== 1 || !c || !c[0] ) {

            return new Decimal( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
        }

        external = false;

        // Initial estimate.
        s = Math.sqrt( +x );

        /*
         Math.sqrt underflow/overflow?
         Pass x to Math.sqrt as integer, then adjust the exponent of the result.
         */
        if ( s == 0 || s == 1 / 0 ) {
            n = coefficientToString(c);

            if ( ( n.length + e ) % 2 == 0 ) {
                n += '0';
            }

            s = Math.sqrt(n);
            e = mathfloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );

            if ( s == 1 / 0 ) {
                n = '1e' + e;
            } else {
                n = s.toExponential();
                n = n.slice( 0, n.indexOf('e') + 1 ) + e;
            }

            r = new Decimal(n);
        } else {
            r = new Decimal( s.toString() );
        }

        sd = ( e = Decimal['precision'] ) + 3;

        // Newton-Raphson iteration.
        for ( ; ; ) {
            t = r;
            r = half['times']( t['plus']( div( x, t, sd + 2, 1 ) ) );

            if ( coefficientToString( t['c'] ).slice( 0, sd ) ===
                ( n = coefficientToString( r['c'] ) ).slice( 0, sd ) ) {
                n = n.slice( sd - 3, sd + 1 );

                /*
                 The 4th rounding digit may be in error by -1 so if the 4 rounding digits are
                 9999 or 4999 (i.e. approaching a rounding boundary) continue the iteration.
                 */
                if ( n == '9999' || !rep && n == '4999' ) {

                    /*
                     On the first iteration only, check to see if rounding up gives the exact result
                     as the nines may infinitely repeat.
                     */
                    if ( !rep ) {
                        rnd( t, e + 1, 0 );

                        if ( t['times'](t)['eq'](x) ) {
                            r = t;

                            break;
                        }
                    }
                    sd += 4;
                    rep = 1;
                } else {

                    /*
                     If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
                     If not, then there are further digits and m will be truthy.
                     */
                    if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {

                        // Truncate to the first rounding digit.
                        rnd( r, e + 1, 1 );
                        m = !r['times'](r)['eq'](x);
                    }

                    break;
                }
            }
        }
        external = true;

        return rnd( r, e, Decimal['rounding'], m );
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new Decimal whose value is this Decimal times Decimal(y), rounded to precision
     * significant digits using rounding mode rounding.
     *
     */
    P['times'] = function ( y, b ) {
        var c, e,
            x = this,
            Decimal = x['constructor'],
            xc = x['c'],
            yc = ( id = 11, y = new Decimal( y, b ), y['c'] ),
            i = mathfloor( x['e'] / LOGBASE ),
            j = mathfloor( y['e'] / LOGBASE ),
            a = x['s'];

        b = y['s'];

        y['s'] = a == b ? 1 : -1;

        // Either NaN/Infinity/0?
        if ( !i && ( !xc || !xc[0] ) || !j && ( !yc || !yc[0] ) ) {

            // Either NaN?
            return new Decimal( !a || !b ||

              // x is 0 and y is Infinity  or y is 0 and x is Infinity?
              xc && !xc[0] && !yc || yc && !yc[0] && !xc

                // Return NaN.
                ? NaN

                // Either Infinity?
                : !xc || !yc

                  // Return +-Infinity.
                  ? y['s'] / 0

                  // x or y is 0. Return +-0.
                  : y['s'] * 0 );
        }

        e = i + j;
        a = xc.length;
        b = yc.length;

        if ( a < b ) {

            // Swap.
            c = xc, xc = yc, yc = c;
            j = a, a = b, b = j;
        }

        for ( j = a + b, c = []; j--; c.push(0) );

        // Multiply!
        for ( i = b - 1; i > -1; i-- ) {

            for ( b = 0, j = a + i; j > i; b = b / BASE | 0 ) {
                  b = c[j] + yc[i] * xc[j - i - 1] + b;
                  c[j--] = b % BASE | 0;
            }

            if (b) {
                c[j] = ( c[j] + b ) % BASE;
            }
        }

        if (b) {
            ++e;
        }

        // Remove any leading zero.
        if ( !c[0] ) {
            c.shift();
        }

        // Remove trailing zeros.
        for ( j = c.length; !c[--j]; c.pop() );

        y['c'] = c;

        // Get the number of digits of c[0].
        for ( a = 1, b = c[0]; b >= 10; b /= 10, a++ );
        y['e'] = a + e * LOGBASE - 1;

        return external ? rnd( y, Decimal['precision'], Decimal['rounding'] ) : y;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of dp
     * decimal places using rounding mode rm or rounding if rm is omitted.
     *
     * If dp is omitted, return a new Decimal whose value is the value of this Decimal.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * 'toDP() dp out of range: {dp}'
     * 'toDP() dp not an integer: {dp}'
     * 'toDP() rounding mode not an integer: {rm}'
     * 'toDP() rounding mode out of range: {rm}'
     *
     */
    P['toDecimalPlaces'] = P['toDP'] = function ( dp, rm ) {
        var x = this;
        x = new x['constructor'](x);

        return dp == null || !checkArg( x, dp, 'toDP' )
          ? x
          : rnd( x, ( dp | 0 ) + x['e'] + 1, checkRM( x, rm, 'toDP' ) );
    };


    /*
     * Return a string representing the value of this Decimal in exponential notation rounded to dp
     * fixed decimal places using rounding mode rounding.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * errors true: Throw if dp and rm are not undefined, null or integers in range.
     * errors false: Ignore dp and rm if not numbers or not in range, and truncate non-integers.
     *
     * 'toExponential() dp not an integer: {dp}'
     * 'toExponential() dp out of range: {dp}'
     * 'toExponential() rounding mode not an integer: {rm}'
     * 'toExponential() rounding mode out of range: {rm}'
     *
     */
    P['toExponential'] = function ( dp, rm ) {
        var x = this;

        return x['c']
          ? format( x, dp != null && checkArg( x, dp, 'toExponential' ) ? dp | 0 : null,
            dp != null && checkRM( x, rm, 'toExponential' ), 1 )
          : x.toString();
    };


    /*
     * Return a string representing the value of this Decimal in normal (fixed-point) notation to
     * dp fixed decimal places and rounded using rounding mode rm or rounding if rm is omitted.
     *
     * Note: as with JS numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, -MAX_DIGITS to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * errors true: Throw if dp and rm are not undefined, null or integers in range.
     * errors false: Ignore dp and rm if not numbers or not in range, and truncate non-integers.
     *
     * 'toFixed() dp not an integer: {dp}'
     * 'toFixed() dp out of range: {dp}'
     * 'toFixed() rounding mode not an integer: {rm}'
     * 'toFixed() rounding mode out of range: {rm}'
     *
     */
    P['toFixed'] = function ( dp, rm ) {
        var str,
            x = this,
            Decimal = x['constructor'],
            neg = Decimal['toExpNeg'],
            pos = Decimal['toExpPos'];

        if ( dp != null ) {
            dp = checkArg( x, dp, str = 'toFixed' ) ? x['e'] + ( dp | 0 ) : null;
            rm = checkRM( x, rm, str );
        }

        // Prevent toString returning exponential notation;
        Decimal['toExpNeg'] = -( Decimal['toExpPos'] = 1 / 0 );

        if ( dp == null || !x['c'] ) {
            str = x.toString();
        } else {
            str = format( x, dp, rm );

            // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.
            // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
            if ( x['s'] < 0 && x['c'] ) {

                // As e.g. (-0).toFixed(3), will wrongly be returned as -0.000 from toString.
                if ( !x['c'][0] ) {
                    str = str.replace( '-', '' );

                // As e.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.
                } else if ( str.indexOf('-') < 0 ) {
                    str = '-' + str;
                }
            }
        }
        Decimal['toExpNeg'] = neg;
        Decimal['toExpPos'] = pos;

        return str;
    };


    /*
     * Return a string representing the value of this Decimal in normal notation rounded using
     * rounding mode rounding to dp fixed decimal places, with the integer part of the number
     * separated into thousands by string sep1 or ',' if sep1 is null or undefined, and the
     * fraction part separated into groups of five digits by string sep2.
     *
     * [sep1] {string} The grouping separator of the integer part of the number.
     * [sep2] {string} The grouping separator of the fraction part of the number.
     * [dp] {number} Decimal places. Integer, -MAX_DIGITS to MAX_DIGITS inclusive.
     *
     * Non-breaking thin-space: \u202f
     *
     * If dp is invalid the error message will incorrectly give the method as toFixed.
     *
     */
    P['toFormat'] = function ( sep1, dp, sep2 ) {
        var arr = this.toFixed(dp).split('.');

        return arr[0].replace( /\B(?=(\d{3})+$)/g, sep1 == null ? ',' : sep1 + '' ) +
            ( arr[1] ? '.' + ( sep2 ? arr[1].replace( /\d{5}\B/g, '$&' + sep2 ) : arr[1] ) : '' );
    };


    /*
     * Return a string array representing the value of this Decimal as a simple fraction with an
     * integer numerator and an integer denominator.
     *
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
     *
     */
    P['toFraction'] = function (maxD) {
        var d0, d2, e, frac, n, n0, p, q,
            x = this,
            Decimal = x['constructor'],
            n1 = d0 = new Decimal( Decimal['ONE'] ),
            d1 = n0 = new Decimal(0),
            xc = x['c'],
            d = new Decimal(d1);

        // NaN, Infinity.
        if ( !xc ) {

            return x.toString();
        }

        e = d['e'] = getCoeffLength(xc) - x['e'] - 1;
        d['c'][0] = mathpow( 10, ( p = e % LOGBASE ) < 0 ? LOGBASE + p : p );

        // If maxD is undefined or null...
        if ( maxD == null ||

             // or NaN...
             ( !( id = 12, n = new Decimal(maxD) )['s'] ||

               // or less than 1, or Infinity...
               ( outOfRange = n['cmp'](n1) < 0 || !n['c'] ) ||

                 // or not an integer...
                 ( Decimal['errors'] && mathfloor( n['e'] / LOGBASE ) < n['c'].length - 1 ) ) &&

                   // 'toFraction() max denominator not an integer: {maxD}'
                   // 'toFraction() max denominator out of range: {maxD}'
                   !ifExceptionsThrow( Decimal, 'max denominator', maxD, 'toFraction', 0 ) ||

                     // or greater than the maximum denominator needed to specify the value exactly.
                     ( maxD = n )['cmp'](d) > 0 ) {

            // d is 10**e, n1 is 1.
            maxD = e > 0 ? d : n1;
        }

        external = false;
        n = new Decimal( coefficientToString(xc) );
        p = Decimal['precision'];
        Decimal['precision'] = e = xc.length * LOGBASE * 2;

        for ( ; ; )  {
            q = div( n, d, 0, 1, 1 );
            d2 = d0['plus']( q['times'](d1) );

            if ( d2['cmp'](maxD) == 1 ) {

                break;
            }
            d0 = d1, d1 = d2;

            n1 = n0['plus']( q['times']( d2 = n1 ) );
            n0 = d2;

            d = n['minus']( q['times']( d2 = d ) );
            n = d2;
        }

        d2 = div( maxD['minus'](d0), d1, 0, 1, 1 );
        n0 = n0['plus']( d2['times'](n1) );
        d0 = d0['plus']( d2['times'](d1) );
        n0['s'] = n1['s'] = x['s'];

        // Determine which fraction is closer to x, n0/d0 or n1/d1?
        frac = div( n1, d1, e, 1 )['minus'](x)['abs']()['cmp'](
               div( n0, d0, e, 1 )['minus'](x)['abs']() ) < 1
          ? [ n1 + '', d1 + '' ]
          : [ n0 + '', d0 + '' ];

        external = true;
        Decimal['precision'] = p;

        return frac;
    };


    /*
     * Returns a new Decimal whose value is the nearest multiple of the magnitude of n to the value
     * of this Decimal.
     *
     * If the value of this Decimal is equidistant from two multiples of n, the rounding mode rm,
     * or rounding if rm is omitted or is null or undefined, determines the direction of the
     * nearest multiple.
     *
     * In the context of this method, rounding mode 4 (ROUND_HALF_UP) is the same as rounding mode 0
     * (ROUND_UP), and so on.
     *
     * The return value will always have the same sign as this Decimal, unless either this Decimal
     * or n is NaN, in which case the return value will be also be NaN.
     *
     * The return value is not rounded to precision significant digits.
     *
     * n {number|string|Decimal} The magnitude to round to a multiple of.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * 'toNearest() rounding mode not an integer: {rm}'
     * 'toNearest() rounding mode out of range: {rm}'
     *
     */
    P['toNearest'] = function ( n, rm ) {
        var x = this,
            Decimal = x['constructor'];

        x = new Decimal(x);

        if ( n == null ) {
            n = new Decimal( Decimal['ONE'] );
            rm = Decimal['rounding'];
        } else {
            id = 17;
            n = new Decimal(n);
            rm = checkRM( x, rm, 'toNearest' );
        }

        // If n is finite...
        if ( n['c'] ) {

           // If x is finite...
            if ( x['c'] ) {

                if ( n['c'][0] ) {
                    external = false;
                    x = div( x, n, 0, rm < 4 ? [4, 5, 7, 8][rm] : rm, 1 )['times'](n);
                    external = true;
                    rnd(x);
                } else {
                    x['c'] = [ x['e'] = 0 ];
                }
            }

        // n is NaN or +-Infinity. If x is not NaN...
        } else if ( x['s'] ) {

            // If n is +-Infinity...
            if ( n['s'] ) {
                n['s'] = x['s'];
            }
            x = n;
        }

        return x;
    };


    /*
     * Return the value of this Decimal converted to a number primitive.
     *
     */
    P['toNumber'] = function () {
        var x = this;

        // Ensure zero has correct sign.
        return +x || ( x['s'] ? 0 * x['s'] : NaN );
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal raised to the power
     * Decimal(y, b), rounded to precision significant digits using rounding mode rounding.
     *
     * ECMAScript compliant.
     *
     *   x is any value, including NaN.
     *   n is any number, including �Infinity unless stated.
     *
     *   pow( x, NaN )                           = NaN
     *   pow( x, �0 )                            = 1

     *   pow( NaN, nonzero )                     = NaN
     *   pow( abs(n) > 1, +Infinity )            = +Infinity
     *   pow( abs(n) > 1, -Infinity )            = +0
     *   pow( abs(n) == 1, �Infinity )           = NaN
     *   pow( abs(n) < 1, +Infinity )            = +0
     *   pow( abs(n) < 1, -Infinity )            = +Infinity
     *   pow( +Infinity, n > 0 )                 = +Infinity
     *   pow( +Infinity, n < 0 )                 = +0
     *   pow( -Infinity, odd integer > 0 )       = -Infinity
     *   pow( -Infinity, even integer > 0 )      = +Infinity
     *   pow( -Infinity, odd integer < 0 )       = -0
     *   pow( -Infinity, even integer < 0 )      = +0
     *   pow( +0, n > 0 )                        = +0
     *   pow( +0, n < 0 )                        = +Infinity
     *   pow( -0, odd integer > 0 )              = -0
     *   pow( -0, even integer > 0 )             = +0
     *   pow( -0, odd integer < 0 )              = -Infinity
     *   pow( -0, even integer < 0 )             = +Infinity
     *   pow( finite n < 0, finite non-integer ) = NaN
     *
     * For non-integer and larger exponents pow(x, y) is calculated using
     *
     *   x^y = exp(y*ln(x))
     *
     * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
     * probability of an incorrectly rounded result
     * P( [49]9{14} | [50]0{14} ) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
     * i.e. 1 in 250,000,000,000,000
     *
     * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
     *
     * y {number|string|Decimal} The power to which to raise this Decimal.
     * [b] {number} The base of y.
     *
     */
    P['toPower'] = P['pow'] = function ( y, b ) {
        var a, e, n, r,
            x = this,
            Decimal = x['constructor'],
            s = x['s'],
            yN = +( id = 13, y = new Decimal( y, b ) ),
            i = yN < 0 ? -yN : yN,
            pr = Decimal['precision'],
            rm = Decimal['rounding'];

        // Handle +-Infinity, NaN and +-0.
        if ( !x['c'] || !y['c'] || ( n = !x['c'][0] ) || !y['c'][0] ) {

            // valueOf -0 is 0, so check for 0 then multiply it by the sign.
            return new Decimal( mathpow( n ? s * 0 : +x, yN ) );
        }

        x = new Decimal(x);
        a = x['c'].length;

        // if x == 1
        if ( !x['e'] && x['c'][0] == x['s'] && a == 1 ) {

            return x;
        }

        b = y['c'].length - 1;

        // if y == 1
        if ( !y['e'] && y['c'][0] == y['s'] && !b ) {
            r = rnd( x, pr, rm );
        } else {
            e = mathfloor( y['e'] / LOGBASE );
            n = e >= b;

            // If y is not an integer and x is negative, return NaN.
            if ( !n && s < 0 ) {
                r = new Decimal(NaN);
            } else {

                /*
                 If the approximate number of significant digits of x multiplied by abs(y) is less
                 than INT_POW_LIMIT use the 'exponentiation by squaring' algorithm.
                 */
                if ( n && a * LOGBASE * i < INT_POW_LIMIT ) {
                    r = intPow( Decimal, x, i );

                    if ( y['s'] < 0 ) {

                        return Decimal['ONE']['div'](r);
                    }
                } else {

                    // Result is negative if x is negative and the last digit of integer y is odd.
                    s = s < 0 && y['c'][ Math.max( e, b ) ] & 1 ? -1 : 1;

                    b = mathpow( +x, yN );

                    /*
                     Estimate result exponent.
                     x^y = 10^e,  where e = y * log10(x)
                     log10(x) = log10(x_significand) + x_exponent
                     log10(x_significand) = ln(x_significand) / ln(10)
                     */
                    e = b == 0 || !isFinite(b)
                      ? mathfloor( yN * (
                        Math.log( '0.' + coefficientToString( x['c'] ) ) / Math.LN10 + x['e'] + 1 ) )
                      : new Decimal( b + '' )['e'];

                    // Estimate may be incorrect e.g.: x: 0.999999999999999999, y: 2.29, e: 0, r.e:-1

                    // Overflow/underflow?
                    if ( e > Decimal['maxE'] + 1 || e < Decimal['minE'] - 1 ) {

                        return new Decimal( e > 0 ? s / 0 : 0 );
                    }

                    external = false;
                    Decimal['rounding'] = x['s'] = 1;

                    /*
                     Estimate extra digits needed from ln(x) to ensure five correct rounding digits
                     in result (i was unnecessary before max exponent was extended?).
                     Example of failure before i was introduced: (precision: 10),
                     new Decimal(2.32456).pow('2087987436534566.46411')
                     should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
                     */
                    i = Math.min( 12, ( e + '' ).length );

                    // r = x^y = exp(y*ln(x))
                    r = exp( y['times']( ln( x, pr + i ) ), pr );

                    // Truncate to the required precision plus five rounding digits.
                    r = rnd( r, pr + 5, 1 );

                    /*
                     If the rounding digits are [49]9999 or [50]0000 increase the precision by 10
                     and recalculate the result.
                     */
                    if ( checkRoundingDigits( r['c'], pr, rm ) ) {
                        e = pr + 10;

                        // Truncate to the increased precision plus five rounding digits.
                        r = rnd( exp( y['times']( ln( x, e + i ) ), e ), e + 5, 1 );

                        /*
                          Check for 14 nines from the 2nd rounding digit (the first rounding digit
                          may be 4 or 9).
                         */
                        if ( +coefficientToString( r['c'] ).slice( pr + 1, pr + 15 ) + 1 == 1e14 ) {
                            r = rnd( r, pr + 1, 0 );
                        }
                    }

                    r['s'] = s;
                    external = true;
                    Decimal['rounding'] = rm;
                }

                r = rnd( r, pr, rm );
            }
        }

        return r;
    };


    /*
     * Return a string representing the value of this Decimal rounded to sd significant digits
     * using rounding mode rounding.
     *
     * Return exponential notation if sd is less than the number of digits necessary to represent
     * the integer part of the value in normal notation.
     *
     * sd {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * errors true: Throw if sd and rm are not undefined, null or integers in range.
     * errors false: Ignore sd and rm if not numbers or not in range, and truncate non-integers.
     *
     * 'toPrecision() sd not an integer: {sd}'
     * 'toPrecision() sd out of range: {sd}'
     * 'toPrecision() rounding mode not an integer: {rm}'
     * 'toPrecision() rounding mode out of range: {rm}'
     *
     */
    P['toPrecision'] = function ( sd, rm ) {
        var x = this;

        return sd != null && checkArg( x, sd, 'toPrecision', 1 ) && x['c']
          ? format( x, --sd | 0, checkRM( x, rm, 'toPrecision' ), 2 )
          : x.toString();
    };


    /*
     * Return a new Decimal whose value is this Decimal rounded to a maximum of d significant
     * digits using rounding mode rm, or to precision and rounding respectively if omitted.
     *
     * [d] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * 'toSD() digits out of range: {d}'
     * 'toSD() digits not an integer: {d}'
     * 'toSD() rounding mode not an integer: {rm}'
     * 'toSD() rounding mode out of range: {rm}'
     *
     */
    P['toSignificantDigits'] = P['toSD'] = function ( d, rm ) {
        var x = this,
            Decimal = x['constructor'];

        x = new Decimal(x);

        return d == null || !checkArg( x, d, 'toSD', 1 )
          ? rnd( x, Decimal['precision'], Decimal['rounding'] )
          : rnd( x, d | 0, checkRM( x, rm, 'toSD' ) );
    };


    /*
     * Return a string representing the value of this Decimal in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round to precision significant digits
     * using rounding mode rounding.
     *
     * Return exponential notation if a base is not specified, and this Decimal has a positive
     * exponent equal to or greater than toExpPos, or a negative exponent equal to or less than
     * toExpNeg.
     *
     * [b] {number} Base. Integer, 2 to 64 inclusive.
     *
     */
     P['toString'] = function (b) {
        var u, str, strL,
            x = this,
            Decimal = x['constructor'],
            xe = x['e'];

        // Infinity or NaN?
        if ( xe === null ) {
            str = x['s'] ? 'Infinity' : 'NaN';

        // Exponential format?
        } else if ( b === u && ( xe <= Decimal['toExpNeg'] || xe >= Decimal['toExpPos'] ) ) {

            return format( x, null, Decimal['rounding'], 1 );
        } else {
            str = coefficientToString( x['c'] );

            // Negative exponent?
            if ( xe < 0 ) {

                // Prepend zeros.
                for ( ; ++xe; str = '0' + str );
                str = '0.' + str;

            // Positive exponent?
            } else if ( strL = str.length, xe > 0 ) {

                if ( ++xe > strL ) {

                    // Append zeros.
                    for ( xe -= strL; xe-- ; str += '0' );

                } else if ( xe < strL ) {
                    str = str.slice( 0, xe ) + '.' + str.slice(xe);
                }

            // Exponent zero.
            } else {
                u = str.charAt(0);

                if ( strL > 1 ) {
                    str = u + '.' + str.slice(1);

                // Avoid '-0'
                } else if ( u == '0' ) {

                    return u;
                }
            }

            if ( b != null ) {

                if ( !( outOfRange = !( b >= 2 && b < 65 ) ) &&
                  ( b == (b | 0) || !Decimal['errors'] ) ) {
                    str = convertBase( Decimal, str, b | 0, 10, x['s'] );

                    // Avoid '-0'
                    if ( str == '0' ) {

                        return str;
                    }
                } else {

                    // 'toString() base not an integer: {b}'
                    // 'toString() base out of range: {b}'
                    ifExceptionsThrow( Decimal, 'base', b, 'toString', 0 );
                }
            }
        }

        return x['s'] < 0 ? '-' + str : str;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
     *
     */
    P['truncated'] = P['trunc'] = function () {

        return rnd( new this['constructor'](this), this['e'] + 1, 1 );
    };


    /*
     * Return as toString, but do not accept a base argument.
     *
     * Ensures that JSON.stringify() uses toString for serialization.
     *
     */
    P['valueOf'] = P['toJSON'] = function () {

        return this.toString();
    };


    /*
    // Add aliases to match BigDecimal method names.
    P['add'] = P['plus'];
    P['subtract'] = P['minus'];
    P['multiply'] = P['times'];
    P['divide'] = P['div'];
    P['remainder'] = P['mod'];
    P['compareTo'] = P['cmp'];
    P['negate'] = P['neg'];
     */


    // Private functions for Decimal.prototype methods.


    /*
     *  coefficientToString
     *  checkRoundingDigits
     *  checkRM
     *  checkArg
     *  convertBase
     *  div
     *  exp
     *  format
     *  getCoeffLength
     *  ifExceptionsThrow
     *  intPow
     *  ln
     *  rnd
     */


    function coefficientToString(a) {
        var s, z,
            i = 1,
            j = a.length,
            r = a[0] + '';

        for ( ; i < j; i++ ) {
            s = a[i] + '';

            for ( z = LOGBASE - s.length; z--; ) {
                s = '0' + s;
            }

            r += s;
        }

        for ( j = r.length; r.charAt(--j) == '0'; );

        return r.slice( 0, j + 1 || 1 );
    }


    /*
     * Check 5 rounding digits if repeating is null, 4 otherwise.
     * repeating == null if caller is log or pow,
     * repeating != null if caller is ln or exp.
     *
     *
     // Previous, much simpler implementation when coefficient was base 10.
     function checkRoundingDigits( c, i, rm, repeating ) {
         return ( !repeating && rm > 3 && c[i] == 4 ||
           ( repeating || rm < 4 ) && c[i] == 9 ) && c[i + 1] == 9 && c[i + 2] == 9 &&
             c[i + 3] == 9 && ( repeating != null || c[i + 4] == 9 ) ||
               repeating == null && ( c[i] == 5 || !c[i] ) && !c[i + 1] && !c[i + 2] &&
                 !c[i + 3] && !c[i + 4];
     }
     */
    function checkRoundingDigits( c, i, rm, repeating ) {
        var ci, k, n, r, rd;

        // Get the length of the first element of the array c.
        for ( k = 1, n = c[0]; n >= 10; n /= 10, k++ );

        n = i - k;

        // Is the rounding digit in the first element of c?
        if ( n < 0 ) {
            n += LOGBASE;
            ci = 0;
        } else {
            ci = Math.ceil( ( n + 1 ) / LOGBASE );
            n %= LOGBASE;
        }

        k =mathpow( 10, LOGBASE - n );
        rd = c[ci] % k | 0;

        if ( repeating == null ) {

            if ( n < 3 ) {

                if ( n == 0 ) {
                    rd = rd / 100 | 0;
                } else if ( n == 1 ) {
                    rd = rd / 10 | 0;
                }

                r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
            } else {
                r = ( rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2 ) &&
                    ( c[ci + 1] / k / 100 | 0 ) == mathpow( 10, n - 2 ) - 1 ||
                        ( rd == k / 2 || rd == 0 ) && ( c[ci + 1] / k / 100 | 0 ) == 0;
            }
        } else {

            if ( n < 4 ) {

                if ( n == 0 ) {
                    rd = rd / 1000 | 0;
                } else if ( n == 1 ) {
                    rd = rd / 100 | 0;
                } else if ( n == 2 ) {
                    rd = rd / 10 | 0;
                }

                r = ( repeating || rm < 4 ) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
            } else {
                r = ( ( repeating || rm < 4 ) && rd + 1 == k ||
                ( !repeating && rm > 3 ) && rd + 1 == k / 2 ) &&
                    ( c[ci + 1] / k / 1000 | 0 ) == mathpow( 10, n - 3 ) - 1;
            }
        }

        return r;
    }


    /*
     * Check and return rounding mode. If rm is invalid, return rounding mode rounding.
     */
    function checkRM( x, rm, method ) {
        var Decimal = x['constructor'];

        return rm == null || ( ( outOfRange = rm < 0 || rm > 8 ) ||
          rm !== 0 && ( Decimal['errors'] ? parseInt : parseFloat )(rm) != rm ) &&
            !ifExceptionsThrow( Decimal, 'rounding mode', rm, method, 0 )
              ? Decimal['rounding'] : rm | 0;
    }


    /*
     * Check that argument n is in range, return true or false.
     */
    function checkArg( x, n, method, min ) {
        var Decimal = x['constructor'];

        return !( outOfRange = n < ( min || 0 ) || n >= MAX_DIGITS + 1 ) &&

          /*
           * Include 'n === 0' because Opera has 'parseFloat(-0) == -0' as false
           * despite having 'parseFloat(-0) === -0 && parseFloat('-0') === -0 && 0 == -0' as true.
           */
          ( n === 0 || ( Decimal['errors'] ? parseInt : parseFloat )(n) == n ) ||
            ifExceptionsThrow( Decimal, 'argument', n, method, 0 );
    }


    /*
     * Convert a numeric string of baseIn to a numeric string of baseOut.
     */
    convertBase = (function () {

        /*
         * Convert string of baseIn to an array of numbers of baseOut.
         * Eg. convertBase('255', 10, 16) returns [15, 15].
         * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
         */
        function toBaseOut( str, baseIn, baseOut ) {
            var j,
                arr = [0],
                arrL,
                i = 0,
                strL = str.length;

            for ( ; i < strL; ) {

                for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );

                arr[ j = 0 ] += NUMERALS.indexOf( str.charAt( i++ ) );

                for ( ; j < arr.length; j++ ) {

                    if ( arr[j] > baseOut - 1 ) {

                        if ( arr[j + 1] == null ) {
                            arr[j + 1] = 0;
                        }
                        arr[j + 1] += arr[j] / baseOut | 0;
                        arr[j] %= baseOut;
                    }
                }
            }

            return arr.reverse();
        }

        return function ( Decimal, str, baseOut, baseIn, sign ) {
            var e, j, r, x, xc, y,
                i = str.indexOf( '.' ),
                pr = Decimal['precision'],
                rm = Decimal['rounding'];

            if ( baseIn < 37 ) {
                str = str.toLowerCase();
            }

            // Non-integer.
            if ( i >= 0 ) {
                str = str.replace( '.', '' );
                y = new Decimal(baseIn);
                x = intPow( Decimal, y, str.length - i );

                /*
                 Convert str as if an integer, then divide the result by its base raised to a power
                 such that the fraction part will be restored.
                 Use toFixed to avoid possible exponential notation.
                 */
                y['c'] = toBaseOut( x.toFixed(), 10, baseOut );
                y['e'] = y['c'].length;
            }

            // Convert the number as integer.
            xc = toBaseOut( str, baseIn, baseOut );
            e = j = xc.length;

            // Remove trailing zeros.
            for ( ; xc[--j] == 0; xc.pop() );

            if ( !xc[0] ) {

                return '0';
            }

            if ( i < 0 ) {
                e--;
            } else {
                x['c'] = xc;
                x['e'] = e;

                // sign is needed for correct rounding.
                x['s'] = sign;
                x = div( x, y, pr, rm, 0, baseOut );
                xc = x['c'];
                r = x['r'];
                e = x['e'];
            }

            // The rounding digit, i.e. the digit after the digit that may be rounded up.
            i = xc[pr];
            j = baseOut / 2;
            r = r || xc[pr + 1] != null;

            if ( rm < 4
              ? ( i != null || r ) && ( rm == 0 || rm == ( x['s'] < 0 ? 3 : 2 ) )
              : i > j || i == j && ( rm == 4 || r || rm == 6 && xc[pr - 1] & 1 ||
                rm == ( x['s'] < 0 ? 8 : 7 ) ) ) {

                xc.length = pr;

                // Rounding up may mean the previous digit has to be rounded up and so on.
                for ( --baseOut; ++xc[--pr] > baseOut; ) {
                    xc[pr] = 0;

                    if ( !pr ) {
                        ++e;
                        xc.unshift(1);
                    }
                }
            } else {
                xc.length = pr;
            }

            // Determine trailing zeros.
            for ( j = xc.length; !xc[--j]; );

            // E.g. [4, 11, 15] becomes 4bf.
            for ( i = 0, str = ''; i <= j; str += NUMERALS.charAt( xc[i++] ) );

            // Negative exponent?
            if ( e < 0 ) {

                // Prepend zeros.
                for ( ; ++e; str = '0' + str );

                str = '0.' + str;

            // Positive exponent?
            } else {
                i = str.length;

                if ( ++e > i ) {

                    // Append zeros.
                    for ( e -= i; e-- ; str += '0' );

                } else if ( e < i ) {
                    str = str.slice( 0, e ) + '.' + str.slice(e);
                }
            }

            // No negative numbers: the caller will add the sign.
            return str;
        }
    })();


    /*
     * Perform division in the specified base. Called by div and convertBase.
     */
    var div = ( function () {

        // Assumes non-zero x and k, and hence non-zero result.
        function multiplyInteger( x, k, base ) {
            var temp,
                carry = 0,
                i = x.length;

            for ( x = x.slice(); i--; ) {
                temp = x[i] * k + carry;
                x[i] = temp % base | 0;
                carry = temp / base | 0;
            }

            if (carry) {
                x.unshift(carry);
            }

            return x;
        }

        function compare( a, b, aL, bL ) {
            var i, cmp;

            if ( aL != bL ) {
                cmp = aL > bL ? 1 : -1;
            } else {

                for ( i = cmp = 0; i < aL; i++ ) {

                    if ( a[i] != b[i] ) {
                        cmp = a[i] > b[i] ? 1 : -1;

                        break;
                    }
                }
            }

            return cmp;
        }

        function subtract( a, b, aL, base ) {
            var i = 0;

            // Subtract b from a.
            for ( ; aL--; ) {
                a[aL] -= i;
                i = a[aL] < b[aL] ? 1 : 0;
                a[aL] = i * base + a[aL] - b[aL];
            }

            // Remove leading zeros.
            for ( ; !a[0] && a.length > 1; a.shift() );
        }

        // x: dividend, y: divisor.
        return function ( x, y, pr, rm, dp, base ) {
            var cmp, e, i, logbase, more, n, prod, prodL, q, qc, rem, remL, rem0, t, xi, xL, yc0,
                yL, yz,
                Decimal = x['constructor'],
                s = x['s'] == y['s'] ? 1 : -1,
                xc = x['c'],
                yc = y['c'];

            // Either NaN, Infinity or 0?
            if ( !xc || !xc[0] || !yc || !yc[0] ) {

                return new Decimal(

                  // Return NaN if either NaN, or both Infinity or 0.
                  !x['s'] || !y['s'] || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :

                    // Return +-0 if x is 0 or y is +-Infinity, or return +-Infinity as y is 0.
                    xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                );
            }

            if (base) {
                logbase = 1;
                e = x['e'] - y['e'];
            } else {
                base = BASE;
                logbase = LOGBASE;
                e = mathfloor( x['e'] / logbase ) - mathfloor( y['e'] / logbase );
            }

            yL = yc.length;
            xL = xc.length;
            q = new Decimal(s);
            qc = q['c'] = [];

            // Result exponent may be one less then the current value of e.
            // The coefficients of the Decimals from convertBase may have trailing zeros.
            for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );

            if ( yc[i] > ( xc[i] || 0 ) ) {
                e--;
            }

            if ( pr == null ) {
                s = pr = Decimal['precision'];
                rm = Decimal['rounding'];
            } else if (dp) {
                s = pr + ( x['e'] - y['e'] ) + 1;
            } else {
                s = pr;
            }

            if ( s < 0 ) {
                qc.push(1);
                more = true;
            } else {

                // Convert base 10 decimal places to base 1e7 decimal places.
                s = s / logbase + 2 | 0;
                i = 0;

                // divisor < 1e7
                if ( yL == 1 ) {
                    n = 0;
                    yc = yc[0];
                    s++;

                    // 'n' is the carry.
                    for ( ; ( i < xL || n ) && s--; i++ ) {
                        t = n * base + ( xc[i] || 0 );
                        qc[i] = t / yc | 0;
                        n = t % yc | 0;
                    }

                    more = n || i < xL;

                // divisor >= 1e7
                } else {

                    // Normalise xc and yc so highest order digit of yc is >= base/2
                    n = base / ( yc[0] + 1 ) | 0;

                    if ( n > 1 ) {
                        yc = multiplyInteger( yc, n, base );
                        xc = multiplyInteger( xc, n, base );
                        yL = yc.length;
                        xL = xc.length;
                    }

                    xi = yL;
                    rem = xc.slice( 0, yL );
                    remL = rem.length;

                    // Add zeros to make remainder as long as divisor.
                    for ( ; remL < yL; rem[remL++] = 0 );

                    yz = yc.slice();
                    yz.unshift(0);
                    yc0 = yc[0];

                    if ( yc[1] >= base / 2 ) {
                        yc0++;
                    }

                    do {
                        n = 0;

                        // Compare divisor and remainder.
                        cmp = compare( yc, rem, yL, remL );

                        // If divisor < remainder.
                        if ( cmp < 0 ) {

                            // Calculate trial digit, n.
                            rem0 = rem[0];

                            if ( yL != remL ) {
                                rem0 = rem0 * base + ( rem[1] || 0 );
                            }

                            // n will be how many times the divisor goes into the current remainder.
                            n = rem0 / yc0 | 0;

                            /*
                              Algorithm:
                              1. product = divisor * trial digit (n)
                              2. if product > remainder: product -= divisor, n--
                              3. remainder -= product
                              4. if product was < remainder at 2:
                                5. compare new remainder and divisor
                                6. If remainder > divisor: remainder -= divisor, n++
                            */

                            if ( n > 1 ) {

                                if ( n >= base ) {
                                    n = base - 1;
                                }

                                // product = divisor * trial digit.
                                prod = multiplyInteger( yc, n, base );
                                prodL = prod.length;
                                remL = rem.length;

                                // Compare product and remainder.
                                cmp = compare( prod, rem, prodL, remL );

                                // product > remainder.
                                if ( cmp == 1 ) {
                                    n--;

                                    // Subtract divisor from product.
                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );
                                }
                            } else {

                                // cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below, so change cmp to 1 to avoid it.
                                // If n is 1 there IS a need to compare yc and rem again below.
                                if ( n == 0 ) {
                                    cmp = n = 1;
                                }
                                prod = yc.slice();
                            }
                            prodL = prod.length;

                            if ( prodL < remL ) {
                                prod.unshift(0);
                            }

                            // Subtract product from remainder.
                            subtract( rem, prod, remL, base );

                            // If product was < previous remainder.
                            if ( cmp == -1 ) {
                                remL = rem.length;

                                // Compare divisor and new remainder.
                                cmp = compare( yc, rem, yL, remL );

                                // If divisor < new remainder, subtract divisor from remainder.
                                if ( cmp < 1 ) {
                                    n++;

                                    // Subtract divisor from remainder.
                                    subtract( rem, yL < remL ? yz : yc, remL, base );
                                }
                            }

                            remL = rem.length;

                        } else if ( cmp === 0 ) {
                            n++;
                            rem = [0];
                        }    // if cmp === 1, n will be 0

                        // Add the next digit, n, to the result array.
                        qc[i++] = n;

                        // Update the remainder.
                        if ( cmp && rem[0] ) {
                            rem[remL++] = xc[xi] || 0;
                        } else {
                            rem = [ xc[xi] ];
                            remL = 1;
                        }

                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );

                    more = rem[0] != null;
                }

                // Leading zero?
                if ( !qc[0] ) {
                    qc.shift();
                }
            }

            // If div is being used for base conversion.
            if ( logbase == 1 ) {
                q['e'] = e;
                q['r'] = +more;
            } else {

                // To calculate q.e, first get the number of digits of qc[0].
                for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );
                q['e'] = i + e * logbase - 1;

                rnd( q, dp ? pr + q['e'] + 1 : pr, rm, more );
            }

            return q;
        }
    })();


    /*
     * Taylor/Maclaurin series.
     *
     * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
     *
     * Argument reduction:
     *   Repeat x = x / 32, k += 5, until |x| < 0.1
     *   exp(x) = exp(x / 2^k)^(2^k)
     *
     * Previously, the argument was initially reduced by
     * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
     * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
     * found to be slower than just dividing repeatedly by 32 as above.
     *
     * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
     * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
     * ( Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324 )
     *
     *  exp(Infinity)  = Infinity
     *  exp(-Infinity) = 0
     *  exp(NaN)       = NaN
     *  exp(+-0)       = 1
     *
     *  exp(x) is non-terminating for any finite, non-zero x.
     *
     *  The result will always be correctly rounded.
     *
     */
    function exp( x, pr ) {
        var denom, guard, j, pow, sd, sum, t,
            rep = 0,
            i = 0,
            k = 0,
            Decimal = x['constructor'],
            one = Decimal['ONE'],
            rm = Decimal['rounding'],
            precision = Decimal['precision'];

        // 0/NaN/Infinity?
        if ( !x['c'] || !x['c'][0] || x['e'] > 17 ) {

            return new Decimal( x['c']
              ? !x['c'][0] ? one : x['s'] < 0 ? 0 : 1 / 0
              : x['s'] ? x['s'] < 0 ? 0 : x : NaN );
        }

        if ( pr == null ) {

            /*
             Estimate result exponent.
             e^x = 10^j, where j = x * log10(e) and
             log10(e) = ln(e) / ln(10) = 1 / ln(10),
             so j = x / ln(10)
            j = mathfloor( x / Math.LN10 );

            // Overflow/underflow? Estimate may be +-1 of true value.
            if ( j > Decimal['maxE'] + 1 || j < Decimal['minE'] - 1 ) {

                return new Decimal( j > 0 ? 1 / 0 : 0 );
            }
             */

            external = false;
            sd = precision;
        } else {
            sd = pr;
        }

        t = new Decimal(0.03125);

        // while abs(x) >= 0.1
        while ( x['e'] > -2 ) {

            // x = x / 2^5
            x = x['times'](t);
            k += 5;
        }

        /*
         Use 2 * log10(2^k) + 5 to estimate the increase in precision necessary to ensure the first
         4 rounding digits are correct.
         */
        guard = Math.log( mathpow( 2, k ) ) / Math.LN10 * 2 + 5 | 0;
        sd += guard;

        denom = pow = sum = new Decimal(one);
        Decimal['precision'] = sd;

        for ( ; ; ) {
            pow = rnd( pow['times'](x), sd, 1 );
            denom = denom['times'](++i);
            t = sum['plus']( div( pow, denom, sd, 1 ) );

            if ( coefficientToString( t['c'] ).slice( 0, sd ) ===
                 coefficientToString( sum['c'] ).slice( 0, sd ) ) {
                j = k;

                while ( j-- ) {
                    sum = rnd( sum['times'](sum), sd, 1 );
                }

                /*
                 Check to see if the first 4 rounding digits are [49]999.
                 If so, repeat the summation with a higher precision, otherwise
                 E.g. with precision: 18, rounding: 1
                 exp(18.404272462595034083567793919843761) = 98372560.1229999999
                                           when it should be 98372560.123

                 sd - guard is the index of first rounding digit.
                 */
                if ( pr == null ) {

                    if ( rep < 3 && checkRoundingDigits( sum['c'], sd - guard, rm, rep ) ) {
                        Decimal['precision'] = sd += 10;
                        denom = pow = t = new Decimal(one);
                        i = 0;
                        rep++;
                    } else {

                        return rnd( sum, Decimal['precision'] = precision, rm, external = true );
                    }
                } else {
                    Decimal['precision'] = precision;

                    return sum;
                }
            }
            sum = t;
        }
    }


    /*
     * Return a string representing the value of Decimal n in normal or exponential notation
     * rounded to the specified decimal places or significant digits.
     * Called by toString, toExponential (k is 1), toFixed, and toPrecision (k is 2).
     * i is the index (with the value in normal notation) of the digit that may be rounded up.
     * j is the rounding mode, then the number of digits required including fraction-part trailing
     * zeros.
     */
    function format( n, i, j, k ) {
        var s, z,
            Decimal = n['constructor'],
            e = ( n = new Decimal(n) )['e'];

        // i == null when toExponential(no arg), or toString() when x >= toExpPos etc.
        if ( i == null ) {
            j = 0;
        } else {
            rnd( n, ++i, j );

            // If toFixed, n['e'] may have changed if the value was rounded up.
            j = k ? i : i + n['e'] - e;
        }

        e = n['e'];
        s = coefficientToString( n['c'] );

        /*
         toPrecision returns exponential notation if the number of significant digits specified
         is less than the number of digits necessary to represent the integer part of the value
         in normal notation.
         */

        // Exponential notation.
        if ( k == 1 || k == 2 && ( i <= e || e <= Decimal['toExpNeg'] ) ) {

            // Append zeros?
            for ( ; s.length < j; s += '0' );

            if ( s.length > 1 ) {
                s = s.charAt(0) + '.' + s.slice(1);
            }

            s += ( e < 0 ? 'e' : 'e+' ) + e;

        // Normal notation.
        } else {
            k = s.length;

            // Negative exponent?
            if ( e < 0 ) {
                z = j - k;

                // Prepend zeros.
                for ( ; ++e; s = '0' + s );
                s = '0.' + s;

            // Positive exponent?
            } else {

                if ( ++e > k ) {
                    z = j - e;

                    // Append zeros.
                    for ( e -= k; e-- ; s += '0' );

                    if ( z > 0 ) {
                        s += '.';
                    }

                } else {
                    z = j - k;

                    if ( e < k ) {
                        s = s.slice( 0, e ) + '.' + s.slice(e);
                    } else if ( z > 0 ) {
                        s += '.';
                    }
                }
            }

            // Append more zeros?
            if ( z > 0 ) {

                for ( ; z--; s += '0' );
            }
        }

        return n['s'] < 0 && n['c'][0] ? '-' + s : s;
    }


    function getCoeffLength(c) {
        var v = c.length - 1,
            n = v * LOGBASE + 1;

        if ( v = c[v] ) {

            // Subtract the number of trailing zeros of the last number.
            for ( ; v % 10 == 0; v /= 10, n-- );

            // Add the number of digits of the first number.
            for ( v = c[0]; v >= 10; v /= 10, n++ );
        }

        return n;
    }


    /*
     * Assemble error messages. Throw Decimal Errors.
     */
    function ifExceptionsThrow( Decimal, message, arg, method, more ) {

        if ( Decimal['errors'] ) {
            var error = new Error( ( method || [
              'new Decimal', 'cmp', 'div', 'eq', 'gt', 'gte', 'lt', 'lte', 'minus', 'mod',
              'plus', 'times', 'toFraction', 'pow', 'random', 'log', 'sqrt', 'toNearest', 'divToInt'
              ][ id ? id < 0 ? -id : id : 1 / id < 0 ? 1 : 0 ] ) + '() ' + ( [
              'number type has more than 15 significant digits', 'LN10 out of digits' ][message]
              || message + ( [ outOfRange ? ' out of range' : ' not an integer',
              ' not a boolean or binary digit' ][more] || '' ) ) + ': ' + arg
            );
            error['name'] = 'Decimal Error';
            outOfRange = id = 0;

            throw error;
        }
    }


    /*
     * Use 'exponentiation by squaring' for small integers. Called by convertBase and pow.
     */
    function intPow( Decimal, x, i ) {
        var r = new Decimal( Decimal['ONE'] );

        for ( external = false; ; ) {

            if ( i & 1 ) {
                r = r['times'](x);
            }
            i >>= 1;

            if ( !i ) {

                break;
            }
            x = x['times'](x);
        }
        external = true;

        return r;
    }


    /*
     *  ln(-n)        = NaN
     *  ln(0)         = -Infinity
     *  ln(-0)        = -Infinity
     *  ln(1)         = 0
     *  ln(Infinity)  = Infinity
     *  ln(-Infinity) = NaN
     *  ln(NaN)       = NaN
     *
     *  ln(n) (n != 1) is non-terminating.
     *
     */
    function ln( y, pr ) {
        var c, c0, denom, e, num, rep, sd, sum, t, x1, x2,
            n = 1,
            guard = 10,
            x = y,
            xc = x['c'],
            Decimal = x['constructor'],
            one = Decimal['ONE'],
            rm = Decimal['rounding'],
            precision = Decimal['precision'];

        // x < 0 or +-Infinity/NaN or 0 or 1.
        if ( x['s'] < 0 || !xc || !xc[0] || !x['e'] && xc[0] == 1 && xc.length == 1 ) {

            return new Decimal( xc && !xc[0] ? -1 / 0 : x['s'] != 1 ? NaN : xc ? 0 : x );
        }

        if ( pr == null ) {
            external = false;
            sd = precision;
        } else {
            sd = pr;
        }

        Decimal['precision'] = sd += guard;

        c = coefficientToString(xc);
        c0 = c.charAt(0);

        if ( Math.abs( e = x['e'] ) < 1.5e15 ) {

            /*
             Argument reduction.
             The series converges faster the closer the argument is to 1, so using
             ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
             multiply the argument by itself until the leading digits of the significand are 7, 8,
             9, 10, 11, 12 or 13, recording the number of multiplications so the sum of the series
             can later be divided by this number, then separate out the power of 10 using
             ln(a*10^b) = ln(a) + b*ln(10).
             */

            // max n is 21 ( gives 0.9, 1.0 or 1.1 ) ( 9e15 / 21 = 4.2e14 ).
            //while ( c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1 ) {
            // max n is 6 ( gives 0.7 - 1.3 )
            while ( c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3 ) {
                x = x['times'](y);
                c = coefficientToString( x['c'] );
                c0 = c.charAt(0);
                n++;
            }

            e = x['e'];

            if ( c0 > 1 ) {
                x = new Decimal( '0.' + c );
                e++;
            } else {
                x = new Decimal( c0 + '.' + c.slice(1) );
            }
        } else {

            /*
             The argument reduction method above may result in overflow if the argument y is a
             massive number with exponent >= 1500000000000000 ( 9e15 / 6 = 1.5e15 ), so instead
             recall this function using ln(x*10^e) = ln(x) + e*ln(10).
             */
            x = new Decimal( c0 + '.' + c.slice(1) );

            if ( sd + 2 > LN10.length ) {
                ifExceptionsThrow( Decimal, 1, sd + 2, 'ln' );
            }

            x = ln( x, sd - guard )['plus'](
                new Decimal( LN10.slice( 0, sd + 2 ) )['times']( e + '' )
            );

            Decimal['precision'] = precision;

            return pr == null ? rnd( x, precision, rm, external = true ) : x;
        }

        // x1 is x reduced to a value near 1.
        x1 = x;

        /*
         Taylor series.
         ln(y) = ln( (1 + x)/(1 - x) ) = 2( x + x^3/3 + x^5/5 + x^7/7 + ... )
         where
         x = (y - 1)/(y + 1)              ( |x| < 1 )
         */
        sum = num = x = div( x['minus'](one), x['plus'](one), sd, 1 );
        x2 = rnd( x['times'](x), sd, 1 );
        denom = 3;

        for ( ; ; ) {
            num = rnd( num['times'](x2), sd, 1 );
            t = sum['plus']( div( num, new Decimal(denom), sd, 1 ) );

            if ( coefficientToString( t['c'] ).slice( 0, sd ) ===
                 coefficientToString( sum['c'] ).slice( 0, sd ) ) {
                sum = sum['times'](2);

                /*
                 Reverse the argument reduction. Check that e is not 0 because, as well as
                 preventing an unnecessary calculation, -0 + 0 = +0 and to ensure correct
                 rounding later -0 needs to stay -0.
                 */
                if ( e !== 0 ) {

                    if ( sd + 2 > LN10.length ) {
                        ifExceptionsThrow( Decimal, 1, sd + 2, 'ln' );
                    }

                    sum = sum['plus'](
                        new Decimal( LN10.slice( 0, sd + 2 ) )['times']( e + '' )
                    );
                }

                sum = div( sum, new Decimal(n), sd, 1 );

                /*
                 Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
                 been repeated previously) and the first 4 rounding digits 9999?

                 If so, restart the summation with a higher precision, otherwise
                 E.g. with precision: 12, rounding: 1
                 ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.

                 sd - guard is the index of first rounding digit.
                 */
                if ( pr == null ) {

                    if ( checkRoundingDigits( sum['c'], sd - guard, rm, rep ) ) {
                        Decimal['precision'] = sd += guard;
                        t = num = x = div( x1['minus'](one), x1['plus'](one), sd, 1 );
                        x2 = rnd( x['times'](x), sd, 1 );
                        denom = rep = 1;
                    } else {

                        return rnd( sum, Decimal['precision'] = precision, rm, external = true );
                    }
                } else {
                    Decimal['precision'] = precision;

                    return sum;
                }
            }

            sum = t;
            denom += 2;
        }
    }


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     */
     function rnd( x, sd, rm, r ) {
        var digits, i, j, k, n, rd, xc, xci,
            Decimal = x['constructor'];

        // Don't round if sd is null or undefined.
        r: if ( sd != i ) {

            // Infinity/NaN.
            if ( !( xc = x['c'] ) ) {

                return x;
            }

            /*
             rd, the rounding digit, i.e. the digit after the digit that may be rounded up,
             n, a base 1e7 number, the element of xc containing rd,
             xci, the index of n within xc,
             digits, the number of digits of n,
             i, what would be the index of rd within n if all the numbers were 7 digits long (i.e. they had leading zeros)
             j, if > 0, the actual index of rd within n (if < 0, rd is a leading zero),
             nLeadingZeros, the number of leading zeros n would have if it were 7 digits long.
             */

            // Get the length of the first element of the coefficient array xc.
            for ( digits = 1, k = xc[0]; k >= 10; k /= 10, digits++ );

            i = sd - digits;

            // Is the rounding digit in the first element of xc?
            if ( i < 0 ) {
                i += LOGBASE;
                j = sd;
                n = xc[ xci = 0 ];

                // Get the rounding digit at index j of n.
                rd = n / mathpow( 10, digits - j - 1 ) % 10 | 0;
            } else {
                xci = Math.ceil( ( i + 1 ) / LOGBASE );

                if ( xci >= xc.length ) {

                    if (r) {

                        // Needed by exp, ln and sqrt.
                        for ( ; xc.length <= xci; xc.push(0) );

                        n = rd = 0;
                        digits = 1;
                        i %= LOGBASE;
                        j = i - LOGBASE + 1;
                    } else {

                      break r;
                    }
                } else {
                    n = k = xc[xci];

                    // Get the number of digits of n.
                    for ( digits = 1; k >= 10; k /= 10, digits++ );

                    // Get the index of rd within n.
                    i %= LOGBASE;

                    // Get the index of rd within n, adjusted for leading zeros.
                    // The number of leading zeros of n is given by LOGBASE - digits.
                    j = i - LOGBASE + digits;

                    // Get the rounding digit at index j of n.
                    // Floor using Math.floor instead of | 0 as rd may be outside int range.
                    rd = j < 0 ? 0 : mathfloor( n / mathpow( 10, digits - j - 1 ) % 10 );
                }
            }

            r = r || sd < 0 ||
              // Are there any non-zero digits after the rounding digit?
              xc[xci + 1] != null || ( j < 0 ? n : n % mathpow( 10, digits - j - 1 ) );

            /*
             The expression  n % mathpow( 10, digits - j - 1 )  returns all the digits of n to the
             right of the digit at (left-to-right) index j,
             e.g. if n is 908714 and j is 2, the expression will give 714.
             */

            r = rm < 4
              ? ( rd || r ) && ( rm == 0 || rm == ( x['s'] < 0 ? 3 : 2 ) )
              : rd > 5 || rd == 5 && ( rm == 4 || r ||
                // Check whether the digit to the left of the rounding digit is odd.
                rm == 6 && ( ( i > 0 ? j > 0 ? n / mathpow( 10, digits - j ) : 0 : xc[xci - 1] ) % 10 ) & 1 ||
                  rm == ( x['s'] < 0 ? 8 : 7 ) );

            if ( sd < 1 || !xc[0] ) {
                xc.length = 0;

                if (r) {

                    // Convert sd to decimal places.
                    sd -= x['e'] + 1;

                    // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                    xc[0] = mathpow( 10, sd % LOGBASE );
                    x['e'] = -sd || 0;
                } else {

                    // Zero.
                    xc[0] = x['e'] = 0;
                }

                return x;
            }

            // Remove excess digits.

            if ( i == 0 ) {
                xc.length = xci;
                k = 1;
                xci--;
            } else {
                xc.length = xci + 1;
                k = mathpow( 10, LOGBASE - i );

                // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                // j > 0 means i > number of leading zeros of n.
                xc[xci] = j > 0 ? ( n / mathpow( 10, digits - j ) % mathpow( 10, j ) | 0 ) * k : 0;
            }

            // Round up?
            if (r) {

                for ( ; ; ) {

                    // Is the digit to be rounded up in the first element of xc.
                    if ( xci == 0 ) {

                        // i will be the length of xc[0] before k is added.
                        for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );

                        j = xc[0] += k;

                        for ( k = 1; j >= 10; j /= 10, k++ );

                        // if i != k the length has increased.
                        if ( i != k ) {
                            x['e']++;

                            if ( xc[0] == BASE ) {
                                xc[0] = 1;
                            }
                        }

                        break;
                    } else {
                        xc[xci] += k;

                        if ( xc[xci] != BASE ) {

                            break;
                        }

                        xc[xci--] = 0;
                        k = 1;
                    }
                }
            }

            // Remove trailing zeros.
            for ( i = xc.length; xc[--i] === 0; xc.pop() );
        }

        if (external) {

            // Overflow?
            if ( x['e'] > Decimal['maxE'] ) {

                // Infinity.
                x['c'] = x['e'] = null;

            // Underflow?
            } else if ( x['e'] < Decimal['minE'] ) {

                // Zero.
                x['c'] = [ x['e'] = 0 ];
            }
        }

        return x;
    }


    DecimalConstructor = (function () {


        // Private functions used by static Decimal methods.


        /*
         *  The following emulations or wrappers of Math object functions are currently
         *  commented-out and not in the public API.
         *
         *  abs
         *  acos
         *  asin
         *  atan
         *  atan2
         *  ceil
         *  cos
         *  floor
         *  round
         *  sin
         *  tan
         *  trunc
         */


        /*
         * Return a new Decimal whose value is the absolute value of n.
         *
         * n {number|string|Decimal}
         *
        function abs(n) { return new this(n)['abs']() }
         */


        /*
         * Return a new Decimal whose value is the arccosine in radians of n.
         *
         * n {number|string|Decimal}
         *
        function acos(n) { return new this( Math.acos(n) + '' ) }
         */


        /*
         * Return a new Decimal whose value is the arcsine in radians of n.
         *
         * n {number|string|Decimal}
         *
        function asin(n) { return new this( Math.asin(n) + '' ) }
         */


        /*
         * Return a new Decimal whose value is the arctangent in radians of n.
         *
         * n {number|string|Decimal}
         *
        function atan(n) { return new this( Math.atan(n) + '' ) }
         */


        /*
         * Return a new Decimal whose value is the arctangent in radians of y/x in the range
         * -PI to PI (inclusive).
         *
         * y {number|string|Decimal} The y-coordinate.
         * x {number|string|Decimal} The x-coordinate.
         *
        function atan2( y, x ) { return new this( Math.atan2( y, x ) + '' ) }
         */


        /*
         * Return a new Decimal whose value is n round to an integer using ROUND_CEIL.
         *
         * n {number|string|Decimal}
         *
        function ceil(n) { return new this(n)['ceil']() }
         */


        /*
         * Configure global settings for a Decimal constructor.
         *
         * obj is an object with any of the following properties,
         *
         *   precision  {number}
         *   rounding   {number}
         *   toExpNeg   {number}
         *   toExpPos   {number}
         *   minE       {number}
         *   maxE       {number}
         *   errors     {boolean|number}
         *   crypto     {boolean|number}
         *   modulo     {number}
         *
         * E.g.
         *   Decimal.config({ precision: 20, rounding: 4 })
         *
         */
        function config(obj) {
            var p, u, v,
                Decimal = this,
                c = 'config',
                parse = Decimal['errors'] ? parseInt : parseFloat;

            if ( obj == u || typeof obj != 'object' &&
              !ifExceptionsThrow( Decimal, 'object expected', obj, c ) ) {

                return Decimal;
            }

            // precision {number|number[]} Integer, 1 to MAX_DIGITS inclusive.
            if ( ( v = obj[ p = 'precision' ] ) != u ) {

                if ( !( outOfRange = v < 1 || v > MAX_DIGITS ) && parse(v) == v ) {
                    Decimal[p] = v | 0;
                } else {

                    // 'config() precision not an integer: {v}'
                    // 'config() precision out of range: {v}'
                    ifExceptionsThrow( Decimal, p, v, c, 0 );
                }
            }

            // rounding {number} Integer, 0 to 8 inclusive.
            if ( ( v = obj[ p = 'rounding' ] ) != u ) {

                if ( !( outOfRange = v < 0 || v > 8 ) && parse(v) == v ) {
                    Decimal[p] = v | 0;
                } else {

                    // 'config() rounding not an integer: {v}'
                    // 'config() rounding out of range: {v}'
                    ifExceptionsThrow( Decimal, p, v, c, 0 );
                }
            }

            // toExpNeg {number} Integer, -EXP_LIMIT to 0 inclusive.
            if ( ( v = obj[ p = 'toExpNeg' ] ) != u ) {

                if ( !( outOfRange = v < -EXP_LIMIT || v > 0 ) && parse(v) == v ) {
                    Decimal[p] = mathfloor(v);
                } else {

                    // 'config() toExpNeg not an integer: {v}'
                    // 'config() toExpNeg out of range: {v}'
                    ifExceptionsThrow( Decimal, p, v, c, 0 );
                }
            }

            // toExpPos {number} Integer, 0 to EXP_LIMIT inclusive.
            if ( ( v = obj[ p = 'toExpPos' ] ) != u ) {

                if ( !( outOfRange = v < 0 || v > EXP_LIMIT ) && parse(v) == v ) {
                    Decimal[p] = mathfloor(v);
                } else {

                    // 'config() toExpPos not an integer: {v}'
                    // 'config() toExpPos out of range: {v}'
                    ifExceptionsThrow( Decimal, p, v, c, 0 );
                }
            }

             // minE {number} Integer, -EXP_LIMIT to 0 inclusive.
            if ( ( v = obj[ p = 'minE' ] ) != u ) {

                if ( !( outOfRange = v < -EXP_LIMIT || v > 0 ) && parse(v) == v ) {
                    Decimal[p] = mathfloor(v);
                } else {

                    // 'config() minE not an integer: {v}'
                    // 'config() minE out of range: {v}'
                    ifExceptionsThrow( Decimal, p, v, c, 0 );
                }
            }

            // maxE {number} Integer, 0 to EXP_LIMIT inclusive.
            if ( ( v = obj[ p = 'maxE' ] ) != u ) {

                if ( !( outOfRange = v < 0 || v > EXP_LIMIT ) && parse(v) == v ) {
                    Decimal[p] = mathfloor(v);
                } else {

                    // 'config() maxE not an integer: {v}'
                    // 'config() maxE out of range: {v}'
                    ifExceptionsThrow( Decimal, p, v, c, 0 );
                }
            }

            // errors {boolean|number} true, false, 1 or 0.
            if ( ( v = obj[ p = 'errors' ] ) != u ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    outOfRange = id = 0;
                    Decimal[p] = !!v;
                } else {

                    // 'config() errors not a boolean or binary digit: {v}'
                    ifExceptionsThrow( Decimal, p, v, c, 1 );
                }
            }

            // crypto {boolean|number} true, false, 1 or 0.
            if ( ( v = obj[ p = 'crypto' ] ) != u ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    Decimal[p] = !!( v && crypto && typeof crypto == 'object' );
                } else {

                    // 'config() crypto not a boolean or binary digit: {v}'
                    ifExceptionsThrow( Decimal, p, v, c, 1 );
                }
            }

            // modulo {number} Integer, 0 to 9 inclusive.
            if ( ( v = obj[ p = 'modulo' ] ) != u ) {

                if ( !( outOfRange = v < 0 || v > 9 ) && parse(v) == v ) {
                    Decimal[p] = v | 0;
                } else {

                    // 'config() modulo not an integer: {v}'
                    // 'config() modulo out of range: {v}'
                    ifExceptionsThrow( Decimal, p, v, c, 0 );
                }
            }

            return Decimal;
        }


        /*
         * Return a new Decimal whose value is the cosine of n.
         *
         * n {number|string|Decimal} A number given in radians.
         *
        function cos(n) { return new this( Math.cos(n) + '' ) }
         */


        /*
         * Return a new Decimal whose value is the exponential of n,
         *
         * n {number|string|Decimal} The power to which to raise the base of the natural log.
         *
         */
        function exp(n) { return new this(n)['exp']() }


        /*
         * Return a new Decimal whose value is n round to an integer using ROUND_FLOOR.
         *
         * n {number|string|Decimal}
         *
        function floor(n) { return new this(n)['floor']() }
         */


        /*
         * Return a new Decimal whose value is the natural logarithm of n.
         *
         * n {number|string|Decimal}
         *
         */
        function ln(n) { return new this(n)['ln']() }


        /*
         * Return a new Decimal whose value is the log of x to the base y, or to base 10 if no
         * base is specified.
         *
         * log[y](x)
         *
         * x {number|string|Decimal} The argument of the logarithm.
         * y {number|string|Decimal} The base of the logarithm.
         *
         */
        function log( x, y ) { return new this(x)['log'](y) }


        /*
         * Handle max and min. ltgt is 'lt' or 'gt'.
         */
        function maxOrMin( Decimal, args, ltgt ) {
            var m, n,
                i = 0;

            if ( toString.call( args[0] ) == '[object Array]' ) {
                args = args[0];
            }

            m = new Decimal( args[0] );

            for ( ; ++i < args.length; ) {
                n = new Decimal( args[i] );

                if ( !n['s'] ) {
                    m = n;

                    break;
                } else if ( m[ltgt](n) ) {
                    m = n;
                }
            }

            return m;
        }


        /*
         * Return a new Decimal whose value is the maximum of the arguments.
         *
         * arguments {number|string|Decimal}
         *
         */
        function max() { return maxOrMin( this, arguments, 'lt' ) }


        /*
         * Return a new Decimal whose value is the minimum of the arguments.
         *
         * arguments {number|string|Decimal}
         *
         */
        function min() { return maxOrMin( this, arguments, 'gt' ) }


        /*
         * Parse the value of a new Decimal from a number or string.
         */
        var parseDecimal = (function () {
            var isValid = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
                trim = String.prototype.trim || function () {return this.replace(/^\s+|\s+$/g, '')};

            return function ( Decimal, x, n, b ) {
                var d, e, i, isNum, orig, valid;

                if ( typeof n != 'string' ) {

                    // TODO: modify so regex test below is avoided if type is number.
                    // If n is a number, check if minus zero.
                    n = ( isNum = typeof n == 'number' || toString.call(n) == '[object Number]' ) &&
                        n === 0 && 1 / n < 0 ? '-0' : n + '';
                }
                orig = n;

                if ( b == e && isValid.test(n) ) {

                    // Determine sign.
                    x['s'] = n.charAt(0) == '-' ? ( n = n.slice(1), -1 ) : 1;

                // Either n is not a valid Decimal or a base has been specified.
                } else {

                    /*
                     Enable exponential notation to be used with base 10 argument.
                     Ensure return value is rounded to precision as with other bases.
                     */
                    if ( b == 10 ) {

                        return rnd( new Decimal(n), Decimal['precision'], Decimal['rounding'] );
                    }

                    n = trim.call(n).replace( /^\+(?!-)/, '' );

                    x['s'] = n.charAt(0) == '-' ? ( n = n.replace( /^-(?!-)/, '' ), -1 ) : 1;

                    if ( b != e ) {

                        if ( ( b == (b | 0) || !Decimal['errors'] ) &&
                          !( outOfRange = !( b >= 2 && b < 65 ) ) ) {
                            d = '[' + NUMERALS.slice( 0, b = b | 0 ) + ']+';

                           // Remove the `.` from e.g. '1.', and replace e.g. '.1' with '0.1'.
                            n = n.replace( /\.$/, '' ).replace( /^\./, '0.' );

                            // Any number in exponential form will fail due to the e+/-.
                            if ( valid = new RegExp(
                              '^' + d + '(?:\\.' + d + ')?$', b < 37 ? 'i' : '' ).test(n)
                            ) {

                                if (isNum) {

                                    if ( n.replace( /^0\.0*|\./, '' ).length > 15 ) {

                                        // '{method} number type has more than 15 significant digits: {n}'
                                        ifExceptionsThrow( Decimal, 0, orig );
                                    }

                                    // Prevent later check for length on converted number.
                                    isNum = !isNum;
                                }
                                n = convertBase( Decimal, n, 10, b, x['s'] );

                            } else if ( n != 'Infinity' && n != 'NaN' ) {

                                // '{method} not a base {b} number: {n}'
                                ifExceptionsThrow( Decimal, 'not a base ' + b + ' number', orig );
                                n = 'NaN';
                            }
                        } else {

                            // '{method} base not an integer: {b}'
                            // '{method} base out of range: {b}'
                            ifExceptionsThrow( Decimal, 'base', b, 0, 0 );

                            // Ignore base.
                            valid = isValid.test(n);
                        }
                    } else {
                        valid = isValid.test(n);
                    }

                    if ( !valid ) {

                        // Infinity/NaN
                        x['c'] = x['e'] = null;

                        // NaN
                        if ( n != 'Infinity' ) {

                            // No exception on NaN.
                            if ( n != 'NaN' ) {

                                // '{method} not a number: {n}'
                                ifExceptionsThrow( Decimal, 'not a number', orig );
                            }
                            x['s'] = null;
                        }
                        id = 0;

                        return x;
                    }
                }

                // Decimal point?
                if ( ( e = n.indexOf('.') ) > -1 ) {
                    n = n.replace( '.', '' );
                }

                // Exponential form?
                if ( ( i = n.search( /e/i ) ) > 0 ) {

                    // Determine exponent.
                    if ( e < 0 ) {
                        e = i;
                    }
                    e += +n.slice( i + 1 );
                    n = n.substring( 0, i );

                } else if ( e < 0 ) {

                    // Integer.
                    e = n.length;
                }

                // Determine leading zeros.
                for ( i = 0; n.charAt(i) == '0'; i++ );

                // Determine trailing zeros.
                for ( b = n.length; n.charAt(--b) == '0'; );

                n = n.slice( i, b + 1 );

                if (n) {
                    b = n.length;

                    // Disallow numbers with over 15 significant digits if number type.
                    if ( isNum && b > 15 ) {

                        // '{method} number type has more than 15 significant digits: {n}'
                        ifExceptionsThrow( Decimal, 0, orig );
                    }

                    x['e'] = e = e - i - 1;
                    x['c'] = [];

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice n to get the first element of the coefficient array.
                    i = ( e + 1 ) % LOGBASE;

                    if ( e < 0 ) {
                        i += LOGBASE;
                    }

                    // b is n.length.
                    if ( i < b ) {

                        if (i) {
                            x['c'].push( +n.slice( 0, i ) );
                        }

                        for ( b -= LOGBASE; i < b; ) {
                            x['c'].push( +n.slice( i, i += LOGBASE ) );
                        }

                        n = n.slice(i);
                        i = LOGBASE - n.length;
                    } else {
                        i -= b;
                    }

                    for ( ; i--; n += '0' );

                    x['c'].push( +n );

                    if (external) {

                        // Overflow?
                        if ( x['e'] > Decimal['maxE'] ) {

                            // Infinity.
                            x['c'] = x['e'] = null;

                        // Underflow?
                        } else if ( x['e'] < Decimal['minE'] ) {

                            // Zero.
                            x['c'] = [ x['e'] = 0 ];
                        }
                    }
                } else {

                    // Zero.
                    x['c'] = [ x['e'] = 0 ];
                }

                id = 0;
            }
        })();


        /*
         * Return a new Decimal whose value is x raised to the power y.
         *
         * x {number|string|Decimal} The base.
         * y {number|string|Decimal} The exponent.
         *
         */
        function pow( x, y ) { return new this(x)['pow'](y) }


        /*
         * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and
         * with dp, or Decimal.precision if dp is omitted, decimal places (or less if trailing
         * zeros are produced).
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
         *
         */
        function random(dp) {
            var a, n, v,
                i = 0,
                r = [],
                Decimal = this,
                rand = new Decimal( Decimal['ONE'] );

            if ( dp == null || !checkArg( rand, dp, 'random' ) ) {
                dp = Decimal['precision'];
            } else {
                dp |= 0;
            }

            n = Math.ceil( dp / LOGBASE );

            if ( Decimal['crypto'] ) {

                // Browsers supporting crypto.getRandomValues.
                if ( crypto && crypto['getRandomValues'] ) {

                    a = crypto['getRandomValues']( new Uint32Array(n) );

                    for ( ; i < n; ) {
                        v = a[i];

                        // 0 >= v < 4294967296
                        // Probability that v >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
                        if ( v >= 4.29e9 ) {

                            a[i] = crypto['getRandomValues']( new Uint32Array(1) )[0];
                        } else {

                            // 0 <= v <= 4289999999
                            // 0 <= ( v % 1e7 ) <= 9999999
                            r[i++] = v % 1e7;
                        }
                    }

                // Node.js supporting crypto.randomBytes.
                } else if ( crypto && crypto['randomBytes'] ) {

                    // buffer
                    a = crypto['randomBytes']( n *= 4 );

                    for ( ; i < n; ) {

                        // 0 <= v < 2147483648
                        v = a[i] + ( a[i + 1] << 8 ) + ( a[i + 2] << 16 ) +
                            ( ( a[i + 3] & 0x7f ) << 24 );

                        // Probability that v >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
                        if ( v >= 2.14e9 ) {
                            crypto['randomBytes'](4).copy( a, i );
                        } else {

                            // 0 <= v <= 4289999999
                            // 0 <= ( v % 1e7 ) <= 9999999
                            r.push( v % 1e7 );
                            i += 4;
                        }
                    }
                    i = n / 4;

                } else {
                    ifExceptionsThrow( Decimal, 'crypto unavailable', crypto, 'random' );
                }
            }

            // Use Math.random: either Decimal.crypto is false or crypto is unavailable and errors is false.
            if (!i) {

                for ( ; i < n; ) {
                    r[i++] = Math.random() * 1e7 | 0;
                }
            }

            n = r[--i];
            dp %= LOGBASE;

            // Convert trailing digits to zeros according to dp.
            if ( n && dp ) {
                v = mathpow( 10, LOGBASE - dp );
                r[i] = ( n / v | 0 ) * v;
            }

            // Remove trailing elements which are zero.
            for ( ; r[i] === 0; i-- ) {
                r.pop();
            }

            // Zero?
            if ( i < 0 ) {
                r = [ n = 0 ];
            } else {
                n = -1;

                // Remove leading elements which are zero and adjust exponent accordingly.
                for ( ; r[0] === 0; ) {
                    r.shift();
                    n -= LOGBASE;
                }

                // Count the digits of the first element of r to determine leading zeros.
                for ( i = 1, v = r[0]; v >= 10; ) {
                    v /= 10;
                    i++;
                }

                // Adjust the exponent for leading zeros of the first element of r.
                if ( i < LOGBASE ) {
                    n -= LOGBASE - i;
                }
            }

            rand['e'] = n;
            rand['c'] = r;

            return rand;
        }


        /*
         * Return a new Decimal whose value is n round to an integer using rounding mode rounding.
         *
         * To emulate Math.round, set rounding to 7 (ROUND_HALF_CEIL).
         *
         * n {number|string|Decimal}
         *
        function round(n) {
            var x = new this(n);

            return rnd( x, x['e'] + 1, this['rounding'] );
        }
         */


        /*
         * Return a new Decimal whose value is the sine of n.
         *
         * n {number|string|Decimal} A number given in radians.
         *
        function sin(n) { return new this( Math.sin(n) + '' ) }
         */


        /*
         * Return a new Decimal whose value is the square root of n.
         *
         * n {number|string|Decimal}
         *
         */
        function sqrt(n) { return new this(n)['sqrt']() }


        /*
         * Return a new Decimal whose value is the tangent of n.
         *
         * n {number|string|Decimal} A number given in radians.
         *
        function tan(n) { return new this( Math.tan(n) + '' ) }
         */


        /*
         * Return a new Decimal whose value is n truncated to an integer.
         *
         * n {number|string|Decimal}
         *
        function trunc(n) { return new this(n)['trunc']() }
         */


        /*
         * Create and return a new Decimal constructor.
         *
         */
        function DecimalFactory(obj) {

            /*
             * The Decimal constructor.
             * Create and return a new instance of a Decimal object.
             *
             * n {number|string|Decimal} A numeric value.
             * [b] {number} The base of n. Integer, 2 to 64 inclusive.
             *
             */
            function Decimal( n, b ) {
                var x = this;

                // Constructor called without new.
                if ( !( x instanceof Decimal ) ) {
                    ifExceptionsThrow( Decimal, 'Decimal called without new', n );

                    return new Decimal( n, b );
                }

                // Duplicate.
                if ( n instanceof Decimal ) {

                    if ( b == null ) {
                        id = 0;
                        x['constructor'] = n['constructor'];
                        x['s'] = n['s'];
                        x['e'] = n['e'];
                        x['c'] = ( n = n['c'] ) ? n.slice() : n;

                        return;
                    } else if ( b == 10 ) {

                        return rnd( new Decimal(n), Decimal['precision'], Decimal['rounding'] );
                    } else {
                        n += '';
                    }
                }

                return parseDecimal( x['constructor'] = Decimal, x, n, b );
            }


            /* ************************ CONSTRUCTOR DEFAULT PROPERTIES *****************************


             These default values must be integers within the stated ranges (inclusive).
             Most of these values can be changed during run-time using Decimal.config.
             */

            /*
             The maximum number of significant digits of the result of a calculation or base
             conversion.
             E.g.  Decimal.config({ precision: 20 })
             */
            Decimal['precision'] = 20;                        // 1 to MAX_DIGITS

            /*
             The rounding mode used when rounding to precision.

             ROUND_UP         0 Away from zero.
             ROUND_DOWN       1 Towards zero.
             ROUND_CEIL       2 Towards +Infinity.
             ROUND_FLOOR      3 Towards -Infinity.
             ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
             ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
             ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
             ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
             ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.

             E.g.
             Decimal.rounding = 4;
             Decimal.rounding = Decimal.ROUND_HALF_UP;
             */
            Decimal['rounding'] = 4;                          // 0 to 8

            /*
             The modulo mode used when calculating the modulus: a mod n.
             The quotient (q = a / n) is calculated according to the corresponding rounding mode.
             The remainder (r) is calculated as: r = a - n * q.

             UP         0 The remainder is positive if the dividend is negative, else is negative.
             DOWN       1 The remainder has the same sign as the dividend.
                          This modulo mode is commonly known as "truncated division" and matches
                          as closely as possible, the behaviour of JS remainder operator (a % n).
             FLOOR      3 The remainder has the same sign as the divisor (Python %).
             HALF_EVEN  6 This modulo mode implements the IEEE 754 remainder function.
             EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)).
                          The remainder is always positive.

             The above modes - truncated division, floored division, Euclidian division and IEEE 754
             remainder - are commonly used for the modulus operation. Although any other of the
             rounding modes can be used, they may not give useful results.
             */
            Decimal['modulo'] = 1;                            // 0 to 9

            // The exponent value at and beneath which toString returns exponential notation.
            // Number type: -7
            Decimal['toExpNeg'] = -7;                       // 0 to -EXP_LIMIT

            // The exponent value at and above which toString returns exponential notation.
            // Number type: 21
            Decimal['toExpPos'] = 21;                       // 0 to EXP_LIMIT

            // The minimum exponent value, beneath which underflow to zero occurs.
            // Number type: -324  (5e-324)
            Decimal['minE'] = -EXP_LIMIT;                    // -1 to -EXP_LIMIT

            // The maximum exponent value, above which overflow to Infinity occurs.
            // Number type:  308  (1.7976931348623157e+308)
            Decimal['maxE'] = EXP_LIMIT;                     // 1 to EXP_LIMIT

            // Whether Decimal Errors are ever thrown.
            Decimal['errors'] = true;                         // true/false

            // Whether to use cryptographically-secure random number generation, if available.
            Decimal['crypto'] = false;                        // true/false


            /* ********************** END OF CONSTRUCTOR DEFAULT PROPERTIES ********************* */


            Decimal.prototype = P;

            Decimal['ONE'] = new Decimal(1);

            /*
            // Pi to 80 s.d.
            Decimal['PI'] = new Decimal(
                '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089'
            );
             */

            Decimal['ROUND_UP'] = 0;
            Decimal['ROUND_DOWN'] = 1;
            Decimal['ROUND_CEIL'] = 2;
            Decimal['ROUND_FLOOR'] = 3;
            Decimal['ROUND_HALF_UP'] = 4;
            Decimal['ROUND_HALF_DOWN'] = 5;
            Decimal['ROUND_HALF_EVEN'] = 6;
            Decimal['ROUND_HALF_CEIL'] = 7;
            Decimal['ROUND_HALF_FLOOR'] = 8;

            // modulo mode
            Decimal['EUCLID'] = 9;

            //Decimal['abs'] = abs;
            //Decimal['acos'] = acos;
            //Decimal['asin'] = asin;
            //Decimal['atan'] = atan;
            //Decimal['atan2'] = atan2;
            //Decimal['ceil'] = ceil;
            //Decimal['cos'] = cos;
            //Decimal['floor'] = floor;
            //Decimal['round'] = round;
            //Decimal['sin'] = sin;
            //Decimal['tan'] = tan;
            //Decimal['trunc'] = trunc;

            Decimal['config'] = config;
            Decimal['constructor'] = DecimalFactory;
            Decimal['exp'] = exp;
            Decimal['ln'] = ln;
            Decimal['log'] = log;
            Decimal['max'] = max;
            Decimal['min'] = min;
            Decimal['pow'] = pow;
            Decimal['sqrt'] = sqrt;
            Decimal['random'] = random;

            if ( obj != null ) {
                Decimal['config'](obj);
            }

            return Decimal;
        }

        return DecimalFactory();
    })();


    // Export.


    // AMD.
    if ( typeof define == 'function' && define.amd ) {

        define(function () {
            return DecimalConstructor;
        });

    // Node and other environments that support module.exports.
    } else if ( typeof module != 'undefined' && module.exports ) {
        module.exports = DecimalConstructor;

        if ( !crypto ) {

            try {
                crypto = require('crypto');
            } catch (e) {}
        }

    // Browser.
    } else {
        noConflict = global['Decimal'];

        DecimalConstructor['noConflict'] = function () {
            global['Decimal'] = noConflict;

            return DecimalConstructor;
        };

        global['Decimal'] = DecimalConstructor;
    }
})(this);

})()
},{"crypto":316}],176:[function(require,module,exports){
'use strict';

/**
 * Create a range error with the message:
 *     'Index out of range (index < min)'
 *     'Index out of range (index < max)'
 *
 * @param {number} index     The actual index
 * @param {number} [min=0]   Minimum index (included)
 * @param {number} [max]     Maximum index (excluded)
 * @extends RangeError
 */
function IndexError(index, min, max) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.index = index;
  if (arguments.length < 3) {
    this.min = 0;
    this.max = min;
  }
  else {
    this.min = min;
    this.max = max;
  }

  if (this.min !== undefined && this.index < this.min) {
    this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';
  }
  else if (this.max !== undefined && this.index >= this.max) {
    this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';
  }
  else {
    this.message = 'Index out of range (' + this.index + ')';
  }

  this.stack = (new Error()).stack;
}

IndexError.prototype = new RangeError();
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = 'IndexError';

module.exports = IndexError;

},{}],175:[function(require,module,exports){
'use strict';

/**
 * Create a range error with the message:
 *     'Dimension mismatch (<actual size> != <expected size>)'
 * @param {number | number[]} actual        The actual size
 * @param {number | number[]} expected      The expected size
 * @param {string} [relation='!=']          Optional relation between actual
 *                                          and expected size: '!=', '<', etc.
 * @extends RangeError
 */
function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.actual   = actual;
  this.expected = expected;
  this.relation = relation;

  this.message = 'Dimension mismatch (' +
      (Array.isArray(actual) ? ('[' + actual.join(', ') + ']') : actual) +
      ' ' + (this.relation || '!=') + ' ' +
      (Array.isArray(expected) ? ('[' + expected.join(', ') + ']') : expected) +
      ')';

  this.stack = (new Error()).stack;
}

DimensionError.prototype = new RangeError();
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = 'DimensionError';

module.exports = DimensionError;

},{}],177:[function(require,module,exports){
'use strict';

/**
 * Create a TypeError with message:
 *      'Function <fn> does not support a parameter of type <type>';
 * @param {String} fn     Function name
 * @param {*...} [types]  The types of the function arguments
 * @extends TypeError
 */
function UnsupportedTypeError(fn, types) {
  if (!(this instanceof UnsupportedTypeError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.fn = fn;
  this.types = Array.prototype.splice.call(arguments, 1);

  if (!fn) {
    this.message = 'Unsupported type of argument';
  }
  else {
    if (this.types.length == 0) {
      this.message = 'Unsupported type of argument in function ' + fn;
    }
    else {
      this.message = 'Function ' + fn + '(' + this.types.join(', ') + ') not supported';
    }
  }

  this.stack = (new Error()).stack;
}

UnsupportedTypeError.prototype = new TypeError();
UnsupportedTypeError.prototype.constructor = TypeError;
UnsupportedTypeError.prototype.name = 'UnsupportedTypeError';

module.exports = UnsupportedTypeError;

},{}],193:[function(require,module,exports){
module.exports = {
  'name': 'e',
  'category': 'Constants',
  'syntax': [
    'e'
  ],
  'description': 'Euler\'s number, the base of the natural logarithm. Approximately equal to 2.71828',
  'examples': [
    'e',
    'e ^ 2',
    'exp(2)',
    'log(e)'
  ],
  'seealso': ['exp']
};

},{}],194:[function(require,module,exports){
module.exports = {
  'name': 'false',
  'category': 'Constants',
  'syntax': [
    'false'
  ],
  'description': 'Boolean value false',
  'examples': [
    'false'
  ],
  'seealso': ['true']
};

},{}],195:[function(require,module,exports){
module.exports = {
  'name': 'i',
  'category': 'Constants',
  'syntax': [
    'i'
  ],
  'description': 'Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.',
  'examples': [
    'i',
    'i * i',
    'sqrt(-1)'
  ],
  'seealso': []
};

},{}],196:[function(require,module,exports){
module.exports = {
  'name': 'Infinity',
  'category': 'Constants',
  'syntax': [
    'Infinity'
  ],
  'description': 'Infinity, a number which is larger than the maximum number that can be handled by a floating point number.',
  'examples': [
    'Infinity',
    '1 / 0'
  ],
  'seealso': []
};

},{}],197:[function(require,module,exports){
module.exports = {
  'name': 'LN2',
  'category': 'Constants',
  'syntax': [
    'LN2'
  ],
  'description': 'Returns the natural logarithm of 2, approximately equal to 0.693',
  'examples': [
    'LN2',
    'log(2)'
  ],
  'seealso': []
};

},{}],198:[function(require,module,exports){
module.exports = {
  'name': 'LN10',
  'category': 'Constants',
  'syntax': [
    'LN10'
  ],
  'description': 'Returns the natural logarithm of 10, approximately equal to 2.302',
  'examples': [
    'LN10',
    'log(10)'
  ],
  'seealso': []
};

},{}],199:[function(require,module,exports){
module.exports = {
  'name': 'LOG2E',
  'category': 'Constants',
  'syntax': [
    'LOG2E'
  ],
  'description': 'Returns the base-2 logarithm of E, approximately equal to 1.442',
  'examples': [
    'LOG2E',
    'log(e, 2)'
  ],
  'seealso': []
};

},{}],200:[function(require,module,exports){
module.exports = {
  'name': 'LOG10E',
  'category': 'Constants',
  'syntax': [
    'LOG10E'
  ],
  'description': 'Returns the base-10 logarithm of E, approximately equal to 0.434',
  'examples': [
    'LOG10E',
    'log(e, 10)'
  ],
  'seealso': []
};

},{}],201:[function(require,module,exports){
module.exports = {
  'name': 'NaN',
  'category': 'Constants',
  'syntax': [
    'NaN'
  ],
  'description': 'Not a number',
  'examples': [
    'NaN',
    '0 / 0'
  ],
  'seealso': []
};

},{}],202:[function(require,module,exports){
module.exports = {
  'name': 'null',
  'category': 'Constants',
  'syntax': [
    'null'
  ],
  'description': 'Value null',
  'examples': [
    'null'
  ],
  'seealso': ['true', 'false']
};

},{}],203:[function(require,module,exports){
module.exports = {
  'name': 'pi',
  'category': 'Constants',
  'syntax': [
    'pi'
  ],
  'description': 'The number pi is a mathematical constant that is the ratio of a circle\'s circumference to its diameter, and is approximately equal to 3.14159',
  'examples': [
    'pi',
    'sin(pi/2)'
  ],
  'seealso': ['tau']
};

},{}],204:[function(require,module,exports){
module.exports = {
  'name': 'phi',
  'category': 'Constants',
  'syntax': [
    'phi'
  ],
  'description': 'Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...',
  'examples': [
    'tau'
  ],
  'seealso': []
};

},{}],205:[function(require,module,exports){
module.exports = {
  'name': 'SQRT1_2',
  'category': 'Constants',
  'syntax': [
    'SQRT1_2'
  ],
  'description': 'Returns the square root of 1/2, approximately equal to 0.707',
  'examples': [
    'SQRT1_2',
    'sqrt(1/2)'
  ],
  'seealso': []
};

},{}],206:[function(require,module,exports){
module.exports = {
  'name': 'SQRT2',
  'category': 'Constants',
  'syntax': [
    'SQRT2'
  ],
  'description': 'Returns the square root of 2, approximately equal to 1.414',
  'examples': [
    'SQRT2',
    'sqrt(2)'
  ],
  'seealso': []
};

},{}],207:[function(require,module,exports){
module.exports = {
  'name': 'tau',
  'category': 'Constants',
  'syntax': [
    'tau'
  ],
  'description': 'Tau is the ratio constant of a circle\'s circumference to radius, equal to 2 * pi, approximately 6.2832.',
  'examples': [
    'tau',
    '2 * pi'
  ],
  'seealso': ['pi']
};

},{}],208:[function(require,module,exports){
module.exports = {
  'name': 'true',
  'category': 'Constants',
  'syntax': [
    'true'
  ],
  'description': 'Boolean value true',
  'examples': [
    'true'
  ],
  'seealso': ['false']
};

},{}],209:[function(require,module,exports){
module.exports = {
  'name': 'version',
  'category': 'Constants',
  'syntax': [
    'version'
  ],
  'description': 'A string with the version number of math.js',
  'examples': [
    'version'
  ],
  'seealso': []
};

},{}],210:[function(require,module,exports){
module.exports = {
  'name': 'abs',
  'category': 'Arithmetic',
  'syntax': [
    'abs(x)'
  ],
  'description': 'Compute the absolute value.',
  'examples': [
    'abs(3.5)',
    'abs(-4.2)'
  ],
  'seealso': ['sign']
};

},{}],211:[function(require,module,exports){
module.exports = {
  'name': 'add',
  'category': 'Operators',
  'syntax': [
    'x + y',
    'add(x, y)'
  ],
  'description': 'Add two values.',
  'examples': [
    'a = 2.1 + 3.6',
    'a - 3.6',
    '3 + 2i',
    '"hello" + " world"',
    '3 cm + 2 inch'
  ],
  'seealso': [
    'subtract'
  ]
};

},{}],212:[function(require,module,exports){
module.exports = {
  'name': 'ceil',
  'category': 'Arithmetic',
  'syntax': [
    'ceil(x)'
  ],
  'description':
      'Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.',
  'examples': [
    'ceil(3.2)',
    'ceil(3.8)',
    'ceil(-4.2)'
  ],
  'seealso': ['floor', 'fix', 'round']
};

},{}],213:[function(require,module,exports){
module.exports = {
  'name': 'cube',
  'category': 'Arithmetic',
  'syntax': [
    'cube(x)'
  ],
  'description': 'Compute the cube of a value. The cube of x is x * x * x.',
  'examples': [
    'cube(2)',
    '2^3',
    '2 * 2 * 2'
  ],
  'seealso': [
    'multiply',
    'square',
    'pow'
  ]
};

},{}],214:[function(require,module,exports){
module.exports = {
  'name': 'divide',
  'category': 'Operators',
  'syntax': [
    'x / y',
    'divide(x, y)'
  ],
  'description': 'Divide two values.',
  'examples': [
    'a = 2 / 3',
    'a * 3',
    '4.5 / 2',
    '3 + 4 / 2',
    '(3 + 4) / 2',
    '18 km / 4.5'
  ],
  'seealso': [
    'multiply'
  ]
};

},{}],215:[function(require,module,exports){
module.exports = {
  'name': 'dotDivide',
  'category': 'Operators',
  'syntax': [
    'x ./ y',
    'dotDivide(x, y)'
  ],
  'description': 'Divide two values element wise.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'b = [2, 1, 1; 3, 2, 5]',
    'a ./ b'
  ],
  'seealso': [
    'multiply',
    'dotMultiply',
    'divide'
  ]
};

},{}],216:[function(require,module,exports){
module.exports = {
  'name': 'dotMultiply',
  'category': 'Operators',
  'syntax': [
    'x .* y',
    'dotMultiply(x, y)'
  ],
  'description': 'Multiply two values element wise.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'b = [2, 1, 1; 3, 2, 5]',
    'a .* b'
  ],
  'seealso': [
    'multiply',
    'divide',
    'dotDivide'
  ]
};

},{}],217:[function(require,module,exports){
module.exports = {
  'name': 'dotpow',
  'category': 'Operators',
  'syntax': [
    'x .^ y',
    'dotpow(x, y)'
  ],
  'description':
      'Calculates the power of x to y element wise.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'a .^ 2'
  ],
  'seealso': [
    'pow'
  ]
};

},{}],218:[function(require,module,exports){
module.exports = {
  'name': 'exp',
  'category': 'Arithmetic',
  'syntax': [
    'exp(x)'
  ],
  'description': 'Calculate the exponent of a value.',
  'examples': [
    'exp(1.3)',
    'e ^ 1.3',
    'log(exp(1.3))',
    'x = 2.4',
    '(exp(i*x) == cos(x) + i*sin(x))   # Euler\'s formula'
  ],
  'seealso': [
    'pow',
    'log'
  ]
};

},{}],219:[function(require,module,exports){
module.exports = {
  'name': 'fix',
  'category': 'Arithmetic',
  'syntax': [
    'fix(x)'
  ],
  'description':
      'Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.',
  'examples': [
    'fix(3.2)',
    'fix(3.8)',
    'fix(-4.2)',
    'fix(-4.8)'
  ],
  'seealso': ['ceil', 'floor', 'round']
};

},{}],220:[function(require,module,exports){
module.exports = {
  'name': 'floor',
  'category': 'Arithmetic',
  'syntax': [
    'floor(x)'
  ],
  'description':
      'Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.',
  'examples': [
    'floor(3.2)',
    'floor(3.8)',
    'floor(-4.2)'
  ],
  'seealso': ['ceil', 'fix', 'round']
};

},{}],221:[function(require,module,exports){
module.exports = {
  'name': 'gcd',
  'category': 'Arithmetic',
  'syntax': [
    'gcd(a, b)',
    'gcd(a, b, c, ...)'
  ],
  'description': 'Compute the greatest common divisor.',
  'examples': [
    'gcd(8, 12)',
    'gcd(-4, 6)',
    'gcd(25, 15, -10)'
  ],
  'seealso': [ 'lcm', 'xgcd' ]
};

},{}],222:[function(require,module,exports){
module.exports = {
  'name': 'lcm',
  'category': 'Arithmetic',
  'syntax': [
    'lcm(x, y)'
  ],
  'description': 'Compute the least common multiple.',
  'examples': [
    'lcm(4, 6)',
    'lcm(6, 21)',
    'lcm(6, 21, 5)'
  ],
  'seealso': [ 'gcd' ]
};

},{}],223:[function(require,module,exports){
module.exports = {
  'name': 'log',
  'category': 'Arithmetic',
  'syntax': [
    'log(x)',
    'log(x, base)'
  ],
  'description': 'Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).',
  'examples': [
    'log(3.5)',
    'a = log(2.4)',
    'exp(a)',
    '10 ^ 4',
    'log(10000, 10)',
    'log(10000) / log(10)',
    'b = log(1024, 2)',
    '2 ^ b'
  ],
  'seealso': [
    'exp',
    'log10'
  ]
};
},{}],224:[function(require,module,exports){
module.exports = {
  'name': 'log10',
  'category': 'Arithmetic',
  'syntax': [
    'log10(x)'
  ],
  'description': 'Compute the 10-base logarithm of a value.',
  'examples': [
    'log10(0.00001)',
    'log10(10000)',
    '10 ^ 4',
    'log(10000) / log(10)',
    'log(10000, 10)'
  ],
  'seealso': [
    'exp',
    'log'
  ]
};

},{}],225:[function(require,module,exports){
module.exports = {
  'name': 'mod',
  'category': 'Operators',
  'syntax': [
    'x % y',
    'x mod y',
    'mod(x, y)'
  ],
  'description':
      'Calculates the modulus, the remainder of an integer division.',
  'examples': [
    '7 % 3',
    '11 % 2',
    '10 mod 4',
    'function isOdd(x) = x % 2',
    'isOdd(2)',
    'isOdd(3)'
  ],
  'seealso': ['divide']
};

},{}],226:[function(require,module,exports){
module.exports = {
  'name': 'multiply',
  'category': 'Operators',
  'syntax': [
    'x * y',
    'multiply(x, y)'
  ],
  'description': 'multiply two values.',
  'examples': [
    'a = 2.1 * 3.4',
    'a / 3.4',
    '2 * 3 + 4',
    '2 * (3 + 4)',
    '3 * 2.1 km'
  ],
  'seealso': [
    'divide'
  ]
};

},{}],227:[function(require,module,exports){
module.exports = {
  'name': 'norm',
  'category': 'Arithmetic',
  'syntax': [
    'norm(x)',
    'norm(x, p)'
  ],
  'description': 'Calculate the norm of a number, vector or matrix.',
  'examples': [
    'abs(-3.5)',
    'norm(-3.5)',
    'norm(3 - 4i))',
    'norm([1, 2, -3], Infinity)',
    'norm([1, 2, -3], -Infinity)',
    'norm([3, 4], 2)',
    'norm([[1, 2], [3, 4]], 1)',
    'norm([[1, 2], [3, 4]], \'inf\')',
    'norm([[1, 2], [3, 4]], \'fro\')'
  ]
};

},{}],228:[function(require,module,exports){
module.exports = {
  'name': 'pow',
  'category': 'Operators',
  'syntax': [
    'x ^ y',
    'pow(x, y)'
  ],
  'description':
      'Calculates the power of x to y, x^y.',
  'examples': [
    '2^3 = 8',
    '2*2*2',
    '1 + e ^ (pi * i)'
  ],
  'seealso': [ 'multiply' ]
};

},{}],229:[function(require,module,exports){
module.exports = {
  'name': 'round',
  'category': 'Arithmetic',
  'syntax': [
    'round(x)',
    'round(x, n)'
  ],
  'description':
      'round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.',
  'examples': [
    'round(3.2)',
    'round(3.8)',
    'round(-4.2)',
    'round(-4.8)',
    'round(pi, 3)',
    'round(123.45678, 2)'
  ],
  'seealso': ['ceil', 'floor', 'fix']
};

},{}],230:[function(require,module,exports){
module.exports = {
  'name': 'sign',
  'category': 'Arithmetic',
  'syntax': [
    'sign(x)'
  ],
  'description':
      'Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.',
  'examples': [
    'sign(3.5)',
    'sign(-4.2)',
    'sign(0)'
  ],
  'seealso': [
    'abs'
  ]
};

},{}],231:[function(require,module,exports){
module.exports = {
  'name': 'sqrt',
  'category': 'Arithmetic',
  'syntax': [
    'sqrt(x)'
  ],
  'description':
      'Compute the square root value. If x = y * y, then y is the square root of x.',
  'examples': [
    'sqrt(25)',
    '5 * 5',
    'sqrt(-1)'
  ],
  'seealso': [
    'square',
    'multiply'
  ]
};

},{}],232:[function(require,module,exports){
module.exports = {
  'name': 'square',
  'category': 'Arithmetic',
  'syntax': [
    'square(x)'
  ],
  'description':
      'Compute the square of a value. The square of x is x * x.',
  'examples': [
    'square(3)',
    'sqrt(9)',
    '3^2',
    '3 * 3'
  ],
  'seealso': [
    'multiply',
    'pow',
    'sqrt',
    'cube'
  ]
};

},{}],233:[function(require,module,exports){
module.exports = {
  'name': 'subtract',
  'category': 'Operators',
  'syntax': [
    'x - y',
    'subtract(x, y)'
  ],
  'description': 'subtract two values.',
  'examples': [
    'a = 5.3 - 2',
    'a + 2',
    '2/3 - 1/6',
    '2 * 3 - 3',
    '2.1 km - 500m'
  ],
  'seealso': [
    'add'
  ]
};

},{}],234:[function(require,module,exports){
module.exports = {
  'name': 'unaryMinus',
  'category': 'Operators',
  'syntax': [
    '-x',
    'unaryMinus(x)'
  ],
  'description':
      'Inverse the sign of a value. Converts booleans and strings to numbers.',
  'examples': [
    '-4.5',
    '-(-5.6)',
    '-"22"'
  ],
  'seealso': [
    'add', 'subtract', 'unaryPlus'
  ]
};

},{}],235:[function(require,module,exports){
module.exports = {
  'name': 'unaryPlus',
  'category': 'Operators',
  'syntax': [
    '+x',
    'unaryPlus(x)'
  ],
  'description':
      'Converts booleans and strings to numbers.',
  'examples': [
    '+true',
    '+"2"'
  ],
  'seealso': [
    'add', 'subtract', 'unaryMinus'
  ]
};

},{}],236:[function(require,module,exports){
module.exports = {
  'name': 'xgcd',
  'category': 'Arithmetic',
  'syntax': [
    'xgcd(a, b)'
  ],
  'description': 'Calculate the extended greatest common divisor for two values',
  'examples': [
    'xgcd(8, 12)',
    'gcd(8, 12)',
    'xgcd(36163, 21199)'
  ],
  'seealso': [ 'gcd', 'lcm' ]
};

},{}],237:[function(require,module,exports){
module.exports = {
  'name': 'compare',
  'category': 'Relational',
  'syntax': [
    'compare(x, y)'
  ],
  'description':
      'Compare two values. Returns 1 if x is larger than y, -1 if x is smaller than y, and 0 if x and y are equal.',
  'examples': [
    'compare(2, 3)',
    'compare(3, 2)',
    'compare(2, 2)',
    'compare(5cm, 40mm)',
    'compare(2, [1, 2, 3])'
  ],
  'seealso': [
    'equal', 'unequal', 'smaller', 'smallerEq', 'largerEq'
  ]
};

},{}],238:[function(require,module,exports){
module.exports = {
  'name': 'deepEqual',
  'category': 'Relational',
  'syntax': [
    'deepEqual(x, y)'
  ],
  'description':
      'Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.',
  'examples': [
    '[1,3,4] == [1,3,4]',
    '[1,3,4] == [1,3]'
  ],
  'seealso': [
    'equal', 'unequal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare'
  ]
};

},{}],239:[function(require,module,exports){
module.exports = {
  'name': 'equal',
  'category': 'Relational',
  'syntax': [
    'x == y',
    'equal(x, y)'
  ],
  'description':
      'Check equality of two values. Returns true if the values are equal, and false if not.',
  'examples': [
    '2+2 == 3',
    '2+2 == 4',
    'a = 3.2',
    'b = 6-2.8',
    'a == b',
    '50cm == 0.5m'
  ],
  'seealso': [
    'unequal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare', 'deepEqual'
  ]
};

},{}],240:[function(require,module,exports){
module.exports = {
  'name': 'larger',
  'category': 'Relational',
  'syntax': [
    'x > y',
    'larger(x, y)'
  ],
  'description':
      'Check if value x is larger than y. Returns true if x is larger than y, and false if not.',
  'examples': [
    '2 > 3',
    '5 > 2*2',
    'a = 3.3',
    'b = 6-2.8',
    '(a > b)',
    '(b < a)',
    '5 cm > 2 inch'
  ],
  'seealso': [
    'equal', 'unequal', 'smaller', 'smallerEq', 'largerEq', 'compare'
  ]
};

},{}],241:[function(require,module,exports){
module.exports = {
  'name': 'largerEq',
  'category': 'Relational',
  'syntax': [
    'x >= y',
    'largerEq(x, y)'
  ],
  'description':
      'Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.',
  'examples': [
    '2 > 1+1',
    '2 >= 1+1',
    'a = 3.2',
    'b = 6-2.8',
    '(a > b)'
  ],
  'seealso': [
    'equal', 'unequal', 'smallerEq', 'smaller', 'largerEq', 'compare'
  ]
};

},{}],242:[function(require,module,exports){
module.exports = {
  'name': 'smaller',
  'category': 'Relational',
  'syntax': [
    'x < y',
    'smaller(x, y)'
  ],
  'description':
      'Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.',
  'examples': [
    '2 < 3',
    '5 < 2*2',
    'a = 3.3',
    'b = 6-2.8',
    '(a < b)',
    '5 cm < 2 inch'
  ],
  'seealso': [
    'equal', 'unequal', 'larger', 'smallerEq', 'largerEq', 'compare'
  ]
};

},{}],243:[function(require,module,exports){
module.exports = {
  'name': 'smallerEq',
  'category': 'Relational',
  'syntax': [
    'x <= y',
    'smallerEq(x, y)'
  ],
  'description':
      'Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.',
  'examples': [
    '2 < 1+1',
    '2 <= 1+1',
    'a = 3.2',
    'b = 6-2.8',
    '(a < b)'
  ],
  'seealso': [
    'equal', 'unequal', 'larger', 'smaller', 'largerEq', 'compare'
  ]
};

},{}],244:[function(require,module,exports){
module.exports = {
  'name': 'unequal',
  'category': 'Relational',
  'syntax': [
    'x != y',
    'unequal(x, y)'
  ],
  'description':
      'Check unequality of two values. Returns true if the values are unequal, and false if they are equal.',
  'examples': [
    '2+2 != 3',
    '2+2 != 4',
    'a = 3.2',
    'b = 6-2.8',
    'a != b',
    '50cm != 0.5m',
    '5 cm != 2 inch'
  ],
  'seealso': [
    'equal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare', 'deepEqual'
  ]
};

},{}],245:[function(require,module,exports){
module.exports = {
  'name': 'arg',
  'category': 'Complex',
  'syntax': [
    'arg(x)'
  ],
  'description':
      'Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).',
  'examples': [
    'arg(2 + 2i)',
    'atan2(3, 2)',
    'arg(2 + 3i)'
  ],
  'seealso': [
    're',
    'im',
    'conj',
    'abs'
  ]
};

},{}],246:[function(require,module,exports){
module.exports = {
  'name': 'conj',
  'category': 'Complex',
  'syntax': [
    'conj(x)'
  ],
  'description':
      'Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.',
  'examples': [
    'conj(2 + 3i)',
    'conj(2 - 3i)',
    'conj(-5.2i)'
  ],
  'seealso': [
    're',
    'im',
    'abs',
    'arg'
  ]
};

},{}],247:[function(require,module,exports){
module.exports = {
  'name': 're',
  'category': 'Complex',
  'syntax': [
    're(x)'
  ],
  'description': 'Get the real part of a complex number.',
  'examples': [
    're(2 + 3i)',
    'im(2 + 3i)',
    're(-5.2i)',
    're(2.4)'
  ],
  'seealso': [
    'im',
    'conj',
    'abs',
    'arg'
  ]
};

},{}],248:[function(require,module,exports){
module.exports = {
  'name': 'im',
  'category': 'Complex',
  'syntax': [
    'im(x)'
  ],
  'description': 'Get the imaginary part of a complex number.',
  'examples': [
    'im(2 + 3i)',
    're(2 + 3i)',
    'im(-5.2i)',
    'im(2.4)'
  ],
  'seealso': [
    're',
    'conj',
    'abs',
    'arg'
  ]
};

},{}],249:[function(require,module,exports){
module.exports = {
  'name': 'bignumber',
  'category': 'Type',
  'syntax': [
    'bignumber(x)'
  ],
  'description':
      'Create a big number from a number or string.',
  'examples': [
    '0.1 + 0.2',
    'bignumber(0.1) + bignumber(0.2)',
    'bignumber("7.2")',
    'bignumber("7.2e500")',
    'bignumber([0.1, 0.2, 0.3])'
  ],
  'seealso': [
    'boolean', 'complex', 'index', 'matrix', 'string', 'unit'
  ]
};

},{}],250:[function(require,module,exports){
module.exports = {
  'name': 'boolean',
  'category': 'Type',
  'syntax': [
    'x',
    'boolean(x)'
  ],
  'description':
      'Convert a string or number into a boolean.',
  'examples': [
    'boolean(0)',
    'boolean(1)',
    'boolean(3)',
    'boolean("true")',
    'boolean("false")',
    'boolean([1, 0, 1, 1])'
  ],
  'seealso': [
    'bignumber', 'complex', 'index', 'matrix', 'number', 'string', 'unit'
  ]
};

},{}],251:[function(require,module,exports){
module.exports = {
  'name': 'complex',
  'category': 'Type',
  'syntax': [
    'complex()',
    'complex(re, im)',
    'complex(string)'
  ],
  'description':
      'Create a complex number.',
  'examples': [
    'complex()',
    'complex(2, 3)',
    'complex("7 - 2i")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'index', 'matrix', 'number', 'string', 'unit'
  ]
};

},{}],252:[function(require,module,exports){
module.exports = {
  'name': 'index',
  'category': 'Type',
  'syntax': [
    '[start]',
    '[start:end]',
    '[start:step:end]',
    '[start1, start 2, ...]',
    '[start1:end1, start2:end2, ...]',
    '[start1:step1:end1, start2:step2:end2, ...]'
  ],
  'description':
      'Create an index to get or replace a subset of a matrix',
  'examples': [
    '[]',
    '[1, 2, 3]',
    'A = [1, 2, 3; 4, 5, 6]',
    'A[1, :]',
    'A[1, 2] = 50',
    'A[0:2, 0:2] = ones(2, 2)'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'matrix,', 'number', 'range', 'string', 'unit'
  ]
};

},{}],253:[function(require,module,exports){
module.exports = {
  'name': 'matrix',
  'category': 'Type',
  'syntax': [
    '[]',
    '[a1, b1, ...; a2, b2, ...]',
    'matrix()',
    'matrix([...])'
  ],
  'description':
      'Create a matrix.',
  'examples': [
    '[]',
    '[1, 2, 3]',
    '[1, 2, 3; 4, 5, 6]',
    'matrix()',
    'matrix([3, 4])'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'number', 'string', 'unit'
  ]
};

},{}],254:[function(require,module,exports){
module.exports = {
  'name': 'number',
  'category': 'Type',
  'syntax': [
    'x',
    'number(x)'
  ],
  'description':
      'Create a number or convert a string or boolean into a number.',
  'examples': [
    '2',
    '2e3',
    '4.05',
    'number(2)',
    'number("7.2")',
    'number(true)',
    'number([true, false, true, true])',
    'number("52cm", "m")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'matrix', 'string', 'unit'
  ]
};

},{}],255:[function(require,module,exports){
module.exports = {
  'name': 'string',
  'category': 'Type',
  'syntax': [
    '"text"',
    'string(x)'
  ],
  'description':
      'Create a string or convert a value to a string',
  'examples': [
    '"Hello World!"',
    'string(4.2)',
    'string(3 + 2i)'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'matrix', 'number', 'unit'
  ]
};

},{}],256:[function(require,module,exports){
module.exports = {
  'name': 'unit',
  'category': 'Type',
  'syntax': [
    'value unit',
    'unit(value, unit)',
    'unit(string)'
  ],
  'description':
      'Create a unit.',
  'examples': [
    '5.5 mm',
    '3 inch',
    'unit(7.1, "kilogram")',
    'unit("23 deg")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'matrix', 'number', 'string'
  ]
};

},{}],257:[function(require,module,exports){
module.exports = {
  'name': 'eval',
  'category': 'Expression',
  'syntax': [
    'eval(expression)',
    'eval([expr1, expr2, expr3, ...])'
  ],
  'description': 'Evaluate an expression or an array with expressions.',
  'examples': [
    'eval("2 + 3")',
    'eval("sqrt(" + 4 + ")")'
  ],
  'seealso': []
};

},{}],258:[function(require,module,exports){
module.exports = {
  'name': 'help',
  'category': 'Expression',
  'syntax': [
    'help(object)',
    'help(string)'
  ],
  'description': 'Display documentation on a function or data type.',
  'examples': [
    'help(sqrt)',
    'help("complex")'
  ],
  'seealso': []
};

},{}],259:[function(require,module,exports){
module.exports = {
  'name': 'concat',
  'category': 'Matrix',
  'syntax': [
    'concat(A, B, C, ...)',
    'concat(A, B, C, ..., dim)'
  ],
  'description': 'Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.',
  'examples': [
    'A = [1, 2; 5, 6]',
    'B = [3, 4; 7, 8]',
    'concat(A, B)',
    'concat(A, B, 1)',
    'concat(A, B, 2)'
  ],
  'seealso': [
    'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'transpose', 'zeros'
  ]
};

},{}],260:[function(require,module,exports){
module.exports = {
  'name': 'det',
  'category': 'Matrix',
  'syntax': [
    'det(x)'
  ],
  'description': 'Calculate the determinant of a matrix',
  'examples': [
    'det([1, 2; 3, 4])',
    'det([-2, 2, 3; -1, 1, 3; 2, 0, -1])'
  ],
  'seealso': [
    'concat', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'transpose', 'zeros'
  ]
};

},{}],261:[function(require,module,exports){
module.exports = {
  'name': 'diag',
  'category': 'Matrix',
  'syntax': [
    'diag(x)',
    'diag(x, k)'
  ],
  'description': 'Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.',
  'examples': [
    'diag(1:3)',
    'diag(1:3, 1)',
    'a = [1, 2, 3; 4, 5, 6; 7, 8, 9]',
    'diag(a)'
  ],
  'seealso': [
    'concat', 'det', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'transpose', 'zeros'
  ]
};

},{}],262:[function(require,module,exports){
module.exports = {
  'name': 'eye',
  'category': 'Matrix',
  'syntax': [
    'eye(n)',
    'eye(m, n)',
    'eye([m, n])',
    'eye'
  ],
  'description': 'Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.',
  'examples': [
    'eye(3)',
    'eye(3, 5)',
    'a = [1, 2, 3; 4, 5, 6]',
    'eye(size(a))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'transpose', 'zeros'
  ]
};

},{}],263:[function(require,module,exports){
module.exports = {
  'name': 'flatten',
  'category': 'Matrix',
  'syntax': [
    'flatten(x)'
  ],
  'description': 'Flatten a multi dimensional matrix into a single dimensional matrix.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'size(a)',
    'b = flatten(a)',
    'size(b)'
  ],
  'seealso': [
    'concat', 'resize', 'size', 'squeeze'
  ]
};

},{}],264:[function(require,module,exports){
module.exports = {
  'name': 'inv',
  'category': 'Matrix',
  'syntax': [
    'inv(x)'
  ],
  'description': 'Calculate the inverse of a matrix',
  'examples': [
    'inv([1, 2; 3, 4])',
    'inv(4)',
    '1 / 4'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'ones', 'range', 'size', 'squeeze', 'subset', 'transpose', 'zeros'
  ]
};

},{}],265:[function(require,module,exports){
module.exports = {
  'name': 'ones',
  'category': 'Matrix',
  'syntax': [
    'ones(m)',
    'ones(m, n)',
    'ones(m, n, p, ...)',
    'ones([m])',
    'ones([m, n])',
    'ones([m, n, p, ...])',
    'ones'
  ],
  'description': 'Create a matrix containing ones.',
  'examples': [
    'ones(3)',
    'ones(3, 5)',
    'ones([2,3]) * 4.5',
    'a = [1, 2, 3; 4, 5, 6]',
    'ones(size(a))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'range', 'size', 'squeeze', 'subset', 'transpose', 'zeros'
  ]
};

},{}],266:[function(require,module,exports){
module.exports = {
  'name': 'range',
  'category': 'Type',
  'syntax': [
    'start:end',
    'start:step:end',
    'range(start, end)',
    'range(start, end, step)',
    'range(string)'
  ],
  'description':
      'Create a range. Lower bound of the range is included, upper bound is excluded.',
  'examples': [
    '1:5',
    '3:-1:-3',
    'range(3, 7)',
    'range(0, 12, 2)',
    'range("4:10")',
    'a = [1, 2, 3, 4; 5, 6, 7, 8]',
    'a[1:2, 1:2]'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'size', 'squeeze', 'subset', 'transpose', 'zeros'
  ]
};

},{}],267:[function(require,module,exports){
module.exports = {
  'name': 'resize',
  'category': 'Matrix',
  'syntax': [
    'resize(x, size)',
    'resize(x, size, defaultValue)'
  ],
  'description': 'Resize a matrix.',
  'examples': [
    'resize([1,2,3,4,5], [3])',
    'resize([1,2,3], [5])',
    'resize([1,2,3], [5], -1)',
    'resize(2, [2, 3])',
    'resize("hello", [8], "!")'
  ],
  'seealso': [
    'size', 'subset', 'squeeze'
  ]
};

},{}],268:[function(require,module,exports){
module.exports = {
  'name': 'size',
  'category': 'Matrix',
  'syntax': [
    'size(x)'
  ],
  'description': 'Calculate the size of a matrix.',
  'examples': [
    'size(2.3)',
    'size("hello world")',
    'a = [1, 2; 3, 4; 5, 6]',
    'size(a)',
    'size(1:6)'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'squeeze', 'subset', 'transpose', 'zeros'
  ]
};

},{}],269:[function(require,module,exports){
module.exports = {
  'name': 'squeeze',
  'category': 'Matrix',
  'syntax': [
    'squeeze(x)'
  ],
  'description': 'Remove inner and outer singleton dimensions from a matrix.',
  'examples': [
    'a = zeros(3,2,1)',
    'size(squeeze(a))',
    'b = zeros(1,1,3)',
    'size(squeeze(b))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'subset', 'transpose', 'zeros'
  ]
};

},{}],270:[function(require,module,exports){
module.exports = {
  'name': 'subset',
  'category': 'Matrix',
  'syntax': [
    'value(index)',
    'value(index) = replacement',
    'subset(value, [index])',
    'subset(value, [index], replacement)'
  ],
  'description': 'Get or set a subset of a matrix or string. ' +
      'Indexes are one-based. ' +
      'Both the ranges lower-bound and upper-bound are included.',
  'examples': [
    'd = [1, 2; 3, 4]',
    'e = []',
    'e[1, 1:2] = [5, 6]',
    'e[2, :] = [7, 8]',
    'f = d * e',
    'f[2, 1]',
    'f[:, 1]'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'transpose', 'zeros'
  ]
};

},{}],271:[function(require,module,exports){
module.exports = {
  'name': 'transpose',
  'category': 'Matrix',
  'syntax': [
    'x\'',
    'transpose(x)'
  ],
  'description': 'Transpose a matrix',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'a\'',
    'transpose(a)'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'zeros'
  ]
};

},{}],272:[function(require,module,exports){
module.exports = {
  'name': 'zeros',
  'category': 'Matrix',
  'syntax': [
    'zeros(m)',
    'zeros(m, n)',
    'zeros(m, n, p, ...)',
    'zeros([m])',
    'zeros([m, n])',
    'zeros([m, n, p, ...])',
    'zeros'
  ],
  'description': 'Create a matrix containing zeros.',
  'examples': [
    'zeros(3)',
    'zeros(3, 5)',
    'a = [1, 2, 3; 4, 5, 6]',
    'zeros(size(a))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'transpose'
  ]
};

},{}],273:[function(require,module,exports){
module.exports = {
  'name': 'combinations',
  'category': 'Probability',
  'syntax': [
    'combinations(n, k)'
  ],
  'description': 'Compute the number of combinations of n items taken k at a time',
  'examples': [
    'combinations(7, 5)'
  ],
  'seealso': ['permutations', 'factorial']
};

},{}],274:[function(require,module,exports){
module.exports = {
  'name': 'factorial',
  'category': 'Probability',
  'syntax': [
    'n!',
    'factorial(n)'
  ],
  'description': 'Compute the factorial of a value',
  'examples': [
    '5!',
    '5*4*3*2*1',
    '3!'
  ],
  'seealso': ['combinations', 'permutations']
};

},{}],275:[function(require,module,exports){
module.exports = {
  'name': 'permutations',
  'category': 'Probability',
  'syntax': [
    'permutations(n)',
    'permutations(n, k)'
  ],
  'description': 'Compute the number of permutations of n items taken k at a time',
  'examples': [
    'permutations(5)',
    'permutations(5, 3)'
  ],
  'seealso': ['combinations', 'factorial']
};

},{}],276:[function(require,module,exports){
module.exports = {
  'name': 'pickRandom',
  'category': 'Probability',
  'syntax': [
    'pickRandom(array)'
  ],
  'description':
      'Pick a random entry from a given array.',
  'examples': [
    'pickRandom(0:10)',
    'pickRandom([1, 3, 1, 6])'
  ],
  'seealso': ['random', 'randomInt']
};

},{}],277:[function(require,module,exports){
module.exports = {
  'name': 'random',
  'category': 'Probability',
  'syntax': [
    'random()',
    'random(max)',
    'random(min, max)',
    'random(size)',
    'random(size, max)',
    'random(size, min, max)'
  ],
  'description':
      'Return a random number.',
  'examples': [
    'random()',
    'random(10, 20)',
    'random([2, 3])'
  ],
  'seealso': ['pickRandom', 'randomInt']
};

},{}],278:[function(require,module,exports){
module.exports = {
  'name': 'randInt',
  'category': 'Probability',
  'syntax': [
    'randInt()',
    'randInt(max)',
    'randInt(min, max)',
    'randInt(size)',
    'randInt(size, max)',
    'randInt(size, min, max)'
  ],
  'description':
      'Return a random integer number',
  'examples': [
    'randInt()',
    'randInt(10, 20)',
    'randInt([2, 3], 10)'
  ],
  'seealso': ['pickRandom', 'random']
};
},{}],279:[function(require,module,exports){
module.exports = {
  'name': 'max',
  'category': 'Statistics',
  'syntax': [
    'max(a, b, c, ...)',
    'max(A)',
    'max(A, dim)'
  ],
  'description': 'Compute the maximum value of a list of values.',
  'examples': [
    'max(2, 3, 4, 1)',
    'max([2, 3, 4, 1])',
    'max([2, 5; 4, 3], 0)',
    'max([2, 5; 4, 3], 1)',
    'max(2.7, 7.1, -4.5, 2.0, 4.1)',
    'min(2.7, 7.1, -4.5, 2.0, 4.1)'
  ],
  'seealso': [
    'mean',
    'median',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],280:[function(require,module,exports){
module.exports = {
  'name': 'mean',
  'category': 'Statistics',
  'syntax': [
    'mean(a, b, c, ...)',
    'mean(A)',
    'mean(A, dim)'
  ],
  'description': 'Compute the arithmetic mean of a list of values.',
  'examples': [
    'mean(2, 3, 4, 1)',
    'mean([2, 3, 4, 1])',
    'mean([2, 5; 4, 3], 0)',
    'mean([2, 5; 4, 3], 1)',
    'mean([1.0, 2.7, 3.2, 4.0])'
  ],
  'seealso': [
    'max',
    'median',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],281:[function(require,module,exports){
module.exports = {
  'name': 'median',
  'category': 'Statistics',
  'syntax': [
    'median(a, b, c, ...)',
    'median(A)'
  ],
  'description': 'Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.',
  'examples': [
    'median(5, 2, 7)',
    'median([3, -1, 5, 7])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],282:[function(require,module,exports){
module.exports = {
  'name': 'min',
  'category': 'Statistics',
  'syntax': [
    'min(a, b, c, ...)',
    'min(A)',
    'min(A, dim)'
  ],
  'description': 'Compute the minimum value of a list of values.',
  'examples': [
    'min(2, 3, 4, 1)',
    'min([2, 3, 4, 1])',
    'min([2, 5; 4, 3], 0)',
    'min([2, 5; 4, 3], 1)',
    'min(2.7, 7.1, -4.5, 2.0, 4.1)',
    'max(2.7, 7.1, -4.5, 2.0, 4.1)'
  ],
  'seealso': [
    'max',
    'mean',
    'median',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],283:[function(require,module,exports){
module.exports = {
  'name': 'prod',
  'category': 'Statistics',
  'syntax': [
    'prod(a, b, c, ...)',
    'prod(A)'
  ],
  'description': 'Compute the product of all values.',
  'examples': [
    'prod(2, 3, 4)',
    'prod([2, 3, 4])',
    'prod([2, 5; 4, 3])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'median',
    'min',
    'std',
    'sum',
    'var'
  ]
};

},{}],284:[function(require,module,exports){
module.exports = {
  'name': 'std',
  'category': 'Statistics',
  'syntax': [
    'std(a, b, c, ...)',
    'std(A)',
    'std(A, normalization)'
  ],
  'description': 'Compute the standard deviation of all values, defined as std(A) = sqrt(var(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  'examples': [
    'std(2, 4, 6)',
    'std([2, 4, 6, 8])',
    'std([2, 4, 6, 8], "uncorrected")',
    'std([2, 4, 6, 8], "biased")',
    'std([1, 2, 3; 4, 5, 6])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'median',
    'min',
    'prod',
    'sum',
    'var'
  ]
};

},{}],285:[function(require,module,exports){
module.exports = {
  'name': 'sum',
  'category': 'Statistics',
  'syntax': [
    'sum(a, b, c, ...)',
    'sum(A)'
  ],
  'description': 'Compute the sum of all values.',
  'examples': [
    'sum(2, 3, 4, 1)',
    'sum([2, 3, 4, 1])',
    'sum([2, 5; 4, 3])'
  ],
  'seealso': [
    'max',
    'mean',
    'median',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],286:[function(require,module,exports){
module.exports = {
  'name': 'var',
  'category': 'Statistics',
  'syntax': [
    'var(a, b, c, ...)',
    'var(A)',
    'var(A, normalization)'
  ],
  'description': 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  'examples': [
    'var(2, 4, 6)',
    'var([2, 4, 6, 8])',
    'var([2, 4, 6, 8], "uncorrected")',
    'var([2, 4, 6, 8], "biased")',
    'var([1, 2, 3; 4, 5, 6])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'median',
    'min',
    'prod',
    'std',
    'sum'
  ]
};

},{}],287:[function(require,module,exports){
module.exports = {
  'name': 'acos',
  'category': 'Trigonometry',
  'syntax': [
    'acos(x)'
  ],
  'description': 'Compute the inverse cosine of a value in radians.',
  'examples': [
    'acos(0.5)',
    'acos(cos(2.3))'
  ],
  'seealso': [
    'cos',
    'atan',
    'asin'
  ]
};

},{}],288:[function(require,module,exports){
module.exports = {
  'name': 'asin',
  'category': 'Trigonometry',
  'syntax': [
    'asin(x)'
  ],
  'description': 'Compute the inverse sine of a value in radians.',
  'examples': [
    'asin(0.5)',
    'asin(sin(2.3))'
  ],
  'seealso': [
    'sin',
    'acos',
    'atan'
  ]
};

},{}],289:[function(require,module,exports){
module.exports = {
  'name': 'atan',
  'category': 'Trigonometry',
  'syntax': [
    'atan(x)'
  ],
  'description': 'Compute the inverse tangent of a value in radians.',
  'examples': [
    'atan(0.5)',
    'atan(tan(2.3))'
  ],
  'seealso': [
    'tan',
    'acos',
    'asin'
  ]
};

},{}],290:[function(require,module,exports){
module.exports = {
  'name': 'atan2',
  'category': 'Trigonometry',
  'syntax': [
    'atan2(y, x)'
  ],
  'description':
      'Computes the principal value of the arc tangent of y/x in radians.',
  'examples': [
    'atan2(2, 2) / pi',
    'angle = 60 deg in rad',
    'x = cos(angle)',
    'y = sin(angle)',
    'atan2(y, x)'
  ],
  'seealso': [
    'sin',
    'cos',
    'tan'
  ]
};

},{}],291:[function(require,module,exports){
module.exports = {
  'name': 'cos',
  'category': 'Trigonometry',
  'syntax': [
    'cos(x)'
  ],
  'description': 'Compute the cosine of x in radians.',
  'examples': [
    'cos(2)',
    'cos(pi / 4) ^ 2',
    'cos(180 deg)',
    'cos(60 deg)',
    'sin(0.2)^2 + cos(0.2)^2'
  ],
  'seealso': [
    'acos',
    'sin',
    'tan'
  ]
};

},{}],292:[function(require,module,exports){
module.exports = {
  'name': 'cosh',
  'category': 'Trigonometry',
  'syntax': [
    'cosh(x)'
  ],
  'description': 'Compute the hyperbolic cosine of x in radians.',
  'examples': [
    'cosh(0.5)'
  ],
  'seealso': [
    'sinh',
    'tanh',
    'coth'
  ]
};

},{}],293:[function(require,module,exports){
module.exports = {
  'name': 'cot',
  'category': 'Trigonometry',
  'syntax': [
    'cot(x)'
  ],
  'description': 'Compute the cotangent of x in radians. Defined as 1/tan(x)',
  'examples': [
    'cot(2)',
    '1 / tan(2)'
  ],
  'seealso': [
    'sec',
    'csc',
    'tan'
  ]
};

},{}],294:[function(require,module,exports){
module.exports = {
  'name': 'coth',
  'category': 'Trigonometry',
  'syntax': [
    'coth(x)'
  ],
  'description': 'Compute the hyperbolic cotangent of x in radians.',
  'examples': [
    'coth(2)',
    '1 / tanh(2)'
  ],
  'seealso': [
    'sech',
    'csch',
    'tanh'
  ]
};

},{}],295:[function(require,module,exports){
module.exports = {
  'name': 'csc',
  'category': 'Trigonometry',
  'syntax': [
    'csc(x)'
  ],
  'description': 'Compute the cosecant of x in radians. Defined as 1/sin(x)',
  'examples': [
    'csc(2)',
    '1 / sin(2)'
  ],
  'seealso': [
    'sec',
    'cot',
    'sin'
  ]
};

},{}],296:[function(require,module,exports){
module.exports = {
  'name': 'csch',
  'category': 'Trigonometry',
  'syntax': [
    'csch(x)'
  ],
  'description': 'Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)',
  'examples': [
    'csch(2)',
    '1 / sinh(2)'
  ],
  'seealso': [
    'sech',
    'coth',
    'sinh'
  ]
};

},{}],297:[function(require,module,exports){
module.exports = {
  'name': 'sec',
  'category': 'Trigonometry',
  'syntax': [
    'sec(x)'
  ],
  'description': 'Compute the secant of x in radians. Defined as 1/cos(x)',
  'examples': [
    'sec(2)',
    '1 / cos(2)'
  ],
  'seealso': [
    'cot',
    'csc',
    'cos'
  ]
};

},{}],298:[function(require,module,exports){
module.exports = {
  'name': 'sech',
  'category': 'Trigonometry',
  'syntax': [
    'sech(x)'
  ],
  'description': 'Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)',
  'examples': [
    'sech(2)',
    '1 / cosh(2)'
  ],
  'seealso': [
    'coth',
    'csch',
    'cosh'
  ]
};

},{}],299:[function(require,module,exports){
module.exports = {
  'name': 'sin',
  'category': 'Trigonometry',
  'syntax': [
    'sin(x)'
  ],
  'description': 'Compute the sine of x in radians.',
  'examples': [
    'sin(2)',
    'sin(pi / 4) ^ 2',
    'sin(90 deg)',
    'sin(30 deg)',
    'sin(0.2)^2 + cos(0.2)^2'
  ],
  'seealso': [
    'asin',
    'cos',
    'tan'
  ]
};

},{}],300:[function(require,module,exports){
module.exports = {
  'name': 'sinh',
  'category': 'Trigonometry',
  'syntax': [
    'sinh(x)'
  ],
  'description': 'Compute the hyperbolic sine of x in radians.',
  'examples': [
    'sinh(0.5)'
  ],
  'seealso': [
    'cosh',
    'tanh'
  ]
};

},{}],301:[function(require,module,exports){
module.exports = {
  'name': 'tan',
  'category': 'Trigonometry',
  'syntax': [
    'tan(x)'
  ],
  'description': 'Compute the tangent of x in radians.',
  'examples': [
    'tan(0.5)',
    'sin(0.5) / cos(0.5)',
    'tan(pi / 4)',
    'tan(45 deg)'
  ],
  'seealso': [
    'atan',
    'sin',
    'cos'
  ]
};

},{}],302:[function(require,module,exports){
module.exports = {
  'name': 'tanh',
  'category': 'Trigonometry',
  'syntax': [
    'tanh(x)'
  ],
  'description': 'Compute the hyperbolic tangent of x in radians.',
  'examples': [
    'tanh(0.5)',
    'sinh(0.5) / cosh(0.5)'
  ],
  'seealso': [
    'sinh',
    'cosh'
  ]
};

},{}],303:[function(require,module,exports){
module.exports = {
  'name': 'to',
  'category': 'Units',
  'syntax': [
    'x to unit',
    'to(x, unit)'
  ],
  'description': 'Change the unit of a value.',
  'examples': [
    '5 inch to cm',
    '3.2kg to g',
    '16 bytes in bits'
  ],
  'seealso': []
};

},{}],304:[function(require,module,exports){
module.exports = {
  'name': 'clone',
  'category': 'Utils',
  'syntax': [
    'clone(x)'
  ],
  'description': 'Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices',
  'examples': [
    'clone(3.5)',
    'clone(2 - 4i)',
    'clone(45 deg)',
    'clone([1, 2; 3, 4])',
    'clone("hello world")'
  ],
  'seealso': []
};

},{}],305:[function(require,module,exports){
module.exports = {
  'name': 'map',
  'category': 'Utils',
  'syntax': [
    'map(x, callback)'
  ],
  'description': 'Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.',
  'examples': [
    'map([1, 2, 3], function(val) { return value * value })'
  ],
  'seealso': ['filter', 'forEach']
};

},{}],306:[function(require,module,exports){
module.exports = {
  'name': 'filter',
  'category': 'Utils',
  'syntax': [
    'filter(x, test)'
  ],
  'description': 'Filter items in a matrix.',
  'examples': [
    'isPositive(x) = x > 0',
    'filter([6, -2, -1, 4, 3], isPositive)',
    'filter([6, -2, 0, 1, 0], x != 0)'
  ],
  'seealso': ['sort', 'map', 'forEach']
};

},{}],307:[function(require,module,exports){
module.exports = {
  'name': 'forEach',
  'category': 'Utils',
  'syntax': [
    'forEach(x, callback)'
  ],
  'description': 'Iterates over all elements of a matrix/array, and executes the given callback function.',
  'examples': [
    'forEach([1, 2, 3], function(val) { console.log(val) })'
  ],
  'seealso': ['map', 'sort', 'filter']
};

},{}],308:[function(require,module,exports){
module.exports = {
  'name': 'format',
  'category': 'Utils',
  'syntax': [
    'format(value)',
    'format(value, precision)'
  ],
  'description': 'Format a value of any type as string.',
  'examples': [
    'format(2.3)',
    'format(3 - 4i)',
    'format([])',
    'format(pi, 3)'
  ],
  'seealso': ['print']
};

},{}],309:[function(require,module,exports){
module.exports = {
  'name': 'import',
  'category': 'Utils',
  'syntax': [
    'import(string)'
  ],
  'description': 'Import functions from a file.',
  'examples': [
    'import("numbers")',
    'import("./mylib.js")'
  ],
  'seealso': []
};

},{}],310:[function(require,module,exports){
module.exports = {
  'name': 'sort',
  'category': 'Utils',
  'syntax': [
    'sort(x)',
    'sort(x, compare)'
  ],
  'description': 'Sort the items in a matrix. Compare can be a string "asc" or "desc", or a custom sort function.',
  'examples': [
    'sort([5, 10, 1])',
    'sort(["C", "B", "A", "D"])',
    'sortByLength(a, b) = size(a)[1] - size(b)[1]',
    'sort(["Langdon", "Tom", "Sara"], sortByLength)'
  ],
  'seealso': ['map', 'filter', 'forEach']
};

},{}],311:[function(require,module,exports){
module.exports = {
  'name': 'typeof',
  'category': 'Utils',
  'syntax': [
    'typeof(x)'
  ],
  'description': 'Get the type of a variable.',
  'examples': [
    'typeof(3.5)',
    'typeof(2 - 4i)',
    'typeof(45 deg)',
    'typeof("hello world")'
  ],
  'seealso': []
};

},{}],313:[function(require,module,exports){
'use strict';

/**
 * Determine the type of a variable
 *
 *     type(x)
 *
 * @param {*} x
 * @return {String} type  Lower case type, for example 'number', 'string',
 *                        'array', 'date'.
 */
exports.type = function(x) {
  var type = typeof x;

  if (type === 'object') {
    if (x === null)           return 'null';
    if (x instanceof Boolean) return 'boolean';
    if (x instanceof Number)  return 'number';
    if (x instanceof String)  return 'string';
    if (Array.isArray(x))     return 'array';
    if (x instanceof Date)    return 'date';
    if (x instanceof RegExp)  return 'regexp';
  }

  return type;
};

},{}],314:[function(require,module,exports){
'use strict';

/**
 * Test whether value is a Boolean
 * @param {*} value
 * @return {Boolean} isBoolean
 */
exports.isBoolean = function(value) {
  return (value instanceof Boolean) || (typeof value == 'boolean');
};

},{}],44:[function(require,module,exports){
'use strict';

var number = require('./number'),
    string = require('./string'),
    object = require('./object'),
    types = require('./types'),

    DimensionError = require('../error/DimensionError'),
    IndexError = require('../error/IndexError'),

    isArray = Array.isArray;

/**
 * Calculate the size of a multi dimensional array.
 * @param {Array} x
 * @Return {Number[]} size
 * @private
 */
function _size(x) {
  var size = [];

  while (isArray(x)) {
    size.push(x.length);
    x = x[0];
  }

  return size;
}

/**
 * Calculate the size of a multi dimensional array.
 * All elements in the array are checked for matching dimensions using the
 * method validate
 * @param {Array} x
 * @Return {Number[]} size
 * @throws RangeError
 */
exports.size = function(x) {
  // calculate the size
  var s = _size(x);

  // verify the size
  exports.validate(x, s);
  // TODO: don't validate here? only in a Matrix constructor?

  return s;
};

/**
 * Recursively validate whether each element in a multi dimensional array
 * has a size corresponding to the provided size array.
 * @param {Array} array    Array to be validated
 * @param {Number[]} size  Array with the size of each dimension
 * @param {Number} dim   Current dimension
 * @throws DimensionError
 * @private
 */
function _validate(array, size, dim) {
  var i;
  var len = array.length;

  if (len != size[dim]) {
    throw new DimensionError(len, size[dim]);
  }

  if (dim < size.length - 1) {
    // recursively validate each child array
    var dimNext = dim + 1;
    for (i = 0; i < len; i++) {
      var child = array[i];
      if (!isArray(child)) {
        throw new DimensionError(size.length - 1, size.length, '<');
      }
      _validate(array[i], size, dimNext);
    }
  }
  else {
    // last dimension. none of the childs may be an array
    for (i = 0; i < len; i++) {
      if (isArray(array[i])) {
        throw new DimensionError(size.length + 1, size.length, '>');
      }
    }
  }
}

/**
 * Validate whether each element in a multi dimensional array has
 * a size corresponding to the provided size array.
 * @param {Array} array    Array to be validated
 * @param {Number[]} size  Array with the size of each dimension
 * @throws DimensionError
 */
exports.validate = function(array, size) {
  var isScalar = (size.length == 0);
  if (isScalar) {
    // scalar
    if (isArray(array)) {
      throw new DimensionError(array.length, 0);
    }
  }
  else {
    // array
    _validate(array, size, 0);
  }
};

/**
 * Test whether index is an integer number with index >= 0 and index < length
 * @param {Number} index    Zero-based index
 * @param {Number} [length] Length of the array
 */
exports.validateIndex = function(index, length) {
  if (!number.isNumber(index) || !number.isInteger(index)) {
    throw new TypeError('Index must be an integer (value: ' + index + ')');
  }
  if (index < 0) {
    throw new IndexError(index);
  }
  if (length !== undefined && index >= length) {
    throw new IndexError(index, length);
  }
};

// a constant used to specify an undefined defaultValue
exports.UNINITIALIZED = {};

/**
 * Resize a multi dimensional array. The resized array is returned.
 * @param {Array} array         Array to be resized
 * @param {Array.<Number>} size Array with the size of each dimension
 * @param {*} [defaultValue=0]  Value to be filled in in new entries,
 *                              zero by default. To leave new entries undefined,
 *                              specify array.UNINITIALIZED as defaultValue
 * @return {Array} array         The resized array
 */
exports.resize = function(array, size, defaultValue) {
  // TODO: add support for scalars, having size=[] ?

  // check the type of the arguments
  if (!isArray(array) || !isArray(size)) {
    throw new TypeError('Array expected');
  }
  if (size.length === 0) {
    throw new Error('Resizing to scalar is not supported');
  }

  // check whether size contains positive integers
  size.forEach(function (value) {
    if (!number.isNumber(value) || !number.isInteger(value) || value < 0) {
      throw new TypeError('Invalid size, must contain positive integers ' +
          '(size: ' + string.format(size) + ')');
    }
  });

  // recursively resize the array
  var _defaultValue = (defaultValue !== undefined) ? defaultValue : 0;
  _resize(array, size, 0, _defaultValue);

  return array;
};

/**
 * Recursively resize a multi dimensional array
 * @param {Array} array         Array to be resized
 * @param {Number[]} size       Array with the size of each dimension
 * @param {Number} dim          Current dimension
 * @param {*} [defaultValue]    Value to be filled in in new entries,
 *                              undefined by default.
 * @private
 */
function _resize (array, size, dim, defaultValue) {
  var i;
  var elem;
  var oldLen = array.length;
  var newLen = size[dim];
  var minLen = Math.min(oldLen, newLen);

  // apply new length
  array.length = newLen;

  if (dim < size.length - 1) {
    // non-last dimension
    var dimNext = dim + 1;

    // resize existing child arrays
    for (i = 0; i < minLen; i++) {
      // resize child array
      elem = array[i];
      if (!isArray(elem)) {
        elem = [elem]; // add a dimension
        array[i] = elem;
      }
      _resize(elem, size, dimNext, defaultValue);
    }

    // create new child arrays
    for (i = minLen; i < newLen; i++) {
      // get child array
      elem = [];
      array[i] = elem;

      // resize new child array
      _resize(elem, size, dimNext, defaultValue);
    }
  }
  else {
    // last dimension

    // remove dimensions of existing values
    for (i = 0; i < minLen; i++) {
      while (isArray(array[i])) {
        array[i] = array[i][0];
      }
    }

    if(defaultValue !== exports.UNINITIALIZED) {
      // fill new elements with the default value
      for (i = minLen; i < newLen; i++) {
        array[i] = object.clone(defaultValue);
      }
    }
  }
}

/**
 * Squeeze a multi dimensional array
 * @param {Array} array
 * @param {Array} [size]
 * @returns {Array} returns the array itself
 * @private
 */
exports.squeeze = function(array, size) {
  var s = size || exports.size(array);

  // squeeze outer dimensions
  while (isArray(array) && array.length === 1) {
    array = array[0];
    s.shift();
  }

  // find the first dimension to be squeezed
  var dims = s.length;
  while (s[dims - 1] === 1) {
    dims--;
  }

  // squeeze inner dimensions
  if (dims < s.length) {
    array = _squeeze(array, dims, 0);
    s.length = dims;
  }

  return array;
};

/**
 * Recursively squeeze a multi dimensional array
 * @param {Array} array
 * @param {number} dims Required number of dimensions
 * @param {number} dim  Current dimension
 * @returns {Array | *} Returns the squeezed array
 * @private
 */
function _squeeze (array, dims, dim) {
  var i, ii;

  if (dim < dims) {
    var next = dim + 1;
    for (i = 0, ii = array.length; i < ii; i++) {
      array[i] = _squeeze(array[i], dims, next);
    }
  }
  else {
    while (isArray(array)) {
      array = array[0];
    }
  }

  return array;
}

/**
 * Unsqueeze a multi dimensional array: add dimensions when missing
 * @param {Array} array
 * @param {Number} dims     Desired number of dimensions of the array
 * @param {Number} [outer]  Number of outer dimensions to be added
 * @param {Array} [size]    Current size of array
 * @returns {Array} returns the array itself
 * @private
 */
exports.unsqueeze = function(array, dims, outer, size) {
  var s = size || exports.size(array);

  // unsqueeze outer dimensions
  if (outer) {
    for (var i = 0; i < outer; i++) {
      array = [array];
      s.unshift(1);
    }
  }

  // unsqueeze inner dimensions
  array = _unsqueeze(array, dims, 0);
  while (s.length < dims) {
    s.push(1);
  }

  return array;
};

/**
 * Recursively unsqueeze a multi dimensional array
 * @param {Array} array
 * @param {number} dims Required number of dimensions
 * @param {number} dim  Current dimension
 * @returns {Array | *} Returns the squeezed array
 * @private
 */
function _unsqueeze (array, dims, dim) {
  var i, ii;

  if (isArray(array)) {
    var next = dim + 1;
    for (i = 0, ii = array.length; i < ii; i++) {
      array[i] = _unsqueeze(array[i], dims, next);
    }
  }
  else {
    for (var d = dim; d < dims; d++) {
      array = [array];
    }
  }

  return array;
}
/**
 * Flatten a multi dimensional array, put all elements in a one dimensional
 * array
 * @param {Array} array   A multi dimensional array
 * @return {Array}        The flattened array (1 dimensional)
 * @private
 */
exports.flatten = function(array) {
  var flat = array,
      isArray = Array.isArray;

  while (isArray(flat[0])) {
    var next = [];
    for (var i = 0, ii = flat.length; i < ii; i++) {
      next = next.concat.apply(next, flat[i]);
    }
    flat = next;
  }

  return flat;
};

/**
 * Convert function arguments to an array.
 * @param {Arguments} args
 * @returns {Array} array
 */
exports.argsToArray = function(args) {
  var array = [];
  for (var i = 0, len = args.length; i < len; i++) {
    array[i] = args[i];
  }
  return array;
};

/**
 * Test whether an object is an array
 * @param {*} value
 * @return {Boolean} isArray
 */
exports.isArray = isArray;
},{"./number":36,"./string":191,"./object":35,"./types":313,"../error/DimensionError":175,"../error/IndexError":176}],178:[function(require,module,exports){
'use strict';

exports.array = require('./array');
exports['boolean'] = require('./boolean');
exports.number = require('./number');
exports.bignumber = require('./bignumber');
exports.object = require('./object');
exports.string = require('./string');
exports.types = require('./types');

},{"./array":44,"./boolean":314,"./number":36,"./bignumber":42,"./object":35,"./string":191,"./types":313}],179:[function(require,module,exports){
'use strict';

var Node = require('./Node'),
    object = require('../../util/object'),
    string = require('../../util/string'),
    collection = require('../../type/collection'),
    util = require('../../util/index'),

    isArray = Array.isArray,
    isNode = Node.isNode;

/**
 * @constructor ArrayNode
 * @extends {Node}
 * Holds an 1-dimensional array with nodes
 * @param {Node[]} [nodes]   1 dimensional array with nodes
 */
function ArrayNode(nodes) {
  if (!(this instanceof ArrayNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.nodes = nodes || [];

  // validate input
  if (!isArray(this.nodes) || !this.nodes.every(isNode)) {
    throw new TypeError('Array containing Nodes expected')
  }
}

ArrayNode.prototype = new Node();

ArrayNode.prototype.type = 'ArrayNode';

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @private
 */
ArrayNode.prototype._compile = function (defs) {
  var asMatrix = (defs.math.config().matrix !== 'array');

  var nodes = this.nodes.map(function (node) {
    return node._compile(defs);
  });

  return (asMatrix ? 'math.matrix([' : '[') +
      nodes.join(',') +
      (asMatrix ? '])' : ']');
};

/**
 * Find all nodes matching given filter
 * @param {Object} filter  See Node.find for a description of the filter options
 * @returns {Node[]} nodes
 */
ArrayNode.prototype.find = function (filter) {
  var results = [];

  // check itself
  if (this.match(filter)) {
    results.push(this);
  }

  // search in all nodes
  var nodes = this.nodes;
  for (var r = 0, rows = nodes.length; r < rows; r++) {
    results = results.concat(nodes[r].find(filter));
  }

  return results;
};

/**
 * Get string representation
 * @return {String} str
 * @override
 */
ArrayNode.prototype.toString = function() {
  return string.format(this.nodes);
};

/**
 * Get LaTeX representation
 * @return {String} str
 */
ArrayNode.prototype.toTex = function(type) {
  type = type || 'bmatrix';
  var s = '\\begin{' + type + '}';

  this.nodes.forEach(function(node) {
    if (node.nodes) {
      s += node.nodes.map(function(childNode) {
        return childNode.toTex();
      }).join('&');
    }
    else {
      s += node.toTex();
    }

    // new line
    s += '\\\\';
  });
  s += '\\end{' + type + '}';
  return s;
};

module.exports = ArrayNode;

},{"./Node":192,"../../util/object":35,"../../util/string":191,"../../type/collection":52,"../../util/index":178}],180:[function(require,module,exports){
'use strict';

var Node = require('./Node'),
    ArrayNode = require('./ArrayNode'),

    keywords = require('../keywords'),

    latex = require('../../util/latex'),
    isString = require('../../util/string').isString;

/**
 * @constructor AssignmentNode
 * @extends {Node}
 * Define a symbol, like "a = 3.2"
 *
 * @param {String} name       Symbol name
 * @param {Node} expr         The expression defining the symbol
 */
function AssignmentNode(name, expr) {
  if (!(this instanceof AssignmentNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input
  if (!isString(name))          throw new TypeError('String expected for parameter "name"');
  if (!(expr instanceof Node))  throw new TypeError('Node expected for parameter "expr"');
  if (name in keywords)         throw new Error('Illegal symbol name, "'  + name +  '" is a reserved keyword');

  this.name = name;
  this.expr = expr;
}

AssignmentNode.prototype = new Node();

AssignmentNode.prototype.type = 'AssignmentNode';

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @private
 */
AssignmentNode.prototype._compile = function (defs) {
  return 'scope["' + this.name + '"] = ' + this.expr._compile(defs) + '';
};

/**
 * Find all nodes matching given filter
 * @param {Object} filter  See Node.find for a description of the filter options
 * @returns {Node[]} nodes
 */
AssignmentNode.prototype.find = function (filter) {
  var nodes = [];

  // check itself
  if (this.match(filter)) {
    nodes.push(this);
  }

  // search in expression
  nodes = nodes.concat(this.expr.find(filter));

  return nodes;
};

/**
 * Get string representation
 * @return {String}
 */
AssignmentNode.prototype.toString = function() {
  return this.name + ' = ' + this.expr.toString();
};

/**
 * Get LaTeX representation
 * @return {String}
 */
AssignmentNode.prototype.toTex = function() {
  var brace;
  if (this.expr instanceof ArrayNode) {
    brace = ['\\mathbf{', '}'];
  }
  return latex.addBraces(latex.toSymbol(this.name), brace) + '=' +
      latex.addBraces(this.expr.toTex());
};

module.exports = AssignmentNode;
},{"./Node":192,"./ArrayNode":179,"../keywords":317,"../../util/latex":318,"../../util/string":191}],181:[function(require,module,exports){
'use strict';

var Node = require('./Node');
var ResultSet = require('../../type/ResultSet');
var isBoolean = require('../../util/boolean').isBoolean;

/**
 * @constructor BlockNode
 * @extends {Node}
 * Holds a set with nodes
 */
function BlockNode() {
  if (!(this instanceof BlockNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.params = [];
}

BlockNode.prototype = new Node();

BlockNode.prototype.type = 'BlockNode';

/**
 * Add an expression. If visible = false, the expression will be evaluated
 * but not returned in the output.
 * @param {Node} expr
 * @param {Boolean} [visible=true]
 */
BlockNode.prototype.add = function (expr, visible) {
  if (visible === undefined) visible = true;

  // validate input
  if (!(expr instanceof Node))  throw new TypeError('Node expected for parameter "expr"');
  if (!isBoolean(visible))      throw new TypeError('Boolean expected for parameter "visible"');

  var index = this.params.length;
  this.params[index] = {
    node: expr,
    visible: visible
  };
};

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @return {String} js
 * @private
 */
BlockNode.prototype._compile = function (defs) {
  defs.ResultSet = ResultSet;
  var params = this.params.map(function (param) {
    var js = param.node._compile(defs);
    if (param.visible) {
      return 'results.push(' + js + ');';
    }
    else {
      return js + ';';
    }
  });

  return '(function () {' +
      'var results = [];' +
      params.join('') +
      'return new ResultSet(results);' +
      '})()';
};

/**
 * Find all nodes matching given filter
 * @param {Object} filter  See Node.find for a description of the filter options
 * @returns {Node[]} nodes
 */
BlockNode.prototype.find = function (filter) {
  var nodes = [];

  // check itself
  if (this.match(filter)) {
    nodes.push(this);
  }

  // search in parameters
  var params = this.params;
  for (var i = 0, len = params.length; i < len; i++) {
    nodes = nodes.concat(params[i].node.find(filter));
  }

  return nodes;
};

/**
 * Get string representation
 * @return {String} str
 * @override
 */
BlockNode.prototype.toString = function() {
  return this.params.map(function (param) {
    return param.node.toString() + (param.visible ? '' : ';');
  }).join('\n');
};

/**
 * Get LaTeX representation
 * @return {String} str
 */
BlockNode.prototype.toTex = function() {
  return this.params.map(function (param) {
    return param.node.toTex() + (param.visible ? '' : ';');
  }).join('\n');
};

module.exports = BlockNode;

},{"./Node":192,"../../type/ResultSet":37,"../../util/boolean":314}],184:[function(require,module,exports){
'use strict';

var Node = require('./Node');
var keywords = require('../keywords');
var latex = require('../../util/latex');
var isString = require('../../util/string').isString;
var isArray = Array.isArray;

/**
 * @constructor FunctionAssignmentNode
 * @extends {Node}
 * Function assignment
 *
 * @param {String} name           Function name
 * @param {String[]} args         Function argument names
 * @param {Node} expr             The function expression
 */
function FunctionAssignmentNode(name, args, expr) {
  if (!(this instanceof FunctionAssignmentNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input
  if (!isString(name)) throw new TypeError('String expected for parameter "name"');
  if (!isArray(args) || !args.every(isString))  throw new TypeError('Array containing strings expected for parameter "args"');
  if (!(expr instanceof Node)) throw new TypeError('Node expected for parameter "expr"');
  if (name in keywords) throw new Error('Illegal function name, "'  + name +  '" is a reserved keyword');

  this.name = name;
  this.args = args;
  this.expr = expr;
}

FunctionAssignmentNode.prototype = new Node();

FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @return {String} js
 * @private
 */
FunctionAssignmentNode.prototype._compile = function (defs) {
  return 'scope["' + this.name + '"] = ' +
      '  (function (scope) {' +
      '    scope = Object.create(scope); ' +
      '    var fn = function ' + this.name + '(' + this.args.join(',') + ') {' +
      '      if (arguments.length != ' + this.args.length + ') {' +
      // TODO: use util.error.ArgumentsError here
      // TODO: test arguments error
      '        throw new SyntaxError("Wrong number of arguments in function ' + this.name + ' (" + arguments.length + " provided, ' + this.args.length + ' expected)");' +
      '      }' +
      this.args.map(function (variable, index) {
        return 'scope["' + variable + '"] = arguments[' + index + '];';
      }).join('') +
      '      return ' + this.expr._compile(defs) + '' +
      '    };' +
      '    fn.syntax = "' + this.name + '(' + this.args.join(', ') + ')";' +
      '    return fn;' +
      '  })(scope);';
};

/**
 * Find all nodes matching given filter
 * @param {Object} filter  See Node.find for a description of the filter options
 * @returns {Node[]} nodes
 */
FunctionAssignmentNode.prototype.find = function (filter) {
  var nodes = [];

  // check itself
  if (this.match(filter)) {
    nodes.push(this);
  }

  // search in expression
  nodes = nodes.concat(this.expr.find(filter));

  return nodes;
};

/**
 * get string representation
 * @return {String} str
 */
FunctionAssignmentNode.prototype.toString = function() {
  return 'function ' + this.name +
      '(' + this.args.join(', ') + ') = ' +
      this.expr.toString();
};

/**
 * get LaTeX representation
 * @return {String} str
 */
FunctionAssignmentNode.prototype.toTex = function() {
  return this.name +
      latex.addBraces(this.args.map(latex.toSymbol).join(', '), true) + '=' +
      latex.addBraces(this.expr.toTex());
};

module.exports = FunctionAssignmentNode;

},{"./Node":192,"../keywords":317,"../../util/latex":318,"../../util/string":191}],186:[function(require,module,exports){
'use strict';

var Node = require('./Node'),
    ConstantNode = require('./ConstantNode'),
    SymbolNode = require('./SymbolNode'),
    FunctionNode = require('./FunctionNode'),
    latex = require('../../util/latex');

/**
 * @constructor OperatorNode
 * @extends {Node}
 * An operator with two arguments, like 2+3
 *
 * @param {String} op       Operator name, for example '+'
 * @param {String} fn       Function name, for example 'add'
 * @param {Node[]} params   Parameters
 */
function OperatorNode (op, fn, params) {
  if (!(this instanceof OperatorNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // TODO: validate input
  this.op = op;
  this.fn = fn;
  this.params = params;
}

OperatorNode.prototype = new Node();

OperatorNode.prototype.type = 'OperatorNode';

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @return {String} js
 * @private
 */
OperatorNode.prototype._compile = function (defs) {
  if (!(this.fn in defs.math)) {
    throw new Error('Function ' + this.fn + ' missing in provided namespace "math"');
  }

  var params = this.params.map(function (param) {
    return param._compile(defs);
  });
  return 'math.' + this.fn + '(' + params.join(', ') + ')';
};

/**
 * Find all nodes matching given filter
 * @param {Object} filter  See Node.find for a description of the filter options
 * @returns {Node[]} nodes
 */
OperatorNode.prototype.find = function (filter) {
  var nodes = [];

  // check itself
  if (this.match(filter)) {
    nodes.push(this);
  }

  // search in parameters
  var params = this.params;
  if (params) {
    for (var i = 0, len = params.length; i < len; i++) {
      nodes = nodes.concat(params[i].find(filter));
    }
  }

  return nodes;
};

/**
 * Get string representation
 * @return {String} str
 */
OperatorNode.prototype.toString = function() {
  var params = this.params;

  switch (params.length) {
    case 1:
      if (this.op == '-') {
        // special case: unary minus
        return '-' + params[0].toString();
      }
      else {
        // for example '5!'
        return params[0].toString() + this.op;
      }

    case 2: // for example '2+3'
      var lhs = params[0].toString();
      if (params[0] instanceof OperatorNode) {
        lhs = '(' + lhs + ')';
      }
      var rhs = params[1].toString();
      if (params[1] instanceof OperatorNode) {
        rhs = '(' + rhs + ')';
      }
      return lhs + ' ' + this.op + ' ' + rhs;

    default: // this should not occur. format as a function call
      return this.op + '(' + this.params.join(', ') + ')';
  }
};

/**
 * Get LaTeX representation
 * @return {String} str
 */
OperatorNode.prototype.toTex = function() {
  var params = this.params,
      mop = latex.toOperator(this.op),
      lp = params[0],
      rp = params[1];

  switch (params.length) {
    case 1:
      if (this.op === '-' || this.op === '+') {
        // special case: unary minus
        return this.op + lp.toTex();
      }
      // for example '5!'
      return lp.toTex() + this.op;

    case 2: // for example '2+3'
      var lhs = lp.toTex(),
          lhb = false,
          rhs = rp.toTex(),
          rhb = false,
          lop = '',
          rop = '';

      switch (this.op) {
        case '/':
          lop = mop;
          mop = '';

          break;

        case '*':
          if (lp instanceof OperatorNode) {
            if (lp.op === '+' || lp.op === '-') {
              lhb = true;
            }
          }

          if (rp instanceof OperatorNode) {
            if (rp.op === '+' || rp.op === '-') {
              rhb = true;
            }
            else if (rp.op === '*') {
              rhb = true;
            }
          }

          if ((lp instanceof ConstantNode || lp instanceof OperatorNode) &&
              (rp instanceof ConstantNode || rp instanceof OperatorNode)) {
            mop = ' \\cdot ';
          }
          else {
            mop = ' \\, ';
          }

          break;

        case '^':
          if (lp instanceof OperatorNode || lp instanceof FunctionNode) {
            lhb = true;
          }
          else if (lp instanceof SymbolNode) {
            lhb = null;
          }

          break;

        case 'to':
          rhs = latex.toUnit(rhs, true);
          break;
      }

      lhs = latex.addBraces(lhs, lhb);
      rhs = latex.addBraces(rhs, rhb);

      return lop + lhs + mop + rhs + rop;

    default: // this should not occur. format as a function call
      return mop + '(' + this.params.map(latex.toSymbol).join(', ') + ')';
  }
};

module.exports = OperatorNode;

},{"./Node":192,"./ConstantNode":183,"./SymbolNode":189,"./FunctionNode":187,"../../util/latex":318}],187:[function(require,module,exports){
'use strict';

var Node = require('./Node');

var latex = require('../../util/latex');
var isNode = Node.isNode;
var isArray = Array.isArray;

/**
 * @constructor FunctionNode
 * @extends {Node}
 * invoke a list with parameters on a node
 * @param {SymbolNode} symbol
 * @param {Node[]} params
 */
function FunctionNode (symbol, params) {
  if (!(this instanceof FunctionNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input
  if (!(symbol instanceof Node)) throw new TypeError('SymbolNode expected for parameter "symbol"');
  if (!isArray(params) || !params.every(isNode)) {
    throw new TypeError('Array containing Nodes expected for parameter "params"');
  }

  this.symbol = symbol;
  this.params = params;
}

FunctionNode.prototype = new Node();

FunctionNode.prototype.type = 'FunctionNode';

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @return {String} js
 * @private
 */
FunctionNode.prototype._compile = function (defs) {
  var fn = defs.math[this.symbol.name];
  var isRaw = (typeof fn === 'function') && (fn.rawArgs == true);

  // compile the parameters
  var params = this.params.map(function (param) {
    return param._compile(defs);
  });

  if (isRaw) {
    // pass unevaluated parameters (nodes) to the function
    var name = this.symbol.name;
    var paramsName;
    do {
      paramsName = 'p' + Math.round(Math.random() * 10000);
    }
    while (paramsName in defs);
    defs[paramsName] = this.params;

    return '("' + name + '" in scope ? ' +
        'scope["' + name + '"](' + params.join(', ') + ') : ' +
        'math["' + name + '"]' + '(' + paramsName + ', math, scope))';
  }
  else {
    // "regular" evaluation
    return this.symbol._compile(defs) + '(' + params.join(', ') + ')';
  }
};

/**
 * Find all nodes matching given filter
 * @param {Object} filter  See Node.find for a description of the filter options
 * @returns {Node[]} nodes
 */
FunctionNode.prototype.find = function (filter) {
  var nodes = [];

  // check itself
  if (this.match(filter)) {
    nodes.push(this);
  }

  // search symbol
  nodes = nodes.concat(this.symbol.find(filter));

  // search in parameters
  var params = this.params;
  for (var i = 0, len = params.length; i < len; i++) {
    nodes = nodes.concat(params[i].find(filter));
  }

  return nodes;
};

/**
 * Get string representation
 * @return {String} str
 */
FunctionNode.prototype.toString = function() {
  // format the parameters like "add(2, 4.2)"
  return this.symbol.toString() + '(' + this.params.join(', ') + ')';
};

/**
 * Get LaTeX representation
 * @return {String} str
 */
FunctionNode.prototype.toTex = function() {
  return latex.toParams(this);
};

module.exports = FunctionNode;

},{"./Node":192,"../../util/latex":318}],188:[function(require,module,exports){
'use strict';

var Node = require('./Node');

var isNode = Node.isNode;

/**
 * @constructor RangeNode
 * @extends {Node}
 * create a range
 * @param {Node[]} params           Array [start, end] or [start, end, step]
 */
function RangeNode (params) {
  if (!(this instanceof RangeNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate inputs
  if (!Array.isArray(params) ||
      (params.length != 2 && params.length != 3) ||
      !params.every(isNode)) {
    throw new TypeError('Expected an Array containing 2 or 3 Nodes as parameter "params"');
  }

  this.start = params[0];  // included lower-bound
  this.end   = params[1];  // included upper-bound
  this.step  = params[2];  // optional step
}

RangeNode.prototype = new Node();

RangeNode.prototype.type = 'RangeNode';

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @return {String} js
 * @private
 */
RangeNode.prototype._compile = function (defs) {
  return 'math.range(' +
      this.start._compile(defs) + ', ' +
      this.end._compile(defs) +
      (this.step ? (', ' + this.step._compile(defs)) : '') +
      ')';
};

/**
 * Find all nodes matching given filter
 * @param {Object} filter  See Node.find for a description of the filter options
 * @returns {Node[]} nodes
 */
RangeNode.prototype.find = function (filter) {
  var nodes = [];

  // check itself
  if (this.match(filter)) {
    nodes.push(this);
  }

  // search in parameters
  nodes = nodes.concat(this.start.find(filter));
  if (this.step) {
    nodes = nodes.concat(this.step.find(filter));
  }
  nodes = nodes.concat(this.end.find(filter));

  return nodes;
};

/**
 * Get string representation
 * @return {String} str
 */
RangeNode.prototype.toString = function() {
  // format the range like "start:step:end"
  var str = this.start.toString();
  if (this.step) {
    str += ':' + this.step.toString();
  }
  str += ':' + this.end.toString();

  return str;
};

/**
 * Get LaTeX representation
 * @return {String} str
 */
RangeNode.prototype.toTex = function() {
  var str = this.start.toTex();
  if (this.step) {
    str += ':' + this.step.toTex();
  }
  str += ':' + this.end.toTex();

  return str;
};

module.exports = RangeNode;

},{"./Node":192}],189:[function(require,module,exports){
'use strict';

var Node = require('./Node'),
    Unit = require('../../type/Unit'),

    latex = require('../../util/latex'),
    isString = require('../../util/string').isString;

/**
 * @constructor SymbolNode
 * @extends {Node}
 * A symbol node can hold and resolve a symbol
 * @param {String} name
 * @extends {Node}
 */
function SymbolNode(name) {
  if (!(this instanceof SymbolNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input
  if (!isString(name))  throw new TypeError('String expected for parameter "name"');

  this.name = name;
}

SymbolNode.prototype = new Node();

SymbolNode.prototype.type = 'SymbolNode';

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @return {String} js
 * @private
 */
SymbolNode.prototype._compile = function (defs) {
  // add a function to the definitions
  defs['undef'] = undef;
  defs['Unit'] = Unit;

  if (this.name in defs.math) {
    return '("' + this.name + '" in scope ? scope["' + this.name + '"] : math["' + this.name + '"])';
  }
  else {
    return '(' +
        '"' + this.name + '" in scope ? scope["' + this.name + '"] : ' +
        (Unit.isValuelessUnit(this.name) ?
            'new Unit(null, "' + this.name + '")' :
            'undef("' + this.name + '")') +
        ')';
  }
};

/**
 * Throws an error 'Undefined symbol {name}'
 * @param {String} name
 */
function undef (name) {
  throw new Error('Undefined symbol ' + name);
}

/**
 * Get string representation
 * @return {String} str
 * @override
 */
SymbolNode.prototype.toString = function() {
  return this.name;
};

/**
 * Get LaTeX representation
 * @return {String} str
 * @override
 */
SymbolNode.prototype.toTex = function() {
  return latex.toSymbol(this.name);
};

module.exports = SymbolNode;

},{"./Node":192,"../../type/Unit":50,"../../util/latex":318,"../../util/string":191}],190:[function(require,module,exports){
'use strict';

var Node = require('./Node'),
    IndexNode = require('./IndexNode');

/**
 * @constructor UpdateNode
 * @extends {Node}
 * Update a matrix subset, like A[2,3] = 4.5
 *
 * @param {IndexNode} index             IndexNode containing symbol and ranges
 * @param {Node} expr                   The expression defining the symbol
 */
function UpdateNode(index, expr) {
  if (!(this instanceof UpdateNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (!(index instanceof IndexNode)) {
    throw new TypeError('Expected IndexNode for parameter "index"');
  }
  if (!(expr instanceof Node)) {
    throw new TypeError('Expected Node for parameter "expr"');
  }

  this.index = index;
  this.expr = expr;
}

UpdateNode.prototype = new Node();

UpdateNode.prototype.type = 'UpdateNode';

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @return {String} js
 * @private
 */
UpdateNode.prototype._compile = function (defs) {
  return 'scope["' + this.index.objectName() + '\"] = ' +
      this.index.compileSubset(defs,  this.expr._compile(defs));
};

/**
 * Find all nodes matching given filter
 * @param {Object} filter  See Node.find for a description of the filter options
 * @returns {Node[]} nodes
 */
UpdateNode.prototype.find = function (filter) {
  var nodes = [];

  // check itself
  if (this.match(filter)) {
    nodes.push(this);
  }

  // search in index
  nodes = nodes.concat(this.index.find(filter));

  // search in expression
  nodes = nodes.concat(this.expr.find(filter));

  return nodes;
};

/**
 * Get string representation
 * @return {String}
 */
UpdateNode.prototype.toString = function() {
  return this.index.toString() + ' = ' + this.expr.toString();
};

/**
 * Get LaTeX representation
 * @return {String}
 */
UpdateNode.prototype.toTex = function() {
  return this.index.toTex() + ' = ' + this.expr.toTex();
};

module.exports = UpdateNode;

},{"./Node":192,"./IndexNode":185}],316:[function(require,module,exports){
var sha = require('./sha')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: {
    hex: sha.hex_sha1,
    binary: sha.b64_sha1,
    ascii: sha.str_sha1
  },
  md5: {
    hex: md5.hex_md5,
    binary: md5.b64_md5,
    ascii: md5.any_md5
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) {
  alg = alg || 'sha1'
  if(!algorithms[alg])
    error('algorithm:', alg, 'is not yet supported')
  var s = ''
  var _alg = algorithms[alg]
  return {
    update: function (data) {
      s += data
      return this
    },
    digest: function (enc) {
      enc = enc || 'binary'
      var fn
      if(!(fn = _alg[enc]))
        error('encoding:', enc , 'is not yet supported for algorithm', alg)
      var r = fn(s)
      s = null //not meant to use the hash after you've called digest.
      return r
    }
  }
}

exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, rng(size));
    } catch (err) { callback(err); }
  } else {
    return rng(size);
  }
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
;['createCredentials'
, 'createHmac'
, 'createCypher'
, 'createCypheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDeffieHellman'
, 'pbkdf2'].forEach(function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./sha":319,"./rng":320,"./md5":321}],192:[function(require,module,exports){
'use strict';

var keywords = require('../keywords');

/**
 * Node
 */
function Node() {
  if (!(this instanceof Node)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }
}

/**
 * Evaluate the node
 * @return {*} result
 */
// TODO: cleanup deprecated code one day. Deprecated since version 0.19.0
Node.prototype.eval = function () {
  throw new Error('Node.eval is deprecated. ' +
      'Use Node.compile(math).eval([scope]) instead.');
};

Node.prototype.type = 'Node';

/**
 * Compile the node to javascript code
 * @param {Object} math             math.js instance
 * @return {{eval: function}} expr  Returns an object with a function 'eval',
 *                                  which can be invoked as expr.eval([scope]),
 *                                  where scope is an optional object with
 *                                  variables.
 */
Node.prototype.compile = function (math) {
  if (!(math instanceof Object)) {
    throw new TypeError('Object expected for parameter math');
  }

  // definitions globally available inside the closure of the compiled expressions
  var defs = {
    math: _transform(math),
    _validateScope: _validateScope
  };

  var code = this._compile(defs);

  var defsCode = Object.keys(defs).map(function (name) {
    return '    var ' + name + ' = defs["' + name + '"];';
  });

  var factoryCode =
      defsCode.join(' ') +
          'return {' +
          '  "eval": function (scope) {' +
          '    if (scope) _validateScope(scope);' +
          '    scope = scope || {};' +
          '    return ' + code + ';' +
          '  }' +
          '};';

  var factory = new Function ('defs', factoryCode);
  return factory(defs);
};

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          and constants globally available inside the closure
 *                          of the compiled expression
 * @return {String} js
 * @private
 */
Node.prototype._compile = function (defs) {
  throw new Error('Cannot compile a Node interface');
};

/**
 * Find any node in the node tree matching given filter. For example, to
 * find all nodes of type SymbolNode having name 'x':
 *
 *     var results = Node.find({
 *         type: SymbolNode,
 *         properties: {
 *             name: 'x'
 *         }
 *     });
 *
 * @param {Object} filter       Available parameters:
 *                                  {Function} type
 *                                  {Object<String, String>} properties
 * @return {Node[]} nodes       An array with nodes matching given filter criteria
 */
Node.prototype.find = function (filter) {
  return this.match(filter) ? [this] : [];
};

/**
 * Test if this object matches given filter
 * @param {Object} [filter]     Available parameters:
 *                              {Function} type
 *                              {Object<String, *>} properties
 * @return {Boolean} matches    True if there is a match
 */
Node.prototype.match = function (filter) {
  var match = true;

  if (filter) {
    if (filter.type && !(this instanceof filter.type)) {
      match = false;
    }

    var properties = filter.properties;
    if (match && properties) {
      for (var prop in properties) {
        if (properties.hasOwnProperty(prop)) {
          if (this[prop] !== properties[prop]) {
            match = false;
            break;
          }
        }
      }
    }
  }

  return match;
};

/**
 * Get string representation
 * @return {String}
 */
Node.prototype.toString = function() {
  return '';
};

/**
 * Get LaTeX representation
 * @return {String}
 */
Node.prototype.toTex = function() {
  return '';
};

/**
 * Test whether an object is a Node
 * @param {*} object
 * @returns {boolean} isNode
 */
Node.isNode = function(object) {
  return object instanceof Node;
};

/**
 * Validate the symbol names of a scope.
 * Throws an error when the scope contains an illegal symbol.
 * @param {Object} scope
 */
function _validateScope (scope) {
  for (var symbol in scope) {
    if (scope.hasOwnProperty(symbol)) {
      if (symbol in keywords) {
        throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
      }
    }
  }
}

/**
 * Replace all functions having a transform function attached at property transform
 * with their transform.
 * @param {Object} math
 * @return {Object} transformed
 * @private
 */
function _transform(math) {
  var transformed = Object.create(math);

  for (var name in math) {
    if (math.hasOwnProperty(name)) {
      var fn = math[name];
      var transform = fn && fn.transform;
      if (transform) {
        transformed[name] = transform;
      }
    }
  }

  return transformed;
}

module.exports = Node;

},{"../keywords":317}],312:[function(require,module,exports){
'use strict';

// NOTE: distribution is NOT added to math.distribution but returned by the factory function
// TODO: rethink math.distribution

module.exports = function (math) {
  var Matrix = require('../../type/Matrix');
  var array = require('../../util/array');
  var collection = require('../../type/collection');
  var isCollection = collection.isCollection;

  /**
   * Create a distribution object with a set of random functions for given
   * random distribution.
   *
   * Syntax:
   *
   *     math.distribution(name)
   *
   * Examples:
   *
   *     var normalDist = math.distribution('normal'); // create a normal distribution
   *     normalDist.random(0, 10);                      // get a random value between 0 and 10
   *
   * See also:
   *
   *     random, randomInt, pickRandom
   *
   * @param {String} name   Name of a distribution. Choose from 'uniform', 'normal'.
   * @return {Object}       Returns a distribution object containing functions:
   *                        `random([size] [, min] [, max])`,
   *                        `randomInt([min] [, max])`,
   *                        `pickRandom(array)`
   */
  function distribution(name) {
    if (!distributions.hasOwnProperty(name))
      throw new Error('Unknown distribution ' + name);

    var args = Array.prototype.slice.call(arguments, 1),
        distribution = distributions[name].apply(this, args);

    return (function(distribution) {

      // This is the public API for all distributions
      var randFunctions = {

        random: function(arg1, arg2, arg3) {
          var size, min, max;
          if (arguments.length > 3) {
            throw new math.error.ArgumentsError('random', arguments.length, 0, 3);

          // `random(max)` or `random(size)`
          } else if (arguments.length === 1) {
            if (isCollection(arg1)) {
              size = arg1;
            }
            else {
              max = arg1;
            }
          // `random(min, max)` or `random(size, max)`
          } else if (arguments.length === 2) {
            if (isCollection(arg1)) {
              size = arg1;
              max = arg2;
            }
            else {
              min = arg1;
              max = arg2;
            }
          // `random(size, min, max)`
          } else {
            size = arg1;
            min = arg2;
            max = arg3;
          }

          // TODO: validate type of min, max, and size

          if (max === undefined) max = 1;
          if (min === undefined) min = 0;
          if (size !== undefined) {
            var res = _randomDataForMatrix(size.valueOf(), min, max, _random);
            return (size instanceof Matrix) ? new Matrix(res) : res;
          }
          else return _random(min, max);
        },

        randomInt: function(arg1, arg2, arg3) {
          var size, min, max;
          if (arguments.length > 3 || arguments.length < 1)
            throw new math.error.ArgumentsError('randomInt', arguments.length, 1, 3);

          // `random(max)` or `random(size)`
          else if (arguments.length === 1)
            if (isCollection(arg1)) {
              size = arg1;
            }
            else {
              max = arg1;
            }
          // `randomInt(min, max)` or `randomInt(size, max)`
          else if (arguments.length === 2) {
            if (isCollection(arg1)) {
              size = arg1;
              max = arg2;
            }
            else {
              min = arg1;
              max = arg2;
            }
          // `randomInt(size, min, max)`
          } else {
            size = arg1;
            min = arg2;
            max = arg3;
          }

          // TODO: validate type of min, max, and size

          if (min === undefined) min = 0;
          if (size !== undefined) {
            var res = _randomDataForMatrix(size.valueOf(), min, max, _randomInt);
            return (size instanceof Matrix) ? new Matrix(res) : res;
          }
          else return _randomInt(min, max);
        },

        pickRandom: function(possibles) {
          if (arguments.length !== 1) {
            throw new math.error.ArgumentsError('pickRandom', arguments.length, 1);
          }
          if (possibles instanceof Matrix) {
            possibles = possibles.valueOf(); // get Array
          }
          else if (!Array.isArray(possibles)) {
            throw new math.error.UnsupportedTypeError('pickRandom', math['typeof'](possibles));
          }

          if (array.size(possibles).length > 1) {
            throw new Error('Only one dimensional vectors supported');
          }

          // TODO: add support for multi dimensional matrices
          return possibles[Math.floor(Math.random() * possibles.length)];
        }

      };

      var _random = function(min, max) {
        return min + distribution() * (max - min);
      };

      var _randomInt = function(min, max) {
        return Math.floor(min + distribution() * (max - min));
      };

      // This is a function for generating a random matrix recursively.
      var _randomDataForMatrix = function(size, min, max, randFunc) {
        var data = [], length, i;
        size = size.slice(0);

        if (size.length > 1) {
          for (i = 0, length = size.shift(); i < length; i++)
            data.push(_randomDataForMatrix(size, min, max, randFunc));
        } else {
          for (i = 0, length = size.shift(); i < length; i++)
            data.push(randFunc(min, max));
        }

        return data;
      };

      return randFunctions;

    })(distribution);
  };

  // Each distribution is a function that takes no argument and when called returns
  // a number between 0 and 1.
  var distributions = {

    uniform: function() {
      return Math.random;
    },

    // Implementation of normal distribution using Box-Muller transform
    // ref : http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
    // We take : mean = 0.5, standard deviation = 1/6
    // so that 99.7% values are in [0, 1].
    normal: function() {
      return function() {
        var u1, u2,
            picked = -1;
        // We reject values outside of the interval [0, 1]
        // TODO: check if it is ok to do that?
        while (picked < 0 || picked > 1) {
          u1 = Math.random();
          u2 = Math.random();
          picked = 1/6 * Math.pow(-2 * Math.log(u1), 0.5) * Math.cos(2 * Math.PI * u2) + 0.5;
        }
        return picked;
      }
    }
  };

  return distribution;
};

},{"../../type/Matrix":49,"../../util/array":44,"../../type/collection":52}],315:[function(require,module,exports){
var DimensionError = require('../../error/DimensionError');
var IndexError = require('../../error/IndexError');

/**
 * Transform zero-based indices to one-based indices in errors
 * @param {Error} err
 * @returns {Error} Returns the transformed error
 */
exports.transform = function (err) {
  if (err instanceof IndexError) {
    return new IndexError(err.index + 1, err.min + 1, err.max + 1);
  }

  return err;
};

},{"../../error/DimensionError":175,"../../error/IndexError":176}],317:[function(require,module,exports){
'use strict';

// Reserved keywords not allowed to use in the parser
module.exports = {
  end: true
};

},{}],319:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

exports.hex_sha1 = hex_sha1;
exports.b64_sha1 = b64_sha1;
exports.str_sha1 = str_sha1;
exports.hex_hmac_sha1 = hex_hmac_sha1;
exports.b64_hmac_sha1 = b64_hmac_sha1;
exports.str_hmac_sha1 = str_hmac_sha1;

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}


},{}],320:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  // currently only available in webkit-based browsers.
  if (_global.crypto && crypto.getRandomValues) {
    var _rnds = new Uint32Array(4);
    whatwgRNG = function(size) {
      var bytes = new Array(size);
      crypto.getRandomValues(_rnds);

      for (var c = 0 ; c < size; c++) {
        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;
      }
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())
},{}],321:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}


exports.hex_md5 = hex_md5;
exports.b64_md5 = b64_md5;
exports.any_md5 = any_md5;

},{}],109:[function(require,module,exports){
'use strict';

module.exports = function (math) {
  var util = require('../../util/index'),

      BigNumber = require('decimal.js'),
      Matrix = require('../../type/Matrix'),
      collection = require('../../type/collection'),

      object = util.object,
      array = util.array,
      isNumber = util.number.isNumber,
      isInteger = util.number.isInteger,
      isCollection = collection.isCollection;

  /**
   * Concatenate two or more matrices.
   *
   * Syntax:
   *
   *     math.concat(A, B, C, ...)
   *     math.concat(A, B, C, ..., dim)
   *
   * Where:
   *
   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
   *   By default the last dimension of the matrices.
   *
   * Examples:
   *
   *    var A = [[1, 2], [5, 6]];
   *    var B = [[3, 4], [7, 8]];
   *
   *    math.concat(A, B);      // returns [[1, 2, 3, 4], [5, 6, 7, 8]]
   *    math.concat(A, B, 0);   // returns [[1, 2], [5, 6], [3, 4], [7, 8]]
   *
   * See also:
   *
   *    size, squeeze, subset, transpose
   *
   * @param {... Array | Matrix} args     Two or more matrices
   * @return {Array | Matrix} Concatenated matrix
   */
  math.concat = function concat (args) {
    var i,
        len = arguments.length,
        dim = -1,  // zero-based dimension
        prevDim,
        asMatrix = false,
        matrices = [];  // contains multi dimensional arrays

    for (i = 0; i < len; i++) {
      var arg = arguments[i];

      // test whether we need to return a Matrix (if not we return an Array)
      if (arg instanceof Matrix) {
        asMatrix = true;
      }

      if ((i == len - 1) && (isNumber(arg) || arg instanceof BigNumber)) {
        // last argument contains the dimension on which to concatenate
        prevDim = dim;
        dim = arg.valueOf(); // change bignumber to number

        if (!isInteger(dim)) {
          throw new TypeError('Integer number expected for dimension');
        }

        if (dim < 0) {
          // TODO: would be more clear when throwing a DimensionError here
          throw new math.error.IndexError(dim);
        }
        if (i > 0 && dim > prevDim) {
          // TODO: would be more clear when throwing a DimensionError here
          throw new math.error.IndexError(dim, prevDim + 1);
        }
      }
      else if (isCollection(arg)) {
        // this is a matrix or array
        var matrix = object.clone(arg).valueOf();
        var size = array.size(arg.valueOf());
        matrices[i] = matrix;
        prevDim = dim;
        dim = size.length - 1;

        // verify whether each of the matrices has the same number of dimensions
        if (i > 0 && dim != prevDim) {
          throw new math.error.DimensionError(prevDim + 1, dim + 1);
        }
      }
      else {
        throw new math.error.UnsupportedTypeError('concat', math['typeof'](arg));
      }
    }

    if (matrices.length == 0) {
      throw new SyntaxError('At least one matrix expected');
    }

    var res = matrices.shift();
    while (matrices.length) {
      res = _concat(res, matrices.shift(), dim, 0);
    }

    return asMatrix ? new Matrix(res) : res;
  };

  /**
   * Recursively concatenate two matrices.
   * The contents of the matrices is not cloned.
   * @param {Array} a             Multi dimensional array
   * @param {Array} b             Multi dimensional array
   * @param {Number} concatDim    The dimension on which to concatenate (zero-based)
   * @param {Number} dim          The current dim (zero-based)
   * @return {Array} c            The concatenated matrix
   * @private
   */
  function _concat(a, b, concatDim, dim) {
    if (dim < concatDim) {
      // recurse into next dimension
      if (a.length != b.length) {
        throw new math.error.DimensionError(a.length, b.length);
      }

      var c = [];
      for (var i = 0; i < a.length; i++) {
        c[i] = _concat(a[i], b[i], concatDim, dim + 1);
      }
      return c;
    }
    else {
      // concatenate this dimension
      return a.concat(b);
    }
  }
};

},{"../../util/index":178,"../../type/Matrix":49,"../../type/collection":52,"decimal.js":173}],162:[function(require,module,exports){
'use strict';

var BigNumber = require('decimal.js');
var errorTransform = require('./error.transform').transform;
var isNumber = require('../../util/number').isNumber;
var argsToArray = require('../../util/array').argsToArray;

/**
 * Attach a transform function to math.range
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function concat
 * from one-based to zero based
 * @param {Object} math
 */
module.exports = function (math) {
  math.concat.transform = function () {
    // copy arguments into an array
    var args = argsToArray(arguments);

    // change last argument from one-based to zero-based
    var lastIndex = args.length - 1;
    var last = args[lastIndex];
    if (isNumber(last)) {
      args[lastIndex] = last - 1;
    }
    else if (last instanceof BigNumber) {
      args[lastIndex] = last.minus(1);
    }

    try {
      return math.concat.apply(math, args);
    }
    catch (err) {
      throw errorTransform(err);
    }
  };
};

},{"./error.transform":315,"../../util/number":36,"../../util/array":44,"decimal.js":173}],165:[function(require,module,exports){
'use strict';

var BigNumber = require('decimal.js');
var Range = require('../../type/Range');
var Index = require('../../type/Index');
var Matrix = require('../../type/Matrix');
var isNumber = require('../../util/number').isNumber;
var isArray = Array.isArray;

/**
 * Attach a transform function to math.index
 * Adds a property transform containing the transform function.
 *
 * This transform creates a one-based index instead of a zero-based index
 * @param {Object} math
 */
module.exports = function (math) {
  math.index.transform = function () {
    var args = [];
    for (var i = 0, ii = arguments.length; i < ii; i++) {
      var arg = arguments[i];

      // change from one-based to zero based, and convert BigNumber to number
      if (arg instanceof Range) {
        arg.start--;
        arg.end -= (arg.step > 0 ? 0 : 2);
      }
      else if (isNumber(arg)) {
        arg--;
      }
      else if (arg instanceof BigNumber) {
        arg = arg.toNumber() - 1;
      }
      else {
        throw new TypeError('Ranges must be a Number or Range');
      }

      args[i] = arg;
    }

    var res = new Index();
    Index.apply(res, args);
    return res;
  };
};

},{"../../type/Range":47,"../../type/Index":48,"../../type/Matrix":49,"../../util/number":36,"decimal.js":173}],164:[function(require,module,exports){
'use strict';

var Matrix = require('../../type/Matrix');
var BigNumber = require('decimal.js');
var Range = require('../../type/Range');
var Index = require('../../type/Index');
var isNumber = require('../../util/number').isNumber;
var isArray = Array.isArray;

/**
 * Attach a transform function to math.forEach
 * Adds a property transform containing the transform function.
 *
 * This transform creates a one-based index instead of a zero-based index
 * @param {Object} math
 */
module.exports = function (math) {
  math.forEach.transform = function (x, callback) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('forEach', arguments.length, 2);
    }

    var arrayIn = x instanceof Matrix ? x.valueOf() : x;
    if (Array.isArray(arrayIn)) {
      var index = [];

      var recurse = function (value, dim) {
        if (Array.isArray(value)) {
          return value.map(function (child, i) {
            index[dim] = i + 1; // one-based index!
            return recurse(child, dim + 1);
          });
        }
        else {
          callback(value, index, x); // Note: pass the original matrix here
        }
      };

      recurse(arrayIn, 0);
    } else {
      throw new math.error.UnsupportedTypeError('forEach', math['typeof'](x));
    }
  };
};

},{"../../type/Matrix":49,"../../type/Range":47,"../../type/Index":48,"../../util/number":36,"decimal.js":173}],166:[function(require,module,exports){
'use strict';

var Matrix = require('../../type/Matrix');
var BigNumber = require('decimal.js');
var Range = require('../../type/Range');
var Index = require('../../type/Index');
var isNumber = require('../../util/number').isNumber;
var isArray = Array.isArray;

/**
 * Attach a transform function to math.map
 * Adds a property transform containing the transform function.
 *
 * This transform creates a one-based index instead of a zero-based index
 * @param {Object} math
 */
module.exports = function (math) {
  math.map.transform = function (x, callback) {
    if (arguments.length != 2) {
      throw new math.error.ArgumentsError('map', arguments.length, 2);
    }

    var asMatrix = x instanceof Matrix;
    var arrayIn = asMatrix ? x.valueOf() : x;
    if (Array.isArray(arrayIn)) {
      var index = [];

      var recurse = function (value, dim) {
        if (Array.isArray(value)) {
          return value.map(function (child, i) {
            index[dim] = i + 1; // one-based index!
            return recurse(child, dim + 1);
          });
        }
        else {
          return callback(value, index, x); // Note: pass the original matrix here
        }
      };

      var res = recurse(arrayIn, 0);
      return asMatrix ? new Matrix(res) : res;
    } else {
      throw new math.error.UnsupportedTypeError('map', math['typeof'](x));
    }
  };
};

},{"../../type/Matrix":49,"../../type/Range":47,"../../type/Index":48,"../../util/number":36,"decimal.js":173}],167:[function(require,module,exports){
'use strict';

var BigNumber = require('decimal.js');
var errorTransform = require('./error.transform').transform;
var isNumber = require('../../util/number').isNumber;
var isCollection = require('../../type/collection').isCollection;
var argsToArray = require('../../util/array').argsToArray;

/**
 * Attach a transform function to math.max
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function max
 * from one-based to zero based
 * @param {Object} math
 */
module.exports = function (math) {
  math.max.transform = function () {
    var args = argsToArray(arguments);

    // change last argument dim from one-based to zero-based
    if (args.length == 2 && isCollection(args[0])) {
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      }
      else if (dim instanceof BigNumber) {
        args[1] = dim.minus(1);
      }
    }

    try {
      return math.max.apply(math, args);
    }
    catch (err) {
      throw errorTransform(err);
    }
  };
};

},{"./error.transform":315,"../../util/number":36,"../../type/collection":52,"../../util/array":44,"decimal.js":173}],168:[function(require,module,exports){
'use strict';

var BigNumber = require('decimal.js');
var errorTransform = require('./error.transform').transform;
var isNumber = require('../../util/number').isNumber;
var isCollection = require('../../type/collection').isCollection;
var argsToArray = require('../../util/array').argsToArray;

/**
 * Attach a transform function to math.mean
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function mean
 * from one-based to zero based
 * @param {Object} math
 */
module.exports = function (math) {
  math.mean.transform = function () {
    var args = argsToArray(arguments);

    // change last argument dim from one-based to zero-based
    if (args.length == 2 && isCollection(args[0])) {
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      }
      else if (dim instanceof BigNumber) {
        args[1] = dim.minus(1);
      }
    }

    try {
      return math.mean.apply(math, args);
    }
    catch (err) {
      throw errorTransform(err);
    }
  };
};

},{"./error.transform":315,"../../util/number":36,"../../type/collection":52,"../../util/array":44,"decimal.js":173}],169:[function(require,module,exports){
'use strict';

var BigNumber = require('decimal.js');
var errorTransform = require('./error.transform').transform;
var isNumber = require('../../util/number').isNumber;
var isCollection = require('../../type/collection').isCollection;
var argsToArray = require('../../util/array').argsToArray;

/**
 * Attach a transform function to math.min
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function min
 * from one-based to zero based
 * @param {Object} math
 */
module.exports = function (math) {
  math.min.transform = function () {
    var args = argsToArray(arguments);

    // change last argument dim from one-based to zero-based
    if (args.length == 2 && isCollection(args[0])) {
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      }
      else if (dim instanceof BigNumber) {
        args[1] = dim.minus(1);
      }
    }

    try {
      return math.min.apply(math, args);
    }
    catch (err) {
      throw errorTransform(err);
    }
  };
};

},{"./error.transform":315,"../../util/number":36,"../../type/collection":52,"../../util/array":44,"decimal.js":173}],318:[function(require,module,exports){
'use strict';

var ArrayNode = require('../expression/node/ArrayNode'),
    OperatorNode = require('../expression/node/OperatorNode');

// GREEK LETTERS
var greek = {
  Alpha: 'A',     alpha: true,
  Beta: 'B',      beta: true,
  Gamma: true,    gamma: true,
  Delta: true,    delta: true,
  Epsilon: 'E',   epsilon: true,  varepsilon: true,
  Zeta: 'Z',      zeta: true,
  Eta: 'H',       eta: true,
  Theta: true,    theta: true,    vartheta: true,
  Iota: 'I',      iota: true,
  Kappa: 'K',     kappa: true,    varkappa: true,
  Lambda: true,   lambda: true,
  Mu: 'M',        mu: true,
  Nu: 'N',        nu: true,
  Xi: true,       xi: true,
  Omicron: 'O',   omicron: true,
  Pi: true,       pi: true,       varpi: true,
  Rho: 'P',       rho: true,      varrho: true,
  Sigma: true,    sigma: true,    varsigma: true,
  Tau: 'T',       tau: true,
  Upsilon: true,  upsilon: true,
  Phi: true,      phi: true,      varphi: true,
  Chi: 'X',       chi: true,
  Psi: true,      psi: true,
  Omega: true,    omega: true
};

var dots = {
  dots: true,
  ldots: true,
  cdots: true,
  vdots: true,
  ddots: true,
  idots: true
};

var logic = {
  'true': '\\mathrm{True}',
  'false': '\\mathrm{False}'
};

var other = {
  inf: '\\infty',
  Inf: '\\infty',
  infinity: '\\infty',
  Infinity: '\\infty',
  oo: '\\infty',
  lim: true,
  'undefined': '\\mathbf{?}'
};

// FUNCTIONS
var functions = {
  acos: '\\cos^{-1}',
  arccos: '\\cos^{-1}',
  cos: true,
  csc: true,
  csch: false,
  exp: true,
  ker: true,
  limsup: true,
  min: true,
  sinh: true,
  asin: '\\sin^{-1}',
  arcsin: '\\sin^{-1}',
  cosh: true,
  deg: true,
  gcd: true,
  lg: true,
  ln: true,
  Pr: true,
  sup: true,
  atan: '\\tan^{-1}',
  atan2: '\\tan2^{-1}',
  arctan: '\\tan^{-1}',
  cot: true,
  det: true,
  hom: true,
  log: true,
  log10: '\\log_{10}',
  sec: true,
  sech: false,
  tan: true,
  arg: true,
  coth: true,
  dim: true,
  inf: true,
  max: true,
  sin: true,
  tanh: true,

  fix: false,
  lcm: false,
  sign: false,
  xgcd: false,
  unaryMinus: false,
  unaryPlus: false,

  // complex
  complex: false,
  conj: false,
  im: false,
  re: false,

  // matrix
  diag: false,
  resize: false,
  size: false,
  squeeze: false,
  subset: false,
  index: false,
  ones: false,
  zeros: false,
  range: false,

  // probability
  random: false,

  // statistics
  mean: '\\mu',
  median: false,
  prod: false,
  std: '\\sigma',
  'var': '\\sigma^2'
};

// CURLY FUNCTIONS
// wrap parameters with {}
var curlyFunctions = {
  sqrt: true,
  inv: true,
  int: '\\int',
  Int: '\\int',
  integrate: '\\int',
  eigenvalues: '\\lambda',
  liminf: true,
  lim: true,
  exp: 'e^',
  sum: true,

  eye: '\\mathbf{I}'
};

var operators = {
  '<=': '\\leq',
  '>=': '\\geq',
  '!=': '\\neq',
  'in': true,
  '*': '\\cdot',
  '/': '\\frac',
  'mod': '\\bmod',
  'to': '\\rightarrow'
};

var units = {
  deg: '^{\\circ}'
};

var symbols = {};

function mapSymbols() {
  var args = Array.prototype.slice.call(arguments),
      obj;
  for (var i = 0, len = args.length; i < len; i++) {
    obj = args[i];
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        symbols[key] = obj[key];
      }
    }
  }
}

mapSymbols(
  functions,
  curlyFunctions,
  greek,
  dots,
  logic,
  other
);

function latexIs(arr, value) {
  return typeof arr[value] !== 'undefined';
}

function latexIsFn(arr) {
  return function(value) {
    return latexIs(arr, value);
  };
}

function latexToFn(arr) {
  return function(value) {
    if (typeof arr[value] === 'boolean') {
      if (arr[value] === true) {
        value = '\\' + value;
      }
      else {
        value = '\\mathrm{' + value + '}';
      }
    }
    else if (typeof arr[value] === 'string') {
      value = arr[value];
    }
    else if (typeof value === 'string') {
      var index = value.indexOf('_');
      if (index !== -1) {
        value = exports.toSymbol(value.substring(0, index)) + '_{' +
            exports.toSymbol(value.substring(index+1)) + '}';
      }
    }

    return value;
  };
}

exports.isSymbol = latexIsFn(symbols);
exports.toSymbol = latexToFn(symbols);

exports.isFunction = latexIsFn(functions);
exports.toFunction = latexToFn(functions);

exports.isCurlyFunction = latexIsFn(curlyFunctions);
exports.toCurlyFunction = latexToFn(curlyFunctions);

exports.isOperator = latexIsFn(operators);
exports.toOperator = latexToFn(operators);

exports.isUnit = latexIsFn(units);
exports.toUnit = (function() {
  var _toUnit = latexToFn(units);

  return function(value, notSpaced) {
    if (exports.isUnit(value)) {
      return _toUnit(value);
    }

    return (notSpaced ? '' : '\\,') + '\\mathrm{' + value + '}';
  };
}());

exports.addBraces = function(s, brace, type) {
  if (brace === null) {
    return s;
  }

  var braces = ['', ''];
  type = type || 'normal';

  if (typeof brace === 'undefined' || brace === false) {
    braces = ['{', '}'];
  }
  else if (brace === true) {
    braces = ['(', ')'];
    type = 'lr';
  }
  else if (Array.isArray(brace) && brace.length === 2) {
    braces = brace;
  }
  else {
    braces = [brace, brace];
  }

  switch (type) {
    case 'normal':
    case false:
      return braces[0] + s + braces[1];

    case 'lr':
      return '\\left' + braces[0] + '{' + s + '}' + '\\right' + braces[1];

    case 'be':
      return '\\begin{' + braces[0] + '}' + s + '\\end{' + braces[1] + '}';
  }

  return braces[0] + s + braces[1];
};

exports.toParams = function(that) {
  var symbol = that.symbol,
      params = that.params,
      func = symbol.toTex(),
      texParams = null,
      brace = null,
      type = false,
      showFunc = false,
      prefix = '',
      suffix = '',
      op = null;

  switch (symbol.name) {
    // OPERATORS
    case 'add':
      op = '+';
      break;

    case 'subtract':
      op = '-';
      break;

    case 'larger':
      op = '>';
      break;

    case 'largerEq':
      op = '>=';
      break;

    case 'smaller':
      op = '<';
      break;

    case 'smallerEq':
      op = '<=';
      break;

    case 'unequal':
      op = '!=';
      break;

    case 'equal':
      op = '=';
      break;

    case 'mod':
      op = 'mod';
      break;

    case 'multiply':
      op = '*';
      break;

    case 'pow':
      op = '^';
      break;

    case 'concat':
      op = '||';
      break;

    case 'factorial':
      op = '!';
      break;

    case 'permutations':
      if (params.length === 1) {
        op = '!';
      }
      else {
        // op = 'P';
        var n = params[0].toTex(),
            k = params[1].toTex();
        return '\\frac{' + n + '!}{\\left(' + n + ' - ' + k + '\\right)!}';
      }
      break;

    // probability
    case 'combinations':
      op = '\\choose';
      break;

    // LR BRACES
    case 'abs':
      brace = '|';
      type = 'lr';
      break;

    case 'norm':
      brace = '\\|';
      type = 'lr';

      if (params.length === 2) {
        var tmp = params[1].toTex();

        if (tmp === '\\text{inf}') {
          tmp = '\\infty';
        }
        else if (tmp === '\\text{-inf}') {
          tmp = '{- \\infty}';
        }
        else if (tmp === '\\text{fro}') {
          tmp = 'F';
        }

        suffix = '_{' + tmp + '}';
        params = [params[0]];
      }
      break;

    case 'ceil':
      brace = ['\\lceil', '\\rceil'];
      type = 'lr';
      break;

    case 'floor':
      brace = ['\\lfloor', '\\rfloor'];
      type = 'lr';
      break;

    case 'round':
      brace = ['\\lfloor', '\\rceil'];
      type = 'lr';

      if (params.length === 2) {
        suffix = '_' + exports.addBraces(params[1].toTex());
        params = [params[0]];
      }
      break;


    // NORMAL BRACES
    case 'inv':
      suffix = '^{-1}';
      break;

    case 'transpose':
      suffix = '^{T}';
      brace = false;
      break;

    // SPECIAL NOTATION
    case 'log':
      var base = 'e';
      if (params.length === 2) {
        base = params[1].toTex();
        func = '\\log_{' + base + '}';
        params = [params[0]];
      }
      if (base === 'e') {
        func = '\\ln';
      }

      showFunc = true;
      break;

    case 'square':
      suffix = '^{2}';
      break;

    case 'cube':
      suffix = '^{3}';
      break;


    // MATRICES
    case 'eye':
      showFunc = true;
      brace = false;
      func += '_';
      break;

    case 'det':
      if (that.params[0] instanceof ArrayNode) {
        return that.params[0].toTex('vmatrix');
      }

      brace = 'vmatrix';
      type = 'be';
      break;

    default:
      showFunc = true;
      break;
  }

  if (op !== null) {
    brace = (op === '+' || op === '-');
    texParams = (new OperatorNode(op, symbol.name, params)).toTex();
  }
  else {
    op = ', ';
  }

  if (brace === null && !exports.isCurlyFunction(symbol.name)) {
    brace = true;
  }

  texParams = texParams || params.map(function(param) {
    return '{' + param.toTex() + '}'  ;
  }).join(op);

  return prefix + (showFunc ? func : '') +
      exports.addBraces(texParams, brace, type) +
      suffix;
};

},{"../expression/node/ArrayNode":179,"../expression/node/OperatorNode":186}],42:[function(require,module,exports){
'use strict';

var BigNumber = require('decimal.js');
var isNumber = require('./number').isNumber;
var digits = require('./number').digits;

/**
 * Test whether value is a BigNumber
 * @param {*} value
 * @return {Boolean} isBigNumber
 */
exports.isBigNumber = function(value) {
  return (value instanceof BigNumber);
};

/**
 * Convert a number to a formatted string representation.
 *
 * Syntax:
 *
 *    format(value)
 *    format(value, options)
 *    format(value, precision)
 *    format(value, fn)
 *
 * Where:
 *
 *    {Number} value   The value to be formatted
 *    {Object} options An object with formatting options. Available options:
 *                     {String} notation
 *                         Number notation. Choose from:
 *                         'fixed'          Always use regular number notation.
 *                                          For example '123.40' and '14000000'
 *                         'exponential'    Always use exponential notation.
 *                                          For example '1.234e+2' and '1.4e+7'
 *                         'auto' (default) Regular number notation for numbers
 *                                          having an absolute value between
 *                                          `lower` and `upper` bounds, and uses
 *                                          exponential notation elsewhere.
 *                                          Lower bound is included, upper bound
 *                                          is excluded.
 *                                          For example '123.4' and '1.4e7'.
 *                     {Number} precision   A number between 0 and 16 to round
 *                                          the digits of the number.
 *                                          In case of notations 'exponential' and
 *                                          'auto', `precision` defines the total
 *                                          number of significant digits returned
 *                                          and is undefined by default.
 *                                          In case of notation 'fixed',
 *                                          `precision` defines the number of
 *                                          significant digits after the decimal
 *                                          point, and is 0 by default.
 *                     {Object} exponential An object containing two parameters,
 *                                          {Number} lower and {Number} upper,
 *                                          used by notation 'auto' to determine
 *                                          when to return exponential notation.
 *                                          Default values are `lower=1e-3` and
 *                                          `upper=1e5`.
 *                                          Only applicable for notation `auto`.
 *    {Function} fn    A custom formatting function. Can be used to override the
 *                     built-in notations. Function `fn` is called with `value` as
 *                     parameter and must return a string. Is useful for example to
 *                     format all values inside a matrix in a particular way.
 *
 * Examples:
 *
 *    format(6.4);                                        // '6.4'
 *    format(1240000);                                    // '1.24e6'
 *    format(1/3);                                        // '0.3333333333333333'
 *    format(1/3, 3);                                     // '0.333'
 *    format(21385, 2);                                   // '21000'
 *    format(12.071, {notation: 'fixed'});                // '12'
 *    format(2.3,    {notation: 'fixed', precision: 2});  // '2.30'
 *    format(52.8,   {notation: 'exponential'});          // '5.28e+1'
 *
 * @param {BigNumber} value
 * @param {Object | Function | Number} [options]
 * @return {String} str The formatted value
 */
exports.format = function(value, options) {
  if (typeof options === 'function') {
    // handle format(value, fn)
    return options(value);
  }

  // handle special cases
  if (!value.isFinite()) {
    return value.isNaN() ? 'NaN' : (value.gt(0) ? 'Infinity' : '-Infinity');
  }

  // default values for options
  var notation = 'auto';
  var precision = undefined;

  if (options !== undefined) {
    // determine notation from options
    if (options.notation) {
      notation = options.notation;
    }

    // determine precision from options
    if (isNumber(options)) {
      precision = options;
    }
    else if (options.precision) {
      precision = options.precision;
    }
  }

  // handle the various notations
  switch (notation) {
    case 'fixed':
      return exports.toFixed(value, precision);

    case 'exponential':
      return exports.toExponential(value, precision);

    case 'auto':
      // determine lower and upper bound for exponential notation.
        // TODO: implement support for upper and lower to be BigNumbers themselves
      var lower = 1e-3;
      var upper = 1e5;
      if (options && options.exponential) {
        if (options.exponential.lower !== undefined) {
          lower = options.exponential.lower;
        }
        if (options.exponential.upper !== undefined) {
          upper = options.exponential.upper;
        }
      }

      // adjust the configuration of the BigNumber constructor (yeah, this is quite tricky...)
      var oldConfig = {
        toExpNeg: value.constructor.toExpNeg,
        toExpPos: value.constructor.toExpPos
      };

      value.constructor.config({
        toExpNeg: Math.round(Math.log(lower) / Math.LN10),
        toExpPos: Math.round(Math.log(upper) / Math.LN10)
      });

      // handle special case zero
      if (value.isZero()) return '0';

      // determine whether or not to output exponential notation
      var str;
      var abs = value.abs();
      if (abs.gte(lower) && abs.lt(upper)) {
        // normal number notation
        str = value.toSignificantDigits(precision).toFixed();
      }
      else {
        // exponential notation
        str = exports.toExponential(value, precision);
      }

      // remove trailing zeros after the decimal point
      return str.replace(/((\.\d*?)(0+))($|e)/, function () {
        var digits = arguments[2];
        var e = arguments[4];
        return (digits !== '.') ? digits + e : e;
      });

    default:
      throw new Error('Unknown notation "' + notation + '". ' +
          'Choose "auto", "exponential", or "fixed".');
  }
};

/**
 * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
 * @param {BigNumber} value
 * @param {Number} [precision]  Number of digits in formatted output.
 *                              If not provided, the maximum available digits
 *                              is used.
 * @returns {string} str
 */
exports.toExponential = function(value, precision) {
  if (precision !== undefined) {
    return value.toExponential(precision - 1); // Note the offset of one
  }
  else {
    return value.toExponential();
  }
};

/**
 * Format a number with fixed notation.
 * @param {BigNumber} value
 * @param {Number} [precision=0]        Optional number of decimals after the
 *                                      decimal point. Zero by default.
 */
exports.toFixed = function(value, precision) {
  return value.toFixed(precision || 0);
  // Note: the (precision || 0) is needed as the toFixed of BigNumber has an
  // undefined default precision instead of 0.
};

},{"./number":36,"decimal.js":173}],191:[function(require,module,exports){
'use strict';

var number = require('./number'),
    bignumber = require('./bignumber'),
    BigNumber = require('decimal.js');

/**
 * Test whether value is a String
 * @param {*} value
 * @return {Boolean} isString
 */
exports.isString = function(value) {
  return (value instanceof String) || (typeof value == 'string');
};

/**
 * Check if a text ends with a certain string.
 * @param {String} text
 * @param {String} search
 */
exports.endsWith = function(text, search) {
  var start = text.length - search.length;
  var end = text.length;
  return (text.substring(start, end) === search);
};

/**
 * Format a value of any type into a string.
 *
 * Usage:
 *     math.format(value)
 *     math.format(value, precision)
 *
 * If value is a function, the returned string is 'function' unless the function
 * has a property `description`, in that case this properties value is returned.
 *
 * Example usage:
 *     math.format(2/7);                // '0.2857142857142857'
 *     math.format(math.pi, 3);         // '3.14'
 *     math.format(new Complex(2, 3));  // '2 + 3i'
 *     math.format('hello');            // '"hello"'
 *
 * @param {*} value             Value to be stringified
 * @param {Object | Number | Function} [options]  Formatting options. See
 *                                                lib/util/number:format for a
 *                                                description of the available
 *                                                options.
 * @return {String} str
 */
exports.format = function(value, options) {
  if (number.isNumber(value)) {
    return number.format(value, options);
  }

  if (value instanceof BigNumber) {
    return bignumber.format(value, options);
  }

  if (Array.isArray(value)) {
    return formatArray(value, options);
  }

  if (exports.isString(value)) {
    return '"' + value + '"';
  }

  if (typeof value === 'function') {
    return value.syntax ? value.syntax + '' : 'function';
  }

  if (value instanceof Object) {
    if (typeof value.format === 'function') {
      return value.format(options);
    }
    else {
      return value.toString();
    }
  }

  return String(value);
};

/**
 * Recursively format an n-dimensional matrix
 * Example output: "[[1, 2], [3, 4]]"
 * @param {Array} array
 * @param {Object | Number | Function} [options]  Formatting options. See
 *                                                lib/util/number:format for a
 *                                                description of the available
 *                                                options.
 * @returns {String} str
 */
function formatArray (array, options) {
  if (Array.isArray(array)) {
    var str = '[';
    var len = array.length;
    for (var i = 0; i < len; i++) {
      if (i != 0) {
        str += ', ';
      }
      str += formatArray(array[i], options);
    }
    str += ']';
    return str;
  }
  else {
    return exports.format(array, options);
  }
}

},{"./number":36,"./bignumber":42,"decimal.js":173}],182:[function(require,module,exports){
'use strict';

var Node = require('./Node');
var latex = require('../../util/latex');
var BigNumber = require('decimal.js');
var Complex = require('../../type/Complex');
var Unit = require('../../type/Unit');
var util = require('../../util');
var isString = util.string.isString;
var isNumber = util.number.isNumber;
var isBoolean = util['boolean'].isBoolean;

/**
 * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
 *
 * @param {Node} condition   Condition, must result in a boolean
 * @param {Node} trueExpr    Expression evaluated when condition is true
 * @param {Node} falseExpr   Expression evaluated when condition is true
 *
 * @constructor ConditionalNode
 * @extends {Node}
 */
function ConditionalNode (condition, trueExpr, falseExpr) {
  if (!(this instanceof ConditionalNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }
  if (!(condition instanceof Node)) throw new TypeError('Parameter condition must be a Node');
  if (!(trueExpr instanceof Node))  throw new TypeError('Parameter trueExpr must be a Node');
  if (!(falseExpr instanceof Node)) throw new TypeError('Parameter falseExpr must be a Node');

  this.condition = condition;
  this.trueExpr = trueExpr;
  this.falseExpr = falseExpr;
}

ConditionalNode.prototype = new Node();

ConditionalNode.prototype.type = 'ConditionalNode';

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @return {String} js
 * @private
 */
ConditionalNode.prototype._compile = function(defs) {
  /**
   * Test whether a condition is met
   * @param {*} condition
   * @returns {boolean} true if condition is true or non-zero, else false
   */
  defs.testCondition = function (condition) {
    if (isNumber(condition) || isBoolean(condition) || isString(condition)) {
      return condition ? true : false;
    }

    if (condition instanceof BigNumber) {
      return condition.isZero() ? false : true;
    }

    if (condition instanceof Complex) {
      return (condition.re || condition.im) ? true : false;
    }

    if (condition instanceof Unit) {
      return condition.value ? true : false;
    }

    if (condition === null || condition === undefined) {
      return false;
    }

    throw new TypeError('Unsupported type of condition "' + defs.math['typeof'](condition) + '"');
  };

  return (
      'testCondition(' + this.condition._compile(defs) + ') ? ' +
      '( ' + this.trueExpr._compile(defs) + ') : ' +
      '( ' + this.falseExpr._compile(defs) + ')'
      );
};

/**
 * Find all nodes matching given filter
 * @param {Object} filter  See Node.find for a description of the filter options
 * @returns {Node[]} nodes
 */
ConditionalNode.prototype.find = function (filter) {
  var nodes = [];

  // check itself
  if (this.match(filter)) {
    nodes.push(this);
  }

  // search in parameters
  nodes = nodes.concat(
      this.condition.find(filter),
      this.trueExpr.find(filter),
      this.falseExpr.find(filter));

  return nodes;
};

/**
 * Get string representation
 * @return {String} str
 */
ConditionalNode.prototype.toString = function() {
  // TODO: not nice adding parenthesis al the time
  return '(' + this.condition.toString() + ') ? (' +
      this.trueExpr.toString() + ') : (' +
      this.falseExpr.toString() + ')';
};

/**
 * Get LaTeX representation
 * @return {String} str
 */
ConditionalNode.prototype.toTex = function() {
  var s = (
      latex.addBraces(this.trueExpr.toTex()) +
      ', &\\quad' +
      latex.addBraces('\\text{if}\\;' + this.condition.toTex())
      ) + '\\\\' + (
      latex.addBraces(this.falseExpr.toTex()) +
      ', &\\quad' +
      latex.addBraces('\\text{otherwise}')
      );

  return latex.addBraces(s, [
    '\\left\\{\\begin{array}{l l}',
    '\\end{array}\\right.'
  ]);
};

module.exports = ConditionalNode;

},{"./Node":192,"../../util/latex":318,"../../type/Complex":43,"../../type/Unit":50,"../../util":178,"decimal.js":173}],185:[function(require,module,exports){
'use strict';

var Node = require('./Node.js');
var RangeNode = require('./RangeNode');
var SymbolNode = require('./SymbolNode');

var BigNumber = require('decimal.js');
var Range = require('../../type/Range');

var isNode = Node.isNode;
var isArray = Array.isArray;

/**
 * @constructor IndexNode
 * @extends Node
 *
 * get a subset of a matrix
 *
 * @param {Node} object
 * @param {Node[]} ranges
 */
function IndexNode (object, ranges) {
  if (!(this instanceof IndexNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input
  if (!(object instanceof Node)) throw new TypeError('Node expected for parameter "object"');
  if (!isArray(ranges) || !ranges.every(isNode)) {
    throw new TypeError('Array containing Nodes expected for parameter "ranges"');
  }

  this.object = object;
  this.ranges = ranges;
}

IndexNode.prototype = new Node();

IndexNode.prototype.type = 'IndexNode';

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @return {String} js
 * @private
 */
IndexNode.prototype._compile = function (defs) {
  return this.compileSubset(defs);
};

/**
 * Compile the node to javascript code
 * @param {Object} defs           Object which can be used to define functions
 *                                or constants globally available for the
 *                                compiled expression
 * @param {String} [replacement]  If provided, the function returns
 *                                  "math.subset(obj, math.index(...), replacement)"
 *                                Else, the function returns
 *                                  "math.subset(obj, math.index(...))"
 * @return {String} js
 * @returns {string}
 */
IndexNode.prototype.compileSubset = function(defs, replacement) {
  // check whether any of the ranges expressions uses the context symbol 'end'
  var filter = {
    type: SymbolNode,
    properties: {
      name: 'end'
    }
  };
  var someUseEnd = false;
  var rangesUseEnd = this.ranges.map(function (range) {
    var useEnd = range.find(filter).length > 0;
    someUseEnd = useEnd ? useEnd : someUseEnd;
    return useEnd;
  });

  // create a Range from start, step and end
  defs.range = function (start, end, step) {
    return new Range(
            start instanceof BigNumber ? start.toNumber() : start,
            end instanceof BigNumber ? end.toNumber() : end,
            step instanceof BigNumber ? step.toNumber() : step
    );
  };

  // TODO: implement support for bignumber (currently bignumbers are silently
  //       reduced to numbers when changing the value to zero-based)

  // TODO: Optimization: when the range values are ConstantNodes,
  //       we can beforehand resolve the zero-based value

  var ranges = this.ranges.map(function(range, i) {
    var useEnd = rangesUseEnd[i];
    if (range instanceof RangeNode) {
      if (useEnd) {
        // resolve end and create range
        return '(function (scope) {' +
            '  scope = Object.create(scope); ' +
            '  scope["end"] = size[' + i + '];' +
            '  return range(' +
            '    ' + range.start._compile(defs) + ', ' +
            '    ' + range.end._compile(defs) + ', ' +
            '    ' + (range.step ? range.step._compile(defs) : '1') +
            '  );' +
            '})(scope)';
      }
      else {
        // create range
        return 'range(' +
            range.start._compile(defs) + ', ' +
            range.end._compile(defs) + ', ' +
            (range.step ? range.step._compile(defs) : '1') +
            ')';
      }
    }
    else {
      if (useEnd) {
        // resolve the parameter 'end'
        return '(function (scope) {' +
            '  scope = Object.create(scope); ' +
            '  scope["end"] = size[' + i + '];' +
            '  return ' + range._compile(defs) + ';' +
            '})(scope)'
      }
      else {
        // just evaluate the expression
        return range._compile(defs);
      }
    }
  });

  // if some parameters use the 'end' parameter, we need to calculate the size
  if (someUseEnd) {
    return '(function () {' +
        '  var obj = ' + this.object._compile(defs) + ';' +
        '  var size = math.size(obj).valueOf();' +
        '  return math.subset(' +
        '    obj, ' +
        '    math.index(' + ranges.join(', ') + ')' +
        '    ' + (replacement ? (', ' + replacement) : '') +
        '  );' +
        '})()';
  }
  else {
    return 'math.subset(' +
        this.object._compile(defs) + ',' +
        'math.index(' + ranges.join(', ') + ')' +
        (replacement ? (', ' + replacement) : '') +
        ')';
  }
};

/**
 * Find all nodes matching given filter
 * @param {Object} filter  See Node.find for a description of the filter options
 * @returns {Node[]} nodes
 */
IndexNode.prototype.find = function (filter) {
  var nodes = [];

  // check itself
  if (this.match(filter)) {
    nodes.push(this);
  }

  // search object
  nodes = nodes.concat(this.object.find(filter));

  // search in parameters
  var ranges = this.ranges;
  for (var i = 0, len = ranges.length; i < len; i++) {
    nodes = nodes.concat(ranges[i].find(filter));
  }

  return nodes;
};

/**
 * Get the name of the object linked to this IndexNode
 * @return {string} name
 */
IndexNode.prototype.objectName = function() {
  return this.object.name;
};

/**
 * Get string representation
 * @return {String} str
 */
IndexNode.prototype.toString = function() {
  // format the parameters like "[1, 0:5]"
  return this.object.toString() + '[' + this.ranges.join(', ') + ']';
};

/**
 * Get LaTeX representation
 * @return {String} str
 */
IndexNode.prototype.toTex = function() {
  return this.object.toTex() + '[' + this.ranges.join(', ') + ']';
};

module.exports = IndexNode;
},{"./Node.js":192,"./RangeNode":188,"./SymbolNode":189,"../../type/Range":47,"decimal.js":173}],183:[function(require,module,exports){
'use strict';

var Node = require('./Node'),
    BigNumber = require('decimal.js'),
    type = require('../../util/types').type,
    isString = require('../../util/string').isString;

/**
 * A ConstantNode holds a constant value like a number or string. A ConstantNode
 * stores a stringified version of the value and uses this to compile to
 * JavaScript.
 *
 * In case of a stringified number as input, this may be compiled to a BigNumber
 * when the math instance is configured for BigNumbers.
 *
 * Usage:
 *
 *     // stringified values with type
 *     new ConstantNode('2.3', 'number');
 *     new ConstantNode('true', 'boolean');
 *     new ConstantNode('hello', 'string');
 *
 *     // non-stringified values, type will be automatically detected
 *     new ConstantNode(2.3);
 *     new ConstantNode('hello');
 *
 * @param {String | Number | Boolean | null | undefined} value
 *                            When valueType is provided, value must contain
 *                            an uninterpreted string representing the value.
 *                            When valueType is undefined, value can be a
 *                            number, string, boolean, null, or undefined, and
 *                            the type will be determined automatically.
 * @param {String} [valueType]  The type of value. Choose from 'number', 'string',
 *                              'boolean', 'undefined', 'null'
 * @constructor ConstantNode
 * @extends {Node}
 */
function ConstantNode(value, valueType) {
  if (!(this instanceof ConstantNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (valueType) {
    if (!isString(valueType)) {
      throw new TypeError('String expected for parameter "valueType"');
    }
    if (!isString(value)){
      throw new TypeError('String expected for parameter "value"');
    }

    this.value = value;
    this.valueType = valueType;
  }
  else {
    // stringify the value and determine the type
    this.value = value + '';
    this.valueType = type(value);
  }

  if (!SUPPORTED_TYPES[this.valueType]) {
    throw new TypeError('Unsupported type of value "' + this.valueType + '"');
  }
}

var SUPPORTED_TYPES = {
  'number': true,
  'string': true,
  'boolean': true,
  'undefined': true,
  'null': true
};

ConstantNode.prototype = new Node();

ConstantNode.prototype.type = 'ConstantNode';

/**
 * Compile the node to javascript code
 * @param {Object} defs     Object which can be used to define functions
 *                          or constants globally available for the compiled
 *                          expression
 * @return {String} js
 * @private
 */
ConstantNode.prototype._compile = function (defs) {
  switch (this.valueType) {
    case 'number':
      if (defs.math.config().number === 'bignumber') {
        return 'math.bignumber("' + this.value + '")';
      }
      else {
        // remove leading zeros like '003.2' which are not allowed by JavaScript
        return this.value.replace(/^(0*)[0-9]/, function (match, zeros) {
          return match.substring(zeros.length);
        });
      }

    case 'string':
      return '"' + this.value + '"';

    case 'boolean':
      return this.value;

    case 'undefined':
      return this.value;

    case 'null':
      return this.value;

    default:
        // TODO: move this error to the constructor?
      throw new TypeError('Unsupported type of constant "' + this.valueType + '"');
  }
};

/**
 * Get string representation
 * @return {String} str
 */
ConstantNode.prototype.toString = function() {
  switch (this.valueType) {
    case 'string':
      return '"' + this.value + '"';

    default:
      return this.value;
  }
};

/**
 * Get LaTeX representation
 * @return {String} str
 */
ConstantNode.prototype.toTex = function() {
  var value = this.value,
      index;
  switch (this.valueType) {
    case 'string':
      return '\\text{' + value + '}';

    case 'number':
      index = value.toLowerCase().indexOf('e');
      if (index !== -1) {
        return value.substring(0, index) + ' \\cdot 10^{' +
            value.substring(index + 1) + '}';
      }
      return value;

    default:
      return value;
  }
};

module.exports = ConstantNode;

},{"./Node":192,"../../util/types":313,"../../util/string":191,"decimal.js":173}]},{},[1])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvc3JjL2luZGV4LmNvZmZlZSIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL3NyYy9maXRuZXNzLmNvZmZlZSIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9zcmMvbmV0d29yay5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9zcmMvdmlld3MvdXNlci12aWV3LmNvZmZlZSIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9zcmMvdmlld3MvZXhwbG9yZS12aWV3LmNvZmZlZSIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9zcmMvdmlld3MvZmF2b3JpdGUtdmlldy5jb2ZmZWUiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvc3JjL3ZpZXdzL2ltYWdlLXZpZXcuY29mZmVlIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL3NyYy9saWIvaHlwb3QuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvc3JjL2xpYi9naW1wLXBhbGV0dGUuY29mZmVlIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL3NyYy92aWV3cy9kaWFsb2ctdmlldy5jb2ZmZWUiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL2dlbmUtcG9vbC9saWIvcG9wdWxhdGlvbi5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9zcmMvdmlld3Mvc2NoZW1lcy12aWV3LmNvZmZlZSIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvZ2VuZS1wb29sL2xpYi9nZW5lLXBvb2wuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL2dydW50LWNvZmZlZWlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvc3JjL2Fubi5jb2ZmZWUiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL2NvbG9ycy1jbHVzdGVyaW5nL2luZGV4LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9jb252bmV0anMvYnVpbGQvY29udm5ldC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbG9kYXNoL2Rpc3QvbG9kYXNoLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9jb2xvcnMtY2x1c3RlcmluZy9ub2RlX21vZHVsZXMvY2FudmFzLWJyb3dzZXJpZnkvYnJvd3Nlci5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9zcmMvdmlld3MvZGV0YWlsLXZpZXcuY29mZmVlIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9jb2xvcnMtY2x1c3RlcmluZy9saWIvQ0lFNzYuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL2NvbG9ycy1jbHVzdGVyaW5nL2xpYi9zZWVkcy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvcHJvbWlzZS9pbmRleC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2luZGV4LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2luZGV4LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9hY3QtanMvYWN0LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2NvbnZlcnNpb25zLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9jb2xvcnMtY2x1c3RlcmluZy9saWIvY2x1c3RlcmluZy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlsL29iamVjdC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlsL251bWJlci5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL1Jlc3VsdFNldC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vc2VsZWN0LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3N0YXRpc3RpY3Mvc3RkLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9kb25lLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9jb3JlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9lczYtZXh0ZW5zaW9ucy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9jb25zdGFudHMuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL25vZGUtZXh0ZW5zaW9ucy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9tYXRoLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Vycm9yL2luZGV4LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvQ29tcGxleC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL1JhbmdlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvSW5kZXguanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9NYXRyaXguanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9Vbml0LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvSGVscC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL2NvbGxlY3Rpb24uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9wYXJzZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL1BhcnNlci5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9jaGFpbmluZy9TZWxlY3Rvci5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvaW5kZXguanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2luZGV4LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2V4cHJlc3Npb24vY29tcGlsZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9leHByZXNzaW9uL2V2YWwuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vZXhwcmVzc2lvbi9oZWxwLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2V4cHJlc3Npb24vcGFyc2UuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9hYnMuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9hZGQuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9jZWlsLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvY3ViZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2RpdmlkZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2RvdERpdmlkZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2RvdE11bHRpcGx5LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvZG90UG93LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvZXhwLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvZml4LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvZmxvb3IuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9nY2QuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9sY20uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cxMC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL21vZC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL211bHRpcGx5LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvbm9ybS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL3Bvdy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL3JvdW5kLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvc2lnbi5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL3NxcnQuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9zcXVhcmUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9zdWJ0cmFjdC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL3VuYXJ5TWludXMuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy91bmFyeVBsdXMuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy94Z2NkLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3JlbGF0aW9uYWwvY29tcGFyZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9yZWxhdGlvbmFsL2RlZXBFcXVhbC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9yZWxhdGlvbmFsL2VxdWFsLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3JlbGF0aW9uYWwvbGFyZ2VyLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3JlbGF0aW9uYWwvbGFyZ2VyRXEuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vcmVsYXRpb25hbC9zbWFsbGVyLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3JlbGF0aW9uYWwvc21hbGxlckVxLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3JlbGF0aW9uYWwvdW5lcXVhbC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9jb21wbGV4L2FyZy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9jb21wbGV4L2NvbmouanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vY29tcGxleC9yZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9jb21wbGV4L2ltLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9iaWdudW1iZXIuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vY29uc3RydWN0aW9uL2Jvb2xlYW4uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vY29uc3RydWN0aW9uL2NvbXBsZXguanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vY29uc3RydWN0aW9uL2luZGV4LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9tYXRyaXguanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vY29uc3RydWN0aW9uL251bWJlci5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vcGFyc2VyLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9zdHJpbmcuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vY29uc3RydWN0aW9uL3VuaXQuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L2RldC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvZGlhZy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvZXllLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9mbGF0dGVuLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9pbnYuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L29uZXMuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L3JhbmdlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9yZXNpemUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L3NpemUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L3NxdWVlemUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L3N1YnNldC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvdHJhbnNwb3NlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC96ZXJvcy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9mYWN0b3JpYWwuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vcHJvYmFiaWxpdHkvcmFuZG9tLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L3JhbmRvbUludC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9waWNrUmFuZG9tLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L3Blcm11dGF0aW9ucy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9jb21iaW5hdGlvbnMuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vc3RhdGlzdGljcy9taW4uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vc3RhdGlzdGljcy9tYXguanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vc3RhdGlzdGljcy9tZWFuLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWVkaWFuLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3N0YXRpc3RpY3MvcHJvZC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9zdGF0aXN0aWNzL3N1bS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9zdGF0aXN0aWNzL3Zhci5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNvcy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXNpbi5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbi5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbjIuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Nvcy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY29zaC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY290LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3RoLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jc2MuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NzY2guanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3NlYy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2VjaC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2luLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zaW5oLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS90YW4uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3RhbmguanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdW5pdHMvdG8uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdXRpbHMvY2xvbmUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdXRpbHMvZmlsdGVyLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3V0aWxzL2Zvcm1hdC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi91dGlscy9pbXBvcnQuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdXRpbHMvbWFwLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3V0aWxzL3ByaW50LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3V0aWxzL3NvcnQuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdXRpbHMvdHlwZW9mLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3V0aWxzL2ZvckVhY2guanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vZmlsdGVyLnRyYW5zZm9ybS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9yYW5nZS50cmFuc2Zvcm0uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vc3Vic2V0LnRyYW5zZm9ybS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvcHJvbWlzZS9ub2RlX21vZHVsZXMvYXNhcC9hc2FwLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3ZlcnNpb24uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXJyb3IvQXJndW1lbnRzRXJyb3IuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9ub2RlX21vZHVsZXMvZGVjaW1hbC5qcy9kZWNpbWFsLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Vycm9yL0luZGV4RXJyb3IuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXJyb3IvRGltZW5zaW9uRXJyb3IuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXJyb3IvVW5zdXBwb3J0ZWRUeXBlRXJyb3IuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9lLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvZmFsc2UuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9pLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvSW5maW5pdHkuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9MTjIuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9MTjEwLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvTE9HMkUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9MT0cxMEUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9OYU4uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9udWxsLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvcGkuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9waGkuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9TUVJUMV8yLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvU1FSVDIuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy90YXUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy90cnVlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvdmVyc2lvbi5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9hYnMuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvYWRkLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2NlaWwuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvY3ViZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9kaXZpZGUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvZG90RGl2aWRlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2RvdE11bHRpcGx5LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2RvdFBvdy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9leHAuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvZml4LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2Zsb29yLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2djZC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9sY20uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvbG9nLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2xvZzEwLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL21vZC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9tdWx0aXBseS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9ub3JtLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL3Bvdy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9yb3VuZC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9zaWduLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL3NxcnQuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvc3F1YXJlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL3N1YnRyYWN0LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL3VuYXJ5TWludXMuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvdW5hcnlQbHVzLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL3hnY2QuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3JlbGF0aW9uYWwvY29tcGFyZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcmVsYXRpb25hbC9kZWVwRXF1YWwuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3JlbGF0aW9uYWwvZXF1YWwuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3JlbGF0aW9uYWwvbGFyZ2VyLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9yZWxhdGlvbmFsL2xhcmdlckVxLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9yZWxhdGlvbmFsL3NtYWxsZXIuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3JlbGF0aW9uYWwvc21hbGxlckVxLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9yZWxhdGlvbmFsL3VuZXF1YWwuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbXBsZXgvYXJnLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb21wbGV4L2NvbmouanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbXBsZXgvcmUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbXBsZXgvaW0uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9iaWdudW1iZXIuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9ib29sZWFuLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vY29tcGxleC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vY29uc3RydWN0aW9uL2luZGV4LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vbWF0cml4LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vbnVtYmVyLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vc3RyaW5nLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vdW5pdC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vZXhwcmVzc2lvbi9ldmFsLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9leHByZXNzaW9uL2hlbHAuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9jb25jYXQuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9kZXQuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9kaWFnLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvZXllLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvZmxhdHRlbi5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L2ludi5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L29uZXMuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9yYW5nZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L3Jlc2l6ZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L3NpemUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9zcXVlZXplLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvc3Vic2V0LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvdHJhbnNwb3NlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvemVyb3MuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L2NvbWJpbmF0aW9ucy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcHJvYmFiaWxpdHkvZmFjdG9yaWFsLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9wcm9iYWJpbGl0eS9wZXJtdXRhdGlvbnMuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L3BpY2tSYW5kb20uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L3JhbmRvbS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcHJvYmFiaWxpdHkvcmFuZG9tSW50LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9zdGF0aXN0aWNzL21heC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vc3RhdGlzdGljcy9tZWFuLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9zdGF0aXN0aWNzL21lZGlhbi5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vc3RhdGlzdGljcy9taW4uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3N0YXRpc3RpY3MvcHJvZC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vc3RhdGlzdGljcy9zdGQuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3N0YXRpc3RpY3Mvc3VtLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9zdGF0aXN0aWNzL3Zhci5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Fjb3MuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2luLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbi5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2F0YW4yLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvY29zLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvY29zaC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NvdC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NvdGguanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jc2MuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jc2NoLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2VjLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2VjaC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3Npbi5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3NpbmguanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS90YW4uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS90YW5oLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi91bml0cy90by5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdXRpbHMvY2xvbmUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3V0aWxzL21hcC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdXRpbHMvZmlsdGVyLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi91dGlscy9mb3JFYWNoLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi91dGlscy9mb3JtYXQuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3V0aWxzL2ltcG9ydC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdXRpbHMvc29ydC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdXRpbHMvdHlwZW9mLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWwvdHlwZXMuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbC9ib29sZWFuLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWwvYXJyYXkuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbC9pbmRleC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvQXJyYXlOb2RlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9Bc3NpZ25tZW50Tm9kZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvQmxvY2tOb2RlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9GdW5jdGlvbkFzc2lnbm1lbnROb2RlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9PcGVyYXRvck5vZGUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL0Z1bmN0aW9uTm9kZS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvUmFuZ2VOb2RlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9TeW1ib2xOb2RlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9VcGRhdGVOb2RlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9ncnVudC1jb2ZmZWVpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvaW5kZXguanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL05vZGUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vcHJvYmFiaWxpdHkvZGlzdHJpYnV0aW9uLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vdHJhbnNmb3JtL2Vycm9yLnRyYW5zZm9ybS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2tleXdvcmRzLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9ncnVudC1jb2ZmZWVpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvc2hhLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9ncnVudC1jb2ZmZWVpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvcm5nLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9ncnVudC1jb2ZmZWVpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbWQ1LmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9jb25jYXQuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vY29uY2F0LnRyYW5zZm9ybS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9pbmRleC50cmFuc2Zvcm0uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vZm9yRWFjaC50cmFuc2Zvcm0uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vbWFwLnRyYW5zZm9ybS5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9tYXgudHJhbnNmb3JtLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vdHJhbnNmb3JtL21lYW4udHJhbnNmb3JtLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vdHJhbnNmb3JtL21pbi50cmFuc2Zvcm0uanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbC9sYXRleC5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlsL2JpZ251bWJlci5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlsL3N0cmluZy5qcyIsIi9ob21lL3plbm96ZW5nL2hvbWUvY29kZS9jb2NvbG91ci9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvQ29uZGl0aW9uYWxOb2RlLmpzIiwiL2hvbWUvemVub3plbmcvaG9tZS9jb2RlL2NvY29sb3VyL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9JbmRleE5vZGUuanMiLCIvaG9tZS96ZW5vemVuZy9ob21lL2NvZGUvY29jb2xvdXIvbm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL0NvbnN0YW50Tm9kZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7Q0FBQSxLQUFBLDJDQUFBOztBQUFJLENBQUosQ0FBQSxDQUFBLENBQUcsQ0FBTSxJQUFVO0NBQ2YsRUFBdUIsQ0FBdkIsRUFBTSxFQUFTLGlCQUFmO0lBREo7O0NBQUEsQ0FJQSxRQUFBLHdDQUFBOztDQUpBLENBT0EsQ0FBVyxJQUFBLENBQVgsa0JBQVc7O0NBUFgsQ0FRQSxDQUFZLElBQUEsRUFBWixrQkFBWTs7Q0FSWixDQVNBLENBQWMsSUFBQSxJQUFkLGtCQUFjOztDQVRkLENBVUEsQ0FBZSxJQUFBLEtBQWYsa0JBQWU7O0NBVmYsQ0FZQSxDQUFJLElBQUEsQ0FBQTs7Q0FaSixDQWFBLENBQUUsTUFBQTtDQUVFLEdBQUksSUFBQTtDQUFKLEdBR0ksS0FBQTtDQUhKLEVBTTBCLENBQTFCLENBQUEsSUFBMEIsT0FBMUI7Q0FDSSxLQUFBLEdBQUEsRUFBQSxhQUFBO0NBQ0EsR0FBQSxJQUFBLENBQUEsSUFBQTtDQUZKLElBQTBCO0NBTjFCLEVBU3VCLENBQXZCLENBQUEsSUFBdUIsSUFBdkI7Q0FBOEIsR0FBQSxLQUFBLElBQUE7Q0FBOUIsSUFBdUI7Q0FUdkIsRUFVd0IsQ0FBeEIsQ0FBQSxJQUF3QixLQUF4QjtDQUErQixHQUFBLE9BQUEsRUFBQTtDQUEvQixJQUF3QjtDQUN4QixFQUF5QixFQUF6QixJQUF5QixFQUF6QixJQUFBO0NBQWdDLEdBQUEsUUFBQSxDQUFBO0NBQWhDLElBQXlCO0NBYjdCLEVBQUU7Q0FiRjs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDditSQTtDQUFBLEtBQUEsb0JBQUE7O0NBQUEsQ0FBQSxDQUFBLElBQU0sT0FBQTs7Q0FBTixDQUNBLENBQVUsSUFBVixJQUFVOztDQURWLENBR0EsQ0FBQSxJQUFNLENBQUE7O0NBSE4sQ0FLQSxDQUFVLEdBQUEsQ0FBVixFQUFXO0NBQWUsRUFBRCxDQUFILE9BQUE7Q0FBUyxDQUFRLElBQVA7Q0FBdEIsS0FBWTtDQUx0QixFQUtVOztDQUxWLENBUUEsQ0FBaUIsR0FBWCxDQUFOO0NBUkE7Ozs7O0FDQUE7QUFDQTtBQUNBOztBQ0FBO0NBQUEsS0FBQSxxQkFBQTs7Q0FBQSxDQUFBLENBQUksSUFBQSxDQUFBOztDQUFKLENBQ0EsQ0FBSyxHQUFNOztDQURYLENBRUEsQ0FBYSxJQUFBLEdBQWIsWUFBYTs7Q0FGYixDQUlNO0NBRVcsRUFBQSxDQUFBLGNBQUE7Q0FDVCxHQUFHLEVBQUgsRUFBVztDQUNQLE9BQWUsT0FBUjtRQURYO0NBQUEsRUFFb0IsQ0FGcEIsRUFFQSxFQUFRO0NBRlIsR0FHQyxFQUFELEdBQUE7Q0FIQSxDQUlBLEVBQUMsRUFBRDtDQUxKLElBQWE7O0NBQWIsRUFPVyxNQUFYO0NBQ0ksU0FBQTtDQUFBLENBQVMsQ0FBRixDQUFQLEVBQUEsQ0FBTztDQUNQLEdBQUcsRUFBSCxNQUFBO0NBQ0ksRUFBTyxDQUFQLEVBQU8sQ0FBUCxDQUFBLEVBQStCO0NBQS9CLEdBQ0EsSUFBQSxxQkFEQTtDQUFBLEdBRUEsSUFBQSxPQUFBO01BSEosRUFBQTtDQUtJLEVBQU8sQ0FBUCxJQUFBLGdFQUFBO0NBQUEsR0FDQSxJQUFBLE9BQUE7UUFQSjtDQVFBLEVBQXlCLENBQXpCLEVBQWdCLENBQWhCLE1BQUE7Q0FoQkosSUFPVzs7Q0FQWCxFQWtCa0IsTUFBQSxPQUFsQjtDQUNJLFNBQUEsYUFBQTtTQUFBLEdBQUE7Q0FBQSxFQUFPLENBQVAsRUFBQSxpU0FBQTtDQUFBLEVBVVEsQ0FBQSxDQUFSLENBQUE7Q0FWQSxFQVcyQyxDQUEzQyxDQUFLLENBQUwsR0FBMkMsZUFBM0M7Q0FBK0MsSUFBQSxVQUFELFNBQUE7Q0FBOUMsTUFBMkM7Q0FYM0MsRUFhaUIsQ0FBQSxDQUFBLENBQWpCLElBQUE7Q0FFTSxFQUFzQixDQUE1QixDQUFLLElBQUwsSUFBQTtDQUVJLFdBQUEsNEJBQUE7Q0FBQSxDQUFhLENBQUYsQ0FBWCxJQUFBO0NBQUEsRUFFVyxDQUFBLENBQUssR0FBaEIsR0FBVztDQUZYLEVBR1csQ0FBQSxDQUFLLEdBQWhCLEdBQVc7Q0FIWCxFQUtRLEVBQVIsR0FBQTtDQUxBLEVBUUksSUFESixDQUFBO0NBQ0ksQ0FBUyxDQUFBLENBQUEsR0FBVCxFQUFVLENBQVY7Q0FDSSxJQUFDLElBQUQsR0FBQTtDQUNXLEdBQVgsTUFBVSxTQUFWO0NBRkosVUFBUztDQUFULENBR08sQ0FBQSxDQUFBLENBQVAsSUFBUSxDQUFSO0NBQ1UsRUFBWSxDQUFaLENBQU4sRUFBQSxFQUFNLFVBQU47Q0FKSixVQUdPO0NBWFgsU0FBQTtDQWFHLENBQUQsRUFBSyxDQUFQLEVBQUEsQ0FBQSxPQUFBO0NBZkosTUFBNEI7Q0FsQ2hDLElBa0JrQjs7Q0FsQmxCLEVBbURtQixNQUFBLFFBQW5CO0NBRUksU0FBQSxhQUFBO1NBQUEsR0FBQTtDQUFBLEVBQU8sQ0FBUCxFQUFBLHlTQUFBO0NBQUEsRUFVUSxDQUFBLENBQVIsQ0FBQTtDQVZBLEVBWWlCLENBQUEsQ0FBQSxDQUFqQixJQUFBO0NBRU0sRUFBc0IsQ0FBNUIsQ0FBSyxJQUFMLElBQUE7Q0FFSSxXQUFBLDRCQUFBO0NBQUEsQ0FBYSxDQUFGLENBQVgsSUFBQTtDQUFBLEVBRVcsQ0FBQSxDQUFLLEdBQWhCLEdBQVc7Q0FGWCxFQUdXLENBQUEsQ0FBSyxHQUFoQixHQUFXO0NBSFgsRUFJUSxDQUFBLENBQVIsR0FBQTtDQUpBLENBTXFCLENBQXJCLENBQUksSUFBSixFQUFBO0NBTkEsQ0FPcUIsQ0FBckIsQ0FBSSxJQUFKLEVBQUE7Q0FQQSxDQVFrQixDQUFsQixDQUFJLENBQUosRUFBQSxDQUFBO0NBUkEsRUFXSSxJQURKLENBQUE7Q0FDSSxDQUFTLENBQUEsQ0FBQSxHQUFULEVBQVUsQ0FBVjtDQUNJLElBQUMsSUFBRCxHQUFBO0NBQ1csR0FBWCxNQUFVLFNBQVY7Q0FGSixVQUFTO0NBQVQsQ0FHTyxDQUFBLENBQUEsQ0FBUCxJQUFRLENBQVI7Q0FDVSxFQUFZLENBQVosQ0FBTixFQUFBLEVBQU0sVUFBTjtDQUpKLFVBR087Q0FkWCxTQUFBO0NBZ0JLLENBQWEsRUFBZCxFQUFKLENBQUEsUUFBQTtDQWxCSixNQUE0QjtDQW5FaEMsSUFtRG1COztDQW5EbkIsRUF1RjBCLE1BQUEsZUFBMUI7Q0FFSSxTQUFBLGFBQUE7Q0FBQSxFQUFPLENBQVAsRUFBQSxxS0FBQTtDQUFBLEVBUVEsQ0FBQSxDQUFSLENBQUE7Q0FSQSxFQVVpQixDQUFBLENBQUEsQ0FBakIsSUFBQTtDQUVNLEVBQXNCLENBQTVCLENBQUssSUFBTCxJQUFBO0NBQ0ksV0FBQSxFQUFBO0NBQUEsRUFBTSxFQUFOLEdBQUEsZ0JBQU07Q0FBTixFQUVJLElBREosQ0FBQTtDQUNJLENBQVMsQ0FBQSxJQUFULEVBQVMsQ0FBVDtDQUNlLEdBQVgsTUFBVSxTQUFWO0NBREosVUFBUztDQUFULENBRU8sQ0FBQSxFQUFQLElBQVEsQ0FBUjtDQUNVLEVBQVksQ0FBWixDQUFOLEVBQUEsRUFBTSxVQUFOO0NBSEosVUFFTztDQUpYLFNBQUE7Q0FNRyxDQUFELEVBQUssQ0FBUCxFQUFBLFFBQUEsS0FBQTtDQVBKLE1BQTRCO0NBckdoQyxJQXVGMEI7O0NBdkYxQixDQThHTSxDQUFBLENBQU4sS0FBTztDQUNILFNBQUEsRUFBQTtDQUFBLENBQUEsQ0FBd0MsR0FBeEMsQ0FBQSxFQUF3QyxNQUF4QztDQUE0QyxJQUFBLFVBQUQsQ0FBQTtDQUEzQyxNQUF3QztDQUF4QyxDQUNBLENBQXlDLEdBQXpDLENBQUEsRUFBeUMsT0FBekM7Q0FBNkMsSUFBQSxVQUFELEVBQUE7Q0FBNUMsTUFBeUM7Q0FDekMsQ0FBQSxDQUFrQyxJQUFsQyxFQUFBLElBQUE7Q0FDSSxDQUFFLEVBQUssRUFBUCxFQUFBO0NBQ0ssR0FBRCxLQUFKLE1BQUE7Q0FGSixNQUFrQztDQWpIdEMsSUE4R007O0NBOUdOOztDQU5KOztDQUFBLENBMkhBLENBQWlCLEdBQVgsQ0FBTixDQTNIQTtDQUFBOzs7OztBQ0ZBO0NBQUEsS0FBQSx5QkFBQTs7Q0FBQSxDQUFBLENBQWMsSUFBQSxJQUFkLFlBQWM7O0NBQWQsQ0FDQSxDQUFJLElBQUEsQ0FBQTs7Q0FESixDQUVBLENBQUssR0FBTTs7Q0FGWCxDQUlNO0NBRVcsRUFBQSxDQUFBLGlCQUFBO0NBQ1QsU0FBQSxHQUFBO0NBQUEsQ0FBVyxDQUFGLEdBQVQsRUFBUztDQUFULENBQ2MsQ0FBRixDQUFBLENBQVosQ0FBQTtDQURBLENBRXVCLEdBQWxCLENBQUwsQ0FBQTtDQUZBLEVBR0EsQ0FBQSxDQUFLLENBQUw7Q0FBc0IsQ0FDVCxDQUFBLElBQVQsQ0FBQSxDQUFVO0NBQ04sRUFBVSxHQUFZLENBQXRCLEVBQXVCLENBQXZCO0NBQ1MsR0FBRCxDQUFKLENBQWlCLElBQVcsU0FBNUI7Q0FETSxVQUFZO0NBQXRCLEdBRUksR0FBQSxHQUFBLENBQUE7Q0FDSixHQUFBLElBQUEsU0FBQTtDQUxjLFFBQ1Q7Q0FKYixPQUdBO0NBSkosSUFBYTs7Q0FBYjs7Q0FOSjs7Q0FBQSxDQWtCQSxDQUFpQixHQUFYLENBQU4sSUFsQkE7Q0FBQTs7Ozs7QUNBQTtDQUFBLEtBQUEsMEJBQUE7O0NBQUEsQ0FBQSxDQUFjLElBQUEsSUFBZCxZQUFjOztDQUFkLENBQ0EsQ0FBSSxJQUFBLENBQUE7O0NBREosQ0FFQSxDQUFLLEdBQU07O0NBRlgsQ0FJTTtDQUVXLEVBQUEsQ0FBQSxrQkFBQTtDQUNULFNBQUEsbUJBQUE7Q0FBQSxDQUFTLENBQUYsQ0FBUCxFQUFBLENBQU87Q0FDUCxHQUFHLEVBQUg7Q0FDSSxFQUFXLENBQUksSUFBZixFQUEwQjtDQUExQixDQUNXLENBQUYsR0FBVCxFQUFBO0NBREEsQ0FFYyxDQUFGLENBQUEsQ0FBWixDQUFZLEVBQVo7Q0FGQSxJQUdLLEdBQUwsRUFBQSxDQUFBO0NBSEEsQ0FJdUIsR0FBbEIsRUFBTCxDQUFBO0NBSkEsQ0FLdUIsR0FBbEIsRUFBTCxDQUFBO0NBTEEsRUFNQSxDQUFBLENBQUssR0FBTDtDQUFzQixDQUNULENBQUEsSUFBVCxFQUFVLENBQVY7Q0FDSSxJQUFBLFdBQUE7Q0FBQSxFQUFVLEdBQVksQ0FBdEIsRUFBdUIsR0FBdkI7Q0FDUyxHQUFELENBQUosQ0FBaUIsSUFBVyxXQUE1QjtDQURNLFlBQVk7Q0FBdEIsQ0FFeUIsQ0FBUSxDQUE3QixDQUFxQixFQUFyQixJQUFBLENBQUE7Q0FDSixHQUFBLElBQUEsV0FBQTtDQUxjLFVBQ1Q7Q0FQYixTQU1BO1FBVEs7Q0FBYixJQUFhOztDQUFiOztDQU5KOztDQUFBLENBd0JBLENBQWlCLEdBQVgsQ0FBTixLQXhCQTtDQUFBOzs7OztBQ0FBO0NBQUEsS0FBQSxvRUFBQTs7Q0FBQSxDQUFBLENBQW1CLElBQUEsU0FBbkIsR0FBbUI7O0NBQW5CLENBQ0EsQ0FBVyxJQUFBLENBQVgsR0FBVzs7Q0FEWCxDQUVBLENBQVUsSUFBVixZQUFVOztDQUZWLENBR0EsQ0FBSSxJQUFBLENBQUE7O0NBSEosQ0FLQSxDQUFjLElBQUEsSUFBZCxZQUFjOztDQUxkLENBT0EsQ0FBYSxNQUFDLENBQWQ7Q0FDSSxPQUFBLGFBQUE7Q0FBQSxFQUNJLENBREosRUFBQTtDQUNJLENBQUssQ0FBTCxHQUFBO0NBQUEsQ0FDVSxJQUFWLEVBQUE7Q0FGSixLQUFBO0NBQUEsRUFJZ0IsQ0FBaEIsSUFBZ0IsQ0FBQyxJQUFqQjtDQUNJLEdBQUEsTUFBQTtDQUFBLEVBQU8sQ0FBUCxFQUFBLENBQW9CLENBQUwsQ0FBTTtDQUNqQixJQUFBLE9BQUE7Q0FBQSxFQUFRLEVBQVIsRUFBZSxDQUFmO0NBQzRDLEVBQUEsQ0FBQSxDQUFLLFVBQWhELDZCQUFBO0NBRkUsTUFBYTtDQUFwQixDQUc2QixDQUFyQixDQUFSLEVBQUEsRUFIQSxjQUdRO0NBQ1IsR0FBQSxLQUFBLElBQUE7Q0FUSixJQUlnQjtDQUpoQixDQVd5QixDQUFBLENBQXpCLEVBQUEsRUFBeUIsQ0FBQyxPQUExQjtDQUNJLFNBQUEsUUFBQTtDQUFBLENBQWtCLENBQUosQ0FBZCxFQUFBLEVBQVEsQ0FBTztDQUFVLEVBQVUsR0FBWCxTQUFBO0NBQXhCLE1BQWM7Q0FBZCxLQUNBLEVBQUEsS0FBQTtDQURBLEVBR0ksQ0FESixFQUFBO0NBQ0ksQ0FBTyxDQUFBLEVBQVAsR0FBQSxDQUFxQjtDQUFnQixJQUFELFlBQUw7Q0FBeEIsUUFBYTtDQUFwQixDQUNTLENBQUEsRUFBYSxFQUF0QixDQUFBLENBQXVCO0NBQWdCLElBQUQsWUFBTDtDQUF4QixRQUFhO0NBRHRCLENBRUcsTUFBSDtDQUZBLENBR0csTUFBSDtDQUhBLENBSWMsQ0FKZCxLQUlBLElBQUE7Q0FKQSxDQUtXLE1BQVgsQ0FBQTtDQUxBLENBTVMsS0FBVCxDQUFBO0NBVEosT0FBQTtDQUFBLEVBVW1CLENBQUEsRUFBbkIsRUFBbUIsSUFBbkI7Q0FDYSxDQUFhLENBQTFCLElBQUEsRUFBMkIsR0FBZixDQUFaO0NBQ0ksRUFBQSxDQUFzQixJQUF0QjtDQUFBLEVBQUEsRUFBQSxFQUFPLEdBQVA7VUFBQTtDQUNnQixHQUFaLEdBQUEsSUFBQSxJQUFBO0NBRlIsTUFBMEI7Q0FaOUIsSUFBeUI7Q0FlekIsRUFBQSxLQUFBLEdBQUE7Q0FBZ0IsQ0FBbUIsQ0FBSyxHQUF2QixTQUFBO0NBM0JSLEtBMkJUO0NBbENKLEVBT2E7O0NBUGIsQ0FvQ007Q0FDVyxFQUFBLENBQUEsZUFBQztDQUVWLEtBQUEsSUFBQTs7R0FGZ0IsS0FBTjtRQUVWO0NBQUEsR0FBQSxFQUFBLEVBQUE7Q0FBQSxFQUdBLEdBQUEsSUFBQTtDQUhBLEVBTVMsR0FBVCxFQUFTO0NBTlQsRUFPb0IsRUFBQSxDQUFwQixHQUFxQixDQUFyQjtDQUFxQyxJQUFELFNBQUwsQ0FBQTtDQVAvQixNQU9vQjtDQVBwQixFQVFtQixFQUFBLENBQW5CLEdBQUE7Q0FBb0MsSUFBRCxTQUFMLENBQUE7Q0FSOUIsTUFRbUI7Q0FSbkIsRUFTcUIsRUFBQSxDQUFyQixHQUFzQixFQUF0QjtDQUFzQyxJQUFELFNBQUwsQ0FBQTtDQVRoQyxNQVNxQjtDQVRyQixFQVVxQixFQUFBLENBQXJCLEdBQXNCLEVBQXRCO0NBQXNDLElBQUQsU0FBTCxDQUFBO0NBVmhDLE1BVXFCO0NBVnJCLEVBV2dCLEVBQUEsQ0FBaEIsR0FBaUI7Q0FBZ0IsSUFBRCxTQUFMLENBQUE7Q0FYM0IsTUFXZ0I7Q0FYaEIsRUFZZ0IsRUFBQSxDQUFoQixHQUFpQjtDQUNiLElBQUssR0FBTCxNQUFBO0NBQUEsRUFDQSxFQUErQixHQUEvQixJQUE0QyxHQUF0QztDQUNLLEVBQVgsT0FBQSxLQUFBO0NBZkosTUFZZ0I7Q0FaaEIsQ0FnQkEsQ0FBNkIsR0FBN0IsQ0FBQSxFQUE2QixJQUE3QjtDQUNJLEtBQUEsTUFBQTtDQUFBLEVBQVMsR0FBVCxFQUFBLGFBQVM7Q0FBVCxLQUNBLEVBQUE7Q0FEQSxDQUVBLENBQW9CLEdBQWQsRUFBTixDQUFxQjtDQUNqQixJQUFBLFNBQUE7Q0FBQSxFQUFRLEVBQVIsQ0FBZSxJQUFmO0NBQ0EsR0FBRyxDQUFILEtBQUE7Q0FDSSxFQUFBLEVBQWdDLE9BQWhDLEdBQU07Q0FBTixFQUNBLE9BQUEsRUFBQTtDQUNPLEtBQUQsYUFBTjtZQUxZO0NBQXBCLFFBQW9CO0NBTWIsSUFBUCxDQUFNLFNBQU47Q0FUSixNQUE2QjtDQWxCakMsSUFBYTs7Q0FBYjs7Q0FyQ0o7O0NBQUEsQ0FrRUEsQ0FBaUIsR0FBWCxDQUFOLEVBbEVBO0NBQUE7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0NBQUEsS0FBQSxFQUFBOztDQUFBLENBQUEsQ0FBVyxDQUFBLEdBQUEsQ0FBWCxDQUFZO0NBQ1IsRUFBQSxLQUFBO0NBQUEsRUFBQSxDQUFBLENBQUEsaUJBQVM7Q0FBVCxFQUdBLENBQUE7Q0FIQSxFQUlnQixDQUFoQixFQUFnQixDQUFULEVBQVU7Q0FDYixFQUFBLENBQU8sRUFBUDtDQURZLEVBRVosQ0FBTyxTQUFQO0NBRkosSUFBZ0I7Q0FMVCxVQVFQO0NBUkosRUFBVzs7Q0FBWCxDQVVBLENBQWlCLEdBQVgsQ0FBTixDQVZBO0NBQUE7Ozs7O0FDREE7Q0FBQSxLQUFBLE9BQUE7O0NBQUEsQ0FBQSxDQUFJLElBQUEsQ0FBQTs7Q0FBSixDQUVNO0NBRVcsRUFBQSxDQUFBLEtBQUEsV0FBQztDQUNWLElBQUEsS0FBQTtDQUFBLEVBQVEsRUFBUixDQUFBLEdBQVE7Q0FBUixDQUNBLEVBQUEsQ0FBSyxDQUFMO0NBREEsSUFFSyxDQUFMLEdBQUE7QUFFTyxDQUFQLEdBQUEsQ0FBQSxDQUFBLElBQWlCO0NBQ2IsR0FBQyxJQUFEO0NBQUEsRUFDbUIsQ0FEbkIsQ0FDQSxHQUFBLEVBQVU7UUFOZDtDQUFBLElBUUssQ0FBTDtDQVRKLElBQWE7O0NBQWIsRUFXTSxDQUFOLEtBQU07Q0FFRixJQUFBLEtBQUE7U0FBQSxHQUFBO0NBQUEsQ0FBQSxDQUEwQixHQUExQixFQUFBLENBQUE7Q0FDSSxDQUFBLEVBQVcsQ0FBYSxFQUFiLENBQVg7Q0FBQyxHQUFELENBQUMsWUFBRDtVQURzQjtDQUExQixNQUEwQjtDQUExQixFQUdRLEVBQVIsQ0FBQSxHQUFRO0NBQ0YsQ0FBTixDQUFrQixFQUFiLEVBQUwsRUFBbUIsSUFBbkI7Q0FDSSxDQUFXLEVBQUEsQ0FBZSxDQUFQLEVBQW5CO0NBQUMsR0FBRCxDQUFDLFlBQUQ7VUFEYztDQUFsQixNQUFrQjtDQWpCdEIsSUFXTTs7Q0FYTixFQW9CTSxDQUFOLEtBQU07Q0FDRixNQUFBLEVBQUEsSUFBQTtDQXJCSixJQW9CTTs7Q0FwQk47O0NBSko7O0NBQUEsQ0EyQkEsQ0FBaUIsR0FBWCxDQUFOLEdBM0JBO0NBQUE7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0NBQUEsS0FBQSw0Q0FBQTs7Q0FBQSxDQUFBLENBQUssR0FBTTs7Q0FBWCxDQUNBLENBQUksSUFBQSxDQUFBOztDQURKLENBRUEsQ0FBYSxJQUFBLEdBQWIsWUFBYTs7Q0FGYixDQUlBLENBQVcsSUFBQSxDQUFYLENBQVk7Q0FDUixHQUFBLEdBQVUsQ0FBUCxFQUFBLEdBQUE7Q0FBSCxZQUNJO0NBQ1ksR0FBUixFQUZSLENBRWUsQ0FBUCxFQUFBLEdBQUE7QUFDSCxDQUFELFlBQUE7TUFISjtDQUFBLFlBS0k7TUFORztDQUpYLEVBSVc7O0NBSlgsQ0FZQSxDQUFXLEVBQUEsRUFBQSxDQUFYLENBQVk7Q0FFUixPQUFBLHFDQUFBO0NBQUEsRUFBUyxDQUFULEVBQUEsQ0FBZ0IsQ0FBUDtDQUFULENBQ2dCLENBQUosQ0FBWixFQUFNLEdBQU87Q0FDUixDQUFhLENBQVAsQ0FBUCxDQUFPLElBQUMsSUFBUjtDQUFpQyxFQUFGLENBQVAsQ0FBUyxVQUFUO0NBQXhCLE1BQU87Q0FEWCxJQUFZO0NBRFosRUFHUyxDQUFULEVBQUE7Q0FIQSxFQUlTLENBQVQsRUFBQSxHQUFTO0NBSlQsQ0FLUyxDQUFGLENBQVAsR0FBTztBQUVBLENBQVAsR0FBQTtDQUNJLElBQUEsQ0FBQSxTQUFBO0NBQ0EsV0FBQTtNQVRKO0NBQUEsQ0FXb0QsQ0FBUSxDQUE1RCxDQUFvRCxFQUE3QyxHQUFQLENBQUEsRUFBQTtDQVhBLENBWW9ELENBQVEsQ0FBNUQsQ0FBb0QsRUFBN0MsR0FBUCxDQUFBLEVBQUE7Q0FaQSxFQWNZLENBQVosSUFBQSxFQUEyQjtDQWQzQixDQWdCVyxDQUFGLENBQVQsRUFBQSxFQUFTO0NBaEJULENBa0JjLENBQUYsQ0FBWixDQUFBLENBQVk7Q0FsQlosQ0FtQndCLEVBQXhCLENBQUssQ0FBTCxDQUFBLENBQUE7Q0FuQkEsQ0FvQnVCLEVBQXZCLENBQUssRUFBTCxDQUFBO0NBQ00sR0FBTixDQUFLLE1BQUw7Q0FBVyxDQUNFLENBQUEsR0FBVCxDQUFBLEVBQVU7Q0FDTixVQUFBLENBQUE7Q0FBQSxHQUFHLENBQWlCLENBQVgsRUFBVDtDQUNJLEVBQWEsQ0FBQSxFQUFiLElBQUE7Q0FBQSxDQUVxQixDQUFyQixHQUFNLEVBQU4sRUFBQTtDQUZBLENBR3FCLENBQXJCLEdBQU0sRUFBTixFQUFBO0NBSEEsQ0FJb0IsQ0FBcEIsRUFBQSxDQUFNLENBQU4sR0FBQTtDQUpBLENBTW9CLENBQXBCLEdBQU0sQ0FBTixDQUFBLEVBQUE7Q0FOQSxDQU9ZLENBQVosQ0FBVSxHQUFPLEdBQWpCO0NBUEEsRUFRRyxDQUFILE1BQUEsU0FBQTtDQVJBLEVBU0EsR0FBTSxJQUFOO0NBQ08sR0FBUCxFQUFNLFdBQU47TUFYSixJQUFBO0NBY0ksRUFBUyxHQUFULElBQUE7Q0FBQSxDQUNvQixDQUFwQixFQUFBLENBQU0sQ0FBTixHQUFBO0NBQ08sR0FBUCxFQUFNLFdBQU47VUFqQkM7Q0FERixNQUNFO0NBeEJOLEtBdUJQO0NBbkNKLEVBWVc7O0NBWlgsQ0F3RE07Q0FFVyxDQUFXLENBQVgsQ0FBQSxDQUFBLEVBQUEsY0FBQztDQUNWLFNBQUE7Q0FBQSxFQURvQixDQUFBLEVBQUQ7Q0FDbkIsRUFBYSxHQUFiLElBQUE7Q0FBQSxDQUNBLEVBQUEsRUFBQSxJQUFVO0NBRFYsR0FFbUIsRUFBbkIsQ0FBa0IsQ0FBQSxFQUFSO0NBSGQsSUFBYTs7Q0FBYixFQUtVLElBQUEsQ0FBVixDQUFXO0NBQ1AsU0FBQSxFQUFBO0NBQVEsRUFBUixHQUFZLENBQUwsRUFBTSxJQUFiO0NBQXlCLElBQUEsQ0FBRCxRQUFBLENBQUE7Q0FBeEIsTUFBWTtDQU5oQixJQUtVOztDQUxWLEVBU2dCLEdBQUEsR0FBQyxLQUFqQjtDQUVJLFNBQUEsZUFBQTtDQUFBLENBQWdCLENBQUosQ0FBWixFQUFBLEdBQWE7Q0FDUixDQUFhLENBQVAsQ0FBUCxDQUFPLElBQUMsTUFBUjtDQUFpQyxFQUFGLENBQVAsQ0FBUyxZQUFUO0NBQXhCLFFBQU87Q0FEWCxNQUFZO0NBQVosRUFHYSxFQUFXLENBQXhCLEdBQXlCLENBQXpCO0NBQStFLEVBQUEsQ0FBQSxDQUFLLFVBQWhELDZCQUFBO0NBQXZCLE1BQVc7Q0FIeEIsQ0FLeUIsQ0FEakIsQ0FBUixFQUFBLEdBQTBDLENBQ1AseUJBRDNCLENBQUEsa0lBSlI7Q0FBQSxFQVNVLENBQUEsRUFBVixDQUFBO0NBVEEsQ0FZb0QsQ0FBUyxDQUE3RCxDQUFvRCxDQUFwRCxDQUFPLEdBQVAsQ0FBQSxFQUFBO0NBWkEsQ0Fhb0QsQ0FBUyxDQUE3RCxDQUFvRCxDQUFwRCxDQUFPLEdBQVAsQ0FBQSxFQUFBO0NBYkEsQ0FlQSxDQUFtQyxHQUFuQyxDQUFPLEVBQTRCLElBQW5DO0NBQ0ksR0FBRyxDQUFxQixFQUFyQixDQUFIO0NBQXdDLENBQVMsS0FBbEIsQ0FBQSxTQUFBO01BQS9CLElBQUE7Q0FBa0UsQ0FBUyxLQUFsQixDQUFBLFNBQUE7VUFEMUI7Q0FBbkMsTUFBbUM7Q0FmbkMsQ0FpQkEsQ0FBbUMsR0FBbkMsQ0FBTyxFQUE0QixJQUFuQztBQUM2QixDQUF6QixHQUFHLENBQXFCLEVBQXJCLENBQUg7Q0FBeUMsQ0FBUyxLQUFsQixDQUFBLFNBQUE7TUFBaEMsSUFBQTtBQUE2RSxDQUFWLENBQVMsS0FBbEIsQ0FBQSxTQUFBO1VBRDNCO0NBQW5DLE1BQW1DO0NBakJuQyxDQW1CQSxDQUF3QyxHQUF4QyxDQUFPLEVBQWlDLFNBQXhDO0NBQ21CLEdBQVgsRUFBQSxJQUFBLEtBQUE7Q0FEUixNQUF3QztDQUVoQyxNQUFBLE1BQVI7Q0FoQ0osSUFTZ0I7O0NBVGhCOztDQTFESjs7Q0FBQSxDQTRGQSxDQUFpQixHQUFYLENBQU4sSUE1RkE7Q0FBQTs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtDQUFBLEtBQUEsMENBQUE7O0NBQUEsQ0FBQSxDQUFZLElBQUEsRUFBWixNQUFZOztDQUFaLENBQ0EsQ0FBSSxJQUFBLENBQUE7O0NBREosQ0FFQSxDQUFPLENBQVAsR0FBTyxDQUFBOztDQUZQLENBR0EsQ0FBVSxJQUFWLElBQVU7O0NBSFYsQ0FJQSxDQUFVLElBQVYsRUFBVTs7Q0FKVixDQUtBLENBQVEsRUFBUixFQUFRLE1BQUE7O0NBTFIsQ0FjTTtDQUlXLEVBQUEsQ0FBQSxHQUFBLE1BQUM7Q0FRVixTQUFBLE1BQUE7O0dBUm9CLEtBQVY7UUFRVjtDQUFBLEVBRUksR0FGSixFQUFBO0NBRUksQ0FBWSxFQUFaLElBQUEsRUFBQTtDQUZKLE9BQUE7Q0FBQSxFQUlTLEdBQVQ7U0FFSTtDQUFBLENBQU8sRUFBTixHQUFELEdBQUM7Q0FBRCxDQUF3QixJQUFSLElBQUE7Q0FBaEIsQ0FBb0MsSUFBUixJQUFBO0NBQTVCLENBQWtELE9BQVgsQ0FBQTtFQUd2QyxRQUxLO0NBS0wsQ0FBTyxFQUFOLE1BQUE7Q0FBRCxDQUEwQixRQUFiLENBQUE7Q0FBYixDQUEwQyxPQUExQyxDQUE4QjtFQUs5QixRQVZLO0NBVUwsQ0FBTyxFQUFOLEtBQUQsQ0FBQztDQUFELENBQStCLFFBQWIsQ0FBQTtVQVZiO0NBSlQsT0FBQTtDQUFBLEVBb0JBLENBQUMsRUFBRCxDQUFrQjtDQXBCbEIsRUFxQkksQ0FBSCxFQUFELElBQUE7Q0FyQkEsQ0F1QitCLENBQXBCLENBQVYsRUFBRCxDQUFBLENBQVc7Q0F2QlgsQ0F5QnFDLENBQXRCLENBQWQsRUFBRCxDQUFBO0NBQXFDLENBRXpCLElBQVIsRUFBQSxFQUZpQztDQUFBLENBS2xCLEVBTGtCLElBS2pDLEtBQUE7Q0FMaUMsQ0FjdkIsSUFkdUIsRUFjakM7Q0FkaUMsQ0FpQnJCLE1BQVosRUFBQTtDQTFDSixPQXlCZTtDQWpDbkIsSUFBYTs7Q0FBYixFQXlEWSxHQUFBLEdBQUMsQ0FBYjtDQUVJLFNBQUEsaURBQUE7Q0FBQSxFQUFZLEdBQVosR0FBQTtDQUVJLEVBQUEsU0FBQTtDQUFBLEVBQUEsS0FBQSxDQUFlO0NBR1gsQ0FBVyxDQUFaLENBQUssQ0FBQSxJQUFDLE1BQVQ7Q0FDSSxHQUFHLENBQUEsS0FBSDtDQUNJLEVBQUEsQ0FBQSxRQUFBO01BREosTUFBQTtDQUdJLEVBQUEsQ0FBQSxRQUFBO1lBSEo7Q0FJVyxHQUFJLEdBQUosR0FBWCxPQUFBO0NBTEosUUFBUTtDQUxBLE1BQVc7Q0FBdkIsRUFZUyxHQUFULENBQVMsRUFBQTtDQVpULENBQUEsQ0FjVyxHQUFYLEVBQUE7QUFDQSxDQUFBLFVBQUEscUNBQUE7NEJBQUE7QUFDSSxDQUFBLFlBQUEscUNBQUE7OEJBQUE7Q0FDSSxDQUFPLEVBQUEsQ0FBTSxLQUFiO0NBQ0ksQ0FBTSxDQUFGLENBQU8sS0FBQyxHQUFaO0NBQWtDLENBQUEsQ0FBSCxDQUFQLGlCQUFBO0NBQXBCLFlBQU87Q0FBWCxDQUNnQyxFQUFoQyxDQUFtQixHQUFYLElBQVI7WUFIUjtDQUFBLFFBREo7Q0FBQSxNQWZBO0NBQUEsQ0FxQmlDLENBQWIsQ0FBcEIsQ0FBWSxDQUFaLEVBQVk7Q0FHQSxFQUFSLENBQUEsRUFBQSxDQUFPLE1BQVA7Q0FuRlIsSUF5RFk7O0NBekRaLEVBMEZPLENBQUEsQ0FBUCxJQUFRO0NBQ0osU0FBQSwyQ0FBQTtTQUFBLEdBQUE7Q0FBQSxFQUFjLENBQUksRUFBbEIsR0FBd0IsRUFBeEI7Q0FFSSxFQUFrQixDQUFmLENBQUEsQ0FBTSxFQUFUO0NBQUEsZ0JBQXlCO01BQXpCLElBQUE7Q0FBQSxnQkFBZ0M7VUFGYjtDQUFULE1BQVM7Q0FBdkIsRUFJWSxDQUFJLEVBQWhCLEdBQUE7Q0FBa0MsSUFBQSxDQUFpQixJQUFsQixLQUFBO0NBQXJCLE1BQVM7Q0FKckIsRUFNVyxHQUFYLEVBQUEsQ0FBVztDQUNQLFdBQUEsT0FBQTtDQUFBLEVBQVEsRUFBUixHQUFBO0NBQUEsRUFDZSxLQUFmLElBQUE7Q0FEQSxDQUV5QixDQUFQLENBQUEsR0FBbEIsQ0FBQSxDQUFTO0NBQ0wsYUFBQSxjQUFBO0NBQUEsQ0FBeUIsQ0FBWixDQUFBLENBQUMsS0FBZDtDQUFBLEVBQ21CLEVBQWtCLEtBQXJDLENBQStCLEtBQS9CO0FBQ0EsQ0FGQSxDQUFBLEdBRUEsS0FBQTtDQUNBLEdBQXNCLENBQWMsS0FBcEMsTUFBQTtBQUFBLENBQUEsV0FBQSxPQUFBO1lBSmM7Q0FBbEIsUUFBa0I7Q0FIWCxFQVFRLFNBQWYsR0FBQTtDQWRKLE1BTVc7QUFVWCxDQUFBLEVBQUEsUUFBVSxtR0FBVjtDQUNJLENBQXlCLENBQVAsQ0FBQSxHQUFsQixDQUFBLENBQVM7Q0FDSixDQUFvQixFQUFyQixDQUFDLEVBQU8sSUFBeUIsTUFBakM7Q0FESixRQUFrQjtDQUFsQixFQUVRLEVBQVIsR0FBQTtDQUZBLENBR3lCLENBQXpCLEVBQUEsRUFBTyxDQUFQO0NBQ0EsRUFBVyxDQUFSLENBQUEsR0FBSDtDQUNJLGVBREo7VUFMSjtDQUFBLE1BaEJBO0NBd0JZLENBQVUsQ0FBVixDQUFSLEVBQVEsQ0FBUixFQUFTLElBQVQ7Q0FBNkIsTUFBQSxRQUFBO0NBQTdCLE1BQVE7Q0FuSGhCLElBMEZPOztDQTFGUCxFQXlIUSxDQUFBLEVBQVIsR0FBUztDQUNMLFNBQUEsS0FBQTtTQUFBLEdBQUE7Q0FBQSxFQUFhLENBQUEsRUFBYixHQUFjLENBQWQ7Q0FDSSxXQUFBLE9BQUE7Q0FBQSxFQUFRLENBQUksQ0FBWixDQUFpQixFQUFqQixDQUFrQjtDQUNkLEdBQUEsVUFBQTtDQUFBLEVBQU8sQ0FBUCxDQUFRLENBQUQsSUFBUDtDQUNPLEVBQVEsQ0FBZixDQUFBLENBQU0sV0FBTjtDQUZJLFFBQVM7Q0FBakIsRUFHUyxDQUFjLENBQVIsQ0FBZixFQUFBLENBQXdCO0NBQUQsZ0JBQVU7Q0FBdkIsS0FIVixHQUd1QjtDQUh2QixFQUlPLENBQVAsQ0FBcUIsQ0FBZCxFQUFQO2VBQ0E7Q0FBQSxDQUFRLEdBQVAsQ0FBRCxJQUFDO0NBQUQsQ0FBOEIsSUFBUixJQUFBO0NBQXRCLENBQTRDLEVBQU4sTUFBQTtDQU43QjtDQUFiLE1BQWE7R0FPYixVQUFBO0NBQ0ksQ0FBSyxDQUFMLENBQUssSUFBTCxFQUFLO0NBQUwsQ0FDVSxDQUF1QixDQUFSLEVBQUosRUFBckIsQ0FBa0MsQ0FBeEI7Q0FBMEMsRUFBUSxFQUFmLENBQU0sV0FBTjtDQUF4QixRQUFZO0NBRGpDLENBRVUsQ0FBdUIsQ0FBUixFQUFKLEVBQXJCLENBQWtDLENBQXhCO0NBQTBDLEVBQVEsRUFBZixDQUFNLFdBQU47Q0FBeEIsUUFBWTtDQUZqQyxDQUdTLEVBQUMsRUFBRCxDQUFULENBQUE7Q0FaQTtDQXpIUixJQXlIUTs7Q0F6SFIsQ0E0SWUsQ0FBVCxDQUFOLEVBQU0sR0FBQyxHQUFEO0NBQ0YsU0FBQSxrQkFBQTs7R0FEMEIsS0FBZjtRQUNYO0FBQU8sQ0FBUCxHQUFBLEVBQUEsTUFBQTtDQUNJLEVBQVEsQ0FBQyxDQUFULENBQTBCLEVBQTFCLEVBQVE7TUFEWixFQUFBO0NBR0ksRUFBUSxFQUFSLENBQUEsRUFBQTtRQUhKO0NBQUEsRUFJSSxDQUFDLENBQUQsQ0FBSixDQUFJO0NBSkosRUFLVyxHQUFYLEVBQUE7Q0FMQSxFQU1XLEdBQVgsRUFBQTtDQVBFLEVBU1MsS0FBWCxLQUFBO0NBckpKLElBNElNOztDQTVJTixFQTBKUSxHQUFSLEdBQVE7Q0FDQyxFQUFjLENBQWYsRUFBVyxHQUFmLElBQUE7Q0EzSkosSUEwSlE7O0NBMUpSOztDQWxCSjs7Q0FBQSxDQW9MQSxDQUFHLENBQVksSUFBZixDQUFnQjtDQUNaLEVBQUEsS0FBQTtBQUFNLENBQU4sRUFBQSxDQUFBO0NBQUEsRUFDRyxDQUFILElBQUE7Q0FGVyxVQUdYO0NBdkxKLEVBb0xlOztDQXBMZixDQXlMQSxDQUFpQixHQUFYLENBQU47Q0F6TEE7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2cEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7Q0FBQSxLQUFBLDRFQUFBOztDQUFBLENBQUEsQ0FBSSxJQUFBLENBQUE7O0NBQUosQ0FDQSxDQUFLLEdBQU07O0NBRFgsQ0FFQSxDQUFhLElBQUEsQ0FBQSxFQUFiOztDQUZBLENBR0EsQ0FBYyxJQUFBLElBQWQsaUJBQWM7O0NBSGQsQ0FJQSxDQUFhLElBQUEsR0FBYixZQUFhOztDQUpiLENBTUEsQ0FBVyxJQUFBLENBQVgsQ0FBWTtDQUNSLElBQUEsR0FBQTtDQUFBLENBQUEsQ0FBSyxDQUFMLEdBQVUsQ0FBQSxDQUFMLEdBQUssSUFBQTtDQUFWLENBQ08sQ0FBSCxDQUFKO0NBREEsQ0FFQSxFQUFBLEVBQUE7Q0FLVyxFQUFDLE1BQUEsQ0FBWixDQUFBO0NBQ0ksSUFBQSxDQUFBO0NBQ0csQ0FBRCxJQUFGLE9BQUE7Q0FGTyxDQUdSLEdBSFM7Q0FkaEIsRUFNVzs7Q0FOWCxDQW1CQSxDQUFtQixNQUFBLE9BQW5CO0NBQ0ksT0FBQSxZQUFBO0NBQUEsQ0FBUyxDQUFGLENBQVAsR0FBTztDQUFQLENBQUEsQ0FDYyxDQUFkLElBQUEsRUFBdUM7Q0FDSSxFQUFwQyxDQUFQLEdBQXNDLENBQS9CLEdBQVAsTUFBTztDQXRCWCxFQW1CbUI7O0NBbkJuQixDQXdCTTtDQUVXLEVBQUEsQ0FBQSxFQUFBLGNBQUM7Q0FDVixTQUFBLENBQUE7Q0FBQSxFQUFPLENBQVAsRUFBQSxxVUFBQTtDQUFBLEVBVVEsQ0FBQSxDQUFSLENBQUE7Q0FWQSxDQVlBLENBQXdDLENBQXhDLENBQUssQ0FBTCxDQUFBLEVBQXdDLE1BQXhDO0NBQ0ksR0FBQSxRQUFBO0NBQUEsRUFBTyxDQUFQLElBQUEsUUFBTztDQUNJLENBQVEsQ0FBQSxHQUFuQixDQUFtQixFQUFDLENBQXBCLEtBQUE7Q0FDYSxDQUFlLENBQVIsQ0FBUCxFQUFULENBQUEsQ0FBQSxTQUFBO0NBREosUUFBbUI7Q0FGdkIsTUFBd0M7Q0FaeEMsQ0FpQkEsQ0FBeUMsQ0FBekMsQ0FBSyxDQUFMLENBQUEsRUFBeUMsT0FBekM7Q0FDSSxXQUFBLENBQUE7Q0FBQSxFQUFPLENBQVAsSUFBQSxRQUFPO0NBQVAsQ0FDNEIsQ0FBbEIsQ0FBQSxFQUFBLENBQVYsQ0FBQSxHQUFVO0NBRFYsRUFFVSxJQUFWLENBQUEsVUFBNkMsY0FBbkM7Q0FDRCxDQUFlLENBQVIsQ0FBUCxFQUFULENBQUEsQ0FBQSxPQUFBO0NBSkosTUFBeUM7Q0FqQnpDLEVBdUIwQyxDQUExQyxDQUFLLENBQUwsR0FBc0QsZUFBdEQ7Q0FDSSxPQUFBLElBQUE7Q0FBQSxFQUFBLENBQU0sQ0FBSyxHQUFYO0NBQUEsRUFDQSxFQUFrQixHQUFsQixDQUF3QjtDQUFPLENBQUQsTUFBQSxTQUFBO0NBQWpCLENBQUQsRUFBQSxLQUFXO0NBRjBCLEVBSXhCLENBRHRCLFNBQUEsRUFBQSxpREFBQTtDQUhtQyxDQUFBLEVBQUEsR0FBVztDQXZCckQsR0FnQ0ksQ0FBQSxDQUFBLElBQUE7Q0FqQ1IsSUFBYTs7Q0FBYjs7Q0ExQko7O0NBQUEsQ0E2REEsQ0FBaUIsR0FBWCxDQUFOLEdBN0RBO0NBQUE7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2oyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3phQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzRIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiIyBSZWRpcmVjdCBvbGQgYnJvd3NlcnNcbmlmICFBcnJheS5wcm90b3R5cGUubWFwXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBcImh0dHA6Ly9icm93c2VoYXBweS5jb20vXCJcblxuIyBJbml0aWFsaXplIEFWT1MgQ2xvdWRcbkFWLmluaXRpYWxpemUoXCJ1YjZwbG1ldzgwZXlkNzdkY3E5cDc1aXVlMHN5d2k5enVub2QxdHVxOTRmcm12aXhcIiwgXCJybDZnZ2d0ZGV2end2azdnNXNibXF4MTY1N2dpaXB5NXgyNDZka2JyeDB0OGs2dGpcIilcblxuIyBMb2FkIHZpZXdzXG5Vc2VyVmlldyA9IHJlcXVpcmUoJy4vdmlld3MvdXNlci12aWV3LmNvZmZlZScpXG5JbWFnZVZpZXcgPSByZXF1aXJlKCcuL3ZpZXdzL2ltYWdlLXZpZXcuY29mZmVlJylcbkV4cGxvcmVWaWV3ID0gcmVxdWlyZSgnLi92aWV3cy9leHBsb3JlLXZpZXcuY29mZmVlJylcbkZhdm9yaXRlVmlldyA9IHJlcXVpcmUoJy4vdmlld3MvZmF2b3JpdGUtdmlldy5jb2ZmZWUnKVxuXG4kID0gcmVxdWlyZSgnanF1ZXJ5JylcbiQgLT5cbiAgICAjIEluaXRpYWxpemUgdXNlciB2aWV3XG4gICAgbmV3IFVzZXJWaWV3KClcblxuICAgICMgRGlzcGxheSBkZWZhdWx0IHZpZXdcbiAgICBuZXcgSW1hZ2VWaWV3KClcblxuICAgICMgQmluZCBldmVudHNcbiAgICAkKCcjbmF2ID4gdWwgPiBsaScpLmNsaWNrIC0+XG4gICAgICAgICQoJyNuYXYgPiB1bCA+IGxpLmN1cnJlbnQnKS5yZW1vdmVDbGFzcyAnY3VycmVudCdcbiAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyAnY3VycmVudCdcbiAgICAkKCcjbmF2LWNyZWF0ZScpLmNsaWNrIC0+IG5ldyBJbWFnZVZpZXcoKVxuICAgICQoJyNuYXYtZXhwbG9yZScpLmNsaWNrIC0+IG5ldyBFeHBsb3JlVmlldygpXG4gICAgJCgnI25hdi1mYXZvcml0ZScpLmNsaWNrIC0+IG5ldyBGYXZvcml0ZVZpZXcoKVxuIiwiKGZ1bmN0aW9uKCl7LyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYyLjEuMVxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDA1LCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTQtMDUtMDFUMTc6MTFaXG4gKi9cblxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIHdpbmRvdyBpcyBwcmVzZW50LFxuXHRcdC8vIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnlcblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGluaGVyZW50bHkgcG9zc2VzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBqUXVlcnktbWFraW5nIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHNcblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIHdpbmRvd1xuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gQ2FuJ3QgZG8gdGhpcyBiZWNhdXNlIHNldmVyYWwgYXBwcyBpbmNsdWRpbmcgQVNQLk5FVCB0cmFjZVxuLy8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmXG4vLyB5b3UgdHJ5IHRvIHRyYWNlIHRocm91Z2ggXCJ1c2Ugc3RyaWN0XCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXG4vLyBTdXBwb3J0OiBGaXJlZm94IDE4K1xuLy9cblxudmFyIGFyciA9IFtdO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cbnZhclxuXHQvLyBVc2UgdGhlIGNvcnJlY3QgZG9jdW1lbnQgYWNjb3JkaW5nbHkgd2l0aCB3aW5kb3cgYXJndW1lbnQgKHNhbmRib3gpXG5cdGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuXG5cdHZlcnNpb24gPSBcIjIuMS4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbXFxkYS16XSkvZ2ksXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIlwiLFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblx0XHRyZXR1cm4gbnVtICE9IG51bGwgP1xuXG5cdFx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0XHQoIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF0gKSA6XG5cblx0XHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRcdHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cdFx0cmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0Ly8gKFlvdSBjYW4gc2VlZCB0aGUgYXJndW1lbnRzIHdpdGggYW4gYXJyYXkgb2YgYXJncywgYnV0IHRoaXMgaXNcblx0Ly8gb25seSB1c2VkIGludGVybmFsbHkuKVxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjaywgYXJncyApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSkpO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbal0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IobnVsbCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbih0YXJnZXQpICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gZXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSkgIT0gbnVsbCApIHtcblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KGNvcHkpKSApICkge1xuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHQvLyBTZWUgdGVzdC91bml0L2NvcmUuanMgZm9yIGRldGFpbHMgY29uY2VybmluZyBpc0Z1bmN0aW9uLlxuXHQvLyBTaW5jZSB2ZXJzaW9uIDEuMywgRE9NIG1ldGhvZHMgYW5kIGZ1bmN0aW9ucyBsaWtlIGFsZXJ0XG5cdC8vIGFyZW4ndCBzdXBwb3J0ZWQuIFRoZXkgcmV0dXJuIGZhbHNlIG9uIElFICgjMjk2OCkuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgPj0gMDtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxuXHRcdC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFwiW29iamVjdCBPYmplY3RdXCJcblx0XHQvLyAtIERPTSBub2Rlc1xuXHRcdC8vIC0gd2luZG93XG5cdFx0aWYgKCBqUXVlcnkudHlwZSggb2JqICkgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgcmV0dXJuZWQgYWxyZWFkeSwgd2UncmUgY29uZmlkZW50IHRoYXRcblx0XHQvLyB8b2JqfCBpcyBhIHBsYWluIG9iamVjdCwgY3JlYXRlZCBieSB7fSBvciBjb25zdHJ1Y3RlZCB3aXRoIG5ldyBPYmplY3Rcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8IDQuMCwgaU9TIDwgNiAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKG9iaikgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0dmFyIHNjcmlwdCxcblx0XHRcdGluZGlyZWN0ID0gZXZhbDtcblxuXHRcdGNvZGUgPSBqUXVlcnkudHJpbSggY29kZSApO1xuXG5cdFx0aWYgKCBjb2RlICkge1xuXHRcdFx0Ly8gSWYgdGhlIGNvZGUgaW5jbHVkZXMgYSB2YWxpZCwgcHJvbG9ndWUgcG9zaXRpb25cblx0XHRcdC8vIHN0cmljdCBtb2RlIHByYWdtYSwgZXhlY3V0ZSBjb2RlIGJ5IGluamVjdGluZyBhXG5cdFx0XHQvLyBzY3JpcHQgdGFnIGludG8gdGhlIGRvY3VtZW50LlxuXHRcdFx0aWYgKCBjb2RlLmluZGV4T2YoXCJ1c2Ugc3RyaWN0XCIpID09PSAxICkge1xuXHRcdFx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuXHRcdFx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdC8vIE90aGVyd2lzZSwgYXZvaWQgdGhlIERPTSBub2RlIGNyZWF0aW9uLCBpbnNlcnRpb25cblx0XHRcdC8vIGFuZCByZW1vdmFsIGJ5IHVzaW5nIGFuIGluZGlyZWN0IGdsb2JhbCBldmFsXG5cdFx0XHRcdGluZGlyZWN0KCBjb2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdC8vIGFyZ3MgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0dmFyIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoLFxuXHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKCBvYmogKTtcblxuXHRcdGlmICggYXJncyApIHtcblx0XHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlsaWtlKCBPYmplY3QoYXJyKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRpc0FycmF5ID0gaXNBcnJheWxpa2UoIGVsZW1zICksXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5ICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSk7XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihpLCBuYW1lKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlsaWtlKCBvYmogKSB7XG5cdHZhciBsZW5ndGggPSBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIG9iai5ub2RlVHlwZSA9PT0gMSAmJiBsZW5ndGggKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjEuMTAuMTlcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMTMgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNC0wNC0xOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIC0obmV3IERhdGUoKSksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXG5cdHN0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQsXG5cdE1BWF9ORUdBVElWRSA9IDEgPDwgMzEsXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGlmIHdlIGNhbid0IHVzZSBhIG5hdGl2ZSBvbmVcblx0aW5kZXhPZiA9IGFyci5pbmRleE9mIHx8IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCB0aGlzW2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBXaGl0ZXNwYWNlIGNoYXJhY3RlcnMgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zeW50YXgvI2NoYXJhY3RlcnNcblx0Y2hhcmFjdGVyRW5jb2RpbmcgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIExvb3NlbHkgbW9kZWxlZCBvbiBDU1MgaWRlbnRpZmllciBjaGFyYWN0ZXJzXG5cdC8vIEFuIHVucXVvdGVkIHZhbHVlIHNob3VsZCBiZSBhIENTUyBpZGVudGlmaWVyIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdC8vIFByb3BlciBzeW50YXg6IGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gY2hhcmFjdGVyRW5jb2RpbmcucmVwbGFjZSggXCJ3XCIsIFwidyNcIiApLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcucmVwbGFjZSggXCJ3XCIsIFwidypcIiApICsgXCIpXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cdHJlc2NhcGUgPSAvJ3xcXFxcL2csXG5cblx0Ly8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9O1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtYXRjaCwgZWxlbSwgbSwgbm9kZVR5cGUsXG5cdFx0Ly8gUVNBIHZhcnNcblx0XHRpLCBncm91cHMsIG9sZCwgbmlkLCBuZXdDb250ZXh0LCBuZXdTZWxlY3RvcjtcblxuXHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblxuXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0aWYgKCAhc2VsZWN0b3IgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0aWYgKCAobm9kZVR5cGUgPSBjb250ZXh0Lm5vZGVUeXBlKSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRpZiAoIGRvY3VtZW50SXNIVE1MICYmICFzZWVkICkge1xuXG5cdFx0Ly8gU2hvcnRjdXRzXG5cdFx0aWYgKCAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIiNJRFwiKVxuXHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApO1xuXHRcdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAoalF1ZXJ5ICM2OTYzKVxuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgSUUsIE9wZXJhLCBhbmQgV2Via2l0IHJldHVybiBpdGVtc1xuXHRcdFx0XHRcdFx0Ly8gYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIENvbnRleHQgaXMgbm90IGEgZG9jdW1lbnRcblx0XHRcdFx0XHRpZiAoIGNvbnRleHQub3duZXJEb2N1bWVudCAmJiAoZWxlbSA9IGNvbnRleHQub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJiBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIlRBR1wiKVxuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIuQ0xBU1NcIilcblx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFFTQSBwYXRoXG5cdFx0aWYgKCBzdXBwb3J0LnFzYSAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXHRcdFx0bmlkID0gb2xkID0gZXhwYW5kbztcblx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0bmV3U2VsZWN0b3IgPSBub2RlVHlwZSA9PT0gOSAmJiBzZWxlY3RvcjtcblxuXHRcdFx0Ly8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXG5cdFx0XHQvLyBXZSBjYW4gd29yayBhcm91bmQgdGhpcyBieSBzcGVjaWZ5aW5nIGFuIGV4dHJhIElEIG9uIHRoZSByb290XG5cdFx0XHQvLyBhbmQgd29ya2luZyB1cCBmcm9tIHRoZXJlIChUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhlIHRlY2huaXF1ZSlcblx0XHRcdC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJiBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXG5cdFx0XHRcdGlmICggKG9sZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKFwiaWRcIikpICkge1xuXHRcdFx0XHRcdG5pZCA9IG9sZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgbmlkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmlkID0gXCJbaWQ9J1wiICsgbmlkICsgXCInXSBcIjtcblxuXHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0Z3JvdXBzW2ldID0gbmlkICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHQ7XG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oXCIsXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoKHFzYUVycm9yKSB7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCAhb2xkICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge0Z1bmN0aW9uKHN0cmluZywgT2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBkaXYgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGRpdi5wYXJlbnROb2RlICkge1xuXHRcdFx0ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGRpdiA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IHN0cnVuZGVmaW5lZCAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYyxcblx0XHRwYXJlbnQgPSBkb2MuZGVmYXVsdFZpZXc7XG5cblx0Ly8gSWYgbm8gZG9jdW1lbnQgYW5kIGRvY3VtZW50RWxlbWVudCBpcyBhdmFpbGFibGUsIHJldHVyblxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFNldCBvdXIgZG9jdW1lbnRcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQgdGVzdHNcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvYyApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPjhcblx0Ly8gSWYgaWZyYW1lIGRvY3VtZW50IGlzIGFzc2lnbmVkIHRvIFwiZG9jdW1lbnRcIiB2YXJpYWJsZSBhbmQgaWYgaWZyYW1lIGhhcyBiZWVuIHJlbG9hZGVkLFxuXHQvLyBJRSB3aWxsIHRocm93IFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIGFjY2Vzc2luZyBcImRvY3VtZW50XCIgdmFyaWFibGUsIHNlZSBqUXVlcnkgIzEzOTM2XG5cdC8vIElFNi04IGRvIG5vdCBzdXBwb3J0IHRoZSBkZWZhdWx0VmlldyBwcm9wZXJ0eSBzbyBwYXJlbnQgd2lsbCBiZSB1bmRlZmluZWRcblx0aWYgKCBwYXJlbnQgJiYgcGFyZW50ICE9PSBwYXJlbnQudG9wICkge1xuXHRcdC8vIElFMTEgZG9lcyBub3QgaGF2ZSBhdHRhY2hFdmVudCwgc28gYWxsIG11c3Qgc3VmZmVyXG5cdFx0aWYgKCBwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHBhcmVudC5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2V0RG9jdW1lbnQoKTtcblx0XHRcdH0sIGZhbHNlICk7XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZXREb2N1bWVudCgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXMgKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIGNhbiBiZSB0cnVzdGVkXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSAmJiBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IGNsYXNzPSdhJz48L2Rpdj48ZGl2IGNsYXNzPSdhIGknPjwvZGl2PlwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpPDRcblx0XHQvLyBDYXRjaCBjbGFzcyBvdmVyLWNhY2hpbmdcblx0XHRkaXYuZmlyc3RDaGlsZC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHQvLyBTdXBwb3J0OiBPcGVyYTwxMFxuXHRcdC8vIENhdGNoIGdFQkNOIGZhaWx1cmUgdG8gZmluZCBub24tbGVhZGluZyBjbGFzc2VzXG5cdFx0cmV0dXJuIGRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaVwiKS5sZW5ndGggPT09IDI7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jLmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2MuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbmQgYW5kIGZpbHRlclxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IHN0cnVuZGVmaW5lZCAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdHJldHVybiBtICYmIG0ucGFyZW50Tm9kZSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBzdHJ1bmRlZmluZWQgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBzdHJ1bmRlZmluZWQgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvYy5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIjxzZWxlY3QgbXNhbGxvd2NsaXA9Jyc+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2xpcF49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBkaXYsIFwiZGl2XCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBkaXYsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgZG9lcyBub3QgaW1wbGVtZW50IGluY2x1c2l2ZSBkZXNjZW5kZW50XG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvYyB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvYyB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBhICkgLSBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvYyA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvYztcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gc3RydW5kZWZpbmVkICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0ICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIGRpZmYsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gcGFyZW50WyBleHBhbmRvIF0gfHwgKHBhcmVudFsgZXhwYW5kbyBdID0ge30pO1xuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IG91dGVyQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMV07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsyXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VDYWNoZSAmJiAoY2FjaGUgPSAoZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0pICYmIGNhY2hlWzBdID09PSBkaXJydW5zICkge1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gY2FjaGVbMV07XG5cblx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLikgb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxICkgJiYgKytkaWZmICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0KG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZi5jYWxsKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGRpciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gb3V0ZXJDYWNoZVsgZGlyIF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIGRpciBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mLmNhbGwoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0cmV0dXJuICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCAhPT0gZG9jdW1lbnQgJiYgY29udGV4dDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIEtlZXAgYGlgIGEgc3RyaW5nIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBzbyBgbWF0Y2hlZENvdW50YCB3aWxsIGJlIFwiMDBcIiBiZWxvd1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgbm8gc2VlZCBhbmQgb25seSBvbmUgZ3JvdXBcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdHN1cHBvcnQuZ2V0QnlJZCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0XHRcdEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWU8MTRcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICgvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8pO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0pO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSk7XG5cblx0fVxuXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0XHR9XG5cblx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID49IDAgKSAhPT0gbm90O1xuXHR9KTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSA/XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdIDpcblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0fSkpO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSkgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdC8vIE5lZWRlZCBiZWNhdXNlICQoIHNlbGVjdG9yLCBjb250ZXh0ICkgYmVjb21lcyAkKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKVxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQgKTtcblx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFwiIFwiICsgc2VsZWN0b3IgOiBzZWxlY3Rvcjtcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UpICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0pO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclswXSA9PT0gXCI8XCIgJiYgc2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsxXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsxXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsyXSApO1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWzBdID0gZWxlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3RqUXVlcnkgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSB0aGlzWzBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiB0eXBlb2Ygcm9vdGpRdWVyeS5yZWFkeSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRcdHJvb3RqUXVlcnkucmVhZHkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cdC8vIG1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRkaXI6IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHRcdHZhciBtYXRjaGVkID0gW10sXG5cdFx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVkO1xuXHR9LFxuXG5cdHNpYmxpbmc6IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHRcdHZhciBtYXRjaGVkID0gW107XG5cblx0XHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVkO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzW2ldICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbaV07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAocG9zID9cblx0XHRcdFx0XHRwb3MuaW5kZXgoY3VyKSA+IC0xIDpcblxuXHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSkgKSB7XG5cblx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpblxuXHQvLyB0aGUgbWF0Y2hlZCBzZXQgb2YgZWxlbWVudHNcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIGluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZShcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKHNlbGVjdG9yKVxuXHRcdCk7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoY3VyID0gY3VyW2Rpcl0pICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuc2libGluZyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlKCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSk7XG52YXIgcm5vdHdoaXRlID0gKC9cXFMrL2cpO1xuXG5cblxuLy8gU3RyaW5nIHRvIE9iamVjdCBvcHRpb25zIGZvcm1hdCBjYWNoZVxudmFyIG9wdGlvbnNDYWNoZSA9IHt9O1xuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lcyBhbmQgc3RvcmUgaW4gY2FjaGVcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSBvcHRpb25zQ2FjaGVbIG9wdGlvbnMgXSA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0KCBvcHRpb25zQ2FjaGVbIG9wdGlvbnMgXSB8fCBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gTGFzdCBmaXJlIHZhbHVlIChmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzKVxuXHRcdG1lbW9yeSxcblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cdFx0Ly8gRmlyc3QgY2FsbGJhY2sgdG8gZmlyZSAodXNlZCBpbnRlcm5hbGx5IGJ5IGFkZCBhbmQgZmlyZVdpdGgpXG5cdFx0ZmlyaW5nU3RhcnQsXG5cdFx0Ly8gRW5kIG9mIHRoZSBsb29wIHdoZW4gZmlyaW5nXG5cdFx0ZmlyaW5nTGVuZ3RoLFxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IHJlbW92ZSBpZiBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXgsXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cdFx0Ly8gU3RhY2sgb2YgZmlyZSBjYWxscyBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHN0YWNrID0gIW9wdGlvbnMub25jZSAmJiBbXSxcblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdG1lbW9yeSA9IG9wdGlvbnMubWVtb3J5ICYmIGRhdGE7XG5cdFx0XHRmaXJlZCA9IHRydWU7XG5cdFx0XHRmaXJpbmdJbmRleCA9IGZpcmluZ1N0YXJ0IHx8IDA7XG5cdFx0XHRmaXJpbmdTdGFydCA9IDA7XG5cdFx0XHRmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IGxpc3QgJiYgZmlyaW5nSW5kZXggPCBmaXJpbmdMZW5ndGg7IGZpcmluZ0luZGV4KysgKSB7XG5cdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggZGF0YVsgMCBdLCBkYXRhWyAxIF0gKSA9PT0gZmFsc2UgJiYgb3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTsgLy8gVG8gcHJldmVudCBmdXJ0aGVyIGNhbGxzIHVzaW5nIGFkZFxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0aWYgKCBzdGFjayApIHtcblx0XHRcdFx0XHRpZiAoIHN0YWNrLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGZpcmUoIHN0YWNrLnNoaWZ0KCkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHQvLyBGaXJzdCwgd2Ugc2F2ZSB0aGUgY3VycmVudCBsZW5ndGhcblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHQoZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHQvLyBEbyB3ZSBuZWVkIHRvIGFkZCB0aGUgY2FsbGJhY2tzIHRvIHRoZVxuXHRcdFx0XHRcdC8vIGN1cnJlbnQgZmlyaW5nIGJhdGNoP1xuXHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0Ly8gV2l0aCBtZW1vcnksIGlmIHdlJ3JlIG5vdCBmaXJpbmcgdGhlblxuXHRcdFx0XHRcdC8vIHdlIHNob3VsZCBjYWxsIHJpZ2h0IGF3YXlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdTdGFydCA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0ZmlyZSggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdMZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdMZW5ndGgtLTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/IGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOiAhISggbGlzdCAmJiBsaXN0Lmxlbmd0aCApO1xuXHRcdFx0fSxcblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHRmaXJpbmdMZW5ndGggPSAwO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBIYXZlIHRoZSBsaXN0IGRvIG5vdGhpbmcgYW55bW9yZVxuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxpc3QgPSBzdGFjayA9IG1lbW9yeSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSXMgaXQgZGlzYWJsZWQ/XG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cdFx0XHQvLyBMb2NrIHRoZSBsaXN0IGluIGl0cyBjdXJyZW50IHN0YXRlXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3RhY2sgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGlmICggIW1lbW9yeSApIHtcblx0XHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBsb2NrZWQ/XG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIXN0YWNrO1xuXHRcdFx0fSxcblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCBsaXN0ICYmICggIWZpcmVkIHx8IHN0YWNrICkgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdHN0YWNrLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZmlyZSggYXJncyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZVxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBcInJlamVjdGVkXCIgXSxcblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJtZW1vcnlcIikgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgaSBdICkgJiYgZm5zWyBpIF07XG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gZm9yIGZvcndhcmRpbmcgYWN0aW9ucyB0byBuZXdEZWZlclxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbMV0gXShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsIGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9KS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0cHJvbWlzZS5waXBlID0gcHJvbWlzZS50aGVuO1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgMyBdO1xuXG5cdFx0XHQvLyBwcm9taXNlWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbMV0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIHN0YXRlID0gWyByZXNvbHZlZCB8IHJlamVjdGVkIF1cblx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXG5cdFx0XHRcdC8vIFsgcmVqZWN0X2xpc3QgfCByZXNvbHZlX2xpc3QgXS5kaXNhYmxlOyBwcm9ncmVzc19saXN0LmxvY2tcblx0XHRcdFx0fSwgdHVwbGVzWyBpIF4gMSBdWyAyIF0uZGlzYWJsZSwgdHVwbGVzWyAyIF1bIDIgXS5sb2NrICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVswXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVswXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gcHJvbWlzZSA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9KTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHN1Ym9yZGluYXRlIC8qICwgLi4uLCBzdWJvcmRpbmF0ZU4gKi8gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0bGVuZ3RoID0gcmVzb2x2ZVZhbHVlcy5sZW5ndGgsXG5cblx0XHRcdC8vIHRoZSBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGxlbmd0aCAhPT0gMSB8fCAoIHN1Ym9yZGluYXRlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBzdWJvcmRpbmF0ZS5wcm9taXNlICkgKSA/IGxlbmd0aCA6IDAsXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWQuIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LlxuXHRcdFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzXG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGksIGNvbnRleHRzLCB2YWx1ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0Y29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG5cblx0XHQvLyBhZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcblx0XHRcdFx0XHRcdC5kb25lKCB1cGRhdGVGdW5jKCBpLCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZmFpbCggZGVmZXJyZWQucmVqZWN0IClcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuXHRcdGlmICggIXJlbWFpbmluZyApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9XG59KTtcblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3Q7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoIGZuICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0aWYgKCBqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIgKSB7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlckhhbmRsZXIoIFwicmVhZHlcIiApO1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XG5cdFx0fVxuXHR9XG59KTtcblxuLyoqXG4gKiBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuICovXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxualF1ZXJ5LnJlYWR5LnByb21pc2UgPSBmdW5jdGlvbiggb2JqICkge1xuXHRpZiAoICFyZWFkeUxpc3QgKSB7XG5cblx0XHRyZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxuXHRcdC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuXHRcdC8vIHdlIG9uY2UgdHJpZWQgdG8gdXNlIHJlYWR5U3RhdGUgXCJpbnRlcmFjdGl2ZVwiIGhlcmUsIGJ1dCBpdCBjYXVzZWQgaXNzdWVzIGxpa2UgdGhlIG9uZVxuXHRcdC8vIGRpc2NvdmVyZWQgYnkgQ2hyaXNTIGhlcmU6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMjgyI2NvbW1lbnQ6MTVcblx0XHRpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiApIHtcblx0XHRcdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHRcdFx0c2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXG5cdFx0XHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkeUxpc3QucHJvbWlzZSggb2JqICk7XG59O1xuXG4vLyBLaWNrIG9mZiB0aGUgRE9NIHJlYWR5IGNoZWNrIGV2ZW4gaWYgdGhlIHVzZXIgZG9lcyBub3RcbmpRdWVyeS5yZWFkeS5wcm9taXNlKCk7XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0galF1ZXJ5LmFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0alF1ZXJ5LmFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbaV0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKCBlbGVtc1tpXSwga2V5LCByYXcgPyB2YWx1ZSA6IHZhbHVlLmNhbGwoIGVsZW1zW2ldLCBpLCBmbiggZWxlbXNbaV0sIGtleSApICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbiA/IGZuKCBlbGVtc1swXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JqZWN0IGNhbiBoYXZlIGRhdGFcbiAqL1xualF1ZXJ5LmFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHQvKiBqc2hpbnQgLVcwMTggKi9cblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDwgNCxcblx0Ly8gT2xkIFdlYktpdCBkb2VzIG5vdCBoYXZlIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucy9mcmVlemUgbWV0aG9kLFxuXHQvLyByZXR1cm4gbmV3IGVtcHR5IG9iamVjdCBpbnN0ZWFkIHdpdGggbm8gW1tzZXRdXSBhY2Nlc3NvclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMuY2FjaGUgPSB7fSwgMCwge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXHR9KTtcblxuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIE1hdGgucmFuZG9tKCk7XG59XG5cbkRhdGEudWlkID0gMTtcbkRhdGEuYWNjZXB0cyA9IGpRdWVyeS5hY2NlcHREYXRhO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblx0a2V5OiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHQvLyBBbHdheXMgcmV0dXJuIHRoZSBrZXkgZm9yIGEgZnJvemVuIG9iamVjdC5cblx0XHRpZiAoICFEYXRhLmFjY2VwdHMoIG93bmVyICkgKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgZGVzY3JpcHRvciA9IHt9LFxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlIGtleVxuXHRcdFx0dW5sb2NrID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdW5sb2NrICkge1xuXHRcdFx0dW5sb2NrID0gRGF0YS51aWQrKztcblxuXHRcdFx0Ly8gU2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSBwcm9wZXJ0eVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGVzY3JpcHRvclsgdGhpcy5leHBhbmRvIF0gPSB7IHZhbHVlOiB1bmxvY2sgfTtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG93bmVyLCBkZXNjcmlwdG9yICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPCA0XG5cdFx0XHQvLyBGYWxsYmFjayB0byBhIGxlc3Mgc2VjdXJlIGRlZmluaXRpb25cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRkZXNjcmlwdG9yWyB0aGlzLmV4cGFuZG8gXSA9IHVubG9jaztcblx0XHRcdFx0alF1ZXJ5LmV4dGVuZCggb3duZXIsIGRlc2NyaXB0b3IgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhlIGNhY2hlIG9iamVjdFxuXHRcdGlmICggIXRoaXMuY2FjaGVbIHVubG9jayBdICkge1xuXHRcdFx0dGhpcy5jYWNoZVsgdW5sb2NrIF0gPSB7fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdW5sb2NrO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHQvLyBUaGVyZSBtYXkgYmUgYW4gdW5sb2NrIGFzc2lnbmVkIHRvIHRoaXMgbm9kZSxcblx0XHRcdC8vIGlmIHRoZXJlIGlzIG5vIGVudHJ5IGZvciB0aGlzIFwib3duZXJcIiwgY3JlYXRlIG9uZSBpbmxpbmVcblx0XHRcdC8vIGFuZCBzZXQgdGhlIHVubG9jayBhcyB0aG91Z2ggYW4gb3duZXIgZW50cnkgaGFkIGFsd2F5cyBleGlzdGVkXG5cdFx0XHR1bmxvY2sgPSB0aGlzLmtleSggb3duZXIgKSxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZVsgdW5sb2NrIF07XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBkYXRhIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEZyZXNoIGFzc2lnbm1lbnRzIGJ5IG9iamVjdCBhcmUgc2hhbGxvdyBjb3BpZWRcblx0XHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5leHRlbmQoIHRoaXMuY2FjaGVbIHVubG9jayBdLCBkYXRhICk7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGNvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0Y2FjaGVbIHByb3AgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0Ly8gRWl0aGVyIGEgdmFsaWQgY2FjaGUgaXMgZm91bmQsIG9yIHdpbGwgYmUgY3JlYXRlZC5cblx0XHQvLyBOZXcgY2FjaGVzIHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlIHVubG9jayByZXR1cm5lZCxcblx0XHQvLyBhbGxvd2luZyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBuZXdseSBjcmVhdGVkXG5cdFx0Ly8gZW1wdHkgZGF0YSBvYmplY3QuIEEgdmFsaWQgb3duZXIgb2JqZWN0IG11c3QgYmUgcHJvdmlkZWQuXG5cdFx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZVsgdGhpcy5rZXkoIG93bmVyICkgXTtcblxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRjYWNoZSA6IGNhY2hlWyBrZXkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHN0b3JlZDtcblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoKGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSApIHtcblxuXHRcdFx0c3RvcmVkID0gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblxuXHRcdFx0cmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0c3RvcmVkIDogdGhpcy5nZXQoIG93bmVyLCBqUXVlcnkuY2FtZWxDYXNlKGtleSkgKTtcblx0XHR9XG5cblx0XHQvLyBbKl1XaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGNhbWVsLFxuXHRcdFx0dW5sb2NrID0gdGhpcy5rZXkoIG93bmVyICksXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGVbIHVubG9jayBdO1xuXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuY2FjaGVbIHVubG9jayBdID0ge307XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0ga2V5LmNvbmNhdCgga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXHRcdFx0XHQvLyBUcnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuXHRcdFx0XHRpZiAoIGtleSBpbiBjYWNoZSApIHtcblx0XHRcdFx0XHRuYW1lID0gWyBrZXksIGNhbWVsIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0bmFtZSA9IGNhbWVsO1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lIGluIGNhY2hlID9cblx0XHRcdFx0XHRcdFsgbmFtZSBdIDogKCBuYW1lLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBuYW1lLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHJldHVybiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoXG5cdFx0XHR0aGlzLmNhY2hlWyBvd25lclsgdGhpcy5leHBhbmRvIF0gXSB8fCB7fVxuXHRcdCk7XG5cdH0sXG5cdGRpc2NhcmQ6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHRpZiAoIG93bmVyWyB0aGlzLmV4cGFuZG8gXSApIHtcblx0XHRcdGRlbGV0ZSB0aGlzLmNhY2hlWyBvd25lclsgdGhpcy5leHBhbmRvIF0gXTtcblx0XHR9XG5cdH1cbn07XG52YXIgZGF0YV9wcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFfdXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vKlxuXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG5cblx0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcblx0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG5cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG5cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcblx0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG5cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuKi9cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cdFx0XHRcdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRcdFx0XHQrZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFfdXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhX3VzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFfcHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFfdXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhX3VzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YV9wcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFfcHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTExK1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSg1KSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhX3ByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhX3VzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhLFxuXHRcdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBjYW1lbGl6ZWRcblx0XHRcdFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIEZpcnN0LCBhdHRlbXB0IHRvIHN0b3JlIGEgY29weSBvciByZWZlcmVuY2Ugb2YgYW55XG5cdFx0XHRcdC8vIGRhdGEgdGhhdCBtaWdodCd2ZSBiZWVuIHN0b3JlIHdpdGggYSBjYW1lbENhc2VkIGtleS5cblx0XHRcdFx0dmFyIGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCB0aGlzLCBjYW1lbEtleSApO1xuXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cblx0XHRcdFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cblx0XHRcdFx0Ly8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXG5cdFx0XHRcdGRhdGFfdXNlci5zZXQoIHRoaXMsIGNhbWVsS2V5LCB2YWx1ZSApO1xuXG5cdFx0XHRcdC8vICouLi4gSW4gdGhlIGNhc2Ugb2YgcHJvcGVydGllcyB0aGF0IG1pZ2h0IF9hY3R1YWxseV9cblx0XHRcdFx0Ly8gaGF2ZSBkYXNoZXMsIHdlIG5lZWQgdG8gYWxzbyBzdG9yZSBhIGNvcHkgb2YgdGhhdFxuXHRcdFx0XHQvLyB1bmNoYW5nZWQgcHJvcGVydHkuXG5cdFx0XHRcdGlmICgga2V5LmluZGV4T2YoXCItXCIpICE9PSAtMSAmJiBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0ZGF0YV91c2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhX3VzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmV4dGVuZCh7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBub3QgaW50ZW5kZWQgZm9yIHB1YmxpYyBjb25zdW1wdGlvbiAtIGdlbmVyYXRlcyBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm5zIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YV9wcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YV9wcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSlcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1swXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIGVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59KTtcbnZhciBwbnVtID0gKC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvKS5zb3VyY2U7XG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8ICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHR9O1xuXG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoL14oPzpjaGVja2JveHxyYWRpbykkL2kpO1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gIzExMjE3IC0gV2ViS2l0IGxvc2VzIGNoZWNrIHdoZW4gdGhlIG5hbWUgaXMgYWZ0ZXIgdGhlIGNoZWNrZWQgYXR0cmlidXRlXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbmVlZCAuc2V0QXR0cmlidXRlIGZvciBXV0Fcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaSA1LjEsIGlPUyA1LjEsIEFuZHJvaWQgNC54LCBBbmRyb2lkIDIuM1xuXHQvLyBvbGQgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHQvLyBTdXBwb3J0OiBJRTktSUUxMStcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0pKCk7XG52YXIgc3RydW5kZWZpbmVkID0gdHlwZW9mIHVuZGVmaW5lZDtcblxuXG5cbnN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudSl8Y2xpY2svLFxuXHRyZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkkLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YV9wcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUpICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gc3RydW5kZWZpbmVkICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbihcIi5cIilcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHwgc3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUsIGZhbHNlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YV9wcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhX3ByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsyXSAmJiBuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8IHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XG5cdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBlbGVtLCBcImV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoXCIuXCIpID49IDAgKSB7XG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdChcIi5cIik7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XG5cdFx0ZXZlbnQubmFtZXNwYWNlX3JlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGN1ciA9IGV2ZW50UGF0aFtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YV9wcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmIGRhdGFfcHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBqUXVlcnkuYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCFzcGVjaWFsLl9kZWZhdWx0IHx8IHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSkgJiZcblx0XHRcdFx0alF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YV9wcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWzBdID0gZXZlbnQ7XG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoIChoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSkgJiYgIWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvclxuXHRcdFx0XHQvLyAyKSBoYXZlIG5hbWVzcGFjZShzKSBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQubmFtZXNwYWNlX3JlIHx8IGV2ZW50Lm5hbWVzcGFjZV9yZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9KS5oYW5kbGUgfHwgaGFuZGxlT2JqLmhhbmRsZXIgKVxuXHRcdFx0XHRcdFx0XHQuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKGV2ZW50LnJlc3VsdCA9IHJldCkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgYnViYmxpbmcgaW4gRmlyZWZveCAoIzM4NjEpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJiAoIWV2ZW50LmJ1dHRvbiB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIpICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID49IDAgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0Ly8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcblx0cHJvcHM6IFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdXNlSG9va3M6IHtcblx0XHRwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXHRcdFx0dmFyIGV2ZW50RG9jLCBkb2MsIGJvZHksXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbjtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0ZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcblxuXHRcdFx0XHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggKyAoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwICk7XG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArICggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcblx0XHQvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3Rcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lIDwgMjhcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZpeEhvb2suZmlsdGVyID8gZml4SG9vay5maWx0ZXIoIGV2ZW50LCBvcmlnaW5hbEV2ZW50ICkgOiBldmVudDtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCwgYnViYmxlICkge1xuXHRcdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZS5cblx0XHQvLyBGYWtlIG9yaWdpbmFsRXZlbnQgdG8gYXZvaWQgZG9ub3IncyBzdG9wUHJvcGFnYXRpb24sIGJ1dCBpZiB0aGVcblx0XHQvLyBzaW11bGF0ZWQgZXZlbnQgcHJldmVudHMgZGVmYXVsdCB0aGVuIHdlIGRvIHRoZSBzYW1lIG9uIHRoZSBkb25vci5cblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWUsXG5cdFx0XHRcdG9yaWdpbmFsRXZlbnQ6IHt9XG5cdFx0XHR9XG5cdFx0KTtcblx0XHRpZiAoIGJ1YmJsZSApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5jYWxsKCBlbGVtLCBlICk7XG5cdFx0fVxuXHRcdGlmICggZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSwgZmFsc2UgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEodGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDwgNC4wXG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnN0b3BQcm9wYWdhdGlvbiApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gU3VwcG9ydDogQ2hyb21lIDE1K1xualF1ZXJ5LmVhY2goe1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkpICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBDcmVhdGUgXCJidWJibGluZ1wiIGZvY3VzIGFuZCBibHVyIGV2ZW50c1xuLy8gU3VwcG9ydDogRmlyZWZveCwgQ2hyb21lLCBTYWZhcmlcbmlmICggIXN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgKSB7XG5cdGpRdWVyeS5lYWNoKHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICksIHRydWUgKTtcblx0XHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIC8qSU5URVJOQUwqLyBvbmUgKSB7XG5cdFx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHRcdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub24oIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRcdG9yaWdGbiA9IGZuO1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fTtcblx0XHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdFx0fSk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0pO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSk7XG5cblxudmFyXG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9naSxcblx0cnRhZ05hbWUgPSAvPChbXFx3Ol0rKS8sXG5cdHJodG1sID0gLzx8JiM/XFx3KzsvLFxuXHRybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLFxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZSA9IC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZyxcblxuXHQvLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxuXHR3cmFwTWFwID0ge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOVxuXHRcdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdFx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRcdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdFx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHRcdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRcdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxuXHR9O1xuXG4vLyBTdXBwb3J0OiBJRSA5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogMS54IGNvbXBhdGliaWxpdHlcbi8vIE1hbmlwdWxhdGluZyB0YWJsZXMgcmVxdWlyZXMgYSB0Ym9keVxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdGpRdWVyeS5ub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSA/XG5cblx0XHRlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF0gfHxcblx0XHRcdGVsZW0uYXBwZW5kQ2hpbGQoIGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIikgKSA6XG5cdFx0ZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSAhPT0gbnVsbCkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YV9wcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sIFwiZ2xvYmFsRXZhbFwiLCAhcmVmRWxlbWVudHMgfHwgZGF0YV9wcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YV9wcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YV9wcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhX3ByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhX3VzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhX3VzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YV91c2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblx0dmFyIHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgPyBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuLy8gU3VwcG9ydDogSUUgPj0gOVxuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFID49IDlcblx0XHQvLyBGaXggQ2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGJ1aWxkRnJhZ21lbnQ6IGZ1bmN0aW9uKCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uICkge1xuXHRcdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdFx0bm9kZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHRcdFx0Ly8galF1ZXJ5Lm1lcmdlIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApO1xuXG5cdFx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBlbGVtLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcblx0XHRcdFx0XHQvLyBqUXVlcnkubWVyZ2UgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHRcdC8vIEZpeGVzICMxMjM0NlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFdlYmtpdCwgSUVcblx0XHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRcdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGVsZW0gPSBub2Rlc1sgaSsrIF0pICkge1xuXG5cdFx0XHQvLyAjNDA4NyAtIElmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gZWxlbWVudHMgYXJlIHRoZSBzYW1lLCBhbmQgdGhpcyBpc1xuXHRcdFx0Ly8gdGhhdCBlbGVtZW50LCBkbyBub3QgZG8gYW55dGhpbmdcblx0XHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSAhPT0gLTEgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gdG1wWyBqKysgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZyYWdtZW50O1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLCBrZXksXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1sgaSBdKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGtleSA9IGVsZW1bIGRhdGFfcHJpdi5leHBhbmRvIF07XG5cblx0XHRcdFx0aWYgKCBrZXkgJiYgKGRhdGEgPSBkYXRhX3ByaXYuY2FjaGVbIGtleSBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBkYXRhX3ByaXYuY2FjaGVbIGtleSBdICkge1xuXHRcdFx0XHRcdFx0Ly8gRGlzY2FyZCBhbnkgcmVtYWluaW5nIGBwcml2YXRlYCBkYXRhXG5cdFx0XHRcdFx0XHRkZWxldGUgZGF0YV9wcml2LmNhY2hlWyBrZXkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIERpc2NhcmQgYW55IHJlbWFpbmluZyBgdXNlcmAgZGF0YVxuXHRcdFx0ZGVsZXRlIGRhdGFfdXNlci5jYWNoZVsgZWxlbVsgZGF0YV91c2VyLmV4cGFuZG8gXSBdO1xuXHRcdH1cblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3Rvciwga2VlcERhdGEgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRlbGVtcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHRoaXMgKSA6IHRoaXMsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCAha2VlcERhdGEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9KTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnID0gYXJndW1lbnRzWyAwIF07XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHR0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0YXJnID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXG5cdFx0XHRpZiAoIGFyZyApIHtcblx0XHRcdFx0YXJnLnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRm9yY2UgcmVtb3ZhbCBpZiB0aGVyZSB3YXMgbm8gbmV3IGNvbnRlbnQgKGUuZy4sIGZyb20gZW1wdHkgYXJndW1lbnRzKVxuXHRcdHJldHVybiBhcmcgJiYgKGFyZy5sZW5ndGggfHwgYXJnLm5vZGVUeXBlKSA/IHRoaXMgOiB0aGlzLnJlbW92ZSgpO1xuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRkb21NYW5pcDogZnVuY3Rpb24oIGFyZ3MsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0XHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNldCA9IHRoaXMsXG5cdFx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0XHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHNldC5lcSggaW5kZXggKTtcblx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuZG9tTWFuaXAoIGFyZ3MsIGNhbGxiYWNrICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGwgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBhcmdzLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIHRoaXMgKTtcblx0XHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmaXJzdCApIHtcblx0XHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcblx0XHRcdFx0XHRcdFx0Ly8galF1ZXJ5Lm1lcmdlIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggdGhpc1sgaSBdLCBub2RlLCBpICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHRcdCFkYXRhX3ByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmIGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaCh7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0pO1xuXG5cbnZhciBpZnJhbWUsXG5cdGVsZW1kaXNwbGF5ID0ge307XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFjdHVhbCBkaXNwbGF5IG9mIGEgZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbm9kZU5hbWUgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgRG9jdW1lbnQgb2JqZWN0XG4gKi9cbi8vIENhbGxlZCBvbmx5IGZyb20gd2l0aGluIGRlZmF1bHREaXNwbGF5XG5mdW5jdGlvbiBhY3R1YWxEaXNwbGF5KCBuYW1lLCBkb2MgKSB7XG5cdHZhciBzdHlsZSxcblx0XHRlbGVtID0galF1ZXJ5KCBkb2MuY3JlYXRlRWxlbWVudCggbmFtZSApICkuYXBwZW5kVG8oIGRvYy5ib2R5ICksXG5cblx0XHQvLyBnZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSBtaWdodCBiZSByZWxpYWJseSB1c2VkIG9ubHkgb24gYXR0YWNoZWQgZWxlbWVudFxuXHRcdGRpc3BsYXkgPSB3aW5kb3cuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgJiYgKCBzdHlsZSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSggZWxlbVsgMCBdICkgKSA/XG5cblx0XHRcdC8vIFVzZSBvZiB0aGlzIG1ldGhvZCBpcyBhIHRlbXBvcmFyeSBmaXggKG1vcmUgbGlrZSBvcHRtaXphdGlvbikgdW50aWwgc29tZXRoaW5nIGJldHRlciBjb21lcyBhbG9uZyxcblx0XHRcdC8vIHNpbmNlIGl0IHdhcyByZW1vdmVkIGZyb20gc3BlY2lmaWNhdGlvbiBhbmQgc3VwcG9ydGVkIG9ubHkgaW4gRkZcblx0XHRcdHN0eWxlLmRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtWyAwIF0sIFwiZGlzcGxheVwiICk7XG5cblx0Ly8gV2UgZG9uJ3QgaGF2ZSBhbnkgZGF0YSBzdG9yZWQgb24gdGhlIGVsZW1lbnQsXG5cdC8vIHNvIHVzZSBcImRldGFjaFwiIG1ldGhvZCBhcyBmYXN0IHdheSB0byBnZXQgcmlkIG9mIHRoZSBlbGVtZW50XG5cdGVsZW0uZGV0YWNoKCk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbi8qKlxuICogVHJ5IHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBkaXNwbGF5IHZhbHVlIG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0RGlzcGxheSggbm9kZU5hbWUgKSB7XG5cdHZhciBkb2MgPSBkb2N1bWVudCxcblx0XHRkaXNwbGF5ID0gZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF07XG5cblx0aWYgKCAhZGlzcGxheSApIHtcblx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXG5cdFx0Ly8gSWYgdGhlIHNpbXBsZSB3YXkgZmFpbHMsIHJlYWQgZnJvbSBpbnNpZGUgYW4gaWZyYW1lXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiB8fCAhZGlzcGxheSApIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgaWZyYW1lIGlmIHBvc3NpYmxlXG5cdFx0XHRpZnJhbWUgPSAoaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSkuYXBwZW5kVG8oIGRvYy5kb2N1bWVudEVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gQWx3YXlzIHdyaXRlIGEgbmV3IEhUTUwgc2tlbGV0b24gc28gV2Via2l0IGFuZCBGaXJlZm94IGRvbid0IGNob2tlIG9uIHJldXNlXG5cdFx0XHRkb2MgPSBpZnJhbWVbIDAgXS5jb250ZW50RG9jdW1lbnQ7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0XHRkb2Mud3JpdGUoKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXG5cdFx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXHRcdFx0aWZyYW1lLmRldGFjaCgpO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHRoZSBjb3JyZWN0IGRlZmF1bHQgZGlzcGxheVxuXHRcdGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdID0gZGlzcGxheTtcblx0fVxuXG5cdHJldHVybiBkaXNwbGF5O1xufVxudmFyIHJtYXJnaW4gPSAoL15tYXJnaW4vKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSBpbiBJRTksIHNlZSAjMTI1Mzdcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblx0fVxuXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA8IDZcblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gaU9TIDwgNiAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xuXHRcdC8vIHRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWUgdG8gbWlzc2luZyBkZXBlbmRlbmN5KSxcblx0XHRcdFx0Ly8gcmVtb3ZlIGl0LlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBhcmUgbm8gb3RoZXIgaG9va3MgZm9yIG1hcmdpblJpZ2h0LCByZW1vdmUgdGhlIHdob2xlIG9iamVjdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXG5cdFx0XHRyZXR1cm4gKHRoaXMuZ2V0ID0gaG9va0ZuKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLFxuXHRcdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDttYXJnaW4tdG9wOjFweDtcIiArXG5cdFx0XCJwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCkge1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpibG9jazttYXJnaW4tdG9wOjElO3RvcDoxJTtcIiArXG5cdFx0XHRcImJvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NHB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2LCBudWxsICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHRkb2NFbGVtLnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IG5vZGUuanMganNkb21cblx0Ly8gRG9uJ3QgYXNzdW1lIHRoYXQgZ2V0Q29tcHV0ZWRTdHlsZSBpcyBhIHByb3BlcnR5IG9mIHRoZSBnbG9iYWwgb2JqZWN0XG5cdGlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFRoaXMgdGVzdCBpcyBleGVjdXRlZCBvbmx5IG9uY2UgYnV0IHdlIHN0aWxsIGRvIG1lbW9pemluZ1xuXHRcdFx0XHQvLyBzaW5jZSB3ZSBjYW4gdXNlIHRoZSBib3hTaXppbmdSZWxpYWJsZSBwcmUtY29tcHV0aW5nLlxuXHRcdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxuXHRcdFx0XHRjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCk7XG5cdFx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdFx0fSxcblx0XHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRcdGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0XHR9LFxuXHRcdFx0cmVsaWFibGVNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdFx0Ly8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXG5cdFx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHRcdHZhciByZXQsXG5cdFx0XHRcdFx0bWFyZ2luRGl2ID0gZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXG5cdFx0XHRcdG1hcmdpbkRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcblx0XHRcdFx0XHRcImJveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdFx0bWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XG5cdFx0XHRcdGRpdi5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XG5cdFx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0XHRcdHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2LCBudWxsICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0XHRkb2NFbGVtLnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KSgpO1xuXG5cbi8vIEEgbWV0aG9kIGZvciBxdWlja2x5IHN3YXBwaW5nIGluL291dCBDU1MgcHJvcGVydGllcyB0byBnZXQgY29ycmVjdCBjYWxjdWxhdGlvbnMuXG5qUXVlcnkuc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhclxuXHQvLyBzd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBzZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRybnVtc3BsaXQgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKC4qKSRcIiwgXCJpXCIgKSxcblx0cnJlbE51bSA9IG5ldyBSZWdFeHAoIFwiXihbKy1dKT0oXCIgKyBwbnVtICsgXCIpXCIsIFwiaVwiICksXG5cblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiT1wiLCBcIk1velwiLCBcIm1zXCIgXTtcblxuLy8gcmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBuYW1lICkge1xuXG5cdC8vIHNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBzdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIGNoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLFxuXHRcdG9yaWdOYW1lID0gbmFtZSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3JpZ05hbWU7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cdHZhciBtYXRjaGVzID0gcm51bXNwbGl0LmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAxIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAyIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cdFx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdFx0NCA6XG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cdFx0Ly8gYm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gc29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QodmFsKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgbmVlZCB0aGUgY2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyB1c2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YV9wcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcblx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3Rcblx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuXHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcblx0XHRcdC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG5cdFx0XHRcdGRhdGFfcHJpdi5zZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiBtb3N0IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXG5cdC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoICFzaG93IHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1sgaW5kZXggXSB8fCBcIlwiIDogXCJub25lXCI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdC8vIG5vcm1hbGl6ZSBmbG9hdCBjc3MgcHJvcGVydHlcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBvcmlnTmFtZSApICk7XG5cblx0XHQvLyBnZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uXG5cdFx0Ly8gZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gY29udmVydCByZWxhdGl2ZSBudW1iZXIgc3RyaW5ncyAoKz0gb3IgLT0pIHRvIHJlbGF0aXZlIG51bWJlcnMuICM3MzQ1XG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHJldCA9IHJyZWxOdW0uZXhlYyggdmFsdWUgKSkgKSB7XG5cdFx0XHRcdHZhbHVlID0gKCByZXRbMV0gKyAxICkgKiByZXRbMl0gKyBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICkgKTtcblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQuIFNlZTogIzcxMTZcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkICdweCcgdG8gdGhlIChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gKSB7XG5cdFx0XHRcdHZhbHVlICs9IFwicHhcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRml4ZXMgIzg5MDgsIGl0IGNhbiBiZSBkb25lIG1vcmUgY29ycmVjdGx5IGJ5IHNwZWNpZnlpbmcgc2V0dGVycyBpbiBjc3NIb29rcyxcblx0XHRcdC8vIGJ1dCBpdCB3b3VsZCBtZWFuIHRvIGRlZmluZSBlaWdodCAoZm9yIGV2ZXJ5IHByb2JsZW1hdGljIHByb3BlcnR5KSBpZGVudGljYWwgZnVuY3Rpb25zXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8ICh2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggZWxlbS5zdHlsZSwgb3JpZ05hbWUgKSApO1xuXG5cdFx0Ly8gZ2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvblxuXHRcdC8vIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly9jb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiwgY29udmVydGluZyB0byBudW1iZXIgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgalF1ZXJ5LmlzTnVtZXJpYyggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHQvLyBjZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gaG93ZXZlciwgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdCBmcm9tIHRoaXNcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiYgZWxlbS5vZmZzZXRXaWR0aCA9PT0gMCA/XG5cdFx0XHRcdFx0alF1ZXJ5LnN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIGV4dHJhID9cblx0XHRcdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCkgOiAwXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xualF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBXb3JrIGFyb3VuZCBieSB0ZW1wb3JhcmlseSBzZXR0aW5nIGVsZW1lbnQgZGlzcGxheSB0byBpbmxpbmUtYmxvY2tcblx0XHRcdHJldHVybiBqUXVlcnkuc3dhcCggZWxlbSwgeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIiB9LFxuXHRcdFx0XHRjdXJDU1MsIFsgZWxlbSwgXCJtYXJnaW5SaWdodFwiIF0gKTtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIGFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KFwiIFwiKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbiggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBcInN3aW5nXCI7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmXG5cdFx0XHRcdCghdHdlZW4uZWxlbS5zdHlsZSB8fCB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCkgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIHBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlsc1xuXHRcdFx0Ly8gc28sIHNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0LlxuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcyBpcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdC8vIHVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0IC0gdXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlIC0gdXNlIC5zdHlsZSBpZiBpdHNcblx0XHRcdC8vIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLnN0eWxlICYmICggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8IGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblxuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH1cbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cmZ4bnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKSxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC8sXG5cdGFuaW1hdGlvblByZWZpbHRlcnMgPSBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblx0dHdlZW5lcnMgPSB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKSxcblx0XHRcdFx0dGFyZ2V0ID0gdHdlZW4uY3VyKCksXG5cdFx0XHRcdHBhcnRzID0gcmZ4bnVtLmV4ZWMoIHZhbHVlICksXG5cdFx0XHRcdHVuaXQgPSBwYXJ0cyAmJiBwYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0XHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0XHRcdHN0YXJ0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICt0YXJnZXQgKSAmJlxuXHRcdFx0XHRcdHJmeG51bS5leGVjKCBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCBwcm9wICkgKSxcblx0XHRcdFx0c2NhbGUgPSAxLFxuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMjA7XG5cblx0XHRcdGlmICggc3RhcnQgJiYgc3RhcnRbIDMgXSAhPT0gdW5pdCApIHtcblx0XHRcdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdFx0XHR1bml0ID0gdW5pdCB8fCBzdGFydFsgMyBdO1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHRcdFx0cGFydHMgPSBwYXJ0cyB8fCBbXTtcblxuXHRcdFx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdFx0XHRzdGFydCA9ICt0YXJnZXQgfHwgMTtcblxuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZypcblx0XHRcdFx0XHQvLyBVc2UgYSBzdHJpbmcgZm9yIGRvdWJsaW5nIGZhY3RvciBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0XHRcdHN0YXJ0ID0gc3RhcnQgLyBzY2FsZTtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHByb3AsIHN0YXJ0ICsgdW5pdCApO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0XHRcdC8vIEFuZCBicmVha2luZyB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoXG5cdFx0XHRcdH0gd2hpbGUgKCBzY2FsZSAhPT0gKHNjYWxlID0gdHdlZW4uY3VyKCkgLyB0YXJnZXQpICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9ucyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdHdlZW4gcHJvcGVydGllc1xuXHRcdFx0aWYgKCBwYXJ0cyApIHtcblx0XHRcdFx0c3RhcnQgPSB0d2Vlbi5zdGFydCA9ICtzdGFydCB8fCArdGFyZ2V0IHx8IDA7XG5cdFx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0XHQvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cblx0XHRcdFx0dHdlZW4uZW5kID0gcGFydHNbIDEgXSA/XG5cdFx0XHRcdFx0c3RhcnQgKyAoIHBhcnRzWyAxIF0gKyAxICkgKiBwYXJ0c1sgMiBdIDpcblx0XHRcdFx0XHQrcGFydHNbIDIgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9O1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIGlmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gaWYgd2UgZG9uJ3QgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNCA7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCB0d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICh0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApKSApIHtcblxuXHRcdFx0Ly8gd2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIHR3ZWVuLCBob29rcywgb2xkZmlyZSwgZGlzcGxheSwgY2hlY2tEaXNwbGF5LFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbiggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YV9wcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIGhhbmRsZSBxdWV1ZTogZmFsc2UgcHJvbWlzZXNcblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gZG9pbmcgdGhpcyBtYWtlcyBzdXJlIHRoYXQgdGhlIGNvbXBsZXRlIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWRcblx0XHRcdC8vIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBoZWlnaHQvd2lkdGggb3ZlcmZsb3cgcGFzc1xuXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcImhlaWdodFwiIGluIHByb3BzIHx8IFwid2lkdGhcIiBpbiBwcm9wcyApICkge1xuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUU5LTEwIGRvIG5vdFxuXHRcdC8vIGNoYW5nZSB0aGUgb3ZlcmZsb3cgYXR0cmlidXRlIHdoZW4gb3ZlcmZsb3dYIGFuZFxuXHRcdC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBTZXQgZGlzcGxheSBwcm9wZXJ0eSB0byBpbmxpbmUtYmxvY2sgZm9yIGhlaWdodC93aWR0aFxuXHRcdC8vIGFuaW1hdGlvbnMgb24gaW5saW5lIGVsZW1lbnRzIHRoYXQgYXJlIGhhdmluZyB3aWR0aC9oZWlnaHQgYW5pbWF0ZWRcblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblxuXHRcdC8vIFRlc3QgZGVmYXVsdCBkaXNwbGF5IGlmIGRpc3BsYXkgaXMgY3VycmVudGx5IFwibm9uZVwiXG5cdFx0Y2hlY2tEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgP1xuXHRcdFx0ZGF0YV9wcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcblxuXHRcdGlmICggY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIHNob3cvaGlkZSBwYXNzXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMuZXhlYyggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvdyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW5cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cblx0XHQvLyBBbnkgbm9uLWZ4IHZhbHVlIHN0b3BzIHVzIGZyb20gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpc3BsYXkgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGFTaG93ID0gZGF0YV9wcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwge30gKTtcblx0XHR9XG5cblx0XHQvLyBzdG9yZSBzdGF0ZSBpZiBpdHMgdG9nZ2xlIC0gZW5hYmxlcyAuc3RvcCgpLnRvZ2dsZSgpIHRvIFwicmV2ZXJzZVwiXG5cdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdH1cblx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdGpRdWVyeSggZWxlbSApLnNob3coKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5pbS5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5oaWRlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0YW5pbS5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3A7XG5cblx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHR0d2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXG5cdFx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0XHR0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0XHR0d2Vlbi5zdGFydCA9IHByb3AgPT09IFwid2lkdGhcIiB8fCBwcm9wID09PSBcImhlaWdodFwiID8gMSA6IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0Ly8gSWYgdGhpcyBpcyBhIG5vb3AgbGlrZSAuaGlkZSgpLmhpZGUoKSwgcmVzdG9yZSBhbiBvdmVyd3JpdHRlbiBkaXNwbGF5IHZhbHVlXG5cdH0gZWxzZSBpZiAoIChkaXNwbGF5ID09PSBcIm5vbmVcIiA/IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5KSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gbm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbnQgb3ZlcndyaXRlIGtleXMgYWxyZWFkeSBwcmVzZW50LlxuXHRcdFx0Ly8gYWxzbyAtIHJldXNpbmcgJ2luZGV4JyBmcm9tIGFib3ZlIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gYW5pbWF0aW9uUHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gZG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0pLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXHRcdFx0XHQvLyBhcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgMSAtICggMC41IHx8IDAgKSAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXHRcdFx0XHRcdC8vIGlmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWVcblx0XHRcdFx0Ly8gb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0pLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gYW5pbWF0aW9uUHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0pXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLnNwbGl0KFwiIFwiKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0dHdlZW5lcnNbIHByb3AgXSA9IHR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHR0d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5pbWF0aW9uUHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID8gb3B0LmR1cmF0aW9uIDpcblx0XHRvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuXHQvLyBub3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBzaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBhbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YV9wcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YV9wcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgKHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUpICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkXG5cdFx0XHQvLyB0aW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoIHdpbGwgZGVxdWV1ZVxuXHRcdFx0Ly8gYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmRcblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YV9wcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBlbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIGVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gdHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKHtcblx0c2xpZGVEb3duOiBnZW5GeChcInNob3dcIiksXG5cdHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KFwidG9nZ2xlXCIpLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5cbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSBzZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRjbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSk7XG59O1xuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBpT1MgNS4xLCBBbmRyb2lkIDQueCwgQW5kcm9pZCAyLjNcblx0Ly8gQ2hlY2sgdGhlIGRlZmF1bHQgY2hlY2tib3gvcmFkaW8gdmFsdWUgKFwiXCIgb24gb2xkIFdlYktpdDsgXCJvblwiIGVsc2V3aGVyZSlcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gTXVzdCBhY2Nlc3MgdGhlIHBhcmVudCB0byBtYWtlIGFuIG9wdGlvbiBzZWxlY3QgcHJvcGVybHlcblx0Ly8gU3VwcG9ydDogSUU5LCBJRTEwXG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIG9wdGlvbnMgaW5zaWRlIGRpc2FibGVkIHNlbGVjdHMgYXJlbid0IG1hcmtlZCBhcyBkaXNhYmxlZFxuXHQvLyAoV2ViS2l0IG1hcmtzIHRoZW0gYXMgZGlzYWJsZWQpXG5cdHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG5cdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG5cdC8vIENoZWNrIGlmIGFuIGlucHV0IG1haW50YWlucyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHQvLyBTdXBwb3J0OiBJRTksIElFMTBcblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSkoKTtcblxuXG52YXIgbm9kZUhvb2ssIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gZG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2Vcblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogbm9kZUhvb2sgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/XG5cdFx0XHRcdHVuZGVmaW5lZCA6XG5cdFx0XHRcdHJldDtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLCBwcm9wTmFtZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKG5hbWUgPSBhdHRyTmFtZXNbaSsrXSkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0XHQvLyBTZXQgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB0byBmYWxzZVxuXHRcdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0Ly8gU2V0dGluZyB0aGUgdHlwZSBvbiBhIHJhZGlvIGJ1dHRvbiBhZnRlciB0aGUgdmFsdWUgcmVzZXRzIHRoZSB2YWx1ZSBpbiBJRTYtOVxuXHRcdFx0XHRcdC8vIFJlc2V0IHZhbHVlIHRvIGRlZmF1bHQgaW4gY2FzZSB0eXBlIGlzIHNldCBhZnRlciB2YWx1ZSBkdXJpbmcgY3JlYXRpb25cblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBuYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59KTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fSxcblxuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsIG5vdHhtbCxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIGRvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcblxuXHRcdGlmICggbm90eG1sICkge1xuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyZXQgOlxuXHRcdFx0XHQoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCA/XG5cdFx0XHRcdHJldCA6XG5cdFx0XHRcdGVsZW1bIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmhhc0F0dHJpYnV0ZSggXCJ0YWJpbmRleFwiICkgfHwgcmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRlbGVtLnRhYkluZGV4IDpcblx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTkrXG4vLyBTZWxlY3RlZG5lc3MgZm9yIGFuIG9wdGlvbiBpbiBhbiBvcHRncm91cCBjYW4gYmUgaW5hY2N1cmF0ZVxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaChbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRwcm9jZWVkID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgdGhpcy5jbGFzc05hbWUgKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBwcm9jZWVkICkge1xuXHRcdFx0Ly8gVGhlIGRpc2p1bmN0aW9uIGhlcmUgaXMgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSByZW1vdmVDbGFzcylcblx0XHRcdGNsYXNzZXMgPSAoIHZhbHVlIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggZWxlbS5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdCggXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRcIiBcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdHByb2NlZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoIHByb2NlZWQgKSB7XG5cdFx0XHRjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID9cblx0XHRcdFx0XHQoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG5cdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID49IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gdmFsdWUgPyBqUXVlcnkudHJpbSggY3VyICkgOiBcIlwiO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gdG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoIChjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSkgKSB7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IHN0cnVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHQvLyBzdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIHRoaXMuY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBcImZhbHNlXCIsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0dGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgPyBcIlwiIDogZGF0YV9wcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggdGhpc1tpXS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpLmluZGV4T2YoIGNsYXNzTmFtZSApID49IDAgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1swXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0Ly8gaGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKHJyZXR1cm4sIFwiXCIpIDpcblx0XHRcdFx0XHQvLyBoYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0XHRyZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTAtMTErXG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdGpRdWVyeS50cmltKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIElFNi05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/ICFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PT0gbnVsbCApICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCAob3B0aW9uLnNlbGVjdGVkID0galF1ZXJ5LmluQXJyYXkoIG9wdGlvbi52YWx1ZSwgdmFsdWVzICkgPj0gMCkgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaChbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlICkgPj0gMCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2Via2l0XG5cdFx0XHQvLyBcIlwiIGlzIHJldHVybmVkIGluc3RlYWQgb2YgXCJvblwiIGlmIGEgdmFsdWUgaXNuJ3Qgc3BlY2lmaWVkXG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5qUXVlcnkuZWFjaCggKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIpLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fSxcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOiB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSk7XG5cblxudmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKC9cXD8vKTtcblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG4vLyBXb3JrYXJvdW5kIGZhaWx1cmUgdG8gc3RyaW5nLWNhc3QgbnVsbCBpbnB1dFxualF1ZXJ5LnBhcnNlSlNPTiA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSArIFwiXCIgKTtcbn07XG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWwsIHRtcDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHR0cnkge1xuXHRcdHRtcCA9IG5ldyBET01QYXJzZXIoKTtcblx0XHR4bWwgPSB0bXAucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdC8vIERvY3VtZW50IGxvY2F0aW9uXG5cdGFqYXhMb2NQYXJ0cyxcblx0YWpheExvY2F0aW9uLFxuXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cdHJ1cmwgPSAvXihbXFx3ListXSs6KSg/OlxcL1xcLyg/OlteXFwvPyNdKkB8KShbXlxcLz8jOl0qKSg/OjooXFxkKyl8KXwpLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KFwiKlwiKTtcblxuLy8gIzgxMzgsIElFIG1heSB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3Npbmdcbi8vIGEgZmllbGQgZnJvbSB3aW5kb3cubG9jYXRpb24gaWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIHNldFxudHJ5IHtcblx0YWpheExvY2F0aW9uID0gbG9jYXRpb24uaHJlZjtcbn0gY2F0Y2goIGUgKSB7XG5cdC8vIFVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUgb2YgYW4gQSBlbGVtZW50XG5cdC8vIHNpbmNlIElFIHdpbGwgbW9kaWZ5IGl0IGdpdmVuIGRvY3VtZW50LmxvY2F0aW9uXG5cdGFqYXhMb2NhdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdGFqYXhMb2NhdGlvbi5ocmVmID0gXCJcIjtcblx0YWpheExvY2F0aW9uID0gYWpheExvY2F0aW9uLmhyZWY7XG59XG5cbi8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0c1xuYWpheExvY1BhcnRzID0gcnVybC5leGVjKCBhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSApIHx8IFtdO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoZGF0YVR5cGUgPSBkYXRhVHlwZXNbaSsrXSkgKSB7XG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbMF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdChzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiYgIXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoZGVlcCA9IHt9KSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgc1sgXCJ0aHJvd3NcIiBdICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHsgc3RhdGU6IFwicGFyc2VyZXJyb3JcIiwgZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50IH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBhamF4TG9jYXRpb24sXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBhamF4TG9jUGFydHNbIDEgXSApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL3htbC8sXG5cdFx0XHRodG1sOiAvaHRtbC8sXG5cdFx0XHRqc29uOiAvanNvbi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogalF1ZXJ5LnBhcnNlSlNPTixcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXHRcdFx0Ly8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzXG5cdFx0XHRwYXJ0cyxcblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiYgKCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5ldmVudCxcblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXHRcdFx0Ly8gVGhlIGpxWEhSIHN0YXRlXG5cdFx0XHRzdGF0ZSA9IDAsXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlID09PSAyID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0dmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApLmNvbXBsZXRlID0gY29tcGxldGVEZWZlcnJlZC5hZGQ7XG5cdFx0anFYSFIuc3VjY2VzcyA9IGpxWEhSLmRvbmU7XG5cdFx0anFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xuXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggY2hhcmFjdGVyICgjNzUzMTogYW5kIHN0cmluZyBwcm9tb3Rpb24pXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgYWpheExvY2F0aW9uICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgYWpheExvY1BhcnRzWyAxIF0gKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHdlIGhhdmUgYSBwcm90b2NvbDpob3N0OnBvcnQgbWlzbWF0Y2hcblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHBhcnRzID0gcnVybC5leGVjKCBzLnVybC50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRzLmNyb3NzRG9tYWluID0gISEoIHBhcnRzICYmXG5cdFx0XHRcdCggcGFydHNbIDEgXSAhPT0gYWpheExvY1BhcnRzWyAxIF0gfHwgcGFydHNbIDIgXSAhPT0gYWpheExvY1BhcnRzWyAyIF0gfHxcblx0XHRcdFx0XHQoIHBhcnRzWyAzIF0gfHwgKCBwYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyBcIjgwXCIgOiBcIjQ0M1wiICkgKSAhPT1cblx0XHRcdFx0XHRcdCggYWpheExvY1BhcnRzWyAzIF0gfHwgKCBhamF4TG9jUGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdGZpcmVHbG9iYWxzID0gcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHRjYWNoZVVSTCA9IHMudXJsO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9ICggcy51cmwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YSApO1xuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVybCBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHMudXJsID0gcnRzLnRlc3QoIGNhY2hlVVJMICkgP1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhICdfJyBwYXJhbWV0ZXIsIHNldCBpdHMgdmFsdWVcblx0XHRcdFx0XHRjYWNoZVVSTC5yZXBsYWNlKCBydHMsIFwiJDFfPVwiICsgbm9uY2UrKyApIDpcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBhZGQgb25lIHRvIHRoZSBlbmRcblx0XHRcdFx0XHRjYWNoZVVSTCArICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyBub25jZSsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gKyAoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJiAoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IHN0YXRlID09PSAyICkgKSB7XG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIGFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Zm9yICggaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9ICkge1xuXHRcdFx0anFYSFJbIGkgXSggc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KFwidGltZW91dFwiKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHN0YXRlID0gMTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0XHQvLyBTaW1wbHkgcmV0aHJvdyBvdGhlcndpc2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gQ2FsbGVkIG9uY2Vcblx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdGUgaXMgXCJkb25lXCIgbm93XG5cdFx0XHRzdGF0ZSA9IDI7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2UgZXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHRcblx0XHRcdFx0Ly8gdGhlbiBub3JtYWxpemUgc3RhdHVzVGV4dCBhbmQgc3RhdHVzIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cdFx0Ly8gc2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9KTtcblx0fTtcbn0pO1xuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFsgXCJhamF4U3RhcnRcIiwgXCJhamF4U3RvcFwiLCBcImFqYXhDb21wbGV0ZVwiLCBcImFqYXhFcnJvclwiLCBcImFqYXhTdWNjZXNzXCIsIFwiYWpheFNlbmRcIiBdLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59KTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdHVybDogdXJsLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9KTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9KS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwodGhpcywgaSkgOiBodG1sICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fSkuZW5kKCk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDw9IDEyLjEyXG5cdC8vIE9wZXJhIHJlcG9ydHMgb2Zmc2V0V2lkdGhzIGFuZCBvZmZzZXRIZWlnaHRzIGxlc3MgdGhhbiB6ZXJvIG9uIHNvbWUgZWxlbWVudHNcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPD0gMCAmJiBlbGVtLm9mZnNldEhlaWdodCA8PSAwO1xufTtcbmpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuKCBlbGVtICk7XG59O1xuXG5cblxuXG52YXIgcjIwID0gLyUyMC9nLFxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgPyBpIDogXCJcIiApICsgXCJdXCIsIHYsIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0pO1xuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSlcblx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9KVxuXHRcdC5tYXAoZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9KS5nZXQoKTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2goIGUgKSB7fVxufTtcblxudmFyIHhocklkID0gMCxcblx0eGhyQ2FsbGJhY2tzID0ge30sXG5cdHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cdFx0Ly8gZmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gT3BlbiByZXF1ZXN0cyBtdXN0IGJlIG1hbnVhbGx5IGFib3J0ZWQgb24gdW5sb2FkICgjNTI4MClcbmlmICggd2luZG93LkFjdGl2ZVhPYmplY3QgKSB7XG5cdGpRdWVyeSggd2luZG93ICkub24oIFwidW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdGZvciAoIHZhciBrZXkgaW4geGhyQ2FsbGJhY2tzICkge1xuXHRcdFx0eGhyQ2FsbGJhY2tzWyBrZXkgXSgpO1xuXHRcdH1cblx0fSk7XG59XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCksXG5cdFx0XHRcdFx0aWQgPSArK3hocklkO1xuXG5cdFx0XHRcdHhoci5vcGVuKCBvcHRpb25zLnR5cGUsIG9wdGlvbnMudXJsLCBvcHRpb25zLmFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkICk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSB4aHJDYWxsYmFja3NbIGlkIF07XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0geGhyLm9ubG9hZCA9IHhoci5vbmVycm9yID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBBY2Nlc3NpbmcgYmluYXJ5LWRhdGEgcmVzcG9uc2VUZXh0IHRocm93cyBhbiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHRcdC8vICgjMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gXCJzdHJpbmdcIiA/IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dDogeGhyLnJlc3BvbnNlVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0fSA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdHhoci5vbmVycm9yID0gY2FsbGJhY2soXCJlcnJvclwiKTtcblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0geGhyQ2FsbGJhY2tzWyBpZCBdID0gY2FsbGJhY2soXCJhYm9ydFwiKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogLyg/OmphdmF8ZWNtYSlzY3JpcHQvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59KTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeShcIjxzY3JpcHQ+XCIpLnByb3Aoe1xuXHRcdFx0XHRcdGFzeW5jOiB0cnVlLFxuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0pLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59KTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiAhKCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBmb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gUmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBkYXRhOiBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LCBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbMV0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbnZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoXCIgXCIpO1xuXG5cdGlmICggb2ZmID49IDAgKSB7XG5cdFx0c2VsZWN0b3IgPSBqUXVlcnkudHJpbSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBpZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkXG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSkuZG9uZShmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeShcIjxkaXY+XCIpLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdH0pLmNvbXBsZXRlKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggY2FsbGJhY2ssIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9KS5sZW5ndGg7XG59O1xuXG5cblxuXG52YXIgZG9jRWxlbSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoXCJhdXRvXCIpID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlciB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGN1ck9mZnNldCApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRpZiAoICFkb2MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0XHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3g7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBnQkNSLCBqdXN0IHVzZSAwLDAgcmF0aGVyIHRoYW4gZXJyb3Jcblx0XHQvLyBCbGFja0JlcnJ5IDUsIGlPUyAzIChvcmlnaW5hbCBpUGhvbmUpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0fVxuXHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogYm94LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0bGVmdDogYm94LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LCBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHQvLyBXZSBhc3N1bWUgdGhhdCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgYXZhaWxhYmxlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2NFbGVtO1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudCwgXCJodG1sXCIgKSAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW5kb3cucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGgsIG51bGwgKTtcblx0fTtcbn0pO1xuXG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwgd2UganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblx0XHRcdFx0Ly8gaWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59KTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LCBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblx0XHQvLyBtYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0Ly8gQXMgb2YgNS84LzIwMTIgdGhpcyB3aWxsIHlpZWxkIGluY29ycmVjdCByZXN1bHRzIGZvciBNb2JpbGUgU2FmYXJpLCBidXQgdGhlcmVcblx0XHRcdFx0XHQvLyBpc24ndCBhIHdob2xlIGxvdCB3ZSBjYW4gZG8uIFNlZSBwdWxsIHJlcXVlc3QgYXQgdGhpcyBVUkwgZm9yIGRpc2N1c3Npb246XG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC83NjRcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlLCBudWxsICk7XG5cdFx0fTtcblx0fSk7XG59KTtcblxuXG4vLyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldFxualF1ZXJ5LmZuLnNpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxualF1ZXJ5LmZuLmFuZFNlbGYgPSBqUXVlcnkuZm4uYWRkQmFjaztcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9KTtcbn1cblxuXG5cblxudmFyXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpblxuLy8gQU1EICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggdHlwZW9mIG5vR2xvYmFsID09PSBzdHJ1bmRlZmluZWQgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcblxufSkpO1xuXG59KSgpIiwiQU5OID0gcmVxdWlyZSAnLi9hbm4uY29mZmVlJ1xubmV0d29yayA9IHJlcXVpcmUgJy4vbmV0d29yaydcblxuYW5uID0gQU5OLmZyb21KU09OIG5ldHdvcmtcblxuZml0bmVzcyA9IChzY2hlbWUpIC0+IGFubi5yYXRlKHtjb2xvcnM6c2NoZW1lfSlcbiMgZml0bmVzcyA9IChzY2hlbWUpIC0+IDAgIyBkZWZhdWx0IG9yZGVyXG5cbm1vZHVsZS5leHBvcnRzID0gZml0bmVzc1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgXCJsYXllcnNcIjpbe1wib3V0X2RlcHRoXCI6MSxcIm91dF9zeFwiOjE2LFwib3V0X3N5XCI6MSxcImxheWVyX3R5cGVcIjpcImlucHV0XCJ9LHtcIm91dF9kZXB0aFwiOjE2LFwib3V0X3N4XCI6MSxcIm91dF9zeVwiOjEsXCJsYXllcl90eXBlXCI6XCJmY1wiLFwibnVtX2lucHV0c1wiOjE2LFwibDFfZGVjYXlfbXVsXCI6MCxcImwyX2RlY2F5X211bFwiOjEsXCJmaWx0ZXJzXCI6W3tcInN4XCI6MSxcInN5XCI6MSxcImRlcHRoXCI6MTYsXCJ3XCI6e1wiMFwiOjAuMjUyNTg4NjQ5NTY2MzUxNCxcIjFcIjotMC4wNzY4MDAxNzM1NTcwNzcyNyxcIjJcIjotMC41MzU3MDY4MjE0MzI0MjUxLFwiM1wiOjAuMTM0NDQ1NjU4Mzg0OTU1NyxcIjRcIjotMC4wMjI5NTc0NjE3MDgwMTgyMDUsXCI1XCI6LTAuNjEwMDY0MjA2Mzg2NTY3LFwiNlwiOjAuMTQzNjc1ODU2NTk2Nzg2MDgsXCI3XCI6MC4zMDEzODcyNTMwMjIyMTY3NSxcIjhcIjotMC4yMzEwMjkxODgzNzc0NTE5OCxcIjlcIjowLjA2MTUzODE4MDQwMDI0MjYsXCIxMFwiOjAuMzQzNTg0NDAxMTQ4NjIwNyxcIjExXCI6LTAuNDE3OTA3NTk4MzQ4MTQ3NTYsXCIxMlwiOjAuNDU3NTA5MjcxMTI0NzgwNTcsXCIxM1wiOjAuMjcyNDQzMTQ5ODY2MTU1MixcIjE0XCI6LTAuMzM4MTQ4MTE2NzgzNTE4MSxcIjE1XCI6LTAuNTE1MTIzNjUyMjk0NDgxNSxcIkJZVEVTX1BFUl9FTEVNRU5UXCI6OCxcImJ1ZmZlclwiOntcIjBcIjo1MixcIjFcIjoxNTYsXCIyXCI6NzgsXCIzXCI6MTQ5LFwiNFwiOjEwNSxcIjVcIjo0MixcIjZcIjoyMDgsXCI3XCI6NjMsXCI4XCI6MTcwLFwiOVwiOjU2LFwiMTBcIjoxOTMsXCIxMVwiOjI1LFwiMTJcIjo0NSxcIjEzXCI6MTY5LFwiMTRcIjoxNzksXCIxNVwiOjE5MSxcIjE2XCI6MjM3LFwiMTdcIjoxMjMsXCIxOFwiOjIwMSxcIjE5XCI6MTYxLFwiMjBcIjoxMzAsXCIyMVwiOjM2LFwiMjJcIjoyMjUsXCIyM1wiOjE5MSxcIjI0XCI6MjgsXCIyNVwiOjMzLFwiMjZcIjoyMzcsXCIyN1wiOjIzNixcIjI4XCI6MTMxLFwiMjlcIjo1MyxcIjMwXCI6MTkzLFwiMzFcIjo2MyxcIjMyXCI6MjA2LFwiMzNcIjoxOTIsXCIzNFwiOjI0MCxcIjM1XCI6NDQsXCIzNlwiOjQxLFwiMzdcIjoxMzAsXCIzOFwiOjE1MSxcIjM5XCI6MTkxLFwiNDBcIjoyNDksXCI0MVwiOjEyNixcIjQyXCI6MjIwLFwiNDNcIjo5NCxcIjQ0XCI6MTY1LFwiNDVcIjoxMzMsXCI0NlwiOjIyNyxcIjQ3XCI6MTkxLFwiNDhcIjoyNDUsXCI0OVwiOjEwNyxcIjUwXCI6MTY3LFwiNTFcIjoxMTIsXCI1MlwiOjI0OCxcIjUzXCI6OTksXCI1NFwiOjE5NCxcIjU1XCI6NjMsXCI1NlwiOjY3LFwiNTdcIjo4OSxcIjU4XCI6MjAyLFwiNTlcIjoxOTQsXCI2MFwiOjIzNyxcIjYxXCI6NzMsXCI2MlwiOjIxMSxcIjYzXCI6NjMsXCI2NFwiOjEzNSxcIjY1XCI6ODQsXCI2NlwiOjY0LFwiNjdcIjo3NixcIjY4XCI6OTMsXCI2OVwiOjE0NixcIjcwXCI6MjA1LFwiNzFcIjoxOTEsXCI3MlwiOjIyMixcIjczXCI6MTI0LFwiNzRcIjoxNDAsXCI3NVwiOjE3NixcIjc2XCI6MjM4LFwiNzdcIjoxMjksXCI3OFwiOjE3NSxcIjc5XCI6NjMsXCI4MFwiOjQ1LFwiODFcIjo4NyxcIjgyXCI6MTUwLFwiODNcIjoxMDksXCI4NFwiOjczLFwiODVcIjoyNTMsXCI4NlwiOjIxMyxcIjg3XCI6NjMsXCI4OFwiOjE5MyxcIjg5XCI6MjM4LFwiOTBcIjoyMzMsXCI5MVwiOjEzMCxcIjkyXCI6MjU1LFwiOTNcIjoxOTAsXCI5NFwiOjIxOCxcIjk1XCI6MTkxLFwiOTZcIjo1MixcIjk3XCI6NjUsXCI5OFwiOjcwLFwiOTlcIjoyNDcsXCIxMDBcIjoyMTIsXCIxMDFcIjo3MSxcIjEwMlwiOjIyMSxcIjEwM1wiOjYzLFwiMTA0XCI6MTE1LFwiMTA1XCI6MTEyLFwiMTA2XCI6MTcyLFwiMTA3XCI6MTAwLFwiMTA4XCI6MTgxLFwiMTA5XCI6MTExLFwiMTEwXCI6MjA5LFwiMTExXCI6NjMsXCIxMTJcIjo2MCxcIjExM1wiOjEzMCxcIjExNFwiOjE3OCxcIjExNVwiOjI1NSxcIjExNlwiOjU1LFwiMTE3XCI6MTY0LFwiMTE4XCI6MjEzLFwiMTE5XCI6MTkxLFwiMTIwXCI6NDAsXCIxMjFcIjo3LFwiMTIyXCI6MCxcIjEyM1wiOjE1MyxcIjEyNFwiOjIyOCxcIjEyNVwiOjEyMyxcIjEyNlwiOjIyNCxcIjEyN1wiOjE5MSxcImJ5dGVMZW5ndGhcIjoxMjh9LFwibGVuZ3RoXCI6MTYsXCJieXRlT2Zmc2V0XCI6MCxcImJ5dGVMZW5ndGhcIjoxMjh9fSx7XCJzeFwiOjEsXCJzeVwiOjEsXCJkZXB0aFwiOjE2LFwid1wiOntcIjBcIjowLjIzNDA5MDg1MDY5OTcxNzk0LFwiMVwiOi0wLjA1OTY3NTQyNjE0MzM5MjEyLFwiMlwiOi0wLjM2NTc5NTQzOTgzNTU1NzU3LFwiM1wiOjAuNDQ0MjkzNzE4MjU4Mzg0NjUsXCI0XCI6MC4zOTYyMzYxNjgzOTY5NDI1LFwiNVwiOi0wLjk2MTE5MTMxNTY2ODM5ODgsXCI2XCI6LTAuMTQzNTk2NjM3MDQzOTE2MTIsXCI3XCI6MC4wNDk0MTU0MDIxNjM3MzAxOSxcIjhcIjotMC4xNzk1NTIwOTQ1OTIxODg1NCxcIjlcIjowLjA3NzAzNjIyOTgxOTg3MjQzLFwiMTBcIjotMC4xNjI0NTQ5MzA2NTc0ODgyOCxcIjExXCI6LTAuNDM3MDUyODE3Njg5NjcxOCxcIjEyXCI6MC4xMjIwMjY2MzEyNDY0OTY3NCxcIjEzXCI6MC4wMDkyNDY4NDUyOTgyMzk2NCxcIjE0XCI6LTAuMzIxNjYxNjI5NzA5OTg0NzQsXCIxNVwiOi0wLjUzMTAzNTgwNDY3MzQxMDIsXCJCWVRFU19QRVJfRUxFTUVOVFwiOjgsXCJidWZmZXJcIjp7XCIwXCI6OTcsXCIxXCI6NDAsXCIyXCI6NixcIjNcIjo5OCxcIjRcIjoxNzYsXCI1XCI6MjQ2LFwiNlwiOjIwNSxcIjdcIjo2MyxcIjhcIjoxMzgsXCI5XCI6NzUsXCIxMFwiOjgyLFwiMTFcIjo3LFwiMTJcIjoxOTksXCIxM1wiOjE0MSxcIjE0XCI6MTc0LFwiMTVcIjoxOTEsXCIxNlwiOjExMSxcIjE3XCI6MTY4LFwiMThcIjoxOTksXCIxOVwiOjcwLFwiMjBcIjo0OSxcIjIxXCI6MTA1LFwiMjJcIjoyMTUsXCIyM1wiOjE5MSxcIjI0XCI6MTAxLFwiMjVcIjo1OSxcIjI2XCI6MTExLFwiMjdcIjoyMzUsXCIyOFwiOjc4LFwiMjlcIjoxMTEsXCIzMFwiOjIyMCxcIjMxXCI6NjMsXCIzMlwiOjYxLFwiMzNcIjoxMTgsXCIzNFwiOjQ4LFwiMzVcIjoyNDIsXCIzNlwiOjIzOCxcIjM3XCI6OTEsXCIzOFwiOjIxNyxcIjM5XCI6NjMsXCI0MFwiOjIzNSxcIjQxXCI6MjE0LFwiNDJcIjo2MyxcIjQzXCI6NzQsXCI0NFwiOjIwLFwiNDVcIjoxOTQsXCI0NlwiOjIzOCxcIjQ3XCI6MTkxLFwiNDhcIjoxMDQsXCI0OVwiOjE2OCxcIjUwXCI6MjQ1LFwiNTFcIjoyMjksXCI1MlwiOjk1LFwiNTNcIjo5NyxcIjU0XCI6MTk0LFwiNTVcIjoxOTEsXCI1NlwiOjgwLFwiNTdcIjoxMjcsXCI1OFwiOjEwOCxcIjU5XCI6MTkyLFwiNjBcIjoyNDksXCI2MVwiOjc2LFwiNjJcIjoxNjksXCI2M1wiOjYzLFwiNjRcIjoyMjcsXCI2NVwiOjIxMCxcIjY2XCI6MjUsXCI2N1wiOjM1LFwiNjhcIjoxNDQsXCI2OVwiOjI1MSxcIjcwXCI6MTk4LFwiNzFcIjoxOTEsXCI3MlwiOjg2LFwiNzNcIjoyNDksXCI3NFwiOjE3NCxcIjc1XCI6MTE5LFwiNzZcIjoxNjUsXCI3N1wiOjE4NCxcIjc4XCI6MTc5LFwiNzlcIjo2MyxcIjgwXCI6MjI0LFwiODFcIjoxODUsXCI4MlwiOjMxLFwiODNcIjoxODcsXCI4NFwiOjgyLFwiODVcIjoyMDMsXCI4NlwiOjE5NixcIjg3XCI6MTkxLFwiODhcIjoxODksXCI4OVwiOjEzMSxcIjkwXCI6MTY2LFwiOTFcIjo5NyxcIjkyXCI6MTcyLFwiOTNcIjoyNDgsXCI5NFwiOjIxOSxcIjk1XCI6MTkxLFwiOTZcIjoxMjIsXCI5N1wiOjIxOSxcIjk4XCI6MTEzLFwiOTlcIjozOCxcIjEwMFwiOjM1LFwiMTAxXCI6NjEsXCIxMDJcIjoxOTEsXCIxMDNcIjo2MyxcIjEwNFwiOjg1LFwiMTA1XCI6NzIsXCIxMDZcIjo0NSxcIjEwN1wiOjE0NSxcIjEwOFwiOjIsXCIxMDlcIjoyNDAsXCIxMTBcIjoxMzAsXCIxMTFcIjo2MyxcIjExMlwiOjEwMyxcIjExM1wiOjIyNCxcIjExNFwiOjI1NCxcIjExNVwiOjE2OCxcIjExNlwiOjI2LFwiMTE3XCI6MTUwLFwiMTE4XCI6MjEyLFwiMTE5XCI6MTkxLFwiMTIwXCI6MTQ3LFwiMTIxXCI6MTIxLFwiMTIyXCI6MTk0LFwiMTIzXCI6MjA0LFwiMTI0XCI6NjIsXCIxMjVcIjoyNTQsXCIxMjZcIjoyMjQsXCIxMjdcIjoxOTEsXCJieXRlTGVuZ3RoXCI6MTI4fSxcImxlbmd0aFwiOjE2LFwiYnl0ZU9mZnNldFwiOjAsXCJieXRlTGVuZ3RoXCI6MTI4fX0se1wic3hcIjoxLFwic3lcIjoxLFwiZGVwdGhcIjoxNixcIndcIjp7XCIwXCI6LTAuMTQ4MDEyNTYyNDI5OTYyODMsXCIxXCI6LTAuMDc1MTQ4NTQ0ODQxODMxNDgsXCIyXCI6MC4wODIyNzQzODY5NTY3MDg3LFwiM1wiOi0wLjQyODA5NTE5NDc2ODc2MTIzLFwiNFwiOi0wLjE3NTMxMDkxMzQwMzcwMTM0LFwiNVwiOjAuNDIyMjM3ODcyODgzMjQ4MDQsXCI2XCI6LTAuNDQ2MDYwOTQxNjkzOTY3MDQsXCI3XCI6LTAuMzA0NjkxOTU1NjY4MDAxMSxcIjhcIjowLjA0MzQzNDgzOTM3NDUwNzc4LFwiOVwiOi0wLjMwMDg3NDI2NzU2OTkwMjksXCIxMFwiOi0wLjI1MzQyMDk1MTQxMDU5NzksXCIxMVwiOjAuNDE5NDUyNDYwMDM1OTQ1OSxcIjEyXCI6LTAuMjgyNjcwNTY4OTY3NTc3NSxcIjEzXCI6LTAuNDE1MDUxOTc2MDkwMjAzMixcIjE0XCI6MC40NDA0NDM5NjgxNjc0Mjk4NyxcIjE1XCI6MC4yNTQyMzIwMDI0MzMxODc5LFwiQllURVNfUEVSX0VMRU1FTlRcIjo4LFwiYnVmZmVyXCI6e1wiMFwiOjM5LFwiMVwiOjg1LFwiMlwiOjEzMixcIjNcIjo5MyxcIjRcIjoxOSxcIjVcIjoyNDIsXCI2XCI6MTk0LFwiN1wiOjE5MSxcIjhcIjo1MixcIjlcIjoxMCxcIjEwXCI6MTEyLFwiMTFcIjo5NCxcIjEyXCI6MjM5LFwiMTNcIjo2MCxcIjE0XCI6MTc5LFwiMTVcIjoxOTEsXCIxNlwiOjIxLFwiMTdcIjoxMSxcIjE4XCI6NzEsXCIxOVwiOjQxLFwiMjBcIjoyMzksXCIyMVwiOjE1LFwiMjJcIjoxODEsXCIyM1wiOjYzLFwiMjRcIjo1MixcIjI1XCI6MjEwLFwiMjZcIjo3MCxcIjI3XCI6OTksXCIyOFwiOjIzMyxcIjI5XCI6MTAxLFwiMzBcIjoyMTksXCIzMVwiOjE5MSxcIjMyXCI6ODUsXCIzM1wiOjE3OSxcIjM0XCI6MjE3LFwiMzVcIjoxMzUsXCIzNlwiOjE1MCxcIjM3XCI6MTEyLFwiMzhcIjoxOTgsXCIzOVwiOjE5MSxcIjQwXCI6NzUsXCI0MVwiOjE2MixcIjQyXCI6MjAyLFwiNDNcIjoyNTUsXCI0NFwiOjI0MSxcIjQ1XCI6NSxcIjQ2XCI6MjE5LFwiNDdcIjo2MyxcIjQ4XCI6MTcwLFwiNDlcIjo3OCxcIjUwXCI6MzgsXCI1MVwiOjQ5LFwiNTJcIjo2NyxcIjUzXCI6MTQwLFwiNTRcIjoyMjAsXCI1NVwiOjE5MSxcIjU2XCI6MTgyLFwiNTdcIjoxNzcsXCI1OFwiOjYwLFwiNTlcIjoxNzYsXCI2MFwiOjE4LFwiNjFcIjoxMjgsXCI2MlwiOjIxMSxcIjYzXCI6MTkxLFwiNjRcIjo4MyxcIjY1XCI6MTgxLFwiNjZcIjo2MSxcIjY3XCI6OTMsXCI2OFwiOjIzLFwiNjlcIjo2MSxcIjcwXCI6MTY2LFwiNzFcIjo2MyxcIjcyXCI6MTM0LFwiNzNcIjoyMzYsXCI3NFwiOjIxOCxcIjc1XCI6MzYsXCI3NlwiOjEzNCxcIjc3XCI6NjUsXCI3OFwiOjIxMSxcIjc5XCI6MTkxLFwiODBcIjoxNDksXCI4MVwiOjEyOCxcIjgyXCI6MTU1LFwiODNcIjoxMzAsXCI4NFwiOjEyLFwiODVcIjo1NixcIjg2XCI6MjA4LFwiODdcIjoxOTEsXCI4OFwiOjc5LFwiODlcIjo0OSxcIjkwXCI6MTMzLFwiOTFcIjozMyxcIjkyXCI6NzksXCI5M1wiOjIxNixcIjk0XCI6MjE4LFwiOTVcIjo2MyxcIjk2XCI6NDgsXCI5N1wiOjEyMixcIjk4XCI6ODAsXCI5OVwiOjc2LFwiMTAwXCI6NzAsXCIxMDFcIjoyMyxcIjEwMlwiOjIxMCxcIjEwM1wiOjE5MSxcIjEwNFwiOjEwOSxcIjEwNVwiOjE2NSxcIjEwNlwiOjIyMCxcIjEwN1wiOjQxLFwiMTA4XCI6NTQsXCIxMDlcIjoxNDQsXCIxMTBcIjoyMTgsXCIxMTFcIjoxOTEsXCIxMTJcIjoxNSxcIjExM1wiOjI0OSxcIjExNFwiOjE5MSxcIjExNVwiOjIyOSxcIjExNlwiOjU5LFwiMTE3XCI6NDgsXCIxMThcIjoyMjAsXCIxMTlcIjo2MyxcIjEyMFwiOjY0LFwiMTIxXCI6NCxcIjEyMlwiOjMsXCIxMjNcIjo3OCxcIjEyNFwiOjg2LFwiMTI1XCI6NjksXCIxMjZcIjoyMDgsXCIxMjdcIjo2MyxcImJ5dGVMZW5ndGhcIjoxMjh9LFwibGVuZ3RoXCI6MTYsXCJieXRlT2Zmc2V0XCI6MCxcImJ5dGVMZW5ndGhcIjoxMjh9fSx7XCJzeFwiOjEsXCJzeVwiOjEsXCJkZXB0aFwiOjE2LFwid1wiOntcIjBcIjotMC40NzEwMDU0MTkzMDEyMDEyLFwiMVwiOjAuMTI3MjY4NTU0OTA5MTAzNyxcIjJcIjotMC4wNzk2MTMxNDI5ODM5MjM0NSxcIjNcIjotMC4xMTgwNjQ3MjkxODE5NDY2NSxcIjRcIjowLjA1MjE2ODQ2MzMxODcyNDg2LFwiNVwiOjAuNDkyMTE4NTg0MDE1NTcyODUsXCI2XCI6LTAuMzY0NzIwMjA5MzE0NDEwMixcIjdcIjowLjI2MDc4NTIxOTA0NTg2OTkzLFwiOFwiOjAuMzI0NjIwNDExNjYyOTU2MzUsXCI5XCI6LTAuMTI1OTI4NjUxMjU0MDY3ODIsXCIxMFwiOi0wLjA4NzI4MzE1OTI2NzIwMDczLFwiMTFcIjowLjEzMjgwODIzMzg3OTY1NzIzLFwiMTJcIjotMC4yNTE1NjYxNTQyMDc1MDg0LFwiMTNcIjotMC4yNTgxNjE1NTI2MzQ1ODUyMyxcIjE0XCI6MC4wNTE2NzY1Mzk3OTE0ODU3MyxcIjE1XCI6MC4zMDI5NTg4NTE0NTk5Mzk2NyxcIkJZVEVTX1BFUl9FTEVNRU5UXCI6OCxcImJ1ZmZlclwiOntcIjBcIjoxNTIsXCIxXCI6MjAzLFwiMlwiOjgsXCIzXCI6MjM0LFwiNFwiOjI0MyxcIjVcIjozNixcIjZcIjoyMjIsXCI3XCI6MTkxLFwiOFwiOjEwMyxcIjlcIjoxMDMsXCIxMFwiOjE0NixcIjExXCI6NCxcIjEyXCI6ODYsXCIxM1wiOjc0LFwiMTRcIjoxOTIsXCIxNVwiOjYzLFwiMTZcIjoyNTEsXCIxN1wiOjE1NyxcIjE4XCI6MTE0LFwiMTlcIjoyMjksXCIyMFwiOjEzNCxcIjIxXCI6OTcsXCIyMlwiOjE4MCxcIjIzXCI6MTkxLFwiMjRcIjo4NyxcIjI1XCI6MTk4LFwiMjZcIjoxNjUsXCIyN1wiOjExOCxcIjI4XCI6MTI1LFwiMjlcIjo1NyxcIjMwXCI6MTkwLFwiMzFcIjoxOTEsXCIzMlwiOjE0OSxcIjMzXCI6NzMsXCIzNFwiOjE3MixcIjM1XCI6MzksXCIzNlwiOjIxMSxcIjM3XCI6MTgxLFwiMzhcIjoxNzAsXCIzOVwiOjYzLFwiNDBcIjoyNCxcIjQxXCI6MTE0LFwiNDJcIjo2LFwiNDNcIjoyNDIsXCI0NFwiOjIyMixcIjQ1XCI6MTI2LFwiNDZcIjoyMjMsXCI0N1wiOjYzLFwiNDhcIjoyMDQsXCI0OVwiOjEzMyxcIjUwXCI6MjA0LFwiNTFcIjoxMTAsXCI1MlwiOjE0NyxcIjUzXCI6ODcsXCI1NFwiOjIxNSxcIjU1XCI6MTkxLFwiNTZcIjoyMjgsXCI1N1wiOjY2LFwiNThcIjoxOTcsXCI1OVwiOjEyNCxcIjYwXCI6MTgwLFwiNjFcIjoxNzYsXCI2MlwiOjIwOCxcIjYzXCI6NjMsXCI2NFwiOjE0MSxcIjY1XCI6NTQsXCI2NlwiOjIzNyxcIjY3XCI6MTc2LFwiNjhcIjoxNDgsXCI2OVwiOjE5OCxcIjcwXCI6MjEyLFwiNzFcIjo2MyxcIjcyXCI6MTM2LFwiNzNcIjoyNTUsXCI3NFwiOjk3LFwiNzVcIjoyMyxcIjc2XCI6MTEwLFwiNzdcIjozMCxcIjc4XCI6MTkyLFwiNzlcIjoxOTEsXCI4MFwiOjIwNixcIjgxXCI6NzksXCI4MlwiOjEzOSxcIjgzXCI6MTA2LFwiODRcIjo0OCxcIjg1XCI6ODgsXCI4NlwiOjE4MixcIjg3XCI6MTkxLFwiODhcIjoyNDAsXCI4OVwiOjEzNyxcIjkwXCI6MTQ3LFwiOTFcIjo1NCxcIjkyXCI6MjIwLFwiOTNcIjoyNTUsXCI5NFwiOjE5MixcIjk1XCI6NjMsXCI5NlwiOjIzOCxcIjk3XCI6MTMwLFwiOThcIjo3MCxcIjk5XCI6MjM3LFwiMTAwXCI6MTY4LFwiMTAxXCI6MjUsXCIxMDJcIjoyMDgsXCIxMDNcIjoxOTEsXCIxMDRcIjoxNzEsXCIxMDVcIjoxNTUsXCIxMDZcIjoxMDUsXCIxMDdcIjo4LFwiMTA4XCI6MTg0LFwiMTA5XCI6MTMzLFwiMTEwXCI6MjA4LFwiMTExXCI6MTkxLFwiMTEyXCI6MTIwLFwiMTEzXCI6MjM5LFwiMTE0XCI6MTkxLFwiMTE1XCI6MjQwLFwiMTE2XCI6ODgsXCIxMTdcIjoxMTcsXCIxMThcIjoxNzAsXCIxMTlcIjo2MyxcIjEyMFwiOjEwMyxcIjEyMVwiOjExOSxcIjEyMlwiOjE5NSxcIjEyM1wiOjEzMyxcIjEyNFwiOjE3MyxcIjEyNVwiOjk5LFwiMTI2XCI6MjExLFwiMTI3XCI6NjMsXCJieXRlTGVuZ3RoXCI6MTI4fSxcImxlbmd0aFwiOjE2LFwiYnl0ZU9mZnNldFwiOjAsXCJieXRlTGVuZ3RoXCI6MTI4fX0se1wic3hcIjoxLFwic3lcIjoxLFwiZGVwdGhcIjoxNixcIndcIjp7XCIwXCI6LTAuNTA5OTkwNzA0NjcxOTM0NCxcIjFcIjotMC40NjIyNTgwNzU3ODY4MzI3LFwiMlwiOjAuNDEzMjE3MTMzNzI0NDM4NSxcIjNcIjowLjA0MDMyMTE3NTA1NjQzNzA0LFwiNFwiOi0wLjE4NzQ4NDM4MTIyODI1OTEsXCI1XCI6MS4yMDE0OTY0NTIzNjAxNzEsXCI2XCI6LTAuMDgzODExMzA0OTQ4MDEzOTIsXCI3XCI6LTAuMjI5MDMyMjI1MTQwNDE0MTYsXCI4XCI6MC4zODIyOTk2MTk0OTA2MTc4LFwiOVwiOjAuNDY0MDYxNjQxNjE5NzIzMzUsXCIxMFwiOi0wLjA3MDI1MzcyOTAzODg4MjU1LFwiMTFcIjowLjI2NDI1NjA1OTI5MTgxLFwiMTJcIjotMC40OTI2NDQ4MDk0NDgxODQzNCxcIjEzXCI6MC4yOTA1NTc0ODE2MjMwOTU1LFwiMTRcIjowLjI5OTczMzUyODc4NjI3ODg1LFwiMTVcIjowLjM5OTYzMzU1MDA5NDk2NjEsXCJCWVRFU19QRVJfRUxFTUVOVFwiOjgsXCJidWZmZXJcIjp7XCIwXCI6MjQ5LFwiMVwiOjE0MixcIjJcIjoxODYsXCIzXCI6NixcIjRcIjoyMTYsXCI1XCI6ODEsXCI2XCI6MjI0LFwiN1wiOjE5MSxcIjhcIjoyMTcsXCI5XCI6NjIsXCIxMFwiOjExNixcIjExXCI6MjI5LFwiMTJcIjoxNjIsXCIxM1wiOjE0OSxcIjE0XCI6MjIxLFwiMTVcIjoxOTEsXCIxNlwiOjE1MSxcIjE3XCI6MTQ2LFwiMThcIjoyMjMsXCIxOVwiOjcwLFwiMjBcIjozOCxcIjIxXCI6MTE0LFwiMjJcIjoyMTgsXCIyM1wiOjYzLFwiMjRcIjoyMDUsXCIyNVwiOjczLFwiMjZcIjoxMDQsXCIyN1wiOjMyLFwiMjhcIjoyNTAsXCIyOVwiOjE2NCxcIjMwXCI6MTY0LFwiMzFcIjo2MyxcIjMyXCI6MjU0LFwiMzNcIjoxMDksXCIzNFwiOjI0MSxcIjM1XCI6MjUwLFwiMzZcIjoxMjQsXCIzN1wiOjI1NSxcIjM4XCI6MTk5LFwiMzlcIjoxOTEsXCI0MFwiOjIzOSxcIjQxXCI6ODksXCI0MlwiOjE4LFwiNDNcIjo4OCxcIjQ0XCI6ODQsXCI0NVwiOjU3LFwiNDZcIjoyNDMsXCI0N1wiOjYzLFwiNDhcIjoyMzIsXCI0OVwiOjEwNyxcIjUwXCI6MjAxLFwiNTFcIjo5MyxcIjUyXCI6MTY4LFwiNTNcIjoxMTYsXCI1NFwiOjE4MSxcIjU1XCI6MTkxLFwiNTZcIjoyMzAsXCI1N1wiOjE2NSxcIjU4XCI6OTAsXCI1OVwiOjE0MixcIjYwXCI6MjM3LFwiNjFcIjo4MCxcIjYyXCI6MjA1LFwiNjNcIjoxOTEsXCI2NFwiOjE0NyxcIjY1XCI6MTcsXCI2NlwiOjE5MSxcIjY3XCI6MjEwLFwiNjhcIjoxNTIsXCI2OVwiOjExOSxcIjcwXCI6MjE2LFwiNzFcIjo2MyxcIjcyXCI6MjcsXCI3M1wiOjEwOSxcIjc0XCI6MTMzLFwiNzVcIjoxNTMsXCI3NlwiOjQ3LFwiNzdcIjoxNzksXCI3OFwiOjIyMSxcIjc5XCI6NjMsXCI4MFwiOjUyLFwiODFcIjoyMjQsXCI4MlwiOjE2NCxcIjgzXCI6MjUyLFwiODRcIjozNyxcIjg1XCI6MjUyLFwiODZcIjoxNzcsXCI4N1wiOjE5MSxcIjg4XCI6MjUzLFwiODlcIjoxMDIsXCI5MFwiOjI3LFwiOTFcIjo2MyxcIjkyXCI6MTQ2LFwiOTNcIjoyMzMsXCI5NFwiOjIwOCxcIjk1XCI6NjMsXCI5NlwiOjgwLFwiOTdcIjoyNDEsXCI5OFwiOjcxLFwiOTlcIjoyNCxcIjEwMFwiOjEyNixcIjEwMVwiOjEzNSxcIjEwMlwiOjIyMyxcIjEwM1wiOjE5MSxcIjEwNFwiOjIzNSxcIjEwNVwiOjEyMSxcIjEwNlwiOjc1LFwiMTA3XCI6MTA0LFwiMTA4XCI6MTI2LFwiMTA5XCI6MTUyLFwiMTEwXCI6MjEwLFwiMTExXCI6NjMsXCIxMTJcIjozNyxcIjExM1wiOjE4MixcIjExNFwiOjIzMyxcIjExNVwiOjEzNyxcIjExNlwiOjIxMyxcIjExN1wiOjQ2LFwiMTE4XCI6MjExLFwiMTE5XCI6NjMsXCIxMjBcIjo4NyxcIjEyMVwiOjE4MCxcIjEyMlwiOjIsXCIxMjNcIjoxNTMsXCIxMjRcIjoxNTIsXCIxMjVcIjoxNDcsXCIxMjZcIjoyMTcsXCIxMjdcIjo2MyxcImJ5dGVMZW5ndGhcIjoxMjh9LFwibGVuZ3RoXCI6MTYsXCJieXRlT2Zmc2V0XCI6MCxcImJ5dGVMZW5ndGhcIjoxMjh9fSx7XCJzeFwiOjEsXCJzeVwiOjEsXCJkZXB0aFwiOjE2LFwid1wiOntcIjBcIjowLjM4NjY5MjQzNzQ0NDAxNTA1LFwiMVwiOi0wLjAzMDMxNTE4MzI0MDM5NDIwNCxcIjJcIjotMC4zMjc0NTQzNzk0NDk5MDMyLFwiM1wiOjAuMjI4NDI0NzkyODk4OTQwMTYsXCI0XCI6LTAuMTA3OTU4NTM2MzU3MTg2LFwiNVwiOi0wLjQ4MDE1NjU0NTM0NTQ3ODQsXCI2XCI6MC4yMjU4OTA0OTkyMjM1NTA2NCxcIjdcIjotMC4wODkwMTY5MDkxMjg3NzYzMSxcIjhcIjotMC4xOTQzMDMyMTgyMDg0NTg3MixcIjlcIjowLjMyMjAyODg2MTM4MDU2NzM1LFwiMTBcIjotMC4xMjQ2MzcyMjg1MDAzMDE4LFwiMTFcIjowLjI1NDIyMzg1NTAzNjk3MzYsXCIxMlwiOi0wLjA4MTM2MjY3ODM4ODIwMTUyLFwiMTNcIjotMC4wNzU1MDU3MzUzMzE2NjQ1MyxcIjE0XCI6LTAuMTAyNDQxMzQwNjcxNDUxMTQsXCIxNVwiOi0wLjA5NDE1NTIzNjAxMDczNCxcIkJZVEVTX1BFUl9FTEVNRU5UXCI6OCxcImJ1ZmZlclwiOntcIjBcIjo2MCxcIjFcIjoxNzUsXCIyXCI6MjcsXCIzXCI6MTYzLFwiNFwiOjE0NSxcIjVcIjoxOTEsXCI2XCI6MjE2LFwiN1wiOjYzLFwiOFwiOjIzMyxcIjlcIjoyMjgsXCIxMFwiOjkxLFwiMTFcIjoxMzAsXCIxMlwiOjI0MSxcIjEzXCI6MTAsXCIxNFwiOjE1OSxcIjE1XCI6MTkxLFwiMTZcIjoyNDQsXCIxN1wiOjIxMyxcIjE4XCI6MTcwLFwiMTlcIjo1NCxcIjIwXCI6MyxcIjIxXCI6MjQ1LFwiMjJcIjoyMTIsXCIyM1wiOjE5MSxcIjI0XCI6MjA1LFwiMjVcIjo5MCxcIjI2XCI6MTQwLFwiMjdcIjoxMSxcIjI4XCI6NixcIjI5XCI6NjEsXCIzMFwiOjIwNSxcIjMxXCI6NjMsXCIzMlwiOjExMixcIjMzXCI6MTAzLFwiMzRcIjoyNTAsXCIzNVwiOjE3NCxcIjM2XCI6NDMsXCIzN1wiOjE2MyxcIjM4XCI6MTg3LFwiMzlcIjoxOTEsXCI0MFwiOjIyOSxcIjQxXCI6NixcIjQyXCI6MjA2LFwiNDNcIjoxMzIsXCI0NFwiOjIyNixcIjQ1XCI6MTg2LFwiNDZcIjoyMjIsXCI0N1wiOjE5MSxcIjQ4XCI6MTc2LFwiNDlcIjo1MyxcIjUwXCI6ODIsXCI1MVwiOjIxNyxcIjUyXCI6MjUwLFwiNTNcIjoyMzMsXCI1NFwiOjIwNCxcIjU1XCI6NjMsXCI1NlwiOjIyOSxcIjU3XCI6MTk2LFwiNThcIjoxMjcsXCI1OVwiOjIzMyxcIjYwXCI6MjA3LFwiNjFcIjoyMDEsXCI2MlwiOjE4MixcIjYzXCI6MTkxLFwiNjRcIjoxODMsXCI2NVwiOjYzLFwiNjZcIjoyMTksXCI2N1wiOjEzNSxcIjY4XCI6MjM3LFwiNjlcIjoyMjIsXCI3MFwiOjIwMCxcIjcxXCI6MTkxLFwiNzJcIjoxNDUsXCI3M1wiOjIxNyxcIjc0XCI6MjU1LFwiNzVcIjoyNDAsXCI3NlwiOjMwLFwiNzdcIjoxNTYsXCI3OFwiOjIxMixcIjc5XCI6NjMsXCI4MFwiOjQxLFwiODFcIjoyMTksXCI4MlwiOjY5LFwiODNcIjoxODAsXCI4NFwiOjU3LFwiODVcIjoyMzIsXCI4NlwiOjE5MSxcIjg3XCI6MTkxLFwiODhcIjo4NSxcIjg5XCI6MjA0LFwiOTBcIjoyMDcsXCI5MVwiOjMzLFwiOTJcIjo1MixcIjkzXCI6NjksXCI5NFwiOjIwOCxcIjk1XCI6NjMsXCI5NlwiOjE1OCxcIjk3XCI6MjExLFwiOThcIjoyMDIsXCI5OVwiOjU4LFwiMTAwXCI6NDcsXCIxMDFcIjoyMTIsXCIxMDJcIjoxODAsXCIxMDNcIjoxOTEsXCIxMDRcIjo1OSxcIjEwNVwiOjI0MSxcIjEwNlwiOjIzMixcIjEwN1wiOjcsXCIxMDhcIjo4OCxcIjEwOVwiOjg0LFwiMTEwXCI6MTc5LFwiMTExXCI6MTkxLFwiMTEyXCI6MjIsXCIxMTNcIjo1NyxcIjExNFwiOjI0MSxcIjExNVwiOjEyNyxcIjExNlwiOjE1MixcIjExN1wiOjU3LFwiMTE4XCI6MTg2LFwiMTE5XCI6MTkxLFwiMTIwXCI6MTcyLFwiMTIxXCI6MjAzLFwiMTIyXCI6MTA1LFwiMTIzXCI6MTg3LFwiMTI0XCI6MTQyLFwiMTI1XCI6MjYsXCIxMjZcIjoxODQsXCIxMjdcIjoxOTEsXCJieXRlTGVuZ3RoXCI6MTI4fSxcImxlbmd0aFwiOjE2LFwiYnl0ZU9mZnNldFwiOjAsXCJieXRlTGVuZ3RoXCI6MTI4fX0se1wic3hcIjoxLFwic3lcIjoxLFwiZGVwdGhcIjoxNixcIndcIjp7XCIwXCI6LTAuMzkwNTgwNjk4MDE5MTg3MTYsXCIxXCI6LTAuMjI2MjMzMzQ1MDg5Nzc3MDIsXCIyXCI6MC4xMTE1NDUxMTkyNzYzMzY4MyxcIjNcIjotMC4zNTQwNTQ1MDM0OTY5MDA2NSxcIjRcIjowLjA4NzA1MjcxNTAxNzk0MjgyLFwiNVwiOjAuMjAzMjA3MDYyODMxMDk4NjgsXCI2XCI6LTAuMzQwMjExMjMyMzQxNDI3MzYsXCI3XCI6MC4wMDc4MzUxMzMzODMwMzExNzksXCI4XCI6MC43ODg1NTU0MDY4MzkyOTEzLFwiOVwiOi0wLjIzMjkxOTc5NzkzODMzODM2LFwiMTBcIjotMC4zNTEzMzE5NjE3ODEyMjA4NCxcIjExXCI6LTAuMTA5MzIxOTYxMzc1NjM4MTEsXCIxMlwiOi0wLjMxNzI3NjgxNjUzMDUwOTMsXCIxM1wiOi0wLjU1MTY0Mjk1MDE5OTQyMTgsXCIxNFwiOi0wLjE0NDUyNTMxNjk2Mjk0MjkzLFwiMTVcIjowLjM2NTc1NDg2MzkwMTgzNzEsXCJCWVRFU19QRVJfRUxFTUVOVFwiOjgsXCJidWZmZXJcIjp7XCIwXCI6MTU4LFwiMVwiOjYxLFwiMlwiOjI4LFwiM1wiOjQ3LFwiNFwiOjcwLFwiNVwiOjI1NSxcIjZcIjoyMTYsXCI3XCI6MTkxLFwiOFwiOjEwMSxcIjlcIjoxMTEsXCIxMFwiOjU0LFwiMTFcIjoyMTcsXCIxMlwiOjU0LFwiMTNcIjoyNDUsXCIxNFwiOjIwNCxcIjE1XCI6MTkxLFwiMTZcIjo2NSxcIjE3XCI6MjU0LFwiMThcIjo4MSxcIjE5XCI6MTQzLFwiMjBcIjo1NixcIjIxXCI6MTQyLFwiMjJcIjoxODgsXCIyM1wiOjYzLFwiMjRcIjo2MyxcIjI1XCI6ODMsXCIyNlwiOjk3LFwiMjdcIjo1NixcIjI4XCI6MjEyLFwiMjlcIjoxNjgsXCIzMFwiOjIxNCxcIjMxXCI6MTkxLFwiMzJcIjoyMTIsXCIzM1wiOjE3OCxcIjM0XCI6NyxcIjM1XCI6NTIsXCIzNlwiOjIyLFwiMzdcIjo3MyxcIjM4XCI6MTgyLFwiMzlcIjo2MyxcIjQwXCI6NDAsXCI0MVwiOjEyOCxcIjQyXCI6MTUwLFwiNDNcIjoxMDAsXCI0NFwiOjE3NixcIjQ1XCI6MixcIjQ2XCI6MjAyLFwiNDdcIjo2MyxcIjQ4XCI6MTgyLFwiNDlcIjoyMTcsXCI1MFwiOjQwLFwiNTFcIjo4NSxcIjUyXCI6NSxcIjUzXCI6MTk4LFwiNTRcIjoyMTMsXCI1NVwiOjE5MSxcIjU2XCI6MTczLFwiNTdcIjoxNDAsXCI1OFwiOjMwLFwiNTlcIjoyMDUsXCI2MFwiOjIyMSxcIjYxXCI6MTEsXCI2MlwiOjEyOCxcIjYzXCI6NjMsXCI2NFwiOjIzNixcIjY1XCI6MTczLFwiNjZcIjoxMTAsXCI2N1wiOjE0MCxcIjY4XCI6MjE2LFwiNjlcIjo1OSxcIjcwXCI6MjMzLFwiNzFcIjo2MyxcIjcyXCI6NjMsXCI3M1wiOjU2LFwiNzRcIjo5NCxcIjc1XCI6MjI1LFwiNzZcIjo4MCxcIjc3XCI6MjA4LFwiNzhcIjoyMDUsXCI3OVwiOjE5MSxcIjgwXCI6MTQyLFwiODFcIjoyNDMsXCI4MlwiOjEyMCxcIjgzXCI6MTMsXCI4NFwiOjU3LFwiODVcIjoxMjQsXCI4NlwiOjIxNCxcIjg3XCI6MTkxLFwiODhcIjoyNDksXCI4OVwiOjIwMixcIjkwXCI6MjE1LFwiOTFcIjo0MCxcIjkyXCI6MTM0LFwiOTNcIjoyNTIsXCI5NFwiOjE4NyxcIjk1XCI6MTkxLFwiOTZcIjoxMixcIjk3XCI6MTk1LFwiOThcIjoxNzcsXCI5OVwiOjEwNyxcIjEwMFwiOjY3LFwiMTAxXCI6NzgsXCIxMDJcIjoyMTIsXCIxMDNcIjoxOTEsXCIxMDRcIjoxMjIsXCIxMDVcIjoxNTcsXCIxMDZcIjoxOTcsXCIxMDdcIjoyOSxcIjEwOFwiOjE1LFwiMTA5XCI6MTY3LFwiMTEwXCI6MjI1LFwiMTExXCI6MTkxLFwiMTEyXCI6NjksXCIxMTNcIjo5OCxcIjExNFwiOjIzMCxcIjExNVwiOjU4LFwiMTE2XCI6MjA2LFwiMTE3XCI6MTI3LFwiMTE4XCI6MTk0LFwiMTE5XCI6MTkxLFwiMTIwXCI6MTc2LFwiMTIxXCI6MjM2LFwiMTIyXCI6MTc5LFwiMTIzXCI6MjIsXCIxMjRcIjoxMzUsXCIxMjVcIjoxMDQsXCIxMjZcIjoyMTUsXCIxMjdcIjo2MyxcImJ5dGVMZW5ndGhcIjoxMjh9LFwibGVuZ3RoXCI6MTYsXCJieXRlT2Zmc2V0XCI6MCxcImJ5dGVMZW5ndGhcIjoxMjh9fSx7XCJzeFwiOjEsXCJzeVwiOjEsXCJkZXB0aFwiOjE2LFwid1wiOntcIjBcIjowLjA0MjE5NDUwNzEwMjIxNDE0LFwiMVwiOjAuMDgyMTkzNzk0Njk2NTAzMTgsXCIyXCI6LTAuMjA2NTk3NTgwMTI1MzE0MDcsXCIzXCI6LTAuMTg0NjYxMjYxNDQ3NDQ4MzUsXCI0XCI6LTAuMzM5MDE2NjE2Mjg2ODA1NCxcIjVcIjotMC40NjI0NzQ2ODcxMjAxNDAxLFwiNlwiOjAuNTA4NTU4MjA0NDE0NzQ2OSxcIjdcIjowLjIwNzE0OTk1MDY1MDI5NDA3LFwiOFwiOi0wLjQ2NDc4NDg0ODAyNjI2Mjc0LFwiOVwiOi0wLjAwNjg0MDE0NDI1NDM2MDExOSxcIjEwXCI6MC4xOTMyMjE5MDgxMDUwNzg4LFwiMTFcIjotMC4zNjkzMDQ5NjgzMDQ4OTQxLFwiMTJcIjowLjczMzM1NjM4MTk1NDQwMzMsXCIxM1wiOi0wLjA1NjU3MzcwNDY2MjYzMDQ5NSxcIjE0XCI6LTAuMjI2MDgwMjM1MzA5MTM1ODIsXCIxNVwiOi0wLjI3NDM2MDE2NDAwNDY3MDUsXCJCWVRFU19QRVJfRUxFTUVOVFwiOjgsXCJidWZmZXJcIjp7XCIwXCI6MTcxLFwiMVwiOjgyLFwiMlwiOjM4LFwiM1wiOjE4NCxcIjRcIjoxMzIsXCI1XCI6MTU0LFwiNlwiOjE2NSxcIjdcIjo2MyxcIjhcIjoxNzIsXCI5XCI6MjE0LFwiMTBcIjozOSxcIjExXCI6MTIsXCIxMlwiOjE2NyxcIjEzXCI6MTAsXCIxNFwiOjE4MSxcIjE1XCI6NjMsXCIxNlwiOjg1LFwiMTdcIjoyMSxcIjE4XCI6OSxcIjE5XCI6MjksXCIyMFwiOjIwMixcIjIxXCI6MTEzLFwiMjJcIjoyMDIsXCIyM1wiOjE5MSxcIjI0XCI6MTEzLFwiMjVcIjoxNjAsXCIyNlwiOjk2LFwiMjdcIjoyMzksXCIyOFwiOjI1MCxcIjI5XCI6MTYyLFwiMzBcIjoxOTksXCIzMVwiOjE5MSxcIjMyXCI6MTI1LFwiMzNcIjozOSxcIjM0XCI6MjQwLFwiMzVcIjoxOTEsXCIzNlwiOjExNCxcIjM3XCI6MTc4LFwiMzhcIjoyMTMsXCIzOVwiOjE5MSxcIjQwXCI6ODcsXCI0MVwiOjQyLFwiNDJcIjoyNixcIjQzXCI6MTEwLFwiNDRcIjo0NyxcIjQ1XCI6MTUzLFwiNDZcIjoyMjEsXCI0N1wiOjE5MSxcIjQ4XCI6MTg5LFwiNDlcIjo5MixcIjUwXCI6MixcIjUxXCI6MjE5LFwiNTJcIjoyNyxcIjUzXCI6NzAsXCI1NFwiOjIyNCxcIjU1XCI6NjMsXCI1NlwiOjEzNixcIjU3XCI6MTU2LFwiNThcIjoxODAsXCI1OVwiOjE4NyxcIjYwXCI6MjI3LFwiNjFcIjoxMzEsXCI2MlwiOjIwMixcIjYzXCI6NjMsXCI2NFwiOjEzNCxcIjY1XCI6MTkwLFwiNjZcIjoxMjQsXCI2N1wiOjI0MixcIjY4XCI6OCxcIjY5XCI6MTkxLFwiNzBcIjoyMjEsXCI3MVwiOjE5MSxcIjcyXCI6MTcyLFwiNzNcIjo4OCxcIjc0XCI6MjQ1LFwiNzVcIjo2MSxcIjc2XCI6MTA1LFwiNzdcIjo0LFwiNzhcIjoxMjQsXCI3OVwiOjE5MSxcIjgwXCI6MjAxLFwiODFcIjo3NixcIjgyXCI6MjMsXCI4M1wiOjIxNixcIjg0XCI6MTI2LFwiODVcIjoxODcsXCI4NlwiOjIwMCxcIjg3XCI6NjMsXCI4OFwiOjEwNCxcIjg5XCI6MTcxLFwiOTBcIjo3MSxcIjkxXCI6NzgsXCI5MlwiOjE3NyxcIjkzXCI6MTYyLFwiOTRcIjoyMTUsXCI5NVwiOjE5MSxcIjk2XCI6ODQsXCI5N1wiOjIxMSxcIjk4XCI6MTUzLFwiOTlcIjoyMDUsXCIxMDBcIjoxNjcsXCIxMDFcIjoxMTksXCIxMDJcIjoyMzEsXCIxMDNcIjo2MyxcIjEwNFwiOjIzMCxcIjEwNVwiOjIxOCxcIjEwNlwiOjE3MyxcIjEwN1wiOjEzNCxcIjEwOFwiOjU4LFwiMTA5XCI6MjQ3LFwiMTEwXCI6MTcyLFwiMTExXCI6MTkxLFwiMTEyXCI6ODEsXCIxMTNcIjo5MyxcIjExNFwiOjExOCxcIjExNVwiOjEyMCxcIjExNlwiOjUwLFwiMTE3XCI6MjQwLFwiMTE4XCI6MjA0LFwiMTE5XCI6MTkxLFwiMTIwXCI6MTUzLFwiMTIxXCI6MTA2LFwiMTIyXCI6MjM4LFwiMTIzXCI6MjM4LFwiMTI0XCI6MjksXCIxMjVcIjoxNDMsXCIxMjZcIjoyMDksXCIxMjdcIjoxOTEsXCJieXRlTGVuZ3RoXCI6MTI4fSxcImxlbmd0aFwiOjE2LFwiYnl0ZU9mZnNldFwiOjAsXCJieXRlTGVuZ3RoXCI6MTI4fX0se1wic3hcIjoxLFwic3lcIjoxLFwiZGVwdGhcIjoxNixcIndcIjp7XCIwXCI6LTAuNTM5NjY4NjYwNjU3NDY2MixcIjFcIjotMC4wMjQzNjIyNzIxOTE0NjkwNCxcIjJcIjotMC4xODI1MDk2Nzg1MjgwMjEsXCIzXCI6LTAuMTk5Nzg5Mjk2MzI3ODk0MDIsXCI0XCI6LTAuMzEzNjE3MDc4NTMzNzI1NDUsXCI1XCI6MC4yODIwOTg1NTU0Njg5ODI0NCxcIjZcIjotMC4xNzY1MjEzMjQzNDMyMzAzNyxcIjdcIjotMC4wODg2NTk2OTE2MDEwNzc1NixcIjhcIjowLjM3NjI5NDYxMzAyNzE3NDcsXCI5XCI6LTAuNTQzMTQ3OTIxMTEwNDc0LFwiMTBcIjotMC42OTQ5MDUzOTI0MTEzMDE4LFwiMTFcIjowLjI0NTYyMzk3NjE2NjM2OTk0LFwiMTJcIjotMC4wOTI1ODY5MjI1OTc4OTU1MyxcIjEzXCI6MC40NjIzNTIwNzc4NDE1ODc5NCxcIjE0XCI6LTAuMDc2MTY1MzgzOTEzMzMyMTIsXCIxNVwiOjAuMTU3MDI3MDcxMDY0NzcxMTIsXCJCWVRFU19QRVJfRUxFTUVOVFwiOjgsXCJidWZmZXJcIjp7XCIwXCI6MjMxLFwiMVwiOjEwMSxcIjJcIjo2LFwiM1wiOjU0LFwiNFwiOjI0NyxcIjVcIjo2OCxcIjZcIjoyMjUsXCI3XCI6MTkxLFwiOFwiOjE2NCxcIjlcIjo2NSxcIjEwXCI6NzAsXCIxMVwiOjEwNSxcIjEyXCI6MTA4LFwiMTNcIjoyNDIsXCIxNFwiOjE1MixcIjE1XCI6MTkxLFwiMTZcIjozLFwiMTdcIjoxNTYsXCIxOFwiOjYxLFwiMTlcIjozOCxcIjIwXCI6MTIyLFwiMjFcIjo5MixcIjIyXCI6MTk5LFwiMjNcIjoxOTEsXCIyNFwiOjQxLFwiMjVcIjoyMTgsXCIyNlwiOjIzMixcIjI3XCI6MjIsXCIyOFwiOjE3OCxcIjI5XCI6MTQ2LFwiMzBcIjoyMDEsXCIzMVwiOjE5MSxcIjMyXCI6MjIsXCIzM1wiOjYyLFwiMzRcIjoyNDEsXCIzNVwiOjkzLFwiMzZcIjo3NyxcIjM3XCI6MTgsXCIzOFwiOjIxMixcIjM5XCI6MTkxLFwiNDBcIjo5OCxcIjQxXCI6NjEsXCI0MlwiOjEyNyxcIjQzXCI6MjUsXCI0NFwiOjIzMSxcIjQ1XCI6MTMsXCI0NlwiOjIxMCxcIjQ3XCI6NjMsXCI0OFwiOjExOCxcIjQ5XCI6MjMwLFwiNTBcIjoxNDAsXCI1MVwiOjQ5LFwiNTJcIjo2NCxcIjUzXCI6MTUyLFwiNTRcIjoxOTgsXCI1NVwiOjE5MSxcIjU2XCI6NjQsXCI1N1wiOjEwNyxcIjU4XCI6MjMwLFwiNTlcIjoyMDMsXCI2MFwiOjEwMixcIjYxXCI6MTc4LFwiNjJcIjoxODIsXCI2M1wiOjE5MSxcIjY0XCI6ODQsXCI2NVwiOjU0LFwiNjZcIjozOSxcIjY3XCI6MCxcIjY4XCI6NTQsXCI2OVwiOjIxLFwiNzBcIjoyMTYsXCI3MVwiOjYzLFwiNzJcIjoxMjUsXCI3M1wiOjIzNCxcIjc0XCI6MTkzLFwiNzVcIjoxOTEsXCI3NlwiOjExOSxcIjc3XCI6OTcsXCI3OFwiOjIyNSxcIjc5XCI6MTkxLFwiODBcIjoxNCxcIjgxXCI6MTUsXCI4MlwiOjE5OSxcIjgzXCI6NTksXCI4NFwiOjE3MCxcIjg1XCI6NjAsXCI4NlwiOjIzMCxcIjg3XCI6MTkxLFwiODhcIjoyMTgsXCI4OVwiOjE5MSxcIjkwXCI6OTUsXCI5MVwiOjY0LFwiOTJcIjoxNTUsXCI5M1wiOjExMixcIjk0XCI6MjA3LFwiOTVcIjo2MyxcIjk2XCI6MjQ0LFwiOTdcIjo5NyxcIjk4XCI6MTUyLFwiOTlcIjoyMDQsXCIxMDBcIjoxOTgsXCIxMDFcIjoxNzksXCIxMDJcIjoxODMsXCIxMDNcIjoxOTEsXCIxMDRcIjoyNCxcIjEwNVwiOjc4LFwiMTA2XCI6MTAwLFwiMTA3XCI6NDMsXCIxMDhcIjo0NSxcIjEwOVwiOjE1MSxcIjExMFwiOjIyMSxcIjExMVwiOjYzLFwiMTEyXCI6ODUsXCIxMTNcIjoxODcsXCIxMTRcIjoyNTQsXCIxMTVcIjoyNCxcIjExNlwiOjE0NyxcIjExN1wiOjEyNyxcIjExOFwiOjE3OSxcIjExOVwiOjE5MSxcIjEyMFwiOjEyNSxcIjEyMVwiOjE2OSxcIjEyMlwiOjEwMyxcIjEyM1wiOjEzOSxcIjEyNFwiOjExOCxcIjEyNVwiOjI1LFwiMTI2XCI6MTk2LFwiMTI3XCI6NjMsXCJieXRlTGVuZ3RoXCI6MTI4fSxcImxlbmd0aFwiOjE2LFwiYnl0ZU9mZnNldFwiOjAsXCJieXRlTGVuZ3RoXCI6MTI4fX0se1wic3hcIjoxLFwic3lcIjoxLFwiZGVwdGhcIjoxNixcIndcIjp7XCIwXCI6LTAuNDM4NjQ4NzYwMDcyMDE3ODYsXCIxXCI6MC4zNDY4OTY3NDYyODQyNjQyNixcIjJcIjowLjM1MTYzMDIwNjA1MDQwNDQ2LFwiM1wiOi0wLjExODc4MDc5NjM0NTk3MjM3LFwiNFwiOi0wLjQzOTA4NDE2MDcyNTI3NDM0LFwiNVwiOjAuNTMyMjM1OTg4NjMxNjM2MyxcIjZcIjotMC4wODQ4NDc3OTYwNTI0NjYsXCI3XCI6MC4xMjI3MzQ4NTYxODUyMDY1NixcIjhcIjowLjU2MDY4MDc3MDA4MTYyMzYsXCI5XCI6LTAuNTUyMTcxNzMzNjg2NzQxNixcIjEwXCI6LTAuMzgzMTcxNzE1MzczNzkzMTMsXCIxMVwiOjAuMzAxMTc2OTQ2MDM0OTYzMjYsXCIxMlwiOi0wLjM1OTMzOTE2Mzk0NzA0NTksXCIxM1wiOi0wLjQ5OTc4NDI2ODM3NTg3MjcsXCIxNFwiOjAuNTE4NjgwNDk0MDA5Mjk0MyxcIjE1XCI6MS4xNTA4MDI3MjUxMzYwMzIsXCJCWVRFU19QRVJfRUxFTUVOVFwiOjgsXCJidWZmZXJcIjp7XCIwXCI6ODcsXCIxXCI6NDUsXCIyXCI6MTg4LFwiM1wiOjYzLFwiNFwiOjIxMCxcIjVcIjoxOCxcIjZcIjoyMjAsXCI3XCI6MTkxLFwiOFwiOjEwNCxcIjlcIjo3NyxcIjEwXCI6MjQsXCIxMVwiOjEwNSxcIjEyXCI6MTQyLFwiMTNcIjo1MSxcIjE0XCI6MjE0LFwiMTVcIjo2MyxcIjE2XCI6NDksXCIxN1wiOjEwOCxcIjE4XCI6MjA5LFwiMTlcIjoyNTAsXCIyMFwiOjI3LFwiMjFcIjoxMjksXCIyMlwiOjIxNCxcIjIzXCI6NjMsXCIyNFwiOjE5MSxcIjI1XCI6MjI3LFwiMjZcIjoxNzgsXCIyN1wiOjE5LFwiMjhcIjoxMDcsXCIyOVwiOjEwNCxcIjMwXCI6MTkwLFwiMzFcIjoxOTEsXCIzMlwiOjM0LFwiMzNcIjoxMDksXCIzNFwiOjE2MCxcIjM1XCI6MTE1LFwiMzZcIjoyNDQsXCIzN1wiOjI1LFwiMzhcIjoyMjAsXCIzOVwiOjE5MSxcIjQwXCI6MjE4LFwiNDFcIjoxNzAsXCI0MlwiOjE1NyxcIjQzXCI6MTk2LFwiNDRcIjoxOSxcIjQ1XCI6OCxcIjQ2XCI6MjI1LFwiNDdcIjo2MyxcIjQ4XCI6OTIsXCI0OVwiOjIxOCxcIjUwXCI6NDYsXCI1MVwiOjIwNSxcIjUyXCI6MTQ5LFwiNTNcIjoxODQsXCI1NFwiOjE4MSxcIjU1XCI6MTkxLFwiNTZcIjoxODcsXCI1N1wiOjEyLFwiNThcIjoxMDEsXCI1OVwiOjQ5LFwiNjBcIjoxNDEsXCI2MVwiOjEwNyxcIjYyXCI6MTkxLFwiNjNcIjo2MyxcIjY0XCI6MTgyLFwiNjVcIjoyMjgsXCI2NlwiOjk1LFwiNjdcIjoyMDQsXCI2OFwiOjI0LFwiNjlcIjoyNDEsXCI3MFwiOjIyNSxcIjcxXCI6NjMsXCI3MlwiOjE5NixcIjczXCI6MTg1LFwiNzRcIjo2MixcIjc1XCI6MTQsXCI3NlwiOjEwMCxcIjc3XCI6MTcxLFwiNzhcIjoyMjUsXCI3OVwiOjE5MSxcIjgwXCI6MzQsXCI4MVwiOjIzLFwiODJcIjoxNDYsXCI4M1wiOjE2OCxcIjg0XCI6MjI2LFwiODVcIjoxMzMsXCI4NlwiOjIxNixcIjg3XCI6MTkxLFwiODhcIjoxMTQsXCI4OVwiOjIyNCxcIjkwXCI6OTcsXCI5MVwiOjE3MSxcIjkyXCI6MTIzLFwiOTNcIjo3MCxcIjk0XCI6MjExLFwiOTVcIjo2MyxcIjk2XCI6ODYsXCI5N1wiOjE5NyxcIjk4XCI6ODQsXCI5OVwiOjE3NyxcIjEwMFwiOjEwNSxcIjEwMVwiOjI1NSxcIjEwMlwiOjIxNCxcIjEwM1wiOjE5MSxcIjEwNFwiOjE5MyxcIjEwNVwiOjE3OCxcIjEwNlwiOjIzOCxcIjEwN1wiOjM5LFwiMTA4XCI6MTE5LFwiMTA5XCI6MjUyLFwiMTEwXCI6MjIzLFwiMTExXCI6MTkxLFwiMTEyXCI6NTMsXCIxMTNcIjoyNTAsXCIxMTRcIjoyMTgsXCIxMTVcIjoyMTMsXCIxMTZcIjo3LFwiMTE3XCI6MTUzLFwiMTE4XCI6MjI0LFwiMTE5XCI6NjMsXCIxMjBcIjoxLFwiMTIxXCI6MTgyLFwiMTIyXCI6NzMsXCIxMjNcIjozMCxcIjEyNFwiOjE3NixcIjEyNVwiOjEwNSxcIjEyNlwiOjI0MixcIjEyN1wiOjYzLFwiYnl0ZUxlbmd0aFwiOjEyOH0sXCJsZW5ndGhcIjoxNixcImJ5dGVPZmZzZXRcIjowLFwiYnl0ZUxlbmd0aFwiOjEyOH19LHtcInN4XCI6MSxcInN5XCI6MSxcImRlcHRoXCI6MTYsXCJ3XCI6e1wiMFwiOi0wLjAyMzIwMDg3NzYzMjI3MzMzLFwiMVwiOjAuMDEyNDEwNzA1MTM4MDU4NTM0LFwiMlwiOi0wLjI3ODM3MTU1NDU3MDEwMzEsXCIzXCI6MC43NTI1NTQ5MDc0MjM0NDY4LFwiNFwiOjAuMDcxMjg1ODEzMDMwMzM0NDcsXCI1XCI6LTAuMjkyMDk3NjUyMjkzNDMxMTUsXCI2XCI6LTAuMDAxMzQwMDAxNjk5MDQwNDc4OSxcIjdcIjowLjIzOTM1NjE4MjE1MTQ0NTcsXCI4XCI6LTAuMjU3Mjk0ODI2Njc1MTU5NzQsXCI5XCI6MC4zMjU4OTY2MzQwNzYzNjUzLFwiMTBcIjowLjEzMzUyMTg4NDEwODY2ODcsXCIxMVwiOi0wLjM5MDMxNTY0MzU3MTMzNzQsXCIxMlwiOjAuMDU1NzU3OTc0MjQxODg2MDgsXCIxM1wiOjAuMDkxNTEwNzkwNTMxNDAzMixcIjE0XCI6LTAuMTcxOTA3NDMwODI0ODIxODIsXCIxNVwiOi0wLjI2NTYwMzI0Njk4NDI5NzE2LFwiQllURVNfUEVSX0VMRU1FTlRcIjo4LFwiYnVmZmVyXCI6e1wiMFwiOjE2OSxcIjFcIjo0MyxcIjJcIjoxNzMsXCIzXCI6MTM4LFwiNFwiOjI0OCxcIjVcIjoxOTMsXCI2XCI6MTUxLFwiN1wiOjE5MSxcIjhcIjoxOTQsXCI5XCI6MTQyLFwiMTBcIjoxMjksXCIxMVwiOjE2NSxcIjEyXCI6MjAwLFwiMTNcIjoxMDYsXCIxNFwiOjEzNyxcIjE1XCI6NjMsXCIxNlwiOjU2LFwiMTdcIjoyNTAsXCIxOFwiOjE5MixcIjE5XCI6MjM2LFwiMjBcIjoyMTQsXCIyMVwiOjIwOCxcIjIyXCI6MjA5LFwiMjNcIjoxOTEsXCIyNFwiOjE4LFwiMjVcIjoxMjcsXCIyNlwiOjEyMixcIjI3XCI6NyxcIjI4XCI6MjM4LFwiMjlcIjoyMCxcIjMwXCI6MjMyLFwiMzFcIjo2MyxcIjMyXCI6MTQ3LFwiMzNcIjo4MSxcIjM0XCI6MTYyLFwiMzVcIjoxMjMsXCIzNlwiOjIwMSxcIjM3XCI6NjMsXCIzOFwiOjE3OCxcIjM5XCI6NjMsXCI0MFwiOjE4MSxcIjQxXCI6MTcyLFwiNDJcIjoyNDUsXCI0M1wiOjg5LFwiNDRcIjoxODYsXCI0NVwiOjE3NyxcIjQ2XCI6MjEwLFwiNDdcIjoxOTEsXCI0OFwiOjMzLFwiNDlcIjoxMDYsXCI1MFwiOjg1LFwiNTFcIjoyMjIsXCI1MlwiOjk1LFwiNTNcIjoyNDQsXCI1NFwiOjg1LFwiNTVcIjoxOTEsXCI1NlwiOjIxOSxcIjU3XCI6MjAyLFwiNThcIjo1NSxcIjU5XCI6NDcsXCI2MFwiOjU3LFwiNjFcIjoxNjMsXCI2MlwiOjIwNixcIjYzXCI6NjMsXCI2NFwiOjE4MyxcIjY1XCI6MjUyLFwiNjZcIjoxMjcsXCI2N1wiOjE4NCxcIjY4XCI6MTMyLFwiNjlcIjoxMTksXCI3MFwiOjIwOCxcIjcxXCI6MTkxLFwiNzJcIjoxMzUsXCI3M1wiOjEsXCI3NFwiOjc5LFwiNzVcIjoxNDIsXCI3NlwiOjEyNSxcIjc3XCI6MjE5LFwiNzhcIjoyMTIsXCI3OVwiOjYzLFwiODBcIjo1NSxcIjgxXCI6NSxcIjgyXCI6MTk4LFwiODNcIjoxOTAsXCI4NFwiOjYyLFwiODVcIjoyMyxcIjg2XCI6MTkzLFwiODdcIjo2MyxcIjg4XCI6MTg2LFwiODlcIjo5OSxcIjkwXCI6MTYsXCI5MVwiOjExOSxcIjkyXCI6MjM4LFwiOTNcIjoyNTAsXCI5NFwiOjIxNixcIjk1XCI6MTkxLFwiOTZcIjoxMjQsXCI5N1wiOjk2LFwiOThcIjoxODQsXCI5OVwiOjM5LFwiMTAwXCI6NzksXCIxMDFcIjoxNDAsXCIxMDJcIjoxNzIsXCIxMDNcIjo2MyxcIjEwNFwiOjExMSxcIjEwNVwiOjY0LFwiMTA2XCI6MTQ0LFwiMTA3XCI6NzYsXCIxMDhcIjo2NCxcIjEwOVwiOjEwOSxcIjExMFwiOjE4MyxcIjExMVwiOjYzLFwiMTEyXCI6MTgzLFwiMTEzXCI6MTI2LFwiMTE0XCI6MTcwLFwiMTE1XCI6MTIsXCIxMTZcIjoxNixcIjExN1wiOjEsXCIxMThcIjoxOTgsXCIxMTlcIjoxOTEsXCIxMjBcIjoyMzQsXCIxMjFcIjoxNDYsXCIxMjJcIjoyMjQsXCIxMjNcIjoxOTQsXCIxMjRcIjoxNjQsXCIxMjVcIjoyNTUsXCIxMjZcIjoyMDgsXCIxMjdcIjoxOTEsXCJieXRlTGVuZ3RoXCI6MTI4fSxcImxlbmd0aFwiOjE2LFwiYnl0ZU9mZnNldFwiOjAsXCJieXRlTGVuZ3RoXCI6MTI4fX0se1wic3hcIjoxLFwic3lcIjoxLFwiZGVwdGhcIjoxNixcIndcIjp7XCIwXCI6LTAuMzQ4NzM2ODkyNTcwNzA1OTUsXCIxXCI6LTAuMDgyNzM0NTU1MzMyNjUxNjcsXCIyXCI6MC4wMjI3NTg4MjgwNTczMzgwMixcIjNcIjotMC4yODQ5ODU1NjI1ODg1NTQ0NSxcIjRcIjowLjEzNDExNzY4ODA5OTAxOTQ3LFwiNVwiOjAuMzc5OTg4ODEzNTcwMzMxOCxcIjZcIjotMC4wODQ3NzQ5MzI5NDA0MDc3NCxcIjdcIjotMC41MDAyMzMzNzU1NDE4NjgxLFwiOFwiOjAuNDcwNDY4MzAyNTUyOTk1OSxcIjlcIjotMC4xMTc4NzMxMDA2NjkxNDY5NSxcIjEwXCI6LTAuMTQ5MDkyNDY2NTIxOTg1NzQsXCIxMVwiOjAuMjg0MDU1NzUyOTM1MzU5MjMsXCIxMlwiOjAuMDczNDE4MzQ5NTMyNzUzOTksXCIxM1wiOi0wLjA1NDMyNzYzNDgyODYzODQ2LFwiMTRcIjowLjM1NjcyODAwNTI3MDUxODU3LFwiMTVcIjowLjM3NjI4NDk0NjI2NDg4MTA3LFwiQllURVNfUEVSX0VMRU1FTlRcIjo4LFwiYnVmZmVyXCI6e1wiMFwiOjEyOCxcIjFcIjoyNTMsXCIyXCI6MzEsXCIzXCI6MTM5LFwiNFwiOjE4MCxcIjVcIjo4MSxcIjZcIjoyMTQsXCI3XCI6MTkxLFwiOFwiOjE1NixcIjlcIjozMixcIjEwXCI6MTAzLFwiMTFcIjoxMjksXCIxMlwiOjIzLFwiMTNcIjo0NixcIjE0XCI6MTgxLFwiMTVcIjoxOTEsXCIxNlwiOjQ1LFwiMTdcIjoxMDAsXCIxOFwiOjIwNixcIjE5XCI6MjQsXCIyMFwiOjIzLFwiMjFcIjo3OCxcIjIyXCI6MTUxLFwiMjNcIjo2MyxcIjI0XCI6MTY0LFwiMjVcIjoxNTMsXCIyNlwiOjIwMSxcIjI3XCI6MjEsXCIyOFwiOjUyLFwiMjlcIjo2MSxcIjMwXCI6MjEwLFwiMzFcIjoxOTEsXCIzMlwiOjY4LFwiMzNcIjoxNjcsXCIzNFwiOjI1LFwiMzVcIjoxODIsXCIzNlwiOjE5NixcIjM3XCI6NDIsXCIzOFwiOjE5MyxcIjM5XCI6NjMsXCI0MFwiOjE4OSxcIjQxXCI6ODgsXCI0MlwiOjIwMCxcIjQzXCI6MTUzLFwiNDRcIjoxODgsXCI0NVwiOjgxLFwiNDZcIjoyMTYsXCI0N1wiOjYzLFwiNDhcIjoxNzcsXCI0OVwiOjIzMixcIjUwXCI6MTI3LFwiNTFcIjo5MixcIjUyXCI6MjA3LFwiNTNcIjoxNzksXCI1NFwiOjE4MSxcIjU1XCI6MTkxLFwiNTZcIjoxMzMsXCI1N1wiOjYxLFwiNThcIjoxMzgsXCI1OVwiOjEwOCxcIjYwXCI6MjMzLFwiNjFcIjoxLFwiNjJcIjoyMjQsXCI2M1wiOjE5MSxcIjY0XCI6MTUyLFwiNjVcIjo2NyxcIjY2XCI6ODEsXCI2N1wiOjIxLFwiNjhcIjozOSxcIjY5XCI6MjgsXCI3MFwiOjIyMixcIjcxXCI6NjMsXCI3MlwiOjI0MyxcIjczXCI6MTg4LFwiNzRcIjoxMTUsXCI3NVwiOjEyMCxcIjc2XCI6MjM4LFwiNzdcIjo0NCxcIjc4XCI6MTkwLFwiNzlcIjoxOTEsXCI4MFwiOjI1LFwiODFcIjo5MyxcIjgyXCI6MjI5LFwiODNcIjo2NSxcIjg0XCI6MTE4LFwiODVcIjoyMSxcIjg2XCI6MTk1LFwiODdcIjoxOTEsXCI4OFwiOjYsXCI4OVwiOjcwLFwiOTBcIjo3MCxcIjkxXCI6NDYsXCI5MlwiOjI0OCxcIjkzXCI6NDUsXCI5NFwiOjIxMCxcIjk1XCI6NjMsXCI5NlwiOjE4NyxcIjk3XCI6OTgsXCI5OFwiOjQzLFwiOTlcIjoxMzAsXCIxMDBcIjoxMzksXCIxMDFcIjoyMDMsXCIxMDJcIjoxNzgsXCIxMDNcIjo2MyxcIjEwNFwiOjE4LFwiMTA1XCI6ODAsXCIxMDZcIjoxODMsXCIxMDdcIjoyMzcsXCIxMDhcIjoyMTIsXCIxMDlcIjoyMDgsXCIxMTBcIjoxNzEsXCIxMTFcIjoxOTEsXCIxMTJcIjoxMjcsXCIxMTNcIjoxNyxcIjExNFwiOjEzLFwiMTE1XCI6MTc5LFwiMTE2XCI6MTYxLFwiMTE3XCI6MjEyLFwiMTE4XCI6MjE0LFwiMTE5XCI6NjMsXCIxMjBcIjoxMTgsXCIxMjFcIjoyMTEsXCIxMjJcIjoxMzksXCIxMjNcIjoxMTYsXCIxMjRcIjoxMyxcIjEyNVwiOjIxLFwiMTI2XCI6MjE2LFwiMTI3XCI6NjMsXCJieXRlTGVuZ3RoXCI6MTI4fSxcImxlbmd0aFwiOjE2LFwiYnl0ZU9mZnNldFwiOjAsXCJieXRlTGVuZ3RoXCI6MTI4fX0se1wic3hcIjoxLFwic3lcIjoxLFwiZGVwdGhcIjoxNixcIndcIjp7XCIwXCI6LTAuMjcyODMzODA2ODU0NTA5LFwiMVwiOi0wLjEzMDc5OTIzNTQ2NjI1NTYsXCIyXCI6LTAuMDYwNDc0MDkxMzYxOTk4NjksXCIzXCI6LTAuMDMwMzQzMTM4OTY2Njc1NTg1LFwiNFwiOi0wLjQ1ODUxMjU5ODc3NDkxMzc0LFwiNVwiOjEuMjE5NTY5MzI2MjYzNDM4LFwiNlwiOi0wLjI3MTM2NzcxOTg4NDgzMzQ0LFwiN1wiOi0wLjMzOTcxMzY0Njk3MTAxMjE0LFwiOFwiOjAuNjc1MzIxMjM3MjExMTU1MSxcIjlcIjotMC4zOTAzNzE0OTY1MDUzNTYxLFwiMTBcIjotMC4wOTk0MjcxMzQwOTY3NzQ0NSxcIjExXCI6MC4yMzgyOTQ2Nzg1NDAyMjU4MixcIjEyXCI6LTAuMDY3MTkxMTY4MTk0NjczODQsXCIxM1wiOjAuMTcyODM5MjA3MjcxODk4MTcsXCIxNFwiOjAuMzQxNTM5NTM0Njg3NjYwMjQsXCIxNVwiOjAuNTgwODcyMzQ3OTQ0NDAzMyxcIkJZVEVTX1BFUl9FTEVNRU5UXCI6OCxcImJ1ZmZlclwiOntcIjBcIjozNCxcIjFcIjoxODcsXCIyXCI6MTA3LFwiM1wiOjIzNyxcIjRcIjoyNyxcIjVcIjoxMTgsXCI2XCI6MjA5LFwiN1wiOjE5MSxcIjhcIjoyNDQsXCI5XCI6MTczLFwiMTBcIjo4NSxcIjExXCI6MTMxLFwiMTJcIjo3LFwiMTNcIjoxOTAsXCIxNFwiOjE5MixcIjE1XCI6MTkxLFwiMTZcIjo4NCxcIjE3XCI6MTA1LFwiMThcIjo3OSxcIjE5XCI6MjAxLFwiMjBcIjoxMTcsXCIyMVwiOjI0NixcIjIyXCI6MTc0LFwiMjNcIjoxOTEsXCIyNFwiOjIxNCxcIjI1XCI6ODQsXCIyNlwiOjIwLFwiMjdcIjoxNTAsXCIyOFwiOjY5LFwiMjlcIjoxOCxcIjMwXCI6MTU5LFwiMzFcIjoxOTEsXCIzMlwiOjIwNSxcIjMzXCI6MTc5LFwiMzRcIjozNCxcIjM1XCI6NTgsXCIzNlwiOjY5LFwiMzdcIjo4OCxcIjM4XCI6MjIxLFwiMzlcIjoxOTEsXCI0MFwiOjEyMixcIjQxXCI6MjUsXCI0MlwiOjU2LFwiNDNcIjozMixcIjQ0XCI6OTEsXCI0NVwiOjEzMSxcIjQ2XCI6MjQzLFwiNDdcIjo2MyxcIjQ4XCI6MjEyLFwiNDlcIjoyNyxcIjUwXCI6MTM0LFwiNTFcIjoxODIsXCI1MlwiOjIyLFwiNTNcIjo5NCxcIjU0XCI6MjA5LFwiNTVcIjoxOTEsXCI1NlwiOjEwNixcIjU3XCI6MTgwLFwiNThcIjoyMzksXCI1OVwiOjc4LFwiNjBcIjoyMjIsXCI2MVwiOjE4OSxcIjYyXCI6MjEzLFwiNjNcIjoxOTEsXCI2NFwiOjE2OSxcIjY1XCI6MTgzLFwiNjZcIjoxMzEsXCI2N1wiOjcyLFwiNjhcIjo1OSxcIjY5XCI6MTU2LFwiNzBcIjoyMjksXCI3MVwiOjYzLFwiNzJcIjo2NixcIjczXCI6MjUzLFwiNzRcIjoxNzcsXCI3NVwiOjE4NixcIjc2XCI6MjE2LFwiNzdcIjoyNTEsXCI3OFwiOjIxNixcIjc5XCI6MTkxLFwiODBcIjoyMjAsXCI4MVwiOjIxNixcIjgyXCI6NzEsXCI4M1wiOjEyOSxcIjg0XCI6MTQsXCI4NVwiOjExNixcIjg2XCI6MTg1LFwiODdcIjoxOTEsXCI4OFwiOjE2OSxcIjg5XCI6MTUsXCI5MFwiOjE0NixcIjkxXCI6MTY1LFwiOTJcIjoxMTIsXCI5M1wiOjEyOCxcIjk0XCI6MjA2LFwiOTVcIjo2MyxcIjk2XCI6MTUxLFwiOTdcIjoyMjksXCI5OFwiOjI0OSxcIjk5XCI6MTg5LFwiMTAwXCI6MTEyLFwiMTAxXCI6NTEsXCIxMDJcIjoxNzcsXCIxMDNcIjoxOTEsXCIxMDRcIjoyMjgsXCIxMDVcIjoxMzIsXCIxMDZcIjo4OSxcIjEwN1wiOjkxLFwiMTA4XCI6MTUyLFwiMTA5XCI6MzEsXCIxMTBcIjoxOTgsXCIxMTFcIjo2MyxcIjExMlwiOjkzLFwiMTEzXCI6MTQ2LFwiMTE0XCI6MjQxLFwiMTE1XCI6MTYyLFwiMTE2XCI6MjAwLFwiMTE3XCI6MjE5LFwiMTE4XCI6MjEzLFwiMTE5XCI6NjMsXCIxMjBcIjo5NixcIjEyMVwiOjc3LFwiMTIyXCI6NTAsXCIxMjNcIjoxNTUsXCIxMjRcIjoxMjksXCIxMjVcIjoxNTAsXCIxMjZcIjoyMjYsXCIxMjdcIjo2MyxcImJ5dGVMZW5ndGhcIjoxMjh9LFwibGVuZ3RoXCI6MTYsXCJieXRlT2Zmc2V0XCI6MCxcImJ5dGVMZW5ndGhcIjoxMjh9fSx7XCJzeFwiOjEsXCJzeVwiOjEsXCJkZXB0aFwiOjE2LFwid1wiOntcIjBcIjowLjQzMTI2MDM0NTQxNzM4ODE3LFwiMVwiOi0wLjE2ODkwODUxNTcyNDczNTk3LFwiMlwiOi0wLjI3ODg5NjA4ODQ3MjA0ODQ0LFwiM1wiOi0wLjA3NDk5MDQ2OTAyODkzMTI0LFwiNFwiOjAuMTMyOTQzNjUxNTMyNTAxMixcIjVcIjotMC45MDUwNzY0MjQwMDIwMTg4LFwiNlwiOjAuMjQxOTg4NzcyMzE3NjIyNTYsXCI3XCI6MC4xNTY0Mzc4MjE2NTY0Nzk1MSxcIjhcIjotMC40OTIzMDczNDQ3NzU5NTE0LFwiOVwiOjAuMzExMjc2NDAyMjAxMjY3MixcIjEwXCI6MC4yNTcwMTM4MzQ0NDM3Mjg1NSxcIjExXCI6LTAuMjc3Njk5NzYxMDUzMzI4OTQsXCIxMlwiOjAuMzAwMjU4NTI3MzQ5MDk5NzUsXCIxM1wiOjAuMzMwNjY0MTk2NTAyNjAxNixcIjE0XCI6LTAuNTA1NjA2OTgyMDU0NDUyLFwiMTVcIjotMC41ODk0NDUwODM2NTMzOTI1LFwiQllURVNfUEVSX0VMRU1FTlRcIjo4LFwiYnVmZmVyXCI6e1wiMFwiOjUxLFwiMVwiOjcxLFwiMlwiOjIzMixcIjNcIjoyNTMsXCI0XCI6MTk2LFwiNVwiOjE1MyxcIjZcIjoyMTksXCI3XCI6NjMsXCI4XCI6MTk2LFwiOVwiOjIyMSxcIjEwXCI6MTM0LFwiMTFcIjo4MyxcIjEyXCI6MjAzLFwiMTNcIjoxNTgsXCIxNFwiOjE5NyxcIjE1XCI6MTkxLFwiMTZcIjoxODUsXCIxN1wiOjE2LFwiMThcIjoxOTAsXCIxOVwiOjI1MCxcIjIwXCI6MTEwLFwiMjFcIjoyMTcsXCIyMlwiOjIwOSxcIjIzXCI6MTkxLFwiMjRcIjoxNTEsXCIyNVwiOjE3NSxcIjI2XCI6MjUzLFwiMjdcIjo3NSxcIjI4XCI6MTQ3LFwiMjlcIjo1MCxcIjMwXCI6MTc5LFwiMzFcIjoxOTEsXCIzMlwiOjQ0LFwiMzNcIjoxMjYsXCIzNFwiOjE5NyxcIjM1XCI6NDUsXCIzNlwiOjc2LFwiMzdcIjo0LFwiMzhcIjoxOTMsXCIzOVwiOjYzLFwiNDBcIjoxMzAsXCI0MVwiOjQsXCI0MlwiOjQ3LFwiNDNcIjoyMTMsXCI0NFwiOjk4LFwiNDVcIjoyNDYsXCI0NlwiOjIzNixcIjQ3XCI6MTkxLFwiNDhcIjoxMzQsXCI0OVwiOjU5LFwiNTBcIjoxNDEsXCI1MVwiOjI0MyxcIjUyXCI6MTI0LFwiNTNcIjoyNDksXCI1NFwiOjIwNixcIjU1XCI6NjMsXCI1NlwiOjE3MCxcIjU3XCI6MTU5LFwiNThcIjoyMzksXCI1OVwiOjE0MyxcIjYwXCI6MzksXCI2MVwiOjYsXCI2MlwiOjE5NixcIjYzXCI6NjMsXCI2NFwiOjI0NCxcIjY1XCI6NDMsXCI2NlwiOjg5LFwiNjdcIjoxNzAsXCI2OFwiOjI0NixcIjY5XCI6MTI5LFwiNzBcIjoyMjMsXCI3MVwiOjE5MSxcIjcyXCI6MTU4LFwiNzNcIjozNixcIjc0XCI6MjIyLFwiNzVcIjoyMTksXCI3NlwiOjI0MyxcIjc3XCI6MjM1LFwiNzhcIjoyMTEsXCI3OVwiOjYzLFwiODBcIjo1NyxcIjgxXCI6MTM5LFwiODJcIjo5OSxcIjgzXCI6MzksXCI4NFwiOjIzNCxcIjg1XCI6MTE0LFwiODZcIjoyMDgsXCI4N1wiOjYzLFwiODhcIjozMixcIjg5XCI6NDgsXCI5MFwiOjI0NSxcIjkxXCI6NTUsXCI5MlwiOjIxMyxcIjkzXCI6MTk3LFwiOTRcIjoyMDksXCI5NVwiOjE5MSxcIjk2XCI6MjM4LFwiOTdcIjoyMDYsXCI5OFwiOjIxMSxcIjk5XCI6MTM4LFwiMTAwXCI6MTExLFwiMTAxXCI6NTUsXCIxMDJcIjoyMTEsXCIxMDNcIjo2MyxcIjEwNFwiOjEwMCxcIjEwNVwiOjI0NCxcIjEwNlwiOjEyMyxcIjEwN1wiOjQxLFwiMTA4XCI6MTU0LFwiMTA5XCI6NDEsXCIxMTBcIjoyMTMsXCIxMTFcIjo2MyxcIjExMlwiOjYyLFwiMTEzXCI6MTc5LFwiMTE0XCI6MTQ1LFwiMTE1XCI6MTc3LFwiMTE2XCI6MjM4LFwiMTE3XCI6NDUsXCIxMThcIjoyMjQsXCIxMTlcIjoxOTEsXCIxMjBcIjoxNzEsXCIxMjFcIjoxMzcsXCIxMjJcIjoxNjIsXCIxMjNcIjoyMzksXCIxMjRcIjoxODcsXCIxMjVcIjoyMjAsXCIxMjZcIjoyMjYsXCIxMjdcIjoxOTEsXCJieXRlTGVuZ3RoXCI6MTI4fSxcImxlbmd0aFwiOjE2LFwiYnl0ZU9mZnNldFwiOjAsXCJieXRlTGVuZ3RoXCI6MTI4fX0se1wic3hcIjoxLFwic3lcIjoxLFwiZGVwdGhcIjoxNixcIndcIjp7XCIwXCI6MC4yMTMwMjE2MDQ4NzU0OTc5NixcIjFcIjotMC4wMzczMzk2MDYwOTM5NTUyLFwiMlwiOi0wLjQ1Njc2MjEyODE3ODk4NjE1LFwiM1wiOjAuMDE1MTk3NzQ1ODI0ODI1Nzg0LFwiNFwiOjAuMjk4NTk1MTI1NTc0NzYwODcsXCI1XCI6LTAuMzA5NjIxNjA1ODExMzAxMDUsXCI2XCI6MC4zNDAyNDAxNzAzMTI1MDc3LFwiN1wiOjAuMjA5MDgwNzEyMjgzNzQyOTgsXCI4XCI6LTAuNTcxNDg1MDQ2NjQ0Nzc3MSxcIjlcIjowLjI1ODEwMzE0MzIwNDcwNSxcIjEwXCI6MC4xMDI0MTA2NTk2OTk0NzgyNyxcIjExXCI6LTAuMDkwNzgyNzQ4ODA2MDEwMjUsXCIxMlwiOi0wLjI3NzQxMjc2NzMzOTk1OTM0LFwiMTNcIjowLjA4NDU4MzgwMTU4ODc3MzE4LFwiMTRcIjotMC40MDk0MzMyMzY3NDI2MjA5LFwiMTVcIjotMC41ODU4MjcwNTI5OTQ4ODQxLFwiQllURVNfUEVSX0VMRU1FTlRcIjo4LFwiYnVmZmVyXCI6e1wiMFwiOjE3MyxcIjFcIjoxNCxcIjJcIjozNixcIjNcIjoxODksXCI0XCI6NzQsXCI1XCI6NjgsXCI2XCI6MjAzLFwiN1wiOjYzLFwiOFwiOjU2LFwiOVwiOjE5NCxcIjEwXCI6OSxcIjExXCI6NzAsXCIxMlwiOjQ1LFwiMTNcIjozMCxcIjE0XCI6MTYzLFwiMTVcIjoxOTEsXCIxNlwiOjExNSxcIjE3XCI6MzIsXCIxOFwiOjE2NSxcIjE5XCI6NTYsXCIyMFwiOjE1MSxcIjIxXCI6NTksXCIyMlwiOjIyMSxcIjIzXCI6MTkxLFwiMjRcIjoxMTcsXCIyNVwiOjEwLFwiMjZcIjo4MyxcIjI3XCI6MjM0LFwiMjhcIjoyNTQsXCIyOVwiOjMxLFwiMzBcIjoxNDMsXCIzMVwiOjYzLFwiMzJcIjoyMDYsXCIzM1wiOjE3MSxcIjM0XCI6MTk3LFwiMzVcIjoxODYsXCIzNlwiOjQ2LFwiMzdcIjoyOCxcIjM4XCI6MjExLFwiMzlcIjo2MyxcIjQwXCI6MjQ4LFwiNDFcIjoxMixcIjQyXCI6MTk4LFwiNDNcIjozNSxcIjQ0XCI6MjE1LFwiNDVcIjoyMDgsXCI0NlwiOjIxMSxcIjQ3XCI6MTkxLFwiNDhcIjoxNzUsXCI0OVwiOjE5NyxcIjUwXCI6MTcsXCI1MVwiOjE4MSxcIjUyXCI6MTI2LFwiNTNcIjoxOTgsXCI1NFwiOjIxMyxcIjU1XCI6NjMsXCI1NlwiOjI0NixcIjU3XCI6MjEyLFwiNThcIjoxODksXCI1OVwiOjM0LFwiNjBcIjo0MCxcIjYxXCI6MTk1LFwiNjJcIjoyMDIsXCI2M1wiOjYzLFwiNjRcIjo4OSxcIjY1XCI6MTkzLFwiNjZcIjo0NyxcIjY3XCI6MixcIjY4XCI6MTU1LFwiNjlcIjo3MyxcIjcwXCI6MjI2LFwiNzFcIjoxOTEsXCI3MlwiOjIyMSxcIjczXCI6MTk4LFwiNzRcIjoxOTUsXCI3NVwiOjExLFwiNzZcIjoxOTUsXCI3N1wiOjEzMixcIjc4XCI6MjA4LFwiNzlcIjo2MyxcIjgwXCI6MTQ0LFwiODFcIjoyMDEsXCI4MlwiOjQzLFwiODNcIjoxOTQsXCI4NFwiOjE0OSxcIjg1XCI6NTUsXCI4NlwiOjE4NixcIjg3XCI6NjMsXCI4OFwiOjE4LFwiODlcIjoxNzMsXCI5MFwiOjQxLFwiOTFcIjoyMDEsXCI5MlwiOjEzNyxcIjkzXCI6NjEsXCI5NFwiOjE4MyxcIjk1XCI6MTkxLFwiOTZcIjoxMDgsXCI5N1wiOjI0MyxcIjk4XCI6MjA1LFwiOTlcIjoxMjIsXCIxMDBcIjozMyxcIjEwMVwiOjE5MyxcIjEwMlwiOjIwOSxcIjEwM1wiOjE5MSxcIjEwNFwiOjE3NCxcIjEwNVwiOjkwLFwiMTA2XCI6MTUyLFwiMTA3XCI6MTgxLFwiMTA4XCI6NzIsXCIxMDlcIjoxNjcsXCIxMTBcIjoxODEsXCIxMTFcIjo2MyxcIjExMlwiOjExMCxcIjExM1wiOjMwLFwiMTE0XCI6MTA5LFwiMTE1XCI6MTE4LFwiMTE2XCI6MzksXCIxMTdcIjo1MixcIjExOFwiOjIxOCxcIjExOVwiOjE5MSxcIjEyMFwiOjIzMixcIjEyMVwiOjUxLFwiMTIyXCI6NTUsXCIxMjNcIjo5NixcIjEyNFwiOjI0LFwiMTI1XCI6MTkxLFwiMTI2XCI6MjI2LFwiMTI3XCI6MTkxLFwiYnl0ZUxlbmd0aFwiOjEyOH0sXCJsZW5ndGhcIjoxNixcImJ5dGVPZmZzZXRcIjowLFwiYnl0ZUxlbmd0aFwiOjEyOH19LHtcInN4XCI6MSxcInN5XCI6MSxcImRlcHRoXCI6MTYsXCJ3XCI6e1wiMFwiOjAuMTUwMzM4MzY0OTkzNzYyMTMsXCIxXCI6LTAuMDIzNTY1Mjk5OTAxMDc2MTI1LFwiMlwiOi0wLjM2NzcyODMwNDE5MDM0OTM1LFwiM1wiOi0wLjA4NTg5ODg0ODU1NjA2OTk1LFwiNFwiOjAuMTIyNjgwMDcxMTM3Mjk0NTcsXCI1XCI6LTAuNDEyNTgxNTAyMDMyNTQxLFwiNlwiOi0wLjEyMzY3MTUyNzQxMDE4MDA1LFwiN1wiOjAuMTU4MjU0NjcxMjg0ODI0MzIsXCI4XCI6LTAuMDY3OTI5MTQxMjc3NDE2NzMsXCI5XCI6MC4wMzY3ODEwMTI5MjE1MTg1ODUsXCIxMFwiOi0wLjAyMjEyNDA3MTQzODI5MjkwOCxcIjExXCI6LTAuNTA3ODI1ODAyMDMxNzIzMixcIjEyXCI6LTAuMDUyNDA1NjUyMjgyNDMyNjIsXCIxM1wiOjAuMzM5MzE3MjE0OTE0NjQ4NTYsXCIxNFwiOi0wLjMwNjIyOTY2Mjk5NDc0ODg1LFwiMTVcIjotMC4zODgwODc3Njg3NTUwNTkyLFwiQllURVNfUEVSX0VMRU1FTlRcIjo4LFwiYnVmZmVyXCI6e1wiMFwiOjE2NixcIjFcIjoxODgsXCIyXCI6MTI1LFwiM1wiOjE1NixcIjRcIjo3MyxcIjVcIjo2MixcIjZcIjoxOTUsXCI3XCI6NjMsXCI4XCI6MjcsXCI5XCI6MTIsXCIxMFwiOjE0OSxcIjExXCI6MTI5LFwiMTJcIjoxMjgsXCIxM1wiOjMzLFwiMTRcIjoxNTIsXCIxNVwiOjE5MSxcIjE2XCI6MjMxLFwiMTdcIjoyMzIsXCIxOFwiOjE5LFwiMTlcIjo3NixcIjIwXCI6MjIwLFwiMjFcIjoxMzYsXCIyMlwiOjIxNSxcIjIzXCI6MTkxLFwiMjRcIjoyNDUsXCIyNVwiOjI0NyxcIjI2XCI6NzksXCIyN1wiOjEzNyxcIjI4XCI6MTE5LFwiMjlcIjoyNTMsXCIzMFwiOjE4MSxcIjMxXCI6MTkxLFwiMzJcIjoxNTYsXCIzM1wiOjIxNSxcIjM0XCI6MTAzLFwiMzVcIjoxMyxcIjM2XCI6MjQ2LFwiMzdcIjoxMDMsXCIzOFwiOjE5MSxcIjM5XCI6NjMsXCI0MFwiOjYxLFwiNDFcIjoxMzIsXCI0MlwiOjEzOCxcIjQzXCI6NjIsXCI0NFwiOjE4OCxcIjQ1XCI6MTAzLFwiNDZcIjoyMTgsXCI0N1wiOjE5MSxcIjQ4XCI6MTc1LFwiNDlcIjo3OSxcIjUwXCI6MTcyLFwiNTFcIjoyMzcsXCI1MlwiOjIzOSxcIjUzXCI6MTY4LFwiNTRcIjoxOTEsXCI1NVwiOjE5MSxcIjU2XCI6NTcsXCI1N1wiOjE5NixcIjU4XCI6MjA1LFwiNTlcIjoxMDIsXCI2MFwiOjE3NixcIjYxXCI6NjUsXCI2MlwiOjE5NixcIjYzXCI6NjMsXCI2NFwiOjE4OCxcIjY1XCI6OTEsXCI2NlwiOjU5LFwiNjdcIjoyMjQsXCI2OFwiOjIwNSxcIjY5XCI6OTksXCI3MFwiOjE3NyxcIjcxXCI6MTkxLFwiNzJcIjoxNDQsXCI3M1wiOjQ1LFwiNzRcIjo1NyxcIjc1XCI6MjU1LFwiNzZcIjoyNDUsXCI3N1wiOjIxMixcIjc4XCI6MTYyLFwiNzlcIjo2MyxcIjgwXCI6MTM5LFwiODFcIjoxNTMsXCI4MlwiOjMyLFwiODNcIjo3NyxcIjg0XCI6MTc3LFwiODVcIjoxNjcsXCI4NlwiOjE1MCxcIjg3XCI6MTkxLFwiODhcIjoxNzYsXCI4OVwiOjgxLFwiOTBcIjoxMjEsXCI5MVwiOjIyOSxcIjkyXCI6MjcsXCI5M1wiOjY0LFwiOTRcIjoyMjQsXCI5NVwiOjE5MSxcIjk2XCI6MjM1LFwiOTdcIjoxMTIsXCI5OFwiOjkxLFwiOTlcIjoyMjksXCIxMDBcIjoyMzMsXCIxMDFcIjoyMTIsXCIxMDJcIjoxNzAsXCIxMDNcIjoxOTEsXCIxMDRcIjo4NyxcIjEwNVwiOjIwNixcIjEwNlwiOjY1LFwiMTA3XCI6MTQxLFwiMTA4XCI6OTUsXCIxMDlcIjoxODMsXCIxMTBcIjoyMTMsXCIxMTFcIjo2MyxcIjExMlwiOjE5MCxcIjExM1wiOjQxLFwiMTE0XCI6MjMyLFwiMTE1XCI6NzYsXCIxMTZcIjo2OCxcIjExN1wiOjE1MyxcIjExOFwiOjIxMSxcIjExOVwiOjE5MSxcIjEyMFwiOjQ3LFwiMTIxXCI6MjQ1LFwiMTIyXCI6MTc3LFwiMTIzXCI6MjAsXCIxMjRcIjoxMTAsXCIxMjVcIjoyMTQsXCIxMjZcIjoyMTYsXCIxMjdcIjoxOTEsXCJieXRlTGVuZ3RoXCI6MTI4fSxcImxlbmd0aFwiOjE2LFwiYnl0ZU9mZnNldFwiOjAsXCJieXRlTGVuZ3RoXCI6MTI4fX1dLFwiYmlhc2VzXCI6e1wic3hcIjoxLFwic3lcIjoxLFwiZGVwdGhcIjoxNixcIndcIjp7XCIwXCI6LTAuMDEwMjM1NDgyMzcyMjIxMTc4LFwiMVwiOi0wLjAwMTU2OTMxOTI0MzcxMjM1NzIsXCIyXCI6LTAuMTQwNTk2MDA2OTE4MTUyNixcIjNcIjotMC4xMTI3NDMzMjUyNzc3MDM0NSxcIjRcIjotMC4xMzM3MzE5OTIzMzk0NjY3NSxcIjVcIjotMC4wMjA4ODYwMTM0Nzc1MzEyMTgsXCI2XCI6LTAuMDkwNzA0OTkyNjc4OTQ3MDEsXCI3XCI6LTAuMDI4NzIwNTUwNzA2MTQ0NDg0LFwiOFwiOi0wLjE0MTU1MjU1NTg2MDYxMDcsXCI5XCI6LTAuMTcxODc2MzEwMjQwODAxMjIsXCIxMFwiOi0wLjAwMzUzMjY0NzMyNDgyNTM0NixcIjExXCI6LTAuMDkzMTc0NTQyOTgxMjYwNTYsXCIxMlwiOi0wLjA5NDQ2OTI2Mzc3MDIwMzUyLFwiMTNcIjowLjA0OTA1NDEyMzY0MjM2NTI4NCxcIjE0XCI6MC4wMDkzMTk0NzYyNDM2MDUzMjUsXCIxNVwiOi0wLjA0MjQwNjAyOTY0NzEzMTYsXCJCWVRFU19QRVJfRUxFTUVOVFwiOjgsXCJidWZmZXJcIjp7XCIwXCI6NzQsXCIxXCI6NTgsXCIyXCI6OTcsXCIzXCI6NDgsXCI0XCI6ODcsXCI1XCI6MjQ2LFwiNlwiOjEzMixcIjdcIjoxOTEsXCI4XCI6NzIsXCI5XCI6MjI1LFwiMTBcIjo5LFwiMTFcIjoxODEsXCIxMlwiOjUxLFwiMTNcIjoxODIsXCIxNFwiOjg5LFwiMTVcIjoxOTEsXCIxNlwiOjMwLFwiMTdcIjoxNzcsXCIxOFwiOjIxMixcIjE5XCI6MjAxLFwiMjBcIjoxMixcIjIxXCI6MjU1LFwiMjJcIjoxOTMsXCIyM1wiOjE5MSxcIjI0XCI6MTI2LFwiMjVcIjoyNDcsXCIyNlwiOjIzMixcIjI3XCI6MzAsXCIyOFwiOjE5MSxcIjI5XCI6MjIwLFwiMzBcIjoxODgsXCIzMVwiOjE5MSxcIjMyXCI6MTMyLFwiMzNcIjoxMTQsXCIzNFwiOjE5NSxcIjM1XCI6NjYsXCIzNlwiOjMzLFwiMzdcIjozMCxcIjM4XCI6MTkzLFwiMzlcIjoxOTEsXCI0MFwiOjQ4LFwiNDFcIjoxODYsXCI0MlwiOjgxLFwiNDNcIjoxNjMsXCI0NFwiOjM2LFwiNDVcIjo5OSxcIjQ2XCI6MTQ5LFwiNDdcIjoxOTEsXCI0OFwiOjIxMyxcIjQ5XCI6MjE0LFwiNTBcIjozNSxcIjUxXCI6NjUsXCI1MlwiOjExMyxcIjUzXCI6NTYsXCI1NFwiOjE4MyxcIjU1XCI6MTkxLFwiNTZcIjoyMzksXCI1N1wiOjM2LFwiNThcIjo2LFwiNTlcIjoxMzYsXCI2MFwiOjIzNSxcIjYxXCI6MTA0LFwiNjJcIjoxNTcsXCI2M1wiOjE5MSxcIjY0XCI6MTU3LFwiNjVcIjoxOSxcIjY2XCI6MTEsXCI2N1wiOjIzMSxcIjY4XCI6MTAwLFwiNjlcIjozMCxcIjcwXCI6MTk0LFwiNzFcIjoxOTEsXCI3MlwiOjEyOSxcIjczXCI6MTI3LFwiNzRcIjoxODQsXCI3NVwiOjI1MyxcIjc2XCI6MTAsXCI3N1wiOjAsXCI3OFwiOjE5OCxcIjc5XCI6MTkxLFwiODBcIjoxNTgsXCI4MVwiOjY5LFwiODJcIjo3OSxcIjgzXCI6MTUxLFwiODRcIjoxMjcsXCI4NVwiOjI0MCxcIjg2XCI6MTA4LFwiODdcIjoxOTEsXCI4OFwiOjg1LFwiODlcIjoxNTYsXCI5MFwiOjIzNixcIjkxXCI6MTEwLFwiOTJcIjo3MyxcIjkzXCI6MjE4LFwiOTRcIjoxODMsXCI5NVwiOjE5MSxcIjk2XCI6MjE5LFwiOTdcIjoxOTgsXCI5OFwiOjk0LFwiOTlcIjo2MixcIjEwMFwiOjM1LFwiMTAxXCI6NDcsXCIxMDJcIjoxODQsXCIxMDNcIjoxOTEsXCIxMDRcIjoyMDksXCIxMDVcIjo3MixcIjEwNlwiOjE0MixcIjEwN1wiOjY1LFwiMTA4XCI6MTU5LFwiMTA5XCI6MjksXCIxMTBcIjoxNjksXCIxMTFcIjo2MyxcIjExMlwiOjE0NSxcIjExM1wiOjIsXCIxMTRcIjoxMTcsXCIxMTVcIjoyMzcsXCIxMTZcIjoyMixcIjExN1wiOjIyLFwiMTE4XCI6MTMxLFwiMTE5XCI6NjMsXCIxMjBcIjoxMzEsXCIxMjFcIjoxNzEsXCIxMjJcIjoyNDksXCIxMjNcIjo2MCxcIjEyNFwiOjYyLFwiMTI1XCI6MTgyLFwiMTI2XCI6MTY1LFwiMTI3XCI6MTkxLFwiYnl0ZUxlbmd0aFwiOjEyOH0sXCJsZW5ndGhcIjoxNixcImJ5dGVPZmZzZXRcIjowLFwiYnl0ZUxlbmd0aFwiOjEyOH19fSx7XCJvdXRfZGVwdGhcIjoxNixcIm91dF9zeFwiOjEsXCJvdXRfc3lcIjoxLFwibGF5ZXJfdHlwZVwiOlwic2lnbW9pZFwifSx7XCJvdXRfZGVwdGhcIjoyLFwib3V0X3N4XCI6MSxcIm91dF9zeVwiOjEsXCJsYXllcl90eXBlXCI6XCJmY1wiLFwibnVtX2lucHV0c1wiOjE2LFwibDFfZGVjYXlfbXVsXCI6MCxcImwyX2RlY2F5X211bFwiOjEsXCJmaWx0ZXJzXCI6W3tcInN4XCI6MSxcInN5XCI6MSxcImRlcHRoXCI6MTYsXCJ3XCI6e1wiMFwiOi0wLjM3NTk3MjI3Njg3NjQ4MzEsXCIxXCI6LTAuMzc1NDI1NDI4MzgwODQwNCxcIjJcIjowLjEwMzYzNDgyNzY4OTA0MDQsXCIzXCI6MC4wNjc4MjE3NjQzNDc2MTAxNyxcIjRcIjowLjM3MzE0NTI2Mjg5NDg0MjU3LFwiNVwiOi0wLjAyMTc4NTM1MDY0NTQ0MjQxNyxcIjZcIjowLjIyMjEzNDk1Njg2MjUzMTg3LFwiN1wiOi0wLjIxOTU2MTUyOTg3MzQ0NTMsXCI4XCI6MC4xNDEzNDQ0ODkyMzU0MzQzMyxcIjlcIjowLjQ3NzM1NDIxNTg2MTk4MzQ2LFwiMTBcIjotMC4xOTY5MTQ5ODk2NDAxMTcyNSxcIjExXCI6LTAuMDEwMTIzMzk5MDM2MzMxMDY1LFwiMTJcIjowLjU3Mjk1MzYyMjU5NjcyNjcsXCIxM1wiOi0wLjQ0NTQwMzI5OTUyMjI2ODg3LFwiMTRcIjotMC42MTg3NTcxMjg1Njc1MTA4LFwiMTVcIjowLjE3NTQ0NzE0NTA4MTEwNDc2LFwiQllURVNfUEVSX0VMRU1FTlRcIjo4LFwiYnVmZmVyXCI6e1wiMFwiOjI1LFwiMVwiOjE5OSxcIjJcIjo4OCxcIjNcIjo2LFwiNFwiOjIzOCxcIjVcIjoxNSxcIjZcIjoyMTYsXCI3XCI6MTkxLFwiOFwiOjcxLFwiOVwiOjIyNSxcIjEwXCI6NjIsXCIxMVwiOjk2LFwiMTJcIjoyNDgsXCIxM1wiOjYsXCIxNFwiOjIxNixcIjE1XCI6MTkxLFwiMTZcIjoxMjcsXCIxN1wiOjE2OSxcIjE4XCI6MTY2LFwiMTlcIjoyMjcsXCIyMFwiOjIwNyxcIjIxXCI6MTM1LFwiMjJcIjoxODYsXCIyM1wiOjYzLFwiMjRcIjo0NCxcIjI1XCI6MTIzLFwiMjZcIjoyMTIsXCIyN1wiOjk5LFwiMjhcIjoxOTYsXCIyOVwiOjkyLFwiMzBcIjoxNzcsXCIzMVwiOjYzLFwiMzJcIjo5MSxcIjMzXCI6MTU0LFwiMzRcIjo1MCxcIjM1XCI6MTcxLFwiMzZcIjoxNTYsXCIzN1wiOjIyNSxcIjM4XCI6MjE1LFwiMzlcIjo2MyxcIjQwXCI6MTMyLFwiNDFcIjo5MyxcIjQyXCI6NTUsXCI0M1wiOjM0LFwiNDRcIjoyMzAsXCI0NVwiOjc4LFwiNDZcIjoxNTAsXCI0N1wiOjE5MSxcIjQ4XCI6MjIyLFwiNDlcIjoyMzksXCI1MFwiOjEzMCxcIjUxXCI6MTksXCI1MlwiOjIzNSxcIjUzXCI6MTEwLFwiNTRcIjoyMDQsXCI1NVwiOjYzLFwiNTZcIjoyLFwiNTdcIjoxOCxcIjU4XCI6MzQsXCI1OVwiOjE1NSxcIjYwXCI6MTUxLFwiNjFcIjoyNixcIjYyXCI6MjA0LFwiNjNcIjoxOTEsXCI2NFwiOjE4NSxcIjY1XCI6NTMsXCI2NlwiOjk0LFwiNjdcIjoxMzEsXCI2OFwiOjE0NyxcIjY5XCI6MjMsXCI3MFwiOjE5NCxcIjcxXCI6NjMsXCI3MlwiOjgwLFwiNzNcIjo5LFwiNzRcIjoxMTEsXCI3NVwiOjE3OCxcIjc2XCI6MjQ4LFwiNzdcIjoxNDAsXCI3OFwiOjIyMixcIjc5XCI6NjMsXCI4MFwiOjEzNyxcIjgxXCI6ODksXCI4MlwiOjc2LFwiODNcIjoxNjgsXCI4NFwiOjEzMCxcIjg1XCI6NTIsXCI4NlwiOjIwMSxcIjg3XCI6MTkxLFwiODhcIjoxODIsXCI4OVwiOjEyNyxcIjkwXCI6NzIsXCI5MVwiOjE1OCxcIjkyXCI6MTQ3LFwiOTNcIjoxODcsXCI5NFwiOjEzMixcIjk1XCI6MTkxLFwiOTZcIjoxMTYsXCI5N1wiOjE3NSxcIjk4XCI6MjI5LFwiOTlcIjoyMTMsXCIxMDBcIjoxNjIsXCIxMDFcIjo4NSxcIjEwMlwiOjIyNixcIjEwM1wiOjYzLFwiMTA0XCI6MjU0LFwiMTA1XCI6MTYxLFwiMTA2XCI6NjIsXCIxMDdcIjoyMTUsXCIxMDhcIjoxMjQsXCIxMDlcIjoxMjksXCIxMTBcIjoyMjAsXCIxMTFcIjoxOTEsXCIxMTJcIjoxNDMsXCIxMTNcIjoxNjgsXCIxMTRcIjoyMzUsXCIxMTVcIjoxOTEsXCIxMTZcIjoyMTksXCIxMTdcIjoyMDQsXCIxMThcIjoyMjcsXCIxMTlcIjoxOTEsXCIxMjBcIjoxMzQsXCIxMjFcIjo5OSxcIjEyMlwiOjM4LFwiMTIzXCI6ODMsXCIxMjRcIjoxMyxcIjEyNVwiOjExNyxcIjEyNlwiOjE5OCxcIjEyN1wiOjYzLFwiYnl0ZUxlbmd0aFwiOjEyOH0sXCJsZW5ndGhcIjoxNixcImJ5dGVPZmZzZXRcIjowLFwiYnl0ZUxlbmd0aFwiOjEyOH19LHtcInN4XCI6MSxcInN5XCI6MSxcImRlcHRoXCI6MTYsXCJ3XCI6e1wiMFwiOjAuMzA5MzAzOTM5Mzc2NDkzNSxcIjFcIjowLjIwMTQ3NDU1NTU2NTE4MjY1LFwiMlwiOi0wLjEzNDA0MzkwNzEyOTMwODkxLFwiM1wiOi0wLjE0NzgyOTMzMTgxNjU3NTg3LFwiNFwiOjAuMDAyMTYwMzI5NDQ3OTc4NzQsXCI1XCI6MC4yNzc2MzU3NDIwNTg2MTY3NCxcIjZcIjotMC4wMDc3NzI2MTAzNzY3MzAxNjQsXCI3XCI6MC4xNjM0NDEwMjM3NTYyMzQ2LFwiOFwiOi0wLjA4Mjk5MTIyNzMwMTM0ODQzLFwiOVwiOi0wLjM3NjkwODg0NDc2MDQ4OTg2LFwiMTBcIjowLjM0NDMxMjc4NjU1MTM5MzEsXCIxMVwiOi0wLjM4MjIxMzc4NzQzMTg0OTI1LFwiMTJcIjotMC4zNzc3NTc2MjY2NjA0MTMxLFwiMTNcIjowLjM5MjY3NzE5NTEyMDM1Mjc2LFwiMTRcIjowLjE5ODM1MjI2MjA5MjA2MTU4LFwiMTVcIjowLjUzMjQzMDI2NjQ0OTQ2MzgsXCJCWVRFU19QRVJfRUxFTUVOVFwiOjgsXCJidWZmZXJcIjp7XCIwXCI6NDIsXCIxXCI6ODgsXCIyXCI6OSxcIjNcIjoxOTIsXCI0XCI6MTYyLFwiNVwiOjIwMyxcIjZcIjoyMTEsXCI3XCI6NjMsXCI4XCI6MTk5LFwiOVwiOjExNyxcIjEwXCI6MTQ0LFwiMTFcIjoxNyxcIjEyXCI6MjM1LFwiMTNcIjoyMDEsXCIxNFwiOjIwMSxcIjE1XCI6NjMsXCIxNlwiOjIwMCxcIjE3XCI6MTUzLFwiMThcIjoxNzIsXCIxOVwiOjIwMixcIjIwXCI6ODksXCIyMVwiOjQwLFwiMjJcIjoxOTMsXCIyM1wiOjE5MSxcIjI0XCI6NjgsXCIyNVwiOjg3LFwiMjZcIjoxOTcsXCIyN1wiOjgwLFwiMjhcIjoxOCxcIjI5XCI6MjM2LFwiMzBcIjoxOTQsXCIzMVwiOjE5MSxcIjMyXCI6MzIsXCIzM1wiOjM3LFwiMzRcIjoxMjQsXCIzNVwiOjEwLFwiMzZcIjoxMzgsXCIzN1wiOjE3OCxcIjM4XCI6OTcsXCIzOVwiOjYzLFwiNDBcIjoxODIsXCI0MVwiOjIzNCxcIjQyXCI6MjEsXCI0M1wiOjE4MCxcIjQ0XCI6MjAwLFwiNDVcIjoxOTYsXCI0NlwiOjIwOSxcIjQ3XCI6NjMsXCI0OFwiOjQsXCI0OVwiOjUwLFwiNTBcIjoyNDYsXCI1MVwiOjUzLFwiNTJcIjo0NCxcIjUzXCI6MjE0LFwiNTRcIjoxMjcsXCI1NVwiOjE5MSxcIjU2XCI6MjQ0LFwiNTdcIjoyMDMsXCI1OFwiOjIzNyxcIjU5XCI6MTczLFwiNjBcIjoxNjIsXCI2MVwiOjIzNSxcIjYyXCI6MTk2LFwiNjNcIjo2MyxcIjY0XCI6MjA3LFwiNjVcIjo1OSxcIjY2XCI6MjksXCI2N1wiOjE5MSxcIjY4XCI6MjMzLFwiNjlcIjo2MixcIjcwXCI6MTgxLFwiNzFcIjoxOTEsXCI3MlwiOjIwMSxcIjczXCI6MTEzLFwiNzRcIjoxMTYsXCI3NVwiOjcwLFwiNzZcIjo3MCxcIjc3XCI6MzEsXCI3OFwiOjIxNixcIjc5XCI6MTkxLFwiODBcIjoxNTYsXCI4MVwiOjc3LFwiODJcIjoxMTcsXCI4M1wiOjEyNyxcIjg0XCI6NTYsXCI4NVwiOjksXCI4NlwiOjIxNCxcIjg3XCI6NjMsXCI4OFwiOjIxNyxcIjg5XCI6MTAzLFwiOTBcIjo3MCxcIjkxXCI6MjA5LFwiOTJcIjo0OCxcIjkzXCI6MTE4LFwiOTRcIjoyMTYsXCI5NVwiOjE5MSxcIjk2XCI6MzAsXCI5N1wiOjE0MCxcIjk4XCI6MjAsXCI5OVwiOjgzLFwiMTAwXCI6NDYsXCIxMDFcIjo0NSxcIjEwMlwiOjIxNixcIjEwM1wiOjE5MSxcIjEwNFwiOjE5MyxcIjEwNVwiOjgyLFwiMTA2XCI6MTg3LFwiMTA3XCI6MTM1LFwiMTA4XCI6MTU5LFwiMTA5XCI6MzMsXCIxMTBcIjoyMTcsXCIxMTFcIjo2MyxcIjExMlwiOjEyNCxcIjExM1wiOjI0MixcIjExNFwiOjk4LFwiMTE1XCI6OTUsXCIxMTZcIjoxNTUsXCIxMTdcIjo5OSxcIjExOFwiOjIwMSxcIjExOVwiOjYzLFwiMTIwXCI6MjMwLFwiMTIxXCI6MTYxLFwiMTIyXCI6MTg1LFwiMTIzXCI6NTAsXCIxMjRcIjoxNzEsXCIxMjVcIjo5LFwiMTI2XCI6MjI1LFwiMTI3XCI6NjMsXCJieXRlTGVuZ3RoXCI6MTI4fSxcImxlbmd0aFwiOjE2LFwiYnl0ZU9mZnNldFwiOjAsXCJieXRlTGVuZ3RoXCI6MTI4fX1dLFwiYmlhc2VzXCI6e1wic3hcIjoxLFwic3lcIjoxLFwiZGVwdGhcIjoyLFwid1wiOntcIjBcIjotMC4wNDI4NDk2NTEwNTQyMDQyNSxcIjFcIjowLjA0Mjg0OTY1MTA1NDIwNDIxLFwiQllURVNfUEVSX0VMRU1FTlRcIjo4LFwiYnVmZmVyXCI6e1wiMFwiOjE5MyxcIjFcIjoxMjMsXCIyXCI6MjE2LFwiM1wiOjE3OSxcIjRcIjo5OSxcIjVcIjoyNDAsXCI2XCI6MTY1LFwiN1wiOjE5MSxcIjhcIjoxODgsXCI5XCI6MTIzLFwiMTBcIjoyMTYsXCIxMVwiOjE3OSxcIjEyXCI6OTksXCIxM1wiOjI0MCxcIjE0XCI6MTY1LFwiMTVcIjo2MyxcImJ5dGVMZW5ndGhcIjoxNn0sXCJsZW5ndGhcIjoyLFwiYnl0ZU9mZnNldFwiOjAsXCJieXRlTGVuZ3RoXCI6MTZ9fX0se1wib3V0X2RlcHRoXCI6MixcIm91dF9zeFwiOjEsXCJvdXRfc3lcIjoxLFwibGF5ZXJfdHlwZVwiOlwic29mdG1heFwiLFwibnVtX2lucHV0c1wiOjJ9XX07XG4iLCIjIFVzZXJWaWV3IChTaW5nbGV0b24pXG5cbiQgPSByZXF1aXJlKCdqcXVlcnknKVxuQVYgPSB3aW5kb3cuQVZcbkRpYWxvZ1ZpZXcgPSByZXF1aXJlKCcuL2RpYWxvZy12aWV3LmNvZmZlZScpXG5cbmNsYXNzIFVzZXJWaWV3XG5cbiAgICBjb25zdHJ1Y3RvcjogLT5cbiAgICAgICAgaWYgVXNlclZpZXcuaW5zdGFuY2VcbiAgICAgICAgICAgIHJldHVybiBVc2VyVmlldy5pbnN0YW5jZVxuICAgICAgICBVc2VyVmlldy5pbnN0YW5jZSA9IHRoaXNcbiAgICAgICAgQHVwZGF0ZU5hdigpXG4gICAgICAgIEBiaW5kIEFWXG5cbiAgICB1cGRhdGVOYXY6IC0+XG4gICAgICAgIHVzZXIgPSBBVi5Vc2VyLmN1cnJlbnQoKVxuICAgICAgICBpZiB1c2VyP1xuICAgICAgICAgICAgaHRtbCA9IFwiPGxpPlwiICsgdXNlci5hdHRyaWJ1dGVzLnVzZXJuYW1lICsgXCI8L2xpPlwiXG4gICAgICAgICAgICBodG1sICs9ICc8bGkgaWQ9XCJsb2dvdXRcIj5Mb2dvdXQ8L2xpPidcbiAgICAgICAgICAgICQoJyNuYXYtZmF2b3JpdGUnKS5zaG93KClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaHRtbCA9IFwiXCJcIjxsaSBpZD1cImxvZ2luLWJ1dHRvblwiPkxvZ2luPC9saT48bGkgaWQ9XCJzaWdudXAtYnV0dG9uXCI+U2lnbnVwPC9saT5cIlwiXCJcbiAgICAgICAgICAgICQoJyNuYXYtZmF2b3JpdGUnKS5oaWRlKClcbiAgICAgICAgJCgnI3VzZXInKS5odG1sIFwiPHVsPlwiICsgaHRtbCArIFwiPC91bD5cIlxuXG4gICAgZGlzcGxheUxvZ2luVmlldzogLT5cbiAgICAgICAgaHRtbCA9IFwiXCJcIlxuICAgICAgICAgICAgPGRpdiBpZD1cImxvZ2luXCI+XG4gICAgICAgICAgICAgICAgPGgyPkxvZ2luPC9oMj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIlVzZXJuYW1lXCIgY2xhc3M9XCJ1c2VybmFtZVwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIiBwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCIgY2xhc3M9XCJwYXNzd29yZFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdWJtaXRcIj5Mb2dpbjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJyZXNldC1wYXNzd29yZC1idXR0b25cIj5Gb3Jnb3QgcGFzc3dvcmQ/PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgXCJcIlwiXG5cbiAgICAgICAgJHZpZXcgPSAkKGh0bWwpXG4gICAgICAgICR2aWV3LmZpbmQoJyNyZXNldC1wYXNzd29yZC1idXR0b24nKS5jbGljayA9PiBAZGlzcGxheVBhc3N3b3JkUmVzZXRWaWV3KClcblxuICAgICAgICBkaWFsb2dWaWV3ID0gbmV3IERpYWxvZ1ZpZXcoJHZpZXcpXG5cbiAgICAgICAgJHZpZXcuZmluZCgnLnN1Ym1pdCcpLmNsaWNrID0+XG5cbiAgICAgICAgICAgIHVzZXIgPSBuZXcgQVYuVXNlcigpXG5cbiAgICAgICAgICAgIHVzZXJuYW1lID0gJHZpZXcuZmluZCgnLnVzZXJuYW1lJykudmFsKClcbiAgICAgICAgICAgIHBhc3N3b3JkID0gJHZpZXcuZmluZCgnLnBhc3N3b3JkJykudmFsKClcblxuICAgICAgICAgICAgJHRoaXMgPSAkKHRoaXMpXG5cbiAgICAgICAgICAgIGhhbmRsZXIgPVxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6ICh1c2VyKSA9PlxuICAgICAgICAgICAgICAgICAgICBAdXBkYXRlTmF2KClcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nVmlldy5oaWRlKClcbiAgICAgICAgICAgICAgICBlcnJvcjogKHVzZXIsIGVycm9yKSAtPlxuICAgICAgICAgICAgICAgICAgICBhbGVydChcIkVycm9yOiBcIiArIGVycm9yLmNvZGUgKyBcIiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgQVYuVXNlci5sb2dJbiB1c2VybmFtZSwgcGFzc3dvcmQsIGhhbmRsZXJcblxuICAgIGRpc3BsYXlTaWdudXBWaWV3OiAtPlxuXG4gICAgICAgIGh0bWwgPSBcIlwiXCJcbiAgICAgICAgICAgIDxkaXYgaWQ9XCJzaWdudXBcIj5cbiAgICAgICAgICAgICAgICA8aDI+U2lnbiBVcDwvaDI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJVc2VybmFtZVwiIGNsYXNzPVwidXNlcm5hbWVcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgcGxhY2Vob2xkZXI9XCJQYXNzd29yZFwiIGNsYXNzPVwicGFzc3dvcmRcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImVtYWlsXCIgcGxhY2Vob2xkZXI9XCJFbWFpbFwiIGNsYXNzPVwiZW1haWxcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3VibWl0XCI+U3VibWl0PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgXCJcIlwiXG5cbiAgICAgICAgJHZpZXcgPSAkKGh0bWwpXG5cbiAgICAgICAgZGlhbG9nVmlldyA9IG5ldyBEaWFsb2dWaWV3KCR2aWV3KVxuXG4gICAgICAgICR2aWV3LmZpbmQoJy5zdWJtaXQnKS5jbGljayA9PlxuXG4gICAgICAgICAgICB1c2VyID0gbmV3IEFWLlVzZXIoKVxuXG4gICAgICAgICAgICB1c2VybmFtZSA9ICR2aWV3LmZpbmQoJy51c2VybmFtZScpLnZhbCgpXG4gICAgICAgICAgICBwYXNzd29yZCA9ICR2aWV3LmZpbmQoJy5wYXNzd29yZCcpLnZhbCgpXG4gICAgICAgICAgICBlbWFpbCA9ICR2aWV3LmZpbmQoJy5lbWFpbCcpLnZhbCgpXG5cbiAgICAgICAgICAgIHVzZXIuc2V0KFwidXNlcm5hbWVcIiwgdXNlcm5hbWUpO1xuICAgICAgICAgICAgdXNlci5zZXQoXCJwYXNzd29yZFwiLCBwYXNzd29yZCk7XG4gICAgICAgICAgICB1c2VyLnNldChcImVtYWlsXCIsIGVtYWlsKTtcblxuICAgICAgICAgICAgaGFuZGxlciA9XG4gICAgICAgICAgICAgICAgc3VjY2VzczogKHVzZXIpID0+XG4gICAgICAgICAgICAgICAgICAgIEB1cGRhdGVOYXYoKVxuICAgICAgICAgICAgICAgICAgICBkaWFsb2dWaWV3LmhpZGUoKVxuICAgICAgICAgICAgICAgIGVycm9yOiAodXNlciwgZXJyb3IpIC0+XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiRXJyb3I6IFwiICsgZXJyb3IuY29kZSArIFwiIFwiICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB1c2VyLnNpZ25VcCBudWxsLCBoYW5kbGVyXG5cbiAgICBkaXNwbGF5UGFzc3dvcmRSZXNldFZpZXc6IC0+XG5cbiAgICAgICAgaHRtbCA9IFwiXCJcIlxuICAgICAgICAgICAgPGRpdiBpZD1cInBhc3N3b3JkLXJlc2V0XCI+XG4gICAgICAgICAgICAgICAgPGgyPlJlc2V0IFBhc3N3b3JkPC9oMj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImVtYWlsXCIgcGxhY2Vob2xkZXI9XCJFbWFpbFwiIGNsYXNzPVwiZW1haWxcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3VibWl0XCI+UmVzZXQ8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBcIlwiXCJcblxuICAgICAgICAkdmlldyA9ICQoaHRtbClcblxuICAgICAgICBkaWFsb2dWaWV3ID0gbmV3IERpYWxvZ1ZpZXcoJHZpZXcpXG5cbiAgICAgICAgJHZpZXcuZmluZCgnLnN1Ym1pdCcpLmNsaWNrIC0+XG4gICAgICAgICAgICBlbWFpbD0kKCcjcGFzc3dvcmQtcmVzZXQgLmVtYWlsJykudmFsKClcbiAgICAgICAgICAgIGhhbmRsZXIgPVxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IC0+XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZ1ZpZXcuaGlkZSgpXG4gICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvcikgLT5cbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJFcnJvcjogXCIgKyBlcnJvci5jb2RlICsgXCIgXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIEFWLlVzZXIucmVxdWVzdFBhc3N3b3JkUmVzZXQgZW1haWwsIGhhbmRsZXJcblxuICAgIGJpbmQ6IChBVikgLT5cbiAgICAgICAgJCgnI3VzZXInKS5vbiAnY2xpY2snLCAnI2xvZ2luLWJ1dHRvbicsID0+IEBkaXNwbGF5TG9naW5WaWV3KClcbiAgICAgICAgJCgnI3VzZXInKS5vbiAnY2xpY2snLCAnI3NpZ251cC1idXR0b24nLCA9PiBAZGlzcGxheVNpZ251cFZpZXcoKVxuICAgICAgICAkKCcjdXNlcicpLm9uICdjbGljaycsICcjbG9nb3V0JywgLT5cbiAgICAgICAgICAgIEFWLlVzZXIubG9nT3V0KClcbiAgICAgICAgICAgIHNlbGYudXBkYXRlTmF2KClcblxubW9kdWxlLmV4cG9ydHMgPSBVc2VyVmlld1xuIiwiU2NoZW1lc1ZpZXcgPSByZXF1aXJlKCcuL3NjaGVtZXMtdmlldy5jb2ZmZWUnKVxuJCA9IHJlcXVpcmUoJ2pxdWVyeScpXG5BViA9IHdpbmRvdy5BVlxuXG5jbGFzcyBFeHBsb3JlVmlld1xuXG4gICAgY29uc3RydWN0b3I6IC0+XG4gICAgICAgIFNjaGVtZSA9IEFWLk9iamVjdC5leHRlbmQoJ1NjaGVtZScpXG4gICAgICAgIHF1ZXJ5ID0gbmV3IEFWLlF1ZXJ5KFNjaGVtZSlcbiAgICAgICAgcXVlcnkuZXF1YWxUbygnc2NvcmUnLCAxKVxuICAgICAgICBxdWVyeS5saW1pdCgxMDApLmZpbmQge1xuICAgICAgICAgICAgc3VjY2VzczogKHNjaGVtZXMpIC0+XG4gICAgICAgICAgICAgICAgc2NoZW1lcyA9IHNjaGVtZXMubWFwIChzY2hlbWUpIC0+XG4gICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2Ugc2NoZW1lLmF0dHJpYnV0ZXMuY29sb3JzXG4gICAgICAgICAgICAgICAgbmV3IFNjaGVtZXNWaWV3KHNjaGVtZXMpXG4gICAgICAgICAgICAgICAgJCgnI2ltYWdlJykuaGlkZSgpXG4gICAgICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBFeHBsb3JlVmlld1xuIiwiU2NoZW1lc1ZpZXcgPSByZXF1aXJlKCcuL3NjaGVtZXMtdmlldy5jb2ZmZWUnKVxuJCA9IHJlcXVpcmUoJ2pxdWVyeScpXG5BViA9IHdpbmRvdy5BVlxuXG5jbGFzcyBGYXZvcml0ZVZpZXdcblxuICAgIGNvbnN0cnVjdG9yOiAtPlxuICAgICAgICB1c2VyID0gQVYuVXNlci5jdXJyZW50KClcbiAgICAgICAgaWYgdXNlclxuICAgICAgICAgICAgdXNlcm5hbWUgPSB1c2VyLmF0dHJpYnV0ZXMudXNlcm5hbWVcbiAgICAgICAgICAgIFNjaGVtZSA9IEFWLk9iamVjdC5leHRlbmQoXCJTY2hlbWVcIilcbiAgICAgICAgICAgIHF1ZXJ5ID0gbmV3IEFWLlF1ZXJ5KFNjaGVtZSlcbiAgICAgICAgICAgIHF1ZXJ5LmRlc2NlbmRpbmcoXCJ1cGRhdGVkQXRcIik7XG4gICAgICAgICAgICBxdWVyeS5lcXVhbFRvKFwib3duZXJcIiwgdXNlcm5hbWUpXG4gICAgICAgICAgICBxdWVyeS5lcXVhbFRvKFwic2NvcmVcIiwgMSlcbiAgICAgICAgICAgIHF1ZXJ5LmxpbWl0KDEwMCkuZmluZCB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogKHNjaGVtZXMpIC0+XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtZXMgPSBzY2hlbWVzLm1hcCAoc2NoZW1lKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZSBzY2hlbWUuYXR0cmlidXRlcy5jb2xvcnNcbiAgICAgICAgICAgICAgICAgICAgbmV3IFNjaGVtZXNWaWV3KHNjaGVtZXMsIHNjb3JlID0gMSlcbiAgICAgICAgICAgICAgICAgICAgJCgnI2ltYWdlJykuaGlkZSgpXG4gICAgICAgICAgICB9XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGYXZvcml0ZVZpZXdcbiIsImNvbG9yc0NsdXN0ZXJpbmcgPSByZXF1aXJlIFwiY29sb3JzLWNsdXN0ZXJpbmdcIlxuR2VuZVBvb2wgPSByZXF1aXJlICdnZW5lLXBvb2wnXG5maXRuZXNzID0gcmVxdWlyZSAnLi4vZml0bmVzcy5jb2ZmZWUnXG4kID0gcmVxdWlyZSAnanF1ZXJ5J1xuXG5TY2hlbWVzVmlldyA9IHJlcXVpcmUoJy4vc2NoZW1lcy12aWV3LmNvZmZlZScpXG5cbnBhcnNlSW1hZ2UgPSAodXJsKSAtPlxuICAgIGNvbmZpZyA9XG4gICAgICAgIHNyYzogdXJsXG4gICAgICAgIG1pbkNvdW50OiA3XG5cbiAgICBkaXNwbGF5Q29sb3JzID0gKGNsdXN0ZXJzKSAtPlxuICAgICAgICBodG1sID0gY2x1c3RlcnMubWFwIChjbHVzdGVyKSAtPlxuICAgICAgICAgICAgY29sb3IgPSBjbHVzdGVyLmNvbG9yXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2NvbG9yJyBzdHlsZT0nYmFja2dyb3VuZDogcmdiKCN7Y29sb3Iuam9pbignLCcpfSknPjwvZGl2PlwiXG4gICAgICAgIGh0bWwgPSBcIjxkaXYgY2xhc3M9J2NvbG9ycyc+I3todG1sLmpvaW4oJycpfTwvZGl2PlwiXG4gICAgICAgICQoXCIjY29sb3JzXCIpLmh0bWwgaHRtbFxuXG4gICAgY29sb3JzQ2x1c3RlcmluZyBjb25maWcsIChjbHVzdGVycykgLT5cbiAgICAgICAgY2x1c3RlcnMuc29ydCAoYSwgYikgLT4gYi53ZWlnaHQgLSBhLndlaWdodFxuICAgICAgICBkaXNwbGF5Q29sb3JzIGNsdXN0ZXJzXG4gICAgICAgIG9wdHMgPVxuICAgICAgICAgICAgZ2VuZXM6IGNsdXN0ZXJzLm1hcCAoY29sb3IpIC0+IGNvbG9yLmNvbG9yXG4gICAgICAgICAgICB3ZWlnaHRzOiBjbHVzdGVycy5tYXAgKGNvbG9yKSAtPiBjb2xvci53ZWlnaHRcbiAgICAgICAgICAgIEs6IDIwXG4gICAgICAgICAgICBOOiA1XG4gICAgICAgICAgICBtdXRhdGlvblJhdGU6IDAuMlxuICAgICAgICAgICAgYmlydGhSYXRlOiAxXG4gICAgICAgICAgICBmaXRuZXNzOiBmaXRuZXNzXG4gICAgICAgIGNvbG9yU2NoZW1lcyA9IG5ldyBHZW5lUG9vbChvcHRzKVxuICAgICAgICBjb2xvclNjaGVtZXMudGltZW91dCA4MDAsIChlcnIsIHNjaGVtZXMpIC0+XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycikgaWYgZXJyXG4gICAgICAgICAgICBuZXcgU2NoZW1lc1ZpZXcoc2NoZW1lcylcbiAgICAkKCcjaW1hZ2UnKS5jc3Mge2JhY2tncm91bmRJbWFnZTogXCJ1cmwoI3t1cmx9KVwifVxuXG5jbGFzcyBJbWFnZVZpZXdcbiAgICBjb25zdHJ1Y3RvcjogKHVybCA9ICcuL3N0YXRpYy9pbWFnZXMvZGVmYXVsdC5qcGcnKSAtPlxuICAgICAgICAjIHNob3cgI2ltYWdlXG4gICAgICAgICQoJyNpbWFnZScpLnNob3coKVxuXG4gICAgICAgICMgcGFyc2UgJiBzaG93IHNjaGVtZXNcbiAgICAgICAgcGFyc2VJbWFnZSB1cmxcblxuICAgICAgICAjIGJpbmQgRE5EIGV2ZW50c1xuICAgICAgICB0YXJnZXQgPSAkKCcjaW1hZ2UnKVswXVxuICAgICAgICB0YXJnZXQub25kcmFnb3ZlciA9IChldmVudCkgLT4gZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0YXJnZXQub25kcmFnZW5kID0gKGV2ZW50KSAtPiBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHRhcmdldC5vbmRyYWdlbnRlciA9IChldmVudCkgLT4gZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0YXJnZXQub25kcmFnbGVhdmUgPSAoZXZlbnQpIC0+IGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdGFyZ2V0Lm9uZHJhZyA9IChldmVudCkgLT4gZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0YXJnZXQub25kcm9wID0gKGV2ZW50KSAtPlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChldmVudC5kYXRhVHJhbnNmZXIuZmlsZXNbMF0pXG4gICAgICAgICAgICBwYXJzZUltYWdlIHVybFxuICAgICAgICAkKCcjbG9hZC1pbWFnZScpLm9uICdjbGljaycsIC0+XG4gICAgICAgICAgICAkaW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cImZpbGVcIj4nKVxuICAgICAgICAgICAgJCgnYm9keScpLmFwcGVuZCAkaW5wdXRcbiAgICAgICAgICAgICRpbnB1dC5vbiAnY2hhbmdlJywgKGUpIC0+XG4gICAgICAgICAgICAgICAgZmlsZXMgPSAkaW5wdXRbMF0uZmlsZXNcbiAgICAgICAgICAgICAgICBpZiBmaWxlc1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGVzWzBdKVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUltYWdlIHVybFxuICAgICAgICAgICAgICAgICAgICAkaW5wdXQucmVtb3ZlKClcbiAgICAgICAgICAgICRpbnB1dC5jbGljaygpXG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VWaWV3XG4iLCIvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2h5cG90XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5oeXBvdCB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IEluZmluaXR5IHx8IGFyZ3VtZW50c1tpXSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgeSArPSBhcmd1bWVudHNbaV0gKiBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnNxcnQoeSk7XG59O1xuIiwiIyBzY2hlbWVzIHNob3VsZCBiZSBhcnJheSBvZiBbciwgZywgYl1cbmdlbmVyYXRlID0gKG5hbWUsIHNjaGVtZXMpIC0+XG4gICAgZ3BsID0gXCJcIlwiR0lNUCBQYWxldHRlXG5OYW1lOiAje25hbWV9XG4jXCJcIlwiXG4gICAgZ3BsICs9ICdcXG4nXG4gICAgc2NoZW1lcy5mb3JFYWNoIChzY2hlbWUpIC0+XG4gICAgICAgIGdwbCArPSBzY2hlbWUuam9pbiAnICdcbiAgICAgICAgZ3BsICs9ICdcXG4nXG4gICAgZ3BsXG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVcbiIsIiQgPSByZXF1aXJlICdqcXVlcnknXG5cbmNsYXNzIERpYWxvZ1ZpZXdcblxuICAgIGNvbnN0cnVjdG9yOiAoJGNoaWxkcmVuKSAtPlxuICAgICAgICAkdmlldyA9ICQoJyNkaWFsb2cnKVxuICAgICAgICAkdmlldy5odG1sICcnXG4gICAgICAgICR2aWV3LmFwcGVuZCAkY2hpbGRyZW5cblxuICAgICAgICB1bmxlc3MgRGlhbG9nVmlldy5ib3VuZFxuICAgICAgICAgICAgQGJpbmQoKVxuICAgICAgICAgICAgRGlhbG9nVmlldy5ib3VuZCA9IHRydWVcblxuICAgICAgICAkdmlldy5mYWRlSW4oKVxuXG4gICAgYmluZDogLT5cbiAgICAgICAgIyBFU0MgdG8gZXhpdFxuICAgICAgICAkKGRvY3VtZW50KS5vbiAna2V5ZG93bicsIChlKSA9PlxuICAgICAgICAgICAgQGhpZGUoKSBpZiBlLmtleUNvZGUgaXMgMjdcblxuICAgICAgICAkdmlldyA9ICQoJyNkaWFsb2cnKVxuICAgICAgICAkdmlldy5vbiAnY2xpY2snLCAoZSkgPT5cbiAgICAgICAgICAgIEBoaWRlKCkgaWYgZS50YXJnZXQuaWQgaXMgJ2RpYWxvZydcblxuICAgIGhpZGU6IC0+XG4gICAgICAgICQoJyNkaWFsb2cnKS5mYWRlT3V0KClcblxubW9kdWxlLmV4cG9ydHMgPSBEaWFsb2dWaWV3XG4iLCJ2YXIgR2VuZVBvb2wgPSByZXF1aXJlKCcuL2dlbmUtcG9vbCcpO1xuXG4vLyBOOiDkuKrkvZPln7rlm6DmlbBcbi8vIEs6IOenjee+pOinhOaooe+8iOenjee+pOeos+WumuaXtueahOaVsOmHj++8iVxuLy8gZ2VuZXM6IOWfuuWboFxuLy8gd2VpZ2h0czog5Z+65Zug5p2D6YeN77yM5b2x5ZON5Ye6546w55qE5Y+v6IO95oCn5aSn5bCPXG4vLyBtdXRhdGlvblJhdGU6IOWfuuWboOeqgeWPmOeOh++8jOWkp+e6puacieWkmuWwkeavlOS+i+eahOWfuuWboOmcgOimgeeqgeWPmFxuLy8gYmlydGhSYXRlOiDlh7rnlJ/njodcblxuLy8gdGltZW91dDog5pyA5aSn5pe26ZmQXG5cbmZ1bmN0aW9uIFBvcHVsYXRpb24ob3B0cykge1xuXG4gICAgLy8gYWxsb3cgdXNlIG9iamVjdCBmb3IgZ2VuZVxuICAgIHZhciBnZW5lcyA9IG9wdHMuZ2VuZXMubWFwKGZ1bmN0aW9uKGdlbmUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9KTtcbiAgICB0aGlzLm9yaUdlbmVzID0gb3B0cy5nZW5lcztcbiAgICB0aGlzLmZpdG5lc3MgPSBmdW5jdGlvbihpbmRpdmlkdWFsKSB7XG4gICAgICAgIGluZGl2aWR1YWwgPSBpbmRpdmlkdWFsLm1hcChmdW5jdGlvbihnZW5lSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRzLmdlbmVzW2dlbmVJbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0cy5maXRuZXNzKGluZGl2aWR1YWwpO1xuICAgIH07XG5cbiAgICB0aGlzLmdlbmVQb29sID0gR2VuZVBvb2woZ2VuZXMsIG9wdHMuTiwgb3B0cy53ZWlnaHRzKTtcbiAgICB0aGlzLksgPSBvcHRzLks7XG4gICAgdGhpcy5OID0gb3B0cy5OO1xuICAgIC8vIHRoZSB2ZXJ5IGZpcnN0IGdlbmVyYXRpb25cbiAgICB0aGlzLnBvcHVsYXRpb24gPSBbXTtcbiAgICB0aGlzLmhpc3RvcnkgPSB7fTsgLy8g6K6w5L2P5Lqn55Sf6L+H55qE5Liq5L2TXG5cbiAgICAvLyDpu5jorqTlsJ3or5UxMDAw5qyh5LuN5peg5paw57uT5p6c5YiZ5Y+W5raI5bCd6K+VXG4gICAgdGhpcy5tYXhMb29wID0gb3B0cy5tYXhMb29wIHx8IDEwMDA7XG5cbiAgICB0aGlzLmJpcnRoUmF0ZSA9IG9wdHMuYmlydGhSYXRlO1xuICAgIHRoaXMubXV0YXRpb25SYXRlID0gb3B0cy5tdXRhdGlvblJhdGU7XG59XG5cbnZhciBwb3B1bGF0aW9uID0gUG9wdWxhdGlvbi5wcm90b3R5cGU7XG5cbi8vIOe5geaullxucG9wdWxhdGlvbi5yZXByb2R1Y2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hpbGQsXG4gICAgICAgIGdlbmU7XG5cbiAgICB2YXIgbWF4TG9vcCA9IHRoaXMubWF4TG9vcDtcblxuICAgIC8vIOWIneS7o+WfuuWboOaAu+aYr+eUseeqgeWPmOS6p+eUn1xuICAgIHZhciBtdXRhdGlvblJhdGUgPSB0aGlzLnBvcHVsYXRpb24ubGVuZ3RoID4gMCA/IHRoaXMubXV0YXRpb25SYXRlIDogMjtcblxuICAgIHdoaWxlKHRoaXMucG9wdWxhdGlvbi5sZW5ndGggPCB0aGlzLksgKiAoMSArIHRoaXMuYmlydGhSYXRlKSkge1xuICAgICAgICBpZihtYXhMb29wIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsIHRvIGdldCBuZXcgaW5kaXZpZHVhbDogZXhjZWVkcyB0aGUgbWF4TG9vcCwgb3B0cy5tYXhMb29wPScgKyB0aGlzLm1heExvb3ApO1xuICAgICAgICB9XG4gICAgICAgIG1heExvb3AtLTtcbiAgICAgICAgY2hpbGQgPSBbXTtcbiAgICAgICAgd2hpbGUoY2hpbGQubGVuZ3RoIDwgdGhpcy5OKSB7XG4gICAgICAgICAgICBpZihNYXRoLnJhbmRvbSgpIDwgbXV0YXRpb25SYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8g5Z+65Zug56qB5Y+YXG4gICAgICAgICAgICAgICAgZ2VuZSA9IHRoaXMuZ2VuZVBvb2wuZ2V0UmFuZG9tR2VuZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyDku47lvZPliY3np43nvqTph4zojrflj5bln7rlm6BcbiAgICAgICAgICAgICAgICBnZW5lID0gdGhpcy5nZXRSYW5kb21HZW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihjaGlsZC5pbmRleE9mKGdlbmUpIDwgMCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnB1c2goZ2VuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJ5IHRvIGFkZCBjaGlsZFxuICAgICAgICBjaGlsZC5zb3J0KCk7XG4gICAgICAgIHZhciBpZCA9IEpTT04uc3RyaW5naWZ5KGNoaWxkKTtcbiAgICAgICAgaWYoIXRoaXMuaGlzdG9yeVtpZF0pIHtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVtpZF0gPSAxO1xuICAgICAgICAgICAgdGhpcy5wb3B1bGF0aW9uLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8g5Lq65bel5a6a5ZCR6YCJ5oupXG5wb3B1bGF0aW9uLnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFNvcnQgYnkgZml0bmVzc1xuICAgIHZhciBmaXRuZXNzID0gdGhpcy5wb3B1bGF0aW9uLm1hcChmdW5jdGlvbihpbmRpdmlkdWFsLCBpKSB7XG4gICAgICAgIHJldHVybiB7aW5kZXg6IGksIGZpdG5lc3M6IHNlbGYuZml0bmVzcyhpbmRpdmlkdWFsKX07XG4gICAgfSkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmZpdG5lc3MgLSBhLmZpdG5lc3M7XG4gICAgfSk7XG5cbiAgICB2YXIgcG9wdWxhdGlvbiA9IGZpdG5lc3MubWFwKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucG9wdWxhdGlvbltlbGVtLmluZGV4XTtcbiAgICB9KTtcblxuICAgIC8vIGtpbGwgd2Vha2VyIGludmlkaWR1YWxzXG4gICAgd2hpbGUocG9wdWxhdGlvbi5sZW5ndGggPiB0aGlzLkspIHtcbiAgICAgICAgcG9wdWxhdGlvbi5wb3AoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBvcHVsYXRpb24gPSBwb3B1bGF0aW9uO1xufTtcblxuLy8g5LuO5b2T5YmN56eN576k5Lit6ZqP5py66I635Y+W5Z+65ZugXG5wb3B1bGF0aW9uLmdldFJhbmRvbUdlbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmFuZG9tID0gTWF0aC5yYW5kb20oKTtcbiAgICAvLyDpmo/mnLrpgInmi6nvvIzotorpnaDliY3vvIhmaXRuZXNz6L6D6auY77yJ55qE5Z+65Zug5pyJ6L6D5aSn5qaC546H5b6X5Yiw6YGX5LygXG4gICAgdmFyIGluZGl2aWR1YWwgPSB0aGlzLnBvcHVsYXRpb25bKHJhbmRvbSAqIHJhbmRvbSAqIHRoaXMucG9wdWxhdGlvbi5sZW5ndGgpIHwgMF07IFxuICAgIHJldHVybiBpbmRpdmlkdWFsWyh0aGlzLk4gKiByYW5kb20pIHwgMF07XG59O1xuXG4vLyDkuIvkuIDku6NcbnBvcHVsYXRpb24ubmV4dCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8g5YWI57mB5q6WXG4gICAgdGhpcy5yZXByb2R1Y2UoKTtcblxuICAgIC8vIOWumuWQkemAieaLqVxuICAgIHRoaXMuc2VsZWN0KCk7XG5cbn07XG5cbnBvcHVsYXRpb24udG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnZW5lcyA9IHRoaXMub3JpR2VuZXM7XG4gICAgcmV0dXJuIHRoaXMucG9wdWxhdGlvbi5tYXAoZnVuY3Rpb24oaW5kaXZpZHVhbCkge1xuICAgICAgICByZXR1cm4gaW5kaXZpZHVhbC5tYXAoZnVuY3Rpb24oZ2VuZUluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXNbZ2VuZUluZGV4XTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5wb3B1bGF0aW9uLnRpbWVvdXQgPSBmdW5jdGlvbih0aW1lb3V0LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZW5kID0gRGF0ZS5ub3coKSArIHRpbWVvdXQ7XG4gICAgdmFyIGl0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoRGF0ZS5ub3coKSA8IGVuZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZWxmLm5leHQoKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGl0ZXIsIDEpO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBzZWxmLnRvQXJyYXkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBzZWxmLnRvQXJyYXkoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGl0ZXIoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9wdWxhdGlvbjtcbiIsIkFWID0gd2luZG93LkFWXG4kID0gcmVxdWlyZSgnanF1ZXJ5JylcbkRldGFpbFZpZXcgPSByZXF1aXJlKCcuL2RldGFpbC12aWV3LmNvZmZlZScpXG5cbmdldFNjb3JlID0gKCRzY2hlbWUpIC0+XG4gICAgaWYgJHNjaGVtZS5maW5kKCcuZmEtaGVhcnQtbycpLmhhc0NsYXNzICdzZWxlY3RlZCdcbiAgICAgICAgMVxuICAgIGVsc2UgaWYgJHNjaGVtZS5maW5kKCcuZmEtdHJhc2gtbycpLmhhc0NsYXNzICdzZWxlY3RlZCdcbiAgICAgICAgLTFcbiAgICBlbHNlXG4gICAgICAgIDBcblxuc2V0U2NvcmUgPSAoJHNjaGVtZSwgc2NvcmUpIC0+XG5cbiAgICBjb2xvcnMgPSAkc2NoZW1lLmRhdGEoJ3NjaGVtZScpXG4gICAgY29sb3JzLnNvcnQgKGEsIGIpIC0+XG4gICAgICAgIGEuc29tZSAoZWxlbSwgaW5kZXgpIC0+IGVsZW0gPiBiW2luZGV4XVxuICAgIGxlbmd0aCA9IGNvbG9ycy5sZW5ndGhcbiAgICBjb2xvcnMgPSBKU09OLnN0cmluZ2lmeShjb2xvcnMpXG4gICAgdXNlciA9IEFWLlVzZXIuY3VycmVudCgpXG5cbiAgICB1bmxlc3MgdXNlclxuICAgICAgICAkKCcjbG9naW4tYnV0dG9uJykuY2xpY2soKVxuICAgICAgICByZXR1cm5cblxuICAgICRzY2hlbWUuZmluZCgnLmZhLWhlYXJ0LW8nKS50b2dnbGVDbGFzcygnc2VsZWN0ZWQnLCBzY29yZSA+IDApXG4gICAgJHNjaGVtZS5maW5kKCcuZmEtdHJhc2gtbycpLnRvZ2dsZUNsYXNzKCdzZWxlY3RlZCcsIHNjb3JlIDwgMClcblxuICAgIHVzZXJuYW1lID0gIHVzZXIuYXR0cmlidXRlcy51c2VybmFtZVxuXG4gICAgU2NoZW1lID0gQVYuT2JqZWN0LmV4dGVuZChcIlNjaGVtZVwiKVxuXG4gICAgcXVlcnkgPSBuZXcgQVYuUXVlcnkoU2NoZW1lKVxuICAgIHF1ZXJ5LmVxdWFsVG8oXCJjb2xvcnNcIiwgY29sb3JzKVxuICAgIHF1ZXJ5LmVxdWFsVG8oXCJvd25lclwiLCB1c2VybmFtZSlcbiAgICBxdWVyeS5maW5kKHtcbiAgICAgICAgc3VjY2VzczogKHJlY29yZCkgLT5cbiAgICAgICAgICAgIGlmIHJlY29yZC5sZW5ndGggaXMgMFxuICAgICAgICAgICAgICAgIHNjaGVtZSA9IG5ldyBTY2hlbWUoKVxuXG4gICAgICAgICAgICAgICAgc2NoZW1lLnNldCAnY29sb3JzJywgY29sb3JzXG4gICAgICAgICAgICAgICAgc2NoZW1lLnNldCAnbGVuZ3RoJywgbGVuZ3RoXG4gICAgICAgICAgICAgICAgc2NoZW1lLnNldCAnc2NvcmUnLCBzY29yZVxuXG4gICAgICAgICAgICAgICAgc2NoZW1lLnNldCAnb3duZXInLCB1c2VybmFtZVxuICAgICAgICAgICAgICAgIEFDTCA9IG5ldyBBVi5BQ0woQVYuVXNlci5jdXJyZW50KCkpXG4gICAgICAgICAgICAgICAgQUNMLnNldFB1YmxpY1JlYWRBY2Nlc3ModHJ1ZSlcbiAgICAgICAgICAgICAgICBzY2hlbWUuc2V0QUNMKEFDTClcbiAgICAgICAgICAgICAgICBzY2hlbWUuc2F2ZSgpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgIyBhbHJlYWR5IGV4aXRzLCB1cGRhdGUgaXRcbiAgICAgICAgICAgICAgICBzY2hlbWUgPSByZWNvcmRbMF1cbiAgICAgICAgICAgICAgICBzY2hlbWUuc2V0ICdzY29yZScsIHNjb3JlXG4gICAgICAgICAgICAgICAgc2NoZW1lLnNhdmUoKVxuICAgIH0pXG5cbmNsYXNzIFNjaGVtZXNWaWV3XG5cbiAgICBjb25zdHJ1Y3RvcjogKHNjaGVtZXMsIEBzY29yZSA9IDApIC0+XG4gICAgICAgICRjb250YWluZXIgPSAkKCcjc2NoZW1lcycpXG4gICAgICAgICRjb250YWluZXIuaHRtbCAnJ1xuICAgICAgICAkY29udGFpbmVyLmFwcGVuZCBAZ2VuZXJhdGUoc2NoZW1lcylcblxuICAgIGdlbmVyYXRlOiAoc2NoZW1lcykgLT5cbiAgICAgICAgc2NoZW1lcy5tYXAgKGNvbG9ycykgPT4gQGdlbmVyYXRlU2NoZW1lKGNvbG9ycylcblxuICAgICMgQHJldHVybiBBcnJheSBvZiBqUXVlcnkgT2JqZWN0c1xuICAgIGdlbmVyYXRlU2NoZW1lOiAoY29sb3JzKSAtPlxuICAgICAgICAjIHNvcnQgY29sb3JzXG4gICAgICAgIGNvbG9ycy5zb3J0IChhLCBiKSAtPlxuICAgICAgICAgICAgYS5zb21lIChlbGVtLCBpbmRleCkgLT4gZWxlbSA+IGJbaW5kZXhdXG5cbiAgICAgICAgY29sb3JzSFRNTCA9IGNvbG9ycy5tYXAgKGNvbG9yKSAtPiBcIjxkaXYgY2xhc3M9J2NvbG9yJyBzdHlsZT0nYmFja2dyb3VuZDogcmdiKCN7Y29sb3Iuam9pbignLCcpfSknPjwvZGl2PlwiXG4gICAgICAgIGh0bWwgPSBcIjxkaXYgY2xhc3M9J3NjaGVtZScgZGF0YS1zY2hlbWU9JyN7SlNPTi5zdHJpbmdpZnkoY29sb3JzKX0nPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz0nY29sb3JzJz4je2NvbG9yc0hUTUwuam9pbignJyl9PC9kaXY+XG4gICAgICAgICAgICA8aSBjbGFzcz0nZmEgZmEtZG93bmxvYWQgZGV0YWlsIGJ1dHRvbic+PC9pPlxuICAgICAgICAgICAgPGkgY2xhc3M9J2ZhIGZhLWhlYXJ0LW8gYnV0dG9uJz48L2k+XG4gICAgICAgICAgICA8aSBjbGFzcz0nZmEgZmEtdHJhc2gtbyBidXR0b24nPjwvaT48L2Rpdj5cIlxuICAgICAgICAkc2NoZW1lID0gJChodG1sKVxuXG4gICAgICAgICMgYXBwbHkgc2NvcmVcbiAgICAgICAgJHNjaGVtZS5maW5kKCcuZmEtaGVhcnQtbycpLnRvZ2dsZUNsYXNzKCdzZWxlY3RlZCcsIEBzY29yZSA+IDApXG4gICAgICAgICRzY2hlbWUuZmluZCgnLmZhLXRyYXNoLW8nKS50b2dnbGVDbGFzcygnc2VsZWN0ZWQnLCBAc2NvcmUgPCAwKVxuXG4gICAgICAgICRzY2hlbWUub24gJ2NsaWNrJywgJy5mYS1oZWFydC1vJywgLT5cbiAgICAgICAgICAgIGlmIGdldFNjb3JlKCRzY2hlbWUpIGlzIDEgdGhlbiBzZXRTY29yZSgkc2NoZW1lLCAwKSBlbHNlIHNldFNjb3JlKCRzY2hlbWUsIDEpXG4gICAgICAgICRzY2hlbWUub24gJ2NsaWNrJywgJy5mYS10cmFzaC1vJywgLT5cbiAgICAgICAgICAgIGlmIGdldFNjb3JlKCRzY2hlbWUpIGlzIC0xIHRoZW4gc2V0U2NvcmUoJHNjaGVtZSwgMCkgZWxzZSBzZXRTY29yZSgkc2NoZW1lLCAtMSlcbiAgICAgICAgJHNjaGVtZS5vbiAnY2xpY2snLCAnLmRldGFpbCwgLmNvbG9ycycsIC0+XG4gICAgICAgICAgICBuZXcgRGV0YWlsVmlldyhjb2xvcnMpXG4gICAgICAgICRzY2hlbWVbMF1cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWVzVmlld1xuIiwiLy8gZ2VuZXM6IOWfuuWboOW6k1xuLy8gbjog5Y2V5Liq5Liq5L2T5Z+65Zug5pWwXG4vLyB3ZWlnaHRzOiDmr4/kuKrln7rlm6DnmoTmnYPph43vvIzlvbHlk43lh7rnjrDnmoTpmo/mnLrnqIvluqZcblxuZnVuY3Rpb24gR2VuZVBvb2woZ2VuZXMsIG4sIHdlaWdodHMpIHtcblxuICAgIGlmKG4gPiBnZW5lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibiBtdXN0IDw9IGdlbmVzLmxlbmd0aFwiKTtcbiAgICB9XG5cbiAgICB3ZWlnaHRzID0gd2VpZ2h0cyB8fCBnZW5lcy5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9KTtcblxuICAgIC8vIOmaj+acuuWPluW+l+S4gOadoeWfuuWboFxuICAgIHZhciBnZXRSYW5kb21HZW5lID0gKGZ1bmN0aW9uKGdlbmVzLCB3ZWlnaHRzKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICB2YXIgd2VpZ2h0Qm91bmRzID0gd2VpZ2h0cy5tYXAoZnVuY3Rpb24od2VpZ2h0KSB7XG4gICAgICAgICAgICBzdW0gKz0gd2VpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmFuZG9tID0gTWF0aC5yYW5kb20oKSAqIHN1bTtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB3ZWlnaHRCb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZihyYW5kb20gPCB3ZWlnaHRCb3VuZHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZW5lc1t3ZWlnaHRCb3VuZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH0pO1xuICAgIH0pKGdlbmVzLCB3ZWlnaHRzKTtcblxuICAgIC8vIOiOt+WPluS4gOS4qumaj+acuuS4quS9k++8iOaVsOe7hO+8ie+8jOivpeS4quS9k+WGheWQqyBuIOadoeS4jemHjeWkjeeahOWfuuWboFxuICAgIHZhciBnZXRSYW5kb21JbmRpdmlkdWFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnZW5lcyA9IFtdLFxuICAgICAgICAgICAgZ2VuZSA9IG51bGw7XG4gICAgICAgIHdoaWxlKGdlbmVzLmxlbmd0aCA8IG4pIHtcbiAgICAgICAgICAgIGdlbmUgPSBnZXRSYW5kb21HZW5lKCk7XG4gICAgICAgICAgICBpZihnZW5lcy5pbmRleE9mKGdlbmUpIDwgMCkge1xuICAgICAgICAgICAgICAgIGdlbmVzLnB1c2goZ2VuZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbmVzID0gW107IC8vIOS/neivgeamgueOh+WIhuW4g+e7k+aenOespuWQiOmihOacn++8jOinge+8mmh0dHBzOi8vZ2l0aHViLmNvbS96ZW5vemVuZy9nZW5lLXBvb2wvaXNzdWVzLzJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VuZXM7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldFJhbmRvbUdlbmU6IGdldFJhbmRvbUdlbmUsXG4gICAgICAgIGdldFJhbmRvbUluZGl2aWR1YWw6IGdldFJhbmRvbUluZGl2aWR1YWxcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVQb29sO1xuXG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsImNvbnZlcnRlciA9IHJlcXVpcmUoJ2NvbG9yLWNvbnZlcnQnKSgpXG5fID0gcmVxdWlyZSAnbG9kYXNoJ1xubWF0aCA9IHJlcXVpcmUgJ21hdGhqcydcbmNvbnZuZXQgPSByZXF1aXJlICdjb252bmV0anMnXG5Qcm9taXNlID0gcmVxdWlyZSAncHJvbWlzZSdcbmh5cG90ID0gcmVxdWlyZSAnLi9saWIvaHlwb3QnXG5cbiMgU2ltcGxlIHdyYXBwZXIgb2YgY29udm5ldCBmb3IgY29sb3Igc2NoZW1lc1xuI1xuIyBAZXhhbXBsZSBjb25zXG4jICAgICBhbm4gPSBuZXcgQU5OKClcbiMgICAgIGFubi50cmFpbihjb2NvbG91ckRhdGEpXG4jICAgICBhbm4ucnVuKHNjaGVtZSlcbiNcbmNsYXNzIEFOTlxuXG4gICAgIyBDb3N0cnVjdG9yXG4gICAgI1xuICAgIGNvbnN0cnVjdG9yOiAob3B0aW9ucyA9IHt9KSAtPlxuXG4gICAgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAgICNcbiAgICAgICAgIyBBTk4gKHVzZSBbW0gsIFMsIEwsIC4uLl0sIF0pXG4gICAgICAgICNcbiAgICAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuICAgICAgICBkZWZhdWx0cyA9XG4gICAgICAgICAgICAjIGl0ZXJhdGlvbnM6IDE4XG4gICAgICAgICAgICBpdGVyYXRpb25zOiAxMDAwICMgbWF4IGl0ZXJhdGlvbnNcblxuICAgICAgICBsYXllcnMgPSBbXG4gICAgICAgICAgICAjIGlucHV0OiA1IGNvbG9ycyAqIDEgKiBbSCwgUywgTF1cbiAgICAgICAgICAgIHt0eXBlOiAnaW5wdXQnLCBvdXRfc3g6IDE2LCBvdXRfc3k6IDEsIG91dF9kZXB0aDogMX0sXG5cbiAgICAgICAgICAgICMgZnVsbHkgY29ubmVjdGVkIGxheWVyc1xuICAgICAgICAgICAge3R5cGU6ICdmYycsIG51bV9uZXVyb25zOiAxNiwgYWN0aXZhdGlvbjogJ3NpZ21vaWQnfSxcblxuICAgICAgICAgICAgIyB7dHlwZToncmVncmVzc2lvbicsIG51bV9uZXVyb25zOiA4fSxcblxuICAgICAgICAgICAgIyBJbiBzb2Z0bWF4LCB0aGUgb3V0cHV0cyBhcmUgcHJvYmFiaWxpdGllcyB0aGF0IHN1bSB0byAxXG4gICAgICAgICAgICB7dHlwZTogJ3NvZnRtYXgnLCBudW1fY2xhc3NlczogMn1cblxuICAgICAgICAgICAgIyBzaW1wbGUgYmluYXJ5IFNWTSBjbGFzc2lmZXJcbiAgICAgICAgICAgICMge3R5cGU6ICdzdm0nLCBudW1fY2xhc3NlczogMn1cbiAgICAgICAgXVxuXG4gICAgICAgIEBuZXQgPSBuZXcgY29udm5ldC5OZXQoKVxuICAgICAgICBAbmV0Lm1ha2VMYXllcnMgbGF5ZXJzXG5cbiAgICAgICAgQG9wdGlvbnMgPSBfLmRlZmF1bHRzIG9wdGlvbnMsIGRlZmF1bHRzXG5cbiAgICAgICAgQHRyYWluZXIgPSBuZXcgY29udm5ldC5UcmFpbmVyKEBuZXQsIHtcbiAgICAgICAgICAgICMgU2VlIGFsc286IGh0dHA6Ly9pbWd1ci5jb20vYS9IcW9scFxuICAgICAgICAgICAgbWV0aG9kOiAnYWRhZGVsdGEnLFxuICAgICAgICAgICAgIyBtZXRob2Q6ICdhZGFncmFkJyxcblxuICAgICAgICAgICAgbGVhcm5pbmdfcmF0ZTogMC4wNSxcblxuICAgICAgICAgICAgIyBZb3UgYmFzaWNhbGx5IGFsd2F5cyB3YW50IHRvIHVzZSBhIG5vbi16ZXJvIGwyX2RlY2F5LlxuICAgICAgICAgICAgIyBJZiBpdCdzIHRvbyBoaWdoLCB0aGUgbmV0d29yayB3aWxsIGJlIHJlZ3VsYXJpemVkIHZlcnkgc3Ryb25nbHkuXG4gICAgICAgICAgICAjIFRoaXMgbWlnaHQgYmUgYSBnb29kIGlkZWEgaWYgeW91IGhhdmUgdmVyeSBmZXcgdHJhaW5pbmcgZGF0YS5cbiAgICAgICAgICAgICMgSWYgeW91ciB0cmFpbmluZyBlcnJvciBpcyBhbHNvIHZlcnkgbG93IChzbyB5b3VyIG5ldHdvcmsgaXMgY3J1c2hpbmcgdGhlIHRyYWluaW5nIHNldCBwZXJmZWN0bHkpLFxuICAgICAgICAgICAgIyB5b3UgbWF5IHdhbnQgdG8gaW5jcmVhc2UgdGhpcyBhIGJpdCB0byBoYXZlIGJldHRlciBnZW5lcmFsaXphdGlvbi5cbiAgICAgICAgICAgICMgSWYgeW91ciB0cmFpbmluZyBlcnJvciBpcyB2ZXJ5IGhpZ2ggKHNvIHRoZSBuZXR3b3JrIGlzIHN0cnVnZ2xpbmcgdG8gbGVhcm4geW91ciBkYXRhKSxcbiAgICAgICAgICAgICMgeW91IG1heSB3YW50IHRvIHRyeSB0byBkZWNyZWFzZSBpdC5cbiAgICAgICAgICAgIGwyX2RlY2F5OiAwLjAwMDUsXG5cbiAgICAgICAgICAgICMgcGVyZm9ybXMgYSB3ZWlnaHQgdXBkYXRlIGV2ZXJ5IDUgZXhhbXBsZXNcbiAgICAgICAgICAgIGJhdGNoX3NpemU6IDVcbiAgICAgICAgfSlcblxuICAgICMgQ29udmVydCBbW1IsIEcsIEJdLCBdIHRvIHRhcmdldCB2ZWN0b3JcbiAgICAjXG4gICAgIyBAcGFyYW0gW0FycmF5XSBzY2hlbWUgYXJyYXkgb2YgUkdCIEFycmF5XG4gICAgI1xuICAgIHByZXByb2Nlc3M6IChjb2xvcnMpIC0+XG5cbiAgICAgICAgaHNsTWF0cml4ID0gY29sb3JzLm1hcCAocmdiKSAtPlxuICAgICAgICAgICAgIyBjb252ZXJ0IHJnYiB0byBoc2xcbiAgICAgICAgICAgIGhzbCA9IGNvbnZlcnRlci5yZ2IocmdiKS5oc2woKVxuXG4gICAgICAgICAgICAjIG5vcm1hbGl6ZSBoc2wgdG8gWzAsIDFdXG4gICAgICAgICAgICBoc2wubWFwIChlbGVtLCBpbmRleCkgLT5cbiAgICAgICAgICAgICAgICBpZiBpbmRleCBpcyAwXG4gICAgICAgICAgICAgICAgICAgIGVsZW0gLz0gMzYwXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBlbGVtIC89IDEwMFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQgZWxlbS50b0ZpeGVkKDMpXG5cbiAgICAgICAgdmVjdG9yID0gXy5mbGF0dGVuKGhzbE1hdHJpeClcblxuICAgICAgICBkaXN0YW5jZSA9IFtdXG4gICAgICAgIGZvciBjMSBpbiBoc2xNYXRyaXhcbiAgICAgICAgICAgIGZvciBjMiBpbiBoc2xNYXRyaXhcbiAgICAgICAgICAgICAgICB1bmxlc3MgYzEgaXMgYzJcbiAgICAgICAgICAgICAgICAgICAgZCA9IGMxLm1hcCAoZWxlbSwgaSkgLT4gZWxlbSAtIGMyW2ldXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlLnB1c2ggaHlwb3QuYXBwbHkobnVsbCwgZClcblxuICAgICAgICB2ZWN0b3IucHVzaCBNYXRoLm1pbi5hcHBseShudWxsLCBkaXN0YW5jZSkgIyBtaW4gZGlzdGFuY2VcbiAgICAgICAgIyB2ZWN0b3IucHVzaCBtYXRoLnZhcihkaXN0YW5jZSwgJ2JpYXNlZCcpICMgdmFyXG5cbiAgICAgICAgbmV3IGNvbnZuZXQuVm9sKHZlY3RvcilcblxuICAgICMgVHJhaW4gZGF0YVxuICAgICNcbiAgICAjIEBwYXJhbSBbQXJyYXldIGRhdGEgY29jb2xvdXIgc3R5bGUgZGF0YSBbe3JnYkNvbG9ycywgc2NvcmV9XVxuICAgICMgQG5vdGUgdGhpcyBtZXRob2QgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcbiAgICAjXG4gICAgdHJhaW46IChkYXRhKSAtPlxuICAgICAgICB0cmFpbkxhYmVscyA9IGRhdGEubWFwIChzY2hlbWUpIC0+XG4gICAgICAgICAgICAjIDAgZm9yIHBvc2l0aXZlIGFuZCAxIGZvciBuZWdhdGl2ZVxuICAgICAgICAgICAgaWYgc2NoZW1lLnNjb3JlID4gMCB0aGVuIDAgZWxzZSAxXG5cbiAgICAgICAgdHJhaW5EYXRhID0gZGF0YS5tYXAgKHNjaGVtZSkgPT4gQHByZXByb2Nlc3Mgc2NoZW1lLmNvbG9yc1xuXG4gICAgICAgIGdldEVycm9yID0gPT5cbiAgICAgICAgICAgIGNvdW50ID0gMFxuICAgICAgICAgICAgdW5tYXRjaENvdW50ID0gMFxuICAgICAgICAgICAgdHJhaW5EYXRhLmZvckVhY2ggKGRhdGEsIGkpID0+XG4gICAgICAgICAgICAgICAgaXNQb3NpdGl2ZSA9IEByYXRlKGRhdGEsIHRydWUpID4gMFxuICAgICAgICAgICAgICAgIGlzUmVhbGx5UG9zaXRpdmUgPSB0cmFpbkxhYmVsc1tpXSBpcyAwXG4gICAgICAgICAgICAgICAgY291bnQrK1xuICAgICAgICAgICAgICAgIHVubWF0Y2hDb3VudCsrIHVubGVzcyBpc1Bvc2l0aXZlID09IGlzUmVhbGx5UG9zaXRpdmVcbiAgICAgICAgICAgIHVubWF0Y2hDb3VudCAvIGNvdW50XG5cbiAgICAgICAgZm9yIF9fIGluIFswLi5Ab3B0aW9ucy5pdGVyYXRpb25zXVxuICAgICAgICAgICAgdHJhaW5EYXRhLmZvckVhY2ggKGRhdGEsIGkpID0+XG4gICAgICAgICAgICAgICAgQHRyYWluZXIudHJhaW4gZGF0YSwgdHJhaW5MYWJlbHNbaV1cbiAgICAgICAgICAgIGVycm9yID0gZ2V0RXJyb3IoKVxuICAgICAgICAgICAgY29uc29sZS5sb2cgcHJvY2Vzcy5waWQsIGVycm9yXG4gICAgICAgICAgICBpZiBlcnJvciA8IDAuMzIgIyDmnIDlpKfmi5/lkIjluqbvvIzkuI3pnIDopoHovr7liLDmlLbmlZvvvIjlkKbliJnlsLHnm7jlr7nov4fmi5/lkIjkuobvvIlcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpIC0+IHJlc29sdmUoKSlcblxuICAgICMgVmVyaWZ5IGRhdGFcbiAgICAjXG4gICAgIyBAcGFyYW0gW0FycmF5XSBkYXRhIGNvY29sb3VyIHN0eWxlIGRhdGEgW3tyZ2JDb2xvcnMsIHNjb3JlfV1cbiAgICAjXG4gICAgdmVyaWZ5OiAoZGF0YSkgLT5cbiAgICAgICAgZ2V0UmVzdWx0cyA9IChkYXRhKSA9PlxuICAgICAgICAgICAgdGVzdHMgPSBkYXRhLm1hcCAoc2NoZW1lKSA9PlxuICAgICAgICAgICAgICAgIHJhdGUgPSBAcmF0ZSBzY2hlbWVcbiAgICAgICAgICAgICAgICBzY2hlbWUuc2NvcmUgKiByYXRlID4gMCAjIOWQjOWPt++8jOihqOaYjuWIpOaWreebuOWQjFxuICAgICAgICAgICAgcGFzc2VkID0gKHRlc3RzLmZpbHRlciAoZWxlbSkgLT4gZWxlbSkubGVuZ3RoXG4gICAgICAgICAgICByYXRlID0gcGFzc2VkIC8gdGVzdHMubGVuZ3RoXG4gICAgICAgICAgICB7dG90YWw6IHRlc3RzLmxlbmd0aCwgcGFzc2VkOiBwYXNzZWQsIHJhdGU6IHJhdGV9XG4gICAgICAgIHJlcyA9XG4gICAgICAgICAgICBhbGw6IGdldFJlc3VsdHMoZGF0YSlcbiAgICAgICAgICAgIHBvc2l0aXZlOiBnZXRSZXN1bHRzKGRhdGEuZmlsdGVyIChzY2hlbWUpIC0+IHNjaGVtZS5zY29yZSA+IDApXG4gICAgICAgICAgICBuZWdhdGl2ZTogZ2V0UmVzdWx0cyhkYXRhLmZpbHRlciAoc2NoZW1lKSAtPiBzY2hlbWUuc2NvcmUgPCAwKVxuICAgICAgICAgICAgbmV0d29yazogQHRvSlNPTigpXG5cbiAgICAjIFJhdGUgZ2l2ZW4gc2NoZW1lXG4gICAgI1xuICAgICMgQHBhcmFtIFtPYmplY3RdIGRhdGEgY29jb2xvdXIgc3R5bGUgZGF0YSB7cmdiQ29sb3JzLCBzY29yZX1cbiAgICAjIEByZXR1cm4gW0Zsb2F0XSBbLTEsIDFdIHsxOiBsaWtlLCAwOiBub3JtYWwsIC0xOiBkaXNsaWtlfVxuICAgICNcbiAgICByYXRlOiAoc2NoZW1lLCBwcmVwcm9jZXNzZWQgPSBmYWxzZSkgLT5cbiAgICAgICAgdW5sZXNzIHByZXByb2Nlc3NlZFxuICAgICAgICAgICAgaW5wdXQgPSBAcHJlcHJvY2VzcyBzY2hlbWUuY29sb3JzXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlucHV0ID0gc2NoZW1lXG4gICAgICAgIHcgPSBAbmV0LmZvcndhcmQoaW5wdXQpLndcbiAgICAgICAgcG9zaXRpdmUgPSB3WzBdXG4gICAgICAgIG5lZ2F0aXZlID0gd1sxXVxuXG4gICAgICAgIHBvc2l0aXZlIC0gbmVnYXRpdmVcblxuICAgICNcbiAgICAjIFNhdmUgbmV0d29yayBhcyBKU09OXG4gICAgI1xuICAgIHRvSlNPTjogLT5cbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoQG5ldC50b0pTT04oKSlcblxuIyBMb2FkIG5ldHdvcmsgZnJvbSBKU09OXG4jXG4jIEBzdGF0aWNcbiMgQHBhcmFtIFtPYmplY3RdIGpzb24gSlNPTiBvYmplY3RcbiNcbkFOTi5mcm9tSlNPTiA9IChqc29uKSAtPlxuICAgIGFubiA9IG5ldyBBTk5cbiAgICBhbm4ubmV0LmZyb21KU09OKGpzb24pXG4gICAgYW5uXG5cbm1vZHVsZS5leHBvcnRzID0gQU5OXG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBDYW52YXMsIEltYWdlLCBjYWxjQ2x1c3RlcnMsIGNsdXN0ZXJpbmc7XG5cbiAgY2FsY0NsdXN0ZXJzID0gcmVxdWlyZShcIi4vbGliL2NsdXN0ZXJpbmcuanNcIik7XG5cbiAgQ2FudmFzID0gcmVxdWlyZShcImNhbnZhcy1icm93c2VyaWZ5XCIpO1xuXG4gIEltYWdlID0gQ2FudmFzLkltYWdlO1xuXG4gIGNsdXN0ZXJpbmcgPSBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlZmF1bHRDb25maWcsIGltZywgaywgdGltZUltZ1N0YXJ0LCB2O1xuICAgIGRlZmF1bHRDb25maWcgPSB7XG4gICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICBtYXhXaWR0aDogMzAsXG4gICAgICBtYXhIZWlnaHQ6IDMwLFxuICAgICAgbWluQ291bnQ6IDFcbiAgICB9O1xuICAgIGZvciAoayBpbiBjb25maWcpIHtcbiAgICAgIHYgPSBjb25maWdba107XG4gICAgICBkZWZhdWx0Q29uZmlnW2tdID0gdjtcbiAgICB9XG4gICAgY29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgICBpbWcgPSBuZXcgSW1hZ2U7XG4gICAgdGltZUltZ1N0YXJ0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2FudmFzLCBjdHgsIGhlaWdodCwgaSwgaW1hZ2UsIGltZ0RhdGEsIHBpeGVscywgc2NhbGUsIHRpbWVTdGFydCwgd2lkdGgsIF9yZWY7XG4gICAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibG9hZCBpbWFnZSBpbiBcIiArICgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdGltZUltZ1N0YXJ0KSArIFwibXNcIik7XG4gICAgICB9XG4gICAgICB0aW1lU3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgaW1hZ2UgPSB0aGlzO1xuICAgICAgc2NhbGUgPSBNYXRoLm1heChpbWFnZS53aWR0aCAvIGNvbmZpZy5tYXhXaWR0aCwgaW1hZ2UuaGVpZ2h0IC8gY29uZmlnLm1heEhlaWdodCwgMSk7XG4gICAgICBfcmVmID0gW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLm1hcChmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChlbGVtIC8gc2NhbGUpO1xuICAgICAgfSksIHdpZHRoID0gX3JlZlswXSwgaGVpZ2h0ID0gX3JlZlsxXTtcbiAgICAgIGNhbnZhcyA9IG5ldyBDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGltZ0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcGl4ZWxzID0gW107XG4gICAgICBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgaW1nRGF0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgICBwaXhlbHMucHVzaChbaW1nRGF0YS5kYXRhW2ldLCBpbWdEYXRhLmRhdGFbaSArIDFdLCBpbWdEYXRhLmRhdGFbaSArIDJdLCBpbWdEYXRhLmRhdGFbaSArIDNdXSk7XG4gICAgICAgIGkgKz0gNDtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJwYXJzZSBpbWFnZSBpbiBcIiArICgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdGltZVN0YXJ0KSArIFwibXNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayhjYWxjQ2x1c3RlcnMocGl4ZWxzLCBjb25maWcpKSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIHJldHVybiBpbWcuc3JjID0gY29uZmlnLnNyYztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGNsdXN0ZXJpbmc7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKXt2YXIgY29udm5ldGpzID0gY29udm5ldGpzIHx8IHsgUkVWSVNJT046ICdBTFBIQScgfTtcbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gUmFuZG9tIG51bWJlciB1dGlsaXRpZXNcbiAgdmFyIHJldHVybl92ID0gZmFsc2U7XG4gIHZhciB2X3ZhbCA9IDAuMDtcbiAgdmFyIGdhdXNzUmFuZG9tID0gZnVuY3Rpb24oKSB7XG4gICAgaWYocmV0dXJuX3YpIHsgXG4gICAgICByZXR1cm5fdiA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHZfdmFsOyBcbiAgICB9XG4gICAgdmFyIHUgPSAyKk1hdGgucmFuZG9tKCktMTtcbiAgICB2YXIgdiA9IDIqTWF0aC5yYW5kb20oKS0xO1xuICAgIHZhciByID0gdSp1ICsgdip2O1xuICAgIGlmKHIgPT0gMCB8fCByID4gMSkgcmV0dXJuIGdhdXNzUmFuZG9tKCk7XG4gICAgdmFyIGMgPSBNYXRoLnNxcnQoLTIqTWF0aC5sb2cocikvcik7XG4gICAgdl92YWwgPSB2KmM7IC8vIGNhY2hlIHRoaXNcbiAgICByZXR1cm5fdiA9IHRydWU7XG4gICAgcmV0dXJuIHUqYztcbiAgfVxuICB2YXIgcmFuZGYgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBNYXRoLnJhbmRvbSgpKihiLWEpK2E7IH1cbiAgdmFyIHJhbmRpID0gZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihiLWEpK2EpOyB9XG4gIHZhciByYW5kbiA9IGZ1bmN0aW9uKG11LCBzdGQpeyByZXR1cm4gbXUrZ2F1c3NSYW5kb20oKSpzdGQ7IH1cblxuICAvLyBBcnJheSB1dGlsaXRpZXNcbiAgdmFyIHplcm9zID0gZnVuY3Rpb24obikge1xuICAgIGlmKHR5cGVvZihuKT09PSd1bmRlZmluZWQnIHx8IGlzTmFOKG4pKSB7IHJldHVybiBbXTsgfVxuICAgIGlmKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGxhY2tpbmcgYnJvd3NlciBzdXBwb3J0XG4gICAgICB2YXIgYXJyID0gbmV3IEFycmF5KG4pO1xuICAgICAgZm9yKHZhciBpPTA7aTxuO2krKykgeyBhcnJbaV09IDA7IH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhcnJDb250YWlucyA9IGZ1bmN0aW9uKGFyciwgZWx0KSB7XG4gICAgZm9yKHZhciBpPTAsbj1hcnIubGVuZ3RoO2k8bjtpKyspIHtcbiAgICAgIGlmKGFycltpXT09PWVsdCkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBhcnJVbmlxdWUgPSBmdW5jdGlvbihhcnIpIHtcbiAgICB2YXIgYiA9IFtdO1xuICAgIGZvcih2YXIgaT0wLG49YXJyLmxlbmd0aDtpPG47aSsrKSB7XG4gICAgICBpZighYXJyQ29udGFpbnMoYiwgYXJyW2ldKSkge1xuICAgICAgICBiLnB1c2goYXJyW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGI7XG4gIH1cblxuICAvLyByZXR1cm4gbWF4IGFuZCBtaW4gb2YgYSBnaXZlbiBub24tZW1wdHkgYXJyYXkuXG4gIHZhciBtYXhtaW4gPSBmdW5jdGlvbih3KSB7XG4gICAgaWYody5sZW5ndGggPT09IDApIHsgcmV0dXJuIHt9OyB9IC8vIC4uLiA7c1xuICAgIHZhciBtYXh2ID0gd1swXTtcbiAgICB2YXIgbWludiA9IHdbMF07XG4gICAgdmFyIG1heGkgPSAwO1xuICAgIHZhciBtaW5pID0gMDtcbiAgICB2YXIgbiA9IHcubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0xO2k8bjtpKyspIHtcbiAgICAgIGlmKHdbaV0gPiBtYXh2KSB7IG1heHYgPSB3W2ldOyBtYXhpID0gaTsgfSBcbiAgICAgIGlmKHdbaV0gPCBtaW52KSB7IG1pbnYgPSB3W2ldOyBtaW5pID0gaTsgfSBcbiAgICB9XG4gICAgcmV0dXJuIHttYXhpOiBtYXhpLCBtYXh2OiBtYXh2LCBtaW5pOiBtaW5pLCBtaW52OiBtaW52LCBkdjptYXh2LW1pbnZ9O1xuICB9XG5cbiAgLy8gY3JlYXRlIHJhbmRvbSBwZXJtdXRhdGlvbiBvZiBudW1iZXJzLCBpbiByYW5nZSBbMC4uLm4tMV1cbiAgdmFyIHJhbmRwZXJtID0gZnVuY3Rpb24obikge1xuICAgIHZhciBpID0gbixcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIHRlbXA7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yKHZhciBxPTA7cTxuO3ErKylhcnJheVtxXT1xO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpKzEpKTtcbiAgICAgICAgdGVtcCA9IGFycmF5W2ldO1xuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICAgICAgICBhcnJheVtqXSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8vIHNhbXBsZSBmcm9tIGxpc3QgbHN0IGFjY29yZGluZyB0byBwcm9iYWJpbGl0aWVzIGluIGxpc3QgcHJvYnNcbiAgLy8gdGhlIHR3byBsaXN0cyBhcmUgb2Ygc2FtZSBzaXplLCBhbmQgcHJvYnMgYWRkcyB1cCB0byAxXG4gIHZhciB3ZWlnaHRlZFNhbXBsZSA9IGZ1bmN0aW9uKGxzdCwgcHJvYnMpIHtcbiAgICB2YXIgcCA9IHJhbmRmKDAsIDEuMCk7XG4gICAgdmFyIGN1bXByb2IgPSAwLjA7XG4gICAgZm9yKHZhciBrPTAsbj1sc3QubGVuZ3RoO2s8bjtrKyspIHtcbiAgICAgIGN1bXByb2IgKz0gcHJvYnNba107XG4gICAgICBpZihwIDwgY3VtcHJvYikgeyByZXR1cm4gbHN0W2tdOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc3ludGFjdGljIHN1Z2FyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlc1xuICB2YXIgZ2V0b3B0ID0gZnVuY3Rpb24ob3B0LCBmaWVsZF9uYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvcHRbZmllbGRfbmFtZV0gIT09ICd1bmRlZmluZWQnID8gb3B0W2ZpZWxkX25hbWVdIDogZGVmYXVsdF92YWx1ZTtcbiAgfVxuXG4gIGdsb2JhbC5yYW5kZiA9IHJhbmRmO1xuICBnbG9iYWwucmFuZGkgPSByYW5kaTtcbiAgZ2xvYmFsLnJhbmRuID0gcmFuZG47XG4gIGdsb2JhbC56ZXJvcyA9IHplcm9zO1xuICBnbG9iYWwubWF4bWluID0gbWF4bWluO1xuICBnbG9iYWwucmFuZHBlcm0gPSByYW5kcGVybTtcbiAgZ2xvYmFsLndlaWdodGVkU2FtcGxlID0gd2VpZ2h0ZWRTYW1wbGU7XG4gIGdsb2JhbC5hcnJVbmlxdWUgPSBhcnJVbmlxdWU7XG4gIGdsb2JhbC5hcnJDb250YWlucyA9IGFyckNvbnRhaW5zO1xuICBnbG9iYWwuZ2V0b3B0ID0gZ2V0b3B0O1xuICBcbn0pKGNvbnZuZXRqcyk7XG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIFZvbCBpcyB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2sgb2YgYWxsIGRhdGEgaW4gYSBuZXQuXG4gIC8vIGl0IGlzIGVzc2VudGlhbGx5IGp1c3QgYSAzRCB2b2x1bWUgb2YgbnVtYmVycywgd2l0aCBhXG4gIC8vIHdpZHRoIChzeCksIGhlaWdodCAoc3kpLCBhbmQgZGVwdGggKGRlcHRoKS5cbiAgLy8gaXQgaXMgdXNlZCB0byBob2xkIGRhdGEgZm9yIGFsbCBmaWx0ZXJzLCBhbGwgdm9sdW1lcyxcbiAgLy8gYWxsIHdlaWdodHMsIGFuZCBhbHNvIHN0b3JlcyBhbGwgZ3JhZGllbnRzIHcuci50LiBcbiAgLy8gdGhlIGRhdGEuIGMgaXMgb3B0aW9uYWxseSBhIHZhbHVlIHRvIGluaXRpYWxpemUgdGhlIHZvbHVtZVxuICAvLyB3aXRoLiBJZiBjIGlzIG1pc3NpbmcsIGZpbGxzIHRoZSBWb2wgd2l0aCByYW5kb20gbnVtYmVycy5cbiAgdmFyIFZvbCA9IGZ1bmN0aW9uKHN4LCBzeSwgZGVwdGgsIGMpIHtcbiAgICAvLyB0aGlzIGlzIGhvdyB5b3UgY2hlY2sgaWYgYSB2YXJpYWJsZSBpcyBhbiBhcnJheS4gT2gsIEphdmFzY3JpcHQgOilcbiAgICBpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3gpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAvLyB3ZSB3ZXJlIGdpdmVuIGEgbGlzdCBpbiBzeCwgYXNzdW1lIDFEIHZvbHVtZSBhbmQgZmlsbCBpdCB1cFxuICAgICAgdGhpcy5zeCA9IDE7XG4gICAgICB0aGlzLnN5ID0gMTtcbiAgICAgIHRoaXMuZGVwdGggPSBzeC5sZW5ndGg7XG4gICAgICAvLyB3ZSBoYXZlIHRvIGRvIHRoZSBmb2xsb3dpbmcgY29weSBiZWNhdXNlIHdlIHdhbnQgdG8gdXNlXG4gICAgICAvLyBmYXN0IHR5cGVkIGFycmF5cywgbm90IGFuIG9yZGluYXJ5IGphdmFzY3JpcHQgYXJyYXlcbiAgICAgIHRoaXMudyA9IGdsb2JhbC56ZXJvcyh0aGlzLmRlcHRoKTtcbiAgICAgIHRoaXMuZHcgPSBnbG9iYWwuemVyb3ModGhpcy5kZXB0aCk7XG4gICAgICBmb3IodmFyIGk9MDtpPHRoaXMuZGVwdGg7aSsrKSB7XG4gICAgICAgIHRoaXMud1tpXSA9IHN4W2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSB3ZXJlIGdpdmVuIGRpbWVuc2lvbnMgb2YgdGhlIHZvbFxuICAgICAgdGhpcy5zeCA9IHN4O1xuICAgICAgdGhpcy5zeSA9IHN5O1xuICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgdmFyIG4gPSBzeCpzeSpkZXB0aDtcbiAgICAgIHRoaXMudyA9IGdsb2JhbC56ZXJvcyhuKTtcbiAgICAgIHRoaXMuZHcgPSBnbG9iYWwuemVyb3Mobik7XG4gICAgICBpZih0eXBlb2YgYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gd2VpZ2h0IG5vcm1hbGl6YXRpb24gaXMgZG9uZSB0byBlcXVhbGl6ZSB0aGUgb3V0cHV0XG4gICAgICAgIC8vIHZhcmlhbmNlIG9mIGV2ZXJ5IG5ldXJvbiwgb3RoZXJ3aXNlIG5ldXJvbnMgd2l0aCBhIGxvdFxuICAgICAgICAvLyBvZiBpbmNvbWluZyBjb25uZWN0aW9ucyBoYXZlIG91dHB1dHMgb2YgbGFyZ2VyIHZhcmlhbmNlXG4gICAgICAgIHZhciBzY2FsZSA9IE1hdGguc3FydCgxLjAvKHN4KnN5KmRlcHRoKSk7XG4gICAgICAgIGZvcih2YXIgaT0wO2k8bjtpKyspIHsgXG4gICAgICAgICAgdGhpcy53W2ldID0gZ2xvYmFsLnJhbmRuKDAuMCwgc2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IodmFyIGk9MDtpPG47aSsrKSB7IFxuICAgICAgICAgIHRoaXMud1tpXSA9IGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBWb2wucHJvdG90eXBlID0ge1xuICAgIGdldDogZnVuY3Rpb24oeCwgeSwgZCkgeyBcbiAgICAgIHZhciBpeD0oKHRoaXMuc3ggKiB5KSt4KSp0aGlzLmRlcHRoK2Q7XG4gICAgICByZXR1cm4gdGhpcy53W2l4XTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oeCwgeSwgZCwgdikgeyBcbiAgICAgIHZhciBpeD0oKHRoaXMuc3ggKiB5KSt4KSp0aGlzLmRlcHRoK2Q7XG4gICAgICB0aGlzLndbaXhdID0gdjsgXG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uKHgsIHksIGQsIHYpIHsgXG4gICAgICB2YXIgaXg9KCh0aGlzLnN4ICogeSkreCkqdGhpcy5kZXB0aCtkO1xuICAgICAgdGhpcy53W2l4XSArPSB2OyBcbiAgICB9LFxuICAgIGdldF9ncmFkOiBmdW5jdGlvbih4LCB5LCBkKSB7IFxuICAgICAgdmFyIGl4ID0gKCh0aGlzLnN4ICogeSkreCkqdGhpcy5kZXB0aCtkO1xuICAgICAgcmV0dXJuIHRoaXMuZHdbaXhdOyBcbiAgICB9LFxuICAgIHNldF9ncmFkOiBmdW5jdGlvbih4LCB5LCBkLCB2KSB7IFxuICAgICAgdmFyIGl4ID0gKCh0aGlzLnN4ICogeSkreCkqdGhpcy5kZXB0aCtkO1xuICAgICAgdGhpcy5kd1tpeF0gPSB2OyBcbiAgICB9LFxuICAgIGFkZF9ncmFkOiBmdW5jdGlvbih4LCB5LCBkLCB2KSB7IFxuICAgICAgdmFyIGl4ID0gKCh0aGlzLnN4ICogeSkreCkqdGhpcy5kZXB0aCtkO1xuICAgICAgdGhpcy5kd1tpeF0gKz0gdjsgXG4gICAgfSxcbiAgICBjbG9uZUFuZFplcm86IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFZvbCh0aGlzLnN4LCB0aGlzLnN5LCB0aGlzLmRlcHRoLCAwLjApfSxcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgViA9IG5ldyBWb2wodGhpcy5zeCwgdGhpcy5zeSwgdGhpcy5kZXB0aCwgMC4wKTtcbiAgICAgIHZhciBuID0gdGhpcy53Lmxlbmd0aDtcbiAgICAgIGZvcih2YXIgaT0wO2k8bjtpKyspIHsgVi53W2ldID0gdGhpcy53W2ldOyB9XG4gICAgICByZXR1cm4gVjtcbiAgICB9LFxuICAgIGFkZEZyb206IGZ1bmN0aW9uKFYpIHsgZm9yKHZhciBrPTA7azx0aGlzLncubGVuZ3RoO2srKykgeyB0aGlzLndba10gKz0gVi53W2tdOyB9fSxcbiAgICBhZGRGcm9tU2NhbGVkOiBmdW5jdGlvbihWLCBhKSB7IGZvcih2YXIgaz0wO2s8dGhpcy53Lmxlbmd0aDtrKyspIHsgdGhpcy53W2tdICs9IGEqVi53W2tdOyB9fSxcbiAgICBzZXRDb25zdDogZnVuY3Rpb24oYSkgeyBmb3IodmFyIGs9MDtrPHRoaXMudy5sZW5ndGg7aysrKSB7IHRoaXMud1trXSA9IGE7IH19LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHRvZG86IHdlIG1heSB3YW50IHRvIG9ubHkgc2F2ZSBkIG1vc3Qgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIHNhdmUgc3BhY2VcbiAgICAgIHZhciBqc29uID0ge31cbiAgICAgIGpzb24uc3ggPSB0aGlzLnN4OyBcbiAgICAgIGpzb24uc3kgPSB0aGlzLnN5O1xuICAgICAganNvbi5kZXB0aCA9IHRoaXMuZGVwdGg7XG4gICAgICBqc29uLncgPSB0aGlzLnc7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICAgIC8vIHdlIHdvbnQgYmFjayB1cCBncmFkaWVudHMgdG8gc2F2ZSBzcGFjZVxuICAgIH0sXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgIHRoaXMuc3ggPSBqc29uLnN4O1xuICAgICAgdGhpcy5zeSA9IGpzb24uc3k7XG4gICAgICB0aGlzLmRlcHRoID0ganNvbi5kZXB0aDtcblxuICAgICAgdmFyIG4gPSB0aGlzLnN4KnRoaXMuc3kqdGhpcy5kZXB0aDtcbiAgICAgIHRoaXMudyA9IGdsb2JhbC56ZXJvcyhuKTtcbiAgICAgIHRoaXMuZHcgPSBnbG9iYWwuemVyb3Mobik7XG4gICAgICAvLyBjb3B5IG92ZXIgdGhlIGVsZW1lbnRzLlxuICAgICAgZm9yKHZhciBpPTA7aTxuO2krKykge1xuICAgICAgICB0aGlzLndbaV0gPSBqc29uLndbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsLlZvbCA9IFZvbDtcbn0pKGNvbnZuZXRqcyk7XG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgVm9sID0gZ2xvYmFsLlZvbDsgLy8gY29udmVuaWVuY2VcblxuICAvLyBWb2x1bWUgdXRpbGl0aWVzXG4gIC8vIGludGVuZGVkIGZvciB1c2Ugd2l0aCBkYXRhIGF1Z21lbnRhdGlvblxuICAvLyBjcm9wIGlzIHRoZSBzaXplIG9mIG91dHB1dFxuICAvLyBkeCxkeSBhcmUgb2Zmc2V0IHdydCBpbmNvbWluZyB2b2x1bWUsIG9mIHRoZSBzaGlmdFxuICAvLyBmbGlwbHIgaXMgYm9vbGVhbiBvbiB3aGV0aGVyIHdlIGFsc28gd2FudCB0byBmbGlwIGxlZnQ8LT5yaWdodFxuICB2YXIgYXVnbWVudCA9IGZ1bmN0aW9uKFYsIGNyb3AsIGR4LCBkeSwgZmxpcGxyKSB7XG4gICAgLy8gbm90ZSBhc3N1bWVzIHNxdWFyZSBvdXRwdXRzIG9mIHNpemUgY3JvcCB4IGNyb3BcbiAgICBpZih0eXBlb2YoZmxpcGxyKT09PSd1bmRlZmluZWQnKSB2YXIgZmxpcGxyID0gZmFsc2U7XG4gICAgaWYodHlwZW9mKGR4KT09PSd1bmRlZmluZWQnKSB2YXIgZHggPSBnbG9iYWwucmFuZGkoMCwgVi5zeCAtIGNyb3ApO1xuICAgIGlmKHR5cGVvZihkeSk9PT0ndW5kZWZpbmVkJykgdmFyIGR5ID0gZ2xvYmFsLnJhbmRpKDAsIFYuc3kgLSBjcm9wKTtcbiAgICBcbiAgICAvLyByYW5kb21seSBzYW1wbGUgYSBjcm9wIGluIHRoZSBpbnB1dCB2b2x1bWVcbiAgICB2YXIgVztcbiAgICBpZihjcm9wICE9PSBWLnN4IHx8IGR4IT09MCB8fCBkeSE9PTApIHtcbiAgICAgIFcgPSBuZXcgVm9sKGNyb3AsIGNyb3AsIFYuZGVwdGgsIDAuMCk7XG4gICAgICBmb3IodmFyIHg9MDt4PGNyb3A7eCsrKSB7XG4gICAgICAgIGZvcih2YXIgeT0wO3k8Y3JvcDt5KyspIHtcbiAgICAgICAgICBpZih4K2R4PDAgfHwgeCtkeD49Vi5zeCB8fCB5K2R5PDAgfHwgeStkeT49Vi5zeSkgY29udGludWU7IC8vIG9vYlxuICAgICAgICAgIGZvcih2YXIgZD0wO2Q8Vi5kZXB0aDtkKyspIHtcbiAgICAgICAgICAgVy5zZXQoeCx5LGQsVi5nZXQoeCtkeCx5K2R5LGQpKTsgLy8gY29weSBkYXRhIG92ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgVyA9IFY7XG4gICAgfVxuXG4gICAgaWYoZmxpcGxyKSB7XG4gICAgICAvLyBmbGlwIHZvbHVtZSBob3J6aW9udGFsbHlcbiAgICAgIHZhciBXMiA9IFcuY2xvbmVBbmRaZXJvKCk7XG4gICAgICBmb3IodmFyIHg9MDt4PFcuc3g7eCsrKSB7XG4gICAgICAgIGZvcih2YXIgeT0wO3k8Vy5zeTt5KyspIHtcbiAgICAgICAgICBmb3IodmFyIGQ9MDtkPFcuZGVwdGg7ZCsrKSB7XG4gICAgICAgICAgIFcyLnNldCh4LHksZCxXLmdldChXLnN4IC0geCAtIDEseSxkKSk7IC8vIGNvcHkgZGF0YSBvdmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBXID0gVzI7IC8vc3dhcFxuICAgIH1cbiAgICByZXR1cm4gVztcbiAgfVxuXG4gIC8vIGltZyBpcyBhIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgYSBsb2FkZWQgaW1hZ2VcbiAgLy8gcmV0dXJucyBhIFZvbCBvZiBzaXplIChXLCBILCA0KS4gNCBpcyBmb3IgUkdCQVxuICB2YXIgaW1nX3RvX3ZvbCA9IGZ1bmN0aW9uKGltZywgY29udmVydF9ncmF5c2NhbGUpIHtcblxuICAgIGlmKHR5cGVvZihjb252ZXJ0X2dyYXlzY2FsZSk9PT0ndW5kZWZpbmVkJykgdmFyIGNvbnZlcnRfZ3JheXNjYWxlID0gZmFsc2U7XG5cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgLy8gZHVlIHRvIGEgRmlyZWZveCBidWdcbiAgICB0cnkge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgPT09IFwiTlNfRVJST1JfTk9UX0FWQUlMQUJMRVwiKSB7XG4gICAgICAgIC8vIHNvbWV0aW1lcyBoYXBwZW5zLCBsZXRzIGp1c3QgYWJvcnRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGltZ19kYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmKGUubmFtZSA9PT0gJ0luZGV4U2l6ZUVycm9yJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG5vdCBzdXJlIHdoYXQgY2F1c2VzIHRoaXMgc29tZXRpbWVzIGJ1dCBva2F5IGFib3J0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHByZXBhcmUgdGhlIGlucHV0OiBnZXQgcGl4ZWxzIGFuZCBub3JtYWxpemUgdGhlbVxuICAgIHZhciBwID0gaW1nX2RhdGEuZGF0YTtcbiAgICB2YXIgVyA9IGltZy53aWR0aDtcbiAgICB2YXIgSCA9IGltZy5oZWlnaHQ7XG4gICAgdmFyIHB2ID0gW11cbiAgICBmb3IodmFyIGk9MDtpPHAubGVuZ3RoO2krKykge1xuICAgICAgcHYucHVzaChwW2ldLzI1NS4wLTAuNSk7IC8vIG5vcm1hbGl6ZSBpbWFnZSBwaXhlbHMgdG8gWy0wLjUsIDAuNV1cbiAgICB9XG4gICAgdmFyIHggPSBuZXcgVm9sKFcsIEgsIDQsIDAuMCk7IC8vaW5wdXQgdm9sdW1lIChpbWFnZSlcbiAgICB4LncgPSBwdjtcblxuICAgIGlmKGNvbnZlcnRfZ3JheXNjYWxlKSB7XG4gICAgICAvLyBmbGF0dGVuIGludG8gZGVwdGg9MSBhcnJheVxuICAgICAgdmFyIHgxID0gbmV3IFZvbChXLCBILCAxLCAwLjApO1xuICAgICAgZm9yKHZhciBpPTA7aTxXO2krKykge1xuICAgICAgICBmb3IodmFyIGo9MDtqPEg7aisrKSB7XG4gICAgICAgICAgeDEuc2V0KGksaiwwLHguZ2V0KGksaiwwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHggPSB4MTtcbiAgICB9XG5cbiAgICByZXR1cm4geDtcbiAgfVxuICBcbiAgZ2xvYmFsLmF1Z21lbnQgPSBhdWdtZW50O1xuICBnbG9iYWwuaW1nX3RvX3ZvbCA9IGltZ190b192b2w7XG5cbn0pKGNvbnZuZXRqcyk7XG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgVm9sID0gZ2xvYmFsLlZvbDsgLy8gY29udmVuaWVuY2VcblxuICAvLyBUaGlzIGZpbGUgY29udGFpbnMgYWxsIGxheWVycyB0aGF0IGRvIGRvdCBwcm9kdWN0cyB3aXRoIGlucHV0LFxuICAvLyBidXQgdXN1YWxseSBpbiBhIGRpZmZlcmVudCBjb25uZWN0aXZpdHkgcGF0dGVybiBhbmQgd2VpZ2h0IHNoYXJpbmdcbiAgLy8gc2NoZW1lczogXG4gIC8vIC0gRnVsbHlDb25uIGlzIGZ1bGx5IGNvbm5lY3RlZCBkb3QgcHJvZHVjdHMgXG4gIC8vIC0gQ29udkxheWVyIGRvZXMgY29udm9sdXRpb25zIChzbyB3ZWlnaHQgc2hhcmluZyBzcGF0aWFsbHkpXG4gIC8vIHB1dHRpbmcgdGhlbSB0b2dldGhlciBpbiBvbmUgZmlsZSBiZWNhdXNlIHRoZXkgYXJlIHZlcnkgc2ltaWxhclxuICB2YXIgQ29udkxheWVyID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgdmFyIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIC8vIHJlcXVpcmVkXG4gICAgdGhpcy5vdXRfZGVwdGggPSBvcHQuZmlsdGVycztcbiAgICB0aGlzLnN4ID0gb3B0LnN4OyAvLyBmaWx0ZXIgc2l6ZS4gU2hvdWxkIGJlIG9kZCBpZiBwb3NzaWJsZSwgaXQncyBjbGVhbmVyLlxuICAgIHRoaXMuaW5fZGVwdGggPSBvcHQuaW5fZGVwdGg7XG4gICAgdGhpcy5pbl9zeCA9IG9wdC5pbl9zeDtcbiAgICB0aGlzLmluX3N5ID0gb3B0LmluX3N5O1xuICAgIFxuICAgIC8vIG9wdGlvbmFsXG4gICAgdGhpcy5zeSA9IHR5cGVvZiBvcHQuc3kgIT09ICd1bmRlZmluZWQnID8gb3B0LnN5IDogdGhpcy5zeDtcbiAgICB0aGlzLnN0cmlkZSA9IHR5cGVvZiBvcHQuc3RyaWRlICE9PSAndW5kZWZpbmVkJyA/IG9wdC5zdHJpZGUgOiAxOyAvLyBzdHJpZGUgYXQgd2hpY2ggd2UgYXBwbHkgZmlsdGVycyB0byBpbnB1dCB2b2x1bWVcbiAgICB0aGlzLnBhZCA9IHR5cGVvZiBvcHQucGFkICE9PSAndW5kZWZpbmVkJyA/IG9wdC5wYWQgOiAwOyAvLyBhbW91bnQgb2YgMCBwYWRkaW5nIHRvIGFkZCBhcm91bmQgYm9yZGVycyBvZiBpbnB1dCB2b2x1bWVcbiAgICB0aGlzLmwxX2RlY2F5X211bCA9IHR5cGVvZiBvcHQubDFfZGVjYXlfbXVsICE9PSAndW5kZWZpbmVkJyA/IG9wdC5sMV9kZWNheV9tdWwgOiAwLjA7XG4gICAgdGhpcy5sMl9kZWNheV9tdWwgPSB0eXBlb2Ygb3B0LmwyX2RlY2F5X211bCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHQubDJfZGVjYXlfbXVsIDogMS4wO1xuXG4gICAgLy8gY29tcHV0ZWRcbiAgICAvLyBub3RlIHdlIGFyZSBkb2luZyBmbG9vciwgc28gaWYgdGhlIHN0cmlkZWQgY29udm9sdXRpb24gb2YgdGhlIGZpbHRlciBkb2VzbnQgZml0IGludG8gdGhlIGlucHV0XG4gICAgLy8gdm9sdW1lIGV4YWN0bHksIHRoZSBvdXRwdXQgdm9sdW1lIHdpbGwgYmUgdHJpbW1lZCBhbmQgbm90IGNvbnRhaW4gdGhlIChpbmNvbXBsZXRlKSBjb21wdXRlZFxuICAgIC8vIGZpbmFsIGFwcGxpY2F0aW9uLlxuICAgIHRoaXMub3V0X3N4ID0gTWF0aC5mbG9vcigodGhpcy5pbl9zeCArIHRoaXMucGFkICogMiAtIHRoaXMuc3gpIC8gdGhpcy5zdHJpZGUgKyAxKTtcbiAgICB0aGlzLm91dF9zeSA9IE1hdGguZmxvb3IoKHRoaXMuaW5fc3kgKyB0aGlzLnBhZCAqIDIgLSB0aGlzLnN5KSAvIHRoaXMuc3RyaWRlICsgMSk7XG4gICAgdGhpcy5sYXllcl90eXBlID0gJ2NvbnYnO1xuXG4gICAgLy8gaW5pdGlhbGl6YXRpb25zXG4gICAgdmFyIGJpYXMgPSB0eXBlb2Ygb3B0LmJpYXNfcHJlZiAhPT0gJ3VuZGVmaW5lZCcgPyBvcHQuYmlhc19wcmVmIDogMC4wO1xuICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgIGZvcih2YXIgaT0wO2k8dGhpcy5vdXRfZGVwdGg7aSsrKSB7IHRoaXMuZmlsdGVycy5wdXNoKG5ldyBWb2wodGhpcy5zeCwgdGhpcy5zeSwgdGhpcy5pbl9kZXB0aCkpOyB9XG4gICAgdGhpcy5iaWFzZXMgPSBuZXcgVm9sKDEsIDEsIHRoaXMub3V0X2RlcHRoLCBiaWFzKTtcbiAgfVxuICBDb252TGF5ZXIucHJvdG90eXBlID0ge1xuICAgIGZvcndhcmQ6IGZ1bmN0aW9uKFYsIGlzX3RyYWluaW5nKSB7XG4gICAgICB0aGlzLmluX2FjdCA9IFY7XG5cbiAgICAgIHZhciBBID0gbmV3IFZvbCh0aGlzLm91dF9zeCwgdGhpcy5vdXRfc3ksIHRoaXMub3V0X2RlcHRoLCAwLjApO1xuICAgICAgZm9yKHZhciBkPTA7ZDx0aGlzLm91dF9kZXB0aDtkKyspIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmZpbHRlcnNbZF07XG4gICAgICAgIHZhciB4ID0gLXRoaXMucGFkO1xuICAgICAgICB2YXIgeSA9IC10aGlzLnBhZDtcbiAgICAgICAgZm9yKHZhciBheD0wOyBheDx0aGlzLm91dF9zeDsgeCs9dGhpcy5zdHJpZGUsYXgrKykge1xuICAgICAgICAgIHkgPSAtdGhpcy5wYWQ7XG4gICAgICAgICAgZm9yKHZhciBheT0wOyBheTx0aGlzLm91dF9zeTsgeSs9dGhpcy5zdHJpZGUsYXkrKykge1xuXG4gICAgICAgICAgICAvLyBjb252b2x2ZSBjZW50ZXJlZCBhdCB0aGlzIHBhcnRpY3VsYXIgbG9jYXRpb25cbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIGJpdCBtb3JlIGVmZmljaWVudCwgZ29pbmcgZm9yIGNvcnJlY3RuZXNzIGZpcnN0XG4gICAgICAgICAgICB2YXIgYSA9IDAuMDtcbiAgICAgICAgICAgIGZvcih2YXIgZng9MDtmeDxmLnN4O2Z4KyspIHtcbiAgICAgICAgICAgICAgZm9yKHZhciBmeT0wO2Z5PGYuc3k7ZnkrKykge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgZmQ9MDtmZDxmLmRlcHRoO2ZkKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBveSA9IHkrZnk7IC8vIGNvb3JkaW5hdGVzIGluIHRoZSBvcmlnaW5hbCBpbnB1dCBhcnJheSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgdmFyIG94ID0geCtmeDtcbiAgICAgICAgICAgICAgICAgIGlmKG95Pj0wICYmIG95PFYuc3kgJiYgb3g+PTAgJiYgb3g8Vi5zeCkge1xuICAgICAgICAgICAgICAgICAgICAvL2EgKz0gZi5nZXQoZngsIGZ5LCBmZCkgKiBWLmdldChveCwgb3ksIGZkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgZnVuY3Rpb24gY2FsbCBvdmVyaGVhZCBmb3IgZWZmaWNpZW5jeSwgY29tcHJvbWlzZSBtb2R1bGFyaXR5IDooXG4gICAgICAgICAgICAgICAgICAgIGEgKz0gZi53WygoZi5zeCAqIGZ5KStmeCkqZi5kZXB0aCtmZF0gKiBWLndbKChWLnN4ICogb3kpK294KSpWLmRlcHRoK2ZkXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgKz0gdGhpcy5iaWFzZXMud1tkXTtcbiAgICAgICAgICAgIEEuc2V0KGF4LCBheSwgZCwgYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm91dF9hY3QgPSBBO1xuICAgICAgcmV0dXJuIHRoaXMub3V0X2FjdDtcbiAgICB9LFxuICAgIGJhY2t3YXJkOiBmdW5jdGlvbigpIHsgXG5cbiAgICAgIC8vIGNvbXB1dGUgZ3JhZGllbnQgd3J0IHdlaWdodHMsIGJpYXNlcyBhbmQgaW5wdXQgZGF0YVxuICAgICAgdmFyIFYgPSB0aGlzLmluX2FjdDtcbiAgICAgIFYuZHcgPSBnbG9iYWwuemVyb3MoVi53Lmxlbmd0aCk7IC8vIHplcm8gb3V0IGdyYWRpZW50IHdydCBib3R0b20gZGF0YSwgd2UncmUgYWJvdXQgdG8gZmlsbCBpdFxuICAgICAgZm9yKHZhciBkPTA7ZDx0aGlzLm91dF9kZXB0aDtkKyspIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmZpbHRlcnNbZF07XG4gICAgICAgIHZhciB4ID0gLXRoaXMucGFkO1xuICAgICAgICB2YXIgeSA9IC10aGlzLnBhZDtcbiAgICAgICAgZm9yKHZhciBheD0wOyBheDx0aGlzLm91dF9zeDsgeCs9dGhpcy5zdHJpZGUsYXgrKykge1xuICAgICAgICAgIHkgPSAtdGhpcy5wYWQ7XG4gICAgICAgICAgZm9yKHZhciBheT0wOyBheTx0aGlzLm91dF9zeTsgeSs9dGhpcy5zdHJpZGUsYXkrKykge1xuICAgICAgICAgICAgLy8gY29udm9sdmUgYW5kIGFkZCB1cCB0aGUgZ3JhZGllbnRzLiBcbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIG1vcmUgZWZmaWNpZW50LCBnb2luZyBmb3IgY29ycmVjdG5lc3MgZmlyc3RcbiAgICAgICAgICAgIHZhciBjaGFpbl9ncmFkID0gdGhpcy5vdXRfYWN0LmdldF9ncmFkKGF4LGF5LGQpOyAvLyBncmFkaWVudCBmcm9tIGFib3ZlLCBmcm9tIGNoYWluIHJ1bGVcbiAgICAgICAgICAgIGZvcih2YXIgZng9MDtmeDxmLnN4O2Z4KyspIHtcbiAgICAgICAgICAgICAgZm9yKHZhciBmeT0wO2Z5PGYuc3k7ZnkrKykge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgZmQ9MDtmZDxmLmRlcHRoO2ZkKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBveSA9IHkrZnk7XG4gICAgICAgICAgICAgICAgICB2YXIgb3ggPSB4K2Z4O1xuICAgICAgICAgICAgICAgICAgaWYob3k+PTAgJiYgb3k8Vi5zeSAmJiBveD49MCAmJiBveDxWLnN4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcndhcmQgcHJvcCBjYWxjdWxhdGVkOiBhICs9IGYuZ2V0KGZ4LCBmeSwgZmQpICogVi5nZXQob3gsIG95LCBmZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vZi5hZGRfZ3JhZChmeCwgZnksIGZkLCBWLmdldChveCwgb3ksIGZkKSAqIGNoYWluX2dyYWQpO1xuICAgICAgICAgICAgICAgICAgICAvL1YuYWRkX2dyYWQob3gsIG95LCBmZCwgZi5nZXQoZngsIGZ5LCBmZCkgKiBjaGFpbl9ncmFkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBhdm9pZCBmdW5jdGlvbiBjYWxsIG92ZXJoZWFkIGFuZCB1c2UgVm9scyBkaXJlY3RseSBmb3IgZWZmaWNpZW5jeVxuICAgICAgICAgICAgICAgICAgICB2YXIgaXgxID0gKChWLnN4ICogb3kpK294KSpWLmRlcHRoK2ZkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXgyID0gKChmLnN4ICogZnkpK2Z4KSpmLmRlcHRoK2ZkO1xuICAgICAgICAgICAgICAgICAgICBmLmR3W2l4Ml0gKz0gVi53W2l4MV0qY2hhaW5fZ3JhZDtcbiAgICAgICAgICAgICAgICAgICAgVi5kd1tpeDFdICs9IGYud1tpeDJdKmNoYWluX2dyYWQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJpYXNlcy5kd1tkXSArPSBjaGFpbl9ncmFkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UGFyYW1zQW5kR3JhZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3BvbnNlID0gW107XG4gICAgICBmb3IodmFyIGk9MDtpPHRoaXMub3V0X2RlcHRoO2krKykge1xuICAgICAgICByZXNwb25zZS5wdXNoKHtwYXJhbXM6IHRoaXMuZmlsdGVyc1tpXS53LCBncmFkczogdGhpcy5maWx0ZXJzW2ldLmR3LCBsMl9kZWNheV9tdWw6IHRoaXMubDJfZGVjYXlfbXVsLCBsMV9kZWNheV9tdWw6IHRoaXMubDFfZGVjYXlfbXVsfSk7XG4gICAgICB9XG4gICAgICByZXNwb25zZS5wdXNoKHtwYXJhbXM6IHRoaXMuYmlhc2VzLncsIGdyYWRzOiB0aGlzLmJpYXNlcy5kdywgbDFfZGVjYXlfbXVsOiAwLjAsIGwyX2RlY2F5X211bDogMC4wfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgIGpzb24uc3ggPSB0aGlzLnN4OyAvLyBmaWx0ZXIgc2l6ZSBpbiB4LCB5IGRpbXNcbiAgICAgIGpzb24uc3kgPSB0aGlzLnN5O1xuICAgICAganNvbi5zdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICAgIGpzb24uaW5fZGVwdGggPSB0aGlzLmluX2RlcHRoO1xuICAgICAganNvbi5vdXRfZGVwdGggPSB0aGlzLm91dF9kZXB0aDtcbiAgICAgIGpzb24ub3V0X3N4ID0gdGhpcy5vdXRfc3g7XG4gICAgICBqc29uLm91dF9zeSA9IHRoaXMub3V0X3N5O1xuICAgICAganNvbi5sYXllcl90eXBlID0gdGhpcy5sYXllcl90eXBlO1xuICAgICAganNvbi5sMV9kZWNheV9tdWwgPSB0aGlzLmwxX2RlY2F5X211bDtcbiAgICAgIGpzb24ubDJfZGVjYXlfbXVsID0gdGhpcy5sMl9kZWNheV9tdWw7XG4gICAgICBqc29uLnBhZCA9IHRoaXMucGFkO1xuICAgICAganNvbi5maWx0ZXJzID0gW107XG4gICAgICBmb3IodmFyIGk9MDtpPHRoaXMuZmlsdGVycy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIGpzb24uZmlsdGVycy5wdXNoKHRoaXMuZmlsdGVyc1tpXS50b0pTT04oKSk7XG4gICAgICB9XG4gICAgICBqc29uLmJpYXNlcyA9IHRoaXMuYmlhc2VzLnRvSlNPTigpO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcbiAgICBmcm9tSlNPTjogZnVuY3Rpb24oanNvbikge1xuICAgICAgdGhpcy5vdXRfZGVwdGggPSBqc29uLm91dF9kZXB0aDtcbiAgICAgIHRoaXMub3V0X3N4ID0ganNvbi5vdXRfc3g7XG4gICAgICB0aGlzLm91dF9zeSA9IGpzb24ub3V0X3N5O1xuICAgICAgdGhpcy5sYXllcl90eXBlID0ganNvbi5sYXllcl90eXBlO1xuICAgICAgdGhpcy5zeCA9IGpzb24uc3g7IC8vIGZpbHRlciBzaXplIGluIHgsIHkgZGltc1xuICAgICAgdGhpcy5zeSA9IGpzb24uc3k7XG4gICAgICB0aGlzLnN0cmlkZSA9IGpzb24uc3RyaWRlO1xuICAgICAgdGhpcy5pbl9kZXB0aCA9IGpzb24uaW5fZGVwdGg7IC8vIGRlcHRoIG9mIGlucHV0IHZvbHVtZVxuICAgICAgdGhpcy5maWx0ZXJzID0gW107XG4gICAgICB0aGlzLmwxX2RlY2F5X211bCA9IHR5cGVvZiBqc29uLmwxX2RlY2F5X211bCAhPT0gJ3VuZGVmaW5lZCcgPyBqc29uLmwxX2RlY2F5X211bCA6IDEuMDtcbiAgICAgIHRoaXMubDJfZGVjYXlfbXVsID0gdHlwZW9mIGpzb24ubDJfZGVjYXlfbXVsICE9PSAndW5kZWZpbmVkJyA/IGpzb24ubDJfZGVjYXlfbXVsIDogMS4wO1xuICAgICAgdGhpcy5wYWQgPSB0eXBlb2YganNvbi5wYWQgIT09ICd1bmRlZmluZWQnID8ganNvbi5wYWQgOiAwO1xuICAgICAgZm9yKHZhciBpPTA7aTxqc29uLmZpbHRlcnMubGVuZ3RoO2krKykge1xuICAgICAgICB2YXIgdiA9IG5ldyBWb2woMCwwLDAsMCk7XG4gICAgICAgIHYuZnJvbUpTT04oanNvbi5maWx0ZXJzW2ldKTtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2godik7XG4gICAgICB9XG4gICAgICB0aGlzLmJpYXNlcyA9IG5ldyBWb2woMCwwLDAsMCk7XG4gICAgICB0aGlzLmJpYXNlcy5mcm9tSlNPTihqc29uLmJpYXNlcyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIEZ1bGx5Q29ubkxheWVyID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgdmFyIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIC8vIHJlcXVpcmVkXG4gICAgLy8gb2sgZmluZSB3ZSB3aWxsIGFsbG93ICdmaWx0ZXJzJyBhcyB0aGUgd29yZCBhcyB3ZWxsXG4gICAgdGhpcy5vdXRfZGVwdGggPSB0eXBlb2Ygb3B0Lm51bV9uZXVyb25zICE9PSAndW5kZWZpbmVkJyA/IG9wdC5udW1fbmV1cm9ucyA6IG9wdC5maWx0ZXJzO1xuXG4gICAgLy8gb3B0aW9uYWwgXG4gICAgdGhpcy5sMV9kZWNheV9tdWwgPSB0eXBlb2Ygb3B0LmwxX2RlY2F5X211bCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHQubDFfZGVjYXlfbXVsIDogMC4wO1xuICAgIHRoaXMubDJfZGVjYXlfbXVsID0gdHlwZW9mIG9wdC5sMl9kZWNheV9tdWwgIT09ICd1bmRlZmluZWQnID8gb3B0LmwyX2RlY2F5X211bCA6IDEuMDtcblxuICAgIC8vIGNvbXB1dGVkXG4gICAgdGhpcy5udW1faW5wdXRzID0gb3B0LmluX3N4ICogb3B0LmluX3N5ICogb3B0LmluX2RlcHRoO1xuICAgIHRoaXMub3V0X3N4ID0gMTtcbiAgICB0aGlzLm91dF9zeSA9IDE7XG4gICAgdGhpcy5sYXllcl90eXBlID0gJ2ZjJztcblxuICAgIC8vIGluaXRpYWxpemF0aW9uc1xuICAgIHZhciBiaWFzID0gdHlwZW9mIG9wdC5iaWFzX3ByZWYgIT09ICd1bmRlZmluZWQnID8gb3B0LmJpYXNfcHJlZiA6IDAuMDtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICBmb3IodmFyIGk9MDtpPHRoaXMub3V0X2RlcHRoIDtpKyspIHsgdGhpcy5maWx0ZXJzLnB1c2gobmV3IFZvbCgxLCAxLCB0aGlzLm51bV9pbnB1dHMpKTsgfVxuICAgIHRoaXMuYmlhc2VzID0gbmV3IFZvbCgxLCAxLCB0aGlzLm91dF9kZXB0aCwgYmlhcyk7XG4gIH1cblxuICBGdWxseUNvbm5MYXllci5wcm90b3R5cGUgPSB7XG4gICAgZm9yd2FyZDogZnVuY3Rpb24oViwgaXNfdHJhaW5pbmcpIHtcbiAgICAgIHRoaXMuaW5fYWN0ID0gVjtcbiAgICAgIHZhciBBID0gbmV3IFZvbCgxLCAxLCB0aGlzLm91dF9kZXB0aCwgMC4wKTtcbiAgICAgIHZhciBWdyA9IFYudztcbiAgICAgIGZvcih2YXIgaT0wO2k8dGhpcy5vdXRfZGVwdGg7aSsrKSB7XG4gICAgICAgIHZhciBhID0gMC4wO1xuICAgICAgICB2YXIgd2kgPSB0aGlzLmZpbHRlcnNbaV0udztcbiAgICAgICAgZm9yKHZhciBkPTA7ZDx0aGlzLm51bV9pbnB1dHM7ZCsrKSB7XG4gICAgICAgICAgYSArPSBWd1tkXSAqIHdpW2RdOyAvLyBmb3IgZWZmaWNpZW5jeSB1c2UgVm9scyBkaXJlY3RseSBmb3Igbm93XG4gICAgICAgIH1cbiAgICAgICAgYSArPSB0aGlzLmJpYXNlcy53W2ldO1xuICAgICAgICBBLndbaV0gPSBhO1xuICAgICAgfVxuICAgICAgdGhpcy5vdXRfYWN0ID0gQTtcbiAgICAgIHJldHVybiB0aGlzLm91dF9hY3Q7XG4gICAgfSxcbiAgICBiYWNrd2FyZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgViA9IHRoaXMuaW5fYWN0O1xuICAgICAgVi5kdyA9IGdsb2JhbC56ZXJvcyhWLncubGVuZ3RoKTsgLy8gemVybyBvdXQgdGhlIGdyYWRpZW50IGluIGlucHV0IFZvbFxuICAgICAgXG4gICAgICAvLyBjb21wdXRlIGdyYWRpZW50IHdydCB3ZWlnaHRzIGFuZCBkYXRhXG4gICAgICBmb3IodmFyIGk9MDtpPHRoaXMub3V0X2RlcHRoO2krKykge1xuICAgICAgICB2YXIgdGZpID0gdGhpcy5maWx0ZXJzW2ldO1xuICAgICAgICB2YXIgY2hhaW5fZ3JhZCA9IHRoaXMub3V0X2FjdC5kd1tpXTtcbiAgICAgICAgZm9yKHZhciBkPTA7ZDx0aGlzLm51bV9pbnB1dHM7ZCsrKSB7XG4gICAgICAgICAgVi5kd1tkXSArPSB0Zmkud1tkXSpjaGFpbl9ncmFkOyAvLyBncmFkIHdydCBpbnB1dCBkYXRhXG4gICAgICAgICAgdGZpLmR3W2RdICs9IFYud1tkXSpjaGFpbl9ncmFkOyAvLyBncmFkIHdydCBwYXJhbXNcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJpYXNlcy5kd1tpXSArPSBjaGFpbl9ncmFkO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UGFyYW1zQW5kR3JhZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3BvbnNlID0gW107XG4gICAgICBmb3IodmFyIGk9MDtpPHRoaXMub3V0X2RlcHRoO2krKykge1xuICAgICAgICByZXNwb25zZS5wdXNoKHtwYXJhbXM6IHRoaXMuZmlsdGVyc1tpXS53LCBncmFkczogdGhpcy5maWx0ZXJzW2ldLmR3LCBsMV9kZWNheV9tdWw6IHRoaXMubDFfZGVjYXlfbXVsLCBsMl9kZWNheV9tdWw6IHRoaXMubDJfZGVjYXlfbXVsfSk7XG4gICAgICB9XG4gICAgICByZXNwb25zZS5wdXNoKHtwYXJhbXM6IHRoaXMuYmlhc2VzLncsIGdyYWRzOiB0aGlzLmJpYXNlcy5kdywgbDFfZGVjYXlfbXVsOiAwLjAsIGwyX2RlY2F5X211bDogMC4wfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgIGpzb24ub3V0X2RlcHRoID0gdGhpcy5vdXRfZGVwdGg7XG4gICAgICBqc29uLm91dF9zeCA9IHRoaXMub3V0X3N4O1xuICAgICAganNvbi5vdXRfc3kgPSB0aGlzLm91dF9zeTtcbiAgICAgIGpzb24ubGF5ZXJfdHlwZSA9IHRoaXMubGF5ZXJfdHlwZTtcbiAgICAgIGpzb24ubnVtX2lucHV0cyA9IHRoaXMubnVtX2lucHV0cztcbiAgICAgIGpzb24ubDFfZGVjYXlfbXVsID0gdGhpcy5sMV9kZWNheV9tdWw7XG4gICAgICBqc29uLmwyX2RlY2F5X211bCA9IHRoaXMubDJfZGVjYXlfbXVsO1xuICAgICAganNvbi5maWx0ZXJzID0gW107XG4gICAgICBmb3IodmFyIGk9MDtpPHRoaXMuZmlsdGVycy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIGpzb24uZmlsdGVycy5wdXNoKHRoaXMuZmlsdGVyc1tpXS50b0pTT04oKSk7XG4gICAgICB9XG4gICAgICBqc29uLmJpYXNlcyA9IHRoaXMuYmlhc2VzLnRvSlNPTigpO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcbiAgICBmcm9tSlNPTjogZnVuY3Rpb24oanNvbikge1xuICAgICAgdGhpcy5vdXRfZGVwdGggPSBqc29uLm91dF9kZXB0aDtcbiAgICAgIHRoaXMub3V0X3N4ID0ganNvbi5vdXRfc3g7XG4gICAgICB0aGlzLm91dF9zeSA9IGpzb24ub3V0X3N5O1xuICAgICAgdGhpcy5sYXllcl90eXBlID0ganNvbi5sYXllcl90eXBlO1xuICAgICAgdGhpcy5udW1faW5wdXRzID0ganNvbi5udW1faW5wdXRzO1xuICAgICAgdGhpcy5sMV9kZWNheV9tdWwgPSB0eXBlb2YganNvbi5sMV9kZWNheV9tdWwgIT09ICd1bmRlZmluZWQnID8ganNvbi5sMV9kZWNheV9tdWwgOiAxLjA7XG4gICAgICB0aGlzLmwyX2RlY2F5X211bCA9IHR5cGVvZiBqc29uLmwyX2RlY2F5X211bCAhPT0gJ3VuZGVmaW5lZCcgPyBqc29uLmwyX2RlY2F5X211bCA6IDEuMDtcbiAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgICAgZm9yKHZhciBpPTA7aTxqc29uLmZpbHRlcnMubGVuZ3RoO2krKykge1xuICAgICAgICB2YXIgdiA9IG5ldyBWb2woMCwwLDAsMCk7XG4gICAgICAgIHYuZnJvbUpTT04oanNvbi5maWx0ZXJzW2ldKTtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2godik7XG4gICAgICB9XG4gICAgICB0aGlzLmJpYXNlcyA9IG5ldyBWb2woMCwwLDAsMCk7XG4gICAgICB0aGlzLmJpYXNlcy5mcm9tSlNPTihqc29uLmJpYXNlcyk7XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsLkNvbnZMYXllciA9IENvbnZMYXllcjtcbiAgZ2xvYmFsLkZ1bGx5Q29ubkxheWVyID0gRnVsbHlDb25uTGF5ZXI7XG4gIFxufSkoY29udm5ldGpzKTtcbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBWb2wgPSBnbG9iYWwuVm9sOyAvLyBjb252ZW5pZW5jZVxuICBcbiAgdmFyIFBvb2xMYXllciA9IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgdmFyIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIC8vIHJlcXVpcmVkXG4gICAgdGhpcy5zeCA9IG9wdC5zeDsgLy8gZmlsdGVyIHNpemVcbiAgICB0aGlzLmluX2RlcHRoID0gb3B0LmluX2RlcHRoO1xuICAgIHRoaXMuaW5fc3ggPSBvcHQuaW5fc3g7XG4gICAgdGhpcy5pbl9zeSA9IG9wdC5pbl9zeTtcblxuICAgIC8vIG9wdGlvbmFsXG4gICAgdGhpcy5zeSA9IHR5cGVvZiBvcHQuc3kgIT09ICd1bmRlZmluZWQnID8gb3B0LnN5IDogdGhpcy5zeDtcbiAgICB0aGlzLnN0cmlkZSA9IHR5cGVvZiBvcHQuc3RyaWRlICE9PSAndW5kZWZpbmVkJyA/IG9wdC5zdHJpZGUgOiAyO1xuICAgIHRoaXMucGFkID0gdHlwZW9mIG9wdC5wYWQgIT09ICd1bmRlZmluZWQnID8gb3B0LnBhZCA6IDA7IC8vIGFtb3VudCBvZiAwIHBhZGRpbmcgdG8gYWRkIGFyb3VuZCBib3JkZXJzIG9mIGlucHV0IHZvbHVtZVxuXG4gICAgLy8gY29tcHV0ZWRcbiAgICB0aGlzLm91dF9kZXB0aCA9IHRoaXMuaW5fZGVwdGg7XG4gICAgdGhpcy5vdXRfc3ggPSBNYXRoLmZsb29yKCh0aGlzLmluX3N4ICsgdGhpcy5wYWQgKiAyIC0gdGhpcy5zeCkgLyB0aGlzLnN0cmlkZSArIDEpO1xuICAgIHRoaXMub3V0X3N5ID0gTWF0aC5mbG9vcigodGhpcy5pbl9zeSArIHRoaXMucGFkICogMiAtIHRoaXMuc3kpIC8gdGhpcy5zdHJpZGUgKyAxKTtcbiAgICB0aGlzLmxheWVyX3R5cGUgPSAncG9vbCc7XG4gICAgLy8gc3RvcmUgc3dpdGNoZXMgZm9yIHgseSBjb29yZGluYXRlcyBmb3Igd2hlcmUgdGhlIG1heCBjb21lcyBmcm9tLCBmb3IgZWFjaCBvdXRwdXQgbmV1cm9uXG4gICAgdGhpcy5zd2l0Y2h4ID0gZ2xvYmFsLnplcm9zKHRoaXMub3V0X3N4KnRoaXMub3V0X3N5KnRoaXMub3V0X2RlcHRoKTtcbiAgICB0aGlzLnN3aXRjaHkgPSBnbG9iYWwuemVyb3ModGhpcy5vdXRfc3gqdGhpcy5vdXRfc3kqdGhpcy5vdXRfZGVwdGgpO1xuICB9XG5cbiAgUG9vbExheWVyLnByb3RvdHlwZSA9IHtcbiAgICBmb3J3YXJkOiBmdW5jdGlvbihWLCBpc190cmFpbmluZykge1xuICAgICAgdGhpcy5pbl9hY3QgPSBWO1xuXG4gICAgICB2YXIgQSA9IG5ldyBWb2wodGhpcy5vdXRfc3gsIHRoaXMub3V0X3N5LCB0aGlzLm91dF9kZXB0aCwgMC4wKTtcbiAgICAgIFxuICAgICAgdmFyIG49MDsgLy8gYSBjb3VudGVyIGZvciBzd2l0Y2hlc1xuICAgICAgZm9yKHZhciBkPTA7ZDx0aGlzLm91dF9kZXB0aDtkKyspIHtcbiAgICAgICAgdmFyIHggPSAtdGhpcy5wYWQ7XG4gICAgICAgIHZhciB5ID0gLXRoaXMucGFkO1xuICAgICAgICBmb3IodmFyIGF4PTA7IGF4PHRoaXMub3V0X3N4OyB4Kz10aGlzLnN0cmlkZSxheCsrKSB7XG4gICAgICAgICAgeSA9IC10aGlzLnBhZDtcbiAgICAgICAgICBmb3IodmFyIGF5PTA7IGF5PHRoaXMub3V0X3N5OyB5Kz10aGlzLnN0cmlkZSxheSsrKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbnZvbHZlIGNlbnRlcmVkIGF0IHRoaXMgcGFydGljdWxhciBsb2NhdGlvblxuICAgICAgICAgICAgdmFyIGEgPSAtOTk5OTk7IC8vIGhvcGVmdWxseSBzbWFsbCBlbm91Z2ggO1xcXG4gICAgICAgICAgICB2YXIgd2lueD0tMSx3aW55PS0xO1xuICAgICAgICAgICAgZm9yKHZhciBmeD0wO2Z4PHRoaXMuc3g7ZngrKykge1xuICAgICAgICAgICAgICBmb3IodmFyIGZ5PTA7Znk8dGhpcy5zeTtmeSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG95ID0geStmeTtcbiAgICAgICAgICAgICAgICB2YXIgb3ggPSB4K2Z4O1xuICAgICAgICAgICAgICAgIGlmKG95Pj0wICYmIG95PFYuc3kgJiYgb3g+PTAgJiYgb3g8Vi5zeCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHYgPSBWLmdldChveCwgb3ksIGQpO1xuICAgICAgICAgICAgICAgICAgLy8gcGVyZm9ybSBtYXggcG9vbGluZyBhbmQgc3RvcmUgcG9pbnRlcnMgdG8gd2hlcmVcbiAgICAgICAgICAgICAgICAgIC8vIHRoZSBtYXggY2FtZSBmcm9tLiBUaGlzIHdpbGwgc3BlZWQgdXAgYmFja3Byb3AgXG4gICAgICAgICAgICAgICAgICAvLyBhbmQgY2FuIGhlbHAgbWFrZSBuaWNlIHZpc3VhbGl6YXRpb25zIGluIGZ1dHVyZVxuICAgICAgICAgICAgICAgICAgaWYodiA+IGEpIHsgYSA9IHY7IHdpbng9b3g7IHdpbnk9b3k7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zd2l0Y2h4W25dID0gd2lueDtcbiAgICAgICAgICAgIHRoaXMuc3dpdGNoeVtuXSA9IHdpbnk7XG4gICAgICAgICAgICBuKys7XG4gICAgICAgICAgICBBLnNldChheCwgYXksIGQsIGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vdXRfYWN0ID0gQTtcbiAgICAgIHJldHVybiB0aGlzLm91dF9hY3Q7XG4gICAgfSxcbiAgICBiYWNrd2FyZDogZnVuY3Rpb24oKSB7IFxuICAgICAgLy8gcG9vbGluZyBsYXllcnMgaGF2ZSBubyBwYXJhbWV0ZXJzLCBzbyBzaW1wbHkgY29tcHV0ZSBcbiAgICAgIC8vIGdyYWRpZW50IHdydCBkYXRhIGhlcmVcbiAgICAgIHZhciBWID0gdGhpcy5pbl9hY3Q7XG4gICAgICBWLmR3ID0gZ2xvYmFsLnplcm9zKFYudy5sZW5ndGgpOyAvLyB6ZXJvIG91dCBncmFkaWVudCB3cnQgZGF0YVxuICAgICAgdmFyIEEgPSB0aGlzLm91dF9hY3Q7IC8vIGNvbXB1dGVkIGluIGZvcndhcmQgcGFzcyBcblxuICAgICAgdmFyIG4gPSAwO1xuICAgICAgZm9yKHZhciBkPTA7ZDx0aGlzLm91dF9kZXB0aDtkKyspIHtcbiAgICAgICAgdmFyIHggPSAtdGhpcy5wYWQ7XG4gICAgICAgIHZhciB5ID0gLXRoaXMucGFkO1xuICAgICAgICBmb3IodmFyIGF4PTA7IGF4PHRoaXMub3V0X3N4OyB4Kz10aGlzLnN0cmlkZSxheCsrKSB7XG4gICAgICAgICAgeSA9IC10aGlzLnBhZDtcbiAgICAgICAgICBmb3IodmFyIGF5PTA7IGF5PHRoaXMub3V0X3N5OyB5Kz10aGlzLnN0cmlkZSxheSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGFpbl9ncmFkID0gdGhpcy5vdXRfYWN0LmdldF9ncmFkKGF4LGF5LGQpO1xuICAgICAgICAgICAgVi5hZGRfZ3JhZCh0aGlzLnN3aXRjaHhbbl0sIHRoaXMuc3dpdGNoeVtuXSwgZCwgY2hhaW5fZ3JhZCk7XG4gICAgICAgICAgICBuKys7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFBhcmFtc0FuZEdyYWRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIganNvbiA9IHt9O1xuICAgICAganNvbi5zeCA9IHRoaXMuc3g7XG4gICAgICBqc29uLnN5ID0gdGhpcy5zeTtcbiAgICAgIGpzb24uc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgICBqc29uLmluX2RlcHRoID0gdGhpcy5pbl9kZXB0aDtcbiAgICAgIGpzb24ub3V0X2RlcHRoID0gdGhpcy5vdXRfZGVwdGg7XG4gICAgICBqc29uLm91dF9zeCA9IHRoaXMub3V0X3N4O1xuICAgICAganNvbi5vdXRfc3kgPSB0aGlzLm91dF9zeTtcbiAgICAgIGpzb24ubGF5ZXJfdHlwZSA9IHRoaXMubGF5ZXJfdHlwZTtcbiAgICAgIGpzb24ucGFkID0gdGhpcy5wYWQ7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuICAgIGZyb21KU09OOiBmdW5jdGlvbihqc29uKSB7XG4gICAgICB0aGlzLm91dF9kZXB0aCA9IGpzb24ub3V0X2RlcHRoO1xuICAgICAgdGhpcy5vdXRfc3ggPSBqc29uLm91dF9zeDtcbiAgICAgIHRoaXMub3V0X3N5ID0ganNvbi5vdXRfc3k7XG4gICAgICB0aGlzLmxheWVyX3R5cGUgPSBqc29uLmxheWVyX3R5cGU7XG4gICAgICB0aGlzLnN4ID0ganNvbi5zeDtcbiAgICAgIHRoaXMuc3kgPSBqc29uLnN5O1xuICAgICAgdGhpcy5zdHJpZGUgPSBqc29uLnN0cmlkZTtcbiAgICAgIHRoaXMuaW5fZGVwdGggPSBqc29uLmluX2RlcHRoO1xuICAgICAgdGhpcy5wYWQgPSB0eXBlb2YganNvbi5wYWQgIT09ICd1bmRlZmluZWQnID8ganNvbi5wYWQgOiAwOyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgdGhpcy5zd2l0Y2h4ID0gZ2xvYmFsLnplcm9zKHRoaXMub3V0X3N4KnRoaXMub3V0X3N5KnRoaXMub3V0X2RlcHRoKTsgLy8gbmVlZCB0byByZS1pbml0IHRoZXNlIGFwcHJvcHJpYXRlbHlcbiAgICAgIHRoaXMuc3dpdGNoeSA9IGdsb2JhbC56ZXJvcyh0aGlzLm91dF9zeCp0aGlzLm91dF9zeSp0aGlzLm91dF9kZXB0aCk7XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsLlBvb2xMYXllciA9IFBvb2xMYXllcjtcblxufSkoY29udm5ldGpzKTtcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIFZvbCA9IGdsb2JhbC5Wb2w7IC8vIGNvbnZlbmllbmNlXG4gIFxuICB2YXIgSW5wdXRMYXllciA9IGZ1bmN0aW9uKG9wdCkge1xuICAgIHZhciBvcHQgPSBvcHQgfHwge307XG5cbiAgICAvLyB0aGlzIGlzIGEgYml0IHNpbGx5IGJ1dCBsZXRzIGFsbG93IHBlb3BsZSB0byBzcGVjaWZ5IGVpdGhlciBpbnMgb3Igb3V0c1xuICAgIHRoaXMub3V0X3N4ID0gdHlwZW9mIG9wdC5vdXRfc3ggIT09ICd1bmRlZmluZWQnID8gb3B0Lm91dF9zeCA6IG9wdC5pbl9zeDtcbiAgICB0aGlzLm91dF9zeSA9IHR5cGVvZiBvcHQub3V0X3N5ICE9PSAndW5kZWZpbmVkJyA/IG9wdC5vdXRfc3kgOiBvcHQuaW5fc3k7XG4gICAgdGhpcy5vdXRfZGVwdGggPSB0eXBlb2Ygb3B0Lm91dF9kZXB0aCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHQub3V0X2RlcHRoIDogb3B0LmluX2RlcHRoO1xuICAgIHRoaXMubGF5ZXJfdHlwZSA9ICdpbnB1dCc7XG4gIH1cbiAgSW5wdXRMYXllci5wcm90b3R5cGUgPSB7XG4gICAgZm9yd2FyZDogZnVuY3Rpb24oViwgaXNfdHJhaW5pbmcpIHtcbiAgICAgIHRoaXMuaW5fYWN0ID0gVjtcbiAgICAgIHRoaXMub3V0X2FjdCA9IFY7XG4gICAgICByZXR1cm4gdGhpcy5vdXRfYWN0OyAvLyBkdW1teSBpZGVudGl0eSBmdW5jdGlvbiBmb3Igbm93XG4gICAgfSxcbiAgICBiYWNrd2FyZDogZnVuY3Rpb24oKSB7IH0sXG4gICAgZ2V0UGFyYW1zQW5kR3JhZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBqc29uID0ge307XG4gICAgICBqc29uLm91dF9kZXB0aCA9IHRoaXMub3V0X2RlcHRoO1xuICAgICAganNvbi5vdXRfc3ggPSB0aGlzLm91dF9zeDtcbiAgICAgIGpzb24ub3V0X3N5ID0gdGhpcy5vdXRfc3k7XG4gICAgICBqc29uLmxheWVyX3R5cGUgPSB0aGlzLmxheWVyX3R5cGU7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuICAgIGZyb21KU09OOiBmdW5jdGlvbihqc29uKSB7XG4gICAgICB0aGlzLm91dF9kZXB0aCA9IGpzb24ub3V0X2RlcHRoO1xuICAgICAgdGhpcy5vdXRfc3ggPSBqc29uLm91dF9zeDtcbiAgICAgIHRoaXMub3V0X3N5ID0ganNvbi5vdXRfc3k7XG4gICAgICB0aGlzLmxheWVyX3R5cGUgPSBqc29uLmxheWVyX3R5cGU7IFxuICAgIH1cbiAgfVxuXG4gIGdsb2JhbC5JbnB1dExheWVyID0gSW5wdXRMYXllcjtcbn0pKGNvbnZuZXRqcyk7XG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgVm9sID0gZ2xvYmFsLlZvbDsgLy8gY29udmVuaWVuY2VcbiAgXG4gIC8vIExheWVycyB0aGF0IGltcGxlbWVudCBhIGxvc3MuIEN1cnJlbnRseSB0aGVzZSBhcmUgdGhlIGxheWVycyB0aGF0IFxuICAvLyBjYW4gaW5pdGlhdGUgYSBiYWNrd2FyZCgpIHBhc3MuIEluIGZ1dHVyZSB3ZSBwcm9iYWJseSB3YW50IGEgbW9yZSBcbiAgLy8gZmxleGlibGUgc3lzdGVtIHRoYXQgY2FuIGFjY29tb2RhdGUgbXVsdGlwbGUgbG9zc2VzIHRvIGRvIG11bHRpLXRhc2tcbiAgLy8gbGVhcm5pbmcsIGFuZCBzdHVmZiBsaWtlIHRoYXQuIEJ1dCBmb3Igbm93LCBvbmUgb2YgdGhlIGxheWVycyBpbiB0aGlzXG4gIC8vIGZpbGUgbXVzdCBiZSB0aGUgZmluYWwgbGF5ZXIgaW4gYSBOZXQuXG5cbiAgLy8gVGhpcyBpcyBhIGNsYXNzaWZpZXIsIHdpdGggTiBkaXNjcmV0ZSBjbGFzc2VzIGZyb20gMCB0byBOLTFcbiAgLy8gaXQgZ2V0cyBhIHN0cmVhbSBvZiBOIGluY29taW5nIG51bWJlcnMgYW5kIGNvbXB1dGVzIHRoZSBzb2Z0bWF4XG4gIC8vIGZ1bmN0aW9uIChleHBvbmVudGlhdGUgYW5kIG5vcm1hbGl6ZSB0byBzdW0gdG8gMSBhcyBwcm9iYWJpbGl0aWVzIHNob3VsZClcbiAgdmFyIFNvZnRtYXhMYXllciA9IGZ1bmN0aW9uKG9wdCkge1xuICAgIHZhciBvcHQgPSBvcHQgfHwge307XG5cbiAgICAvLyBjb21wdXRlZFxuICAgIHRoaXMubnVtX2lucHV0cyA9IG9wdC5pbl9zeCAqIG9wdC5pbl9zeSAqIG9wdC5pbl9kZXB0aDtcbiAgICB0aGlzLm91dF9kZXB0aCA9IHRoaXMubnVtX2lucHV0cztcbiAgICB0aGlzLm91dF9zeCA9IDE7XG4gICAgdGhpcy5vdXRfc3kgPSAxO1xuICAgIHRoaXMubGF5ZXJfdHlwZSA9ICdzb2Z0bWF4JztcbiAgfVxuXG4gIFNvZnRtYXhMYXllci5wcm90b3R5cGUgPSB7XG4gICAgZm9yd2FyZDogZnVuY3Rpb24oViwgaXNfdHJhaW5pbmcpIHtcbiAgICAgIHRoaXMuaW5fYWN0ID0gVjtcblxuICAgICAgdmFyIEEgPSBuZXcgVm9sKDEsIDEsIHRoaXMub3V0X2RlcHRoLCAwLjApO1xuXG4gICAgICAvLyBjb21wdXRlIG1heCBhY3RpdmF0aW9uXG4gICAgICB2YXIgYXMgPSBWLnc7XG4gICAgICB2YXIgYW1heCA9IFYud1swXTtcbiAgICAgIGZvcih2YXIgaT0xO2k8dGhpcy5vdXRfZGVwdGg7aSsrKSB7XG4gICAgICAgIGlmKGFzW2ldID4gYW1heCkgYW1heCA9IGFzW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBjb21wdXRlIGV4cG9uZW50aWFscyAoY2FyZWZ1bGx5IHRvIG5vdCBibG93IHVwKVxuICAgICAgdmFyIGVzID0gZ2xvYmFsLnplcm9zKHRoaXMub3V0X2RlcHRoKTtcbiAgICAgIHZhciBlc3VtID0gMC4wO1xuICAgICAgZm9yKHZhciBpPTA7aTx0aGlzLm91dF9kZXB0aDtpKyspIHtcbiAgICAgICAgdmFyIGUgPSBNYXRoLmV4cChhc1tpXSAtIGFtYXgpO1xuICAgICAgICBlc3VtICs9IGU7XG4gICAgICAgIGVzW2ldID0gZTtcbiAgICAgIH1cblxuICAgICAgLy8gbm9ybWFsaXplIGFuZCBvdXRwdXQgdG8gc3VtIHRvIG9uZVxuICAgICAgZm9yKHZhciBpPTA7aTx0aGlzLm91dF9kZXB0aDtpKyspIHtcbiAgICAgICAgZXNbaV0gLz0gZXN1bTtcbiAgICAgICAgQS53W2ldID0gZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXMgPSBlczsgLy8gc2F2ZSB0aGVzZSBmb3IgYmFja3Byb3BcbiAgICAgIHRoaXMub3V0X2FjdCA9IEE7XG4gICAgICByZXR1cm4gdGhpcy5vdXRfYWN0O1xuICAgIH0sXG4gICAgYmFja3dhcmQ6IGZ1bmN0aW9uKHkpIHtcblxuICAgICAgLy8gY29tcHV0ZSBhbmQgYWNjdW11bGF0ZSBncmFkaWVudCB3cnQgd2VpZ2h0cyBhbmQgYmlhcyBvZiB0aGlzIGxheWVyXG4gICAgICB2YXIgeCA9IHRoaXMuaW5fYWN0O1xuICAgICAgeC5kdyA9IGdsb2JhbC56ZXJvcyh4LncubGVuZ3RoKTsgLy8gemVybyBvdXQgdGhlIGdyYWRpZW50IG9mIGlucHV0IFZvbFxuXG4gICAgICBmb3IodmFyIGk9MDtpPHRoaXMub3V0X2RlcHRoO2krKykge1xuICAgICAgICB2YXIgaW5kaWNhdG9yID0gaSA9PT0geSA/IDEuMCA6IDAuMDtcbiAgICAgICAgdmFyIG11bCA9IC0oaW5kaWNhdG9yIC0gdGhpcy5lc1tpXSk7XG4gICAgICAgIHguZHdbaV0gPSBtdWw7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvc3MgaXMgdGhlIGNsYXNzIG5lZ2F0aXZlIGxvZyBsaWtlbGlob29kXG4gICAgICByZXR1cm4gLU1hdGgubG9nKHRoaXMuZXNbeV0pO1xuICAgIH0sXG4gICAgZ2V0UGFyYW1zQW5kR3JhZHM6IGZ1bmN0aW9uKCkgeyBcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIganNvbiA9IHt9O1xuICAgICAganNvbi5vdXRfZGVwdGggPSB0aGlzLm91dF9kZXB0aDtcbiAgICAgIGpzb24ub3V0X3N4ID0gdGhpcy5vdXRfc3g7XG4gICAgICBqc29uLm91dF9zeSA9IHRoaXMub3V0X3N5O1xuICAgICAganNvbi5sYXllcl90eXBlID0gdGhpcy5sYXllcl90eXBlO1xuICAgICAganNvbi5udW1faW5wdXRzID0gdGhpcy5udW1faW5wdXRzO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcbiAgICBmcm9tSlNPTjogZnVuY3Rpb24oanNvbikge1xuICAgICAgdGhpcy5vdXRfZGVwdGggPSBqc29uLm91dF9kZXB0aDtcbiAgICAgIHRoaXMub3V0X3N4ID0ganNvbi5vdXRfc3g7XG4gICAgICB0aGlzLm91dF9zeSA9IGpzb24ub3V0X3N5O1xuICAgICAgdGhpcy5sYXllcl90eXBlID0ganNvbi5sYXllcl90eXBlO1xuICAgICAgdGhpcy5udW1faW5wdXRzID0ganNvbi5udW1faW5wdXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIGltcGxlbWVudHMgYW4gTDIgcmVncmVzc2lvbiBjb3N0IGxheWVyLFxuICAvLyBzbyBwZW5hbGl6ZXMgXFxzdW1faSh8fHhfaSAtIHlfaXx8XjIpLCB3aGVyZSB4IGlzIGl0cyBpbnB1dFxuICAvLyBhbmQgeSBpcyB0aGUgdXNlci1wcm92aWRlZCBhcnJheSBvZiBcImNvcnJlY3RcIiB2YWx1ZXMuXG4gIHZhciBSZWdyZXNzaW9uTGF5ZXIgPSBmdW5jdGlvbihvcHQpIHtcbiAgICB2YXIgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgLy8gY29tcHV0ZWRcbiAgICB0aGlzLm51bV9pbnB1dHMgPSBvcHQuaW5fc3ggKiBvcHQuaW5fc3kgKiBvcHQuaW5fZGVwdGg7XG4gICAgdGhpcy5vdXRfZGVwdGggPSB0aGlzLm51bV9pbnB1dHM7XG4gICAgdGhpcy5vdXRfc3ggPSAxO1xuICAgIHRoaXMub3V0X3N5ID0gMTtcbiAgICB0aGlzLmxheWVyX3R5cGUgPSAncmVncmVzc2lvbic7XG4gIH1cblxuICBSZWdyZXNzaW9uTGF5ZXIucHJvdG90eXBlID0ge1xuICAgIGZvcndhcmQ6IGZ1bmN0aW9uKFYsIGlzX3RyYWluaW5nKSB7XG4gICAgICB0aGlzLmluX2FjdCA9IFY7XG4gICAgICB0aGlzLm91dF9hY3QgPSBWO1xuICAgICAgcmV0dXJuIFY7IC8vIGlkZW50aXR5IGZ1bmN0aW9uXG4gICAgfSxcbiAgICAvLyB5IGlzIGEgbGlzdCBoZXJlIG9mIHNpemUgbnVtX2lucHV0c1xuICAgIGJhY2t3YXJkOiBmdW5jdGlvbih5KSB7IFxuXG4gICAgICAvLyBjb21wdXRlIGFuZCBhY2N1bXVsYXRlIGdyYWRpZW50IHdydCB3ZWlnaHRzIGFuZCBiaWFzIG9mIHRoaXMgbGF5ZXJcbiAgICAgIHZhciB4ID0gdGhpcy5pbl9hY3Q7XG4gICAgICB4LmR3ID0gZ2xvYmFsLnplcm9zKHgudy5sZW5ndGgpOyAvLyB6ZXJvIG91dCB0aGUgZ3JhZGllbnQgb2YgaW5wdXQgVm9sXG4gICAgICB2YXIgbG9zcyA9IDAuMDtcbiAgICAgIGlmKHkgaW5zdGFuY2VvZiBBcnJheSB8fCB5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSB7XG4gICAgICAgIGZvcih2YXIgaT0wO2k8dGhpcy5vdXRfZGVwdGg7aSsrKSB7XG4gICAgICAgICAgdmFyIGR5ID0geC53W2ldIC0geVtpXTtcbiAgICAgICAgICB4LmR3W2ldID0gZHk7XG4gICAgICAgICAgbG9zcyArPSAyKmR5KmR5O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhc3N1bWUgaXQgaXMgYSBzdHJ1Y3Qgd2l0aCBlbnRyaWVzIC5kaW0gYW5kIC52YWxcbiAgICAgICAgLy8gYW5kIHdlIHBhc3MgZ3JhZGllbnQgb25seSBhbG9uZyBkaW1lbnNpb24gZGltIHRvIGJlIGVxdWFsIHRvIHZhbFxuICAgICAgICB2YXIgaSA9IHkuZGltO1xuICAgICAgICB2YXIgeWkgPSB5LnZhbDtcbiAgICAgICAgdmFyIGR5ID0geC53W2ldIC0geWk7XG4gICAgICAgIHguZHdbaV0gPSBkeTtcbiAgICAgICAgbG9zcyArPSAyKmR5KmR5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvc3M7XG4gICAgfSxcbiAgICBnZXRQYXJhbXNBbmRHcmFkczogZnVuY3Rpb24oKSB7IFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBqc29uID0ge307XG4gICAgICBqc29uLm91dF9kZXB0aCA9IHRoaXMub3V0X2RlcHRoO1xuICAgICAganNvbi5vdXRfc3ggPSB0aGlzLm91dF9zeDtcbiAgICAgIGpzb24ub3V0X3N5ID0gdGhpcy5vdXRfc3k7XG4gICAgICBqc29uLmxheWVyX3R5cGUgPSB0aGlzLmxheWVyX3R5cGU7XG4gICAgICBqc29uLm51bV9pbnB1dHMgPSB0aGlzLm51bV9pbnB1dHM7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuICAgIGZyb21KU09OOiBmdW5jdGlvbihqc29uKSB7XG4gICAgICB0aGlzLm91dF9kZXB0aCA9IGpzb24ub3V0X2RlcHRoO1xuICAgICAgdGhpcy5vdXRfc3ggPSBqc29uLm91dF9zeDtcbiAgICAgIHRoaXMub3V0X3N5ID0ganNvbi5vdXRfc3k7XG4gICAgICB0aGlzLmxheWVyX3R5cGUgPSBqc29uLmxheWVyX3R5cGU7XG4gICAgICB0aGlzLm51bV9pbnB1dHMgPSBqc29uLm51bV9pbnB1dHM7XG4gICAgfVxuICB9XG5cbiAgdmFyIFNWTUxheWVyID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgdmFyIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIC8vIGNvbXB1dGVkXG4gICAgdGhpcy5udW1faW5wdXRzID0gb3B0LmluX3N4ICogb3B0LmluX3N5ICogb3B0LmluX2RlcHRoO1xuICAgIHRoaXMub3V0X2RlcHRoID0gdGhpcy5udW1faW5wdXRzO1xuICAgIHRoaXMub3V0X3N4ID0gMTtcbiAgICB0aGlzLm91dF9zeSA9IDE7XG4gICAgdGhpcy5sYXllcl90eXBlID0gJ3N2bSc7XG4gIH1cblxuICBTVk1MYXllci5wcm90b3R5cGUgPSB7XG4gICAgZm9yd2FyZDogZnVuY3Rpb24oViwgaXNfdHJhaW5pbmcpIHtcbiAgICAgIHRoaXMuaW5fYWN0ID0gVjtcbiAgICAgIHRoaXMub3V0X2FjdCA9IFY7IC8vIG5vdGhpbmcgdG8gZG8sIG91dHB1dCByYXcgc2NvcmVzXG4gICAgICByZXR1cm4gVjtcbiAgICB9LFxuICAgIGJhY2t3YXJkOiBmdW5jdGlvbih5KSB7XG5cbiAgICAgIC8vIGNvbXB1dGUgYW5kIGFjY3VtdWxhdGUgZ3JhZGllbnQgd3J0IHdlaWdodHMgYW5kIGJpYXMgb2YgdGhpcyBsYXllclxuICAgICAgdmFyIHggPSB0aGlzLmluX2FjdDtcbiAgICAgIHguZHcgPSBnbG9iYWwuemVyb3MoeC53Lmxlbmd0aCk7IC8vIHplcm8gb3V0IHRoZSBncmFkaWVudCBvZiBpbnB1dCBWb2xcblxuICAgICAgdmFyIHlzY29yZSA9IHgud1t5XTsgLy8gc2NvcmUgb2YgZ3JvdW5kIHRydXRoXG4gICAgICB2YXIgbWFyZ2luID0gMS4wO1xuICAgICAgdmFyIGxvc3MgPSAwLjA7XG4gICAgICBmb3IodmFyIGk9MDtpPHRoaXMub3V0X2RlcHRoO2krKykge1xuICAgICAgICBpZigteXNjb3JlICsgeC53W2ldICsgbWFyZ2luID4gMCkge1xuICAgICAgICAgIC8vIHZpb2xhdGluZyBleGFtcGxlLCBhcHBseSBsb3NzXG4gICAgICAgICAgLy8gSSBsb3ZlIGhpbmdlIGxvc3MsIGJ5IHRoZSB3YXkuIFRydWx5LlxuICAgICAgICAgIC8vIFNlcmlvdXNseSwgY29tcGFyZSB0aGlzIFNWTSBjb2RlIHdpdGggU29mdG1heCBmb3J3YXJkIEFORCBiYWNrcHJvcCBjb2RlIGFib3ZlXG4gICAgICAgICAgLy8gaXQncyBjbGVhciB3aGljaCBvbmUgaXMgc3VwZXJpb3IsIG5vdCBvbmx5IGluIGNvZGUsIHNpbXBsaWNpdHlcbiAgICAgICAgICAvLyBhbmQgYmVhdXR5LCBidXQgYWxzbyBpbiBwcmFjdGljZS5cbiAgICAgICAgICB4LmR3W2ldICs9IDE7XG4gICAgICAgICAgeC5kd1t5XSAtPSAxO1xuICAgICAgICAgIGxvc3MgKz0gLXlzY29yZSArIHgud1tpXSArIG1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9zcztcbiAgICB9LFxuICAgIGdldFBhcmFtc0FuZEdyYWRzOiBmdW5jdGlvbigpIHsgXG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgIGpzb24ub3V0X2RlcHRoID0gdGhpcy5vdXRfZGVwdGg7XG4gICAgICBqc29uLm91dF9zeCA9IHRoaXMub3V0X3N4O1xuICAgICAganNvbi5vdXRfc3kgPSB0aGlzLm91dF9zeTtcbiAgICAgIGpzb24ubGF5ZXJfdHlwZSA9IHRoaXMubGF5ZXJfdHlwZTtcbiAgICAgIGpzb24ubnVtX2lucHV0cyA9IHRoaXMubnVtX2lucHV0cztcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0sXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgIHRoaXMub3V0X2RlcHRoID0ganNvbi5vdXRfZGVwdGg7XG4gICAgICB0aGlzLm91dF9zeCA9IGpzb24ub3V0X3N4O1xuICAgICAgdGhpcy5vdXRfc3kgPSBqc29uLm91dF9zeTtcbiAgICAgIHRoaXMubGF5ZXJfdHlwZSA9IGpzb24ubGF5ZXJfdHlwZTtcbiAgICAgIHRoaXMubnVtX2lucHV0cyA9IGpzb24ubnVtX2lucHV0cztcbiAgICB9XG4gIH1cbiAgXG4gIGdsb2JhbC5SZWdyZXNzaW9uTGF5ZXIgPSBSZWdyZXNzaW9uTGF5ZXI7XG4gIGdsb2JhbC5Tb2Z0bWF4TGF5ZXIgPSBTb2Z0bWF4TGF5ZXI7XG4gIGdsb2JhbC5TVk1MYXllciA9IFNWTUxheWVyO1xuXG59KShjb252bmV0anMpO1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgVm9sID0gZ2xvYmFsLlZvbDsgLy8gY29udmVuaWVuY2VcbiAgXG4gIC8vIEltcGxlbWVudHMgUmVMVSBub25saW5lYXJpdHkgZWxlbWVudHdpc2VcbiAgLy8geCAtPiBtYXgoMCwgeClcbiAgLy8gdGhlIG91dHB1dCBpcyBpbiBbMCwgaW5mKVxuICB2YXIgUmVsdUxheWVyID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgdmFyIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIC8vIGNvbXB1dGVkXG4gICAgdGhpcy5vdXRfc3ggPSBvcHQuaW5fc3g7XG4gICAgdGhpcy5vdXRfc3kgPSBvcHQuaW5fc3k7XG4gICAgdGhpcy5vdXRfZGVwdGggPSBvcHQuaW5fZGVwdGg7XG4gICAgdGhpcy5sYXllcl90eXBlID0gJ3JlbHUnO1xuICB9XG4gIFJlbHVMYXllci5wcm90b3R5cGUgPSB7XG4gICAgZm9yd2FyZDogZnVuY3Rpb24oViwgaXNfdHJhaW5pbmcpIHtcbiAgICAgIHRoaXMuaW5fYWN0ID0gVjtcbiAgICAgIHZhciBWMiA9IFYuY2xvbmUoKTtcbiAgICAgIHZhciBOID0gVi53Lmxlbmd0aDtcbiAgICAgIHZhciBWMncgPSBWMi53O1xuICAgICAgZm9yKHZhciBpPTA7aTxOO2krKykgeyBcbiAgICAgICAgaWYoVjJ3W2ldIDwgMCkgVjJ3W2ldID0gMDsgLy8gdGhyZXNob2xkIGF0IDBcbiAgICAgIH1cbiAgICAgIHRoaXMub3V0X2FjdCA9IFYyO1xuICAgICAgcmV0dXJuIHRoaXMub3V0X2FjdDtcbiAgICB9LFxuICAgIGJhY2t3YXJkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBWID0gdGhpcy5pbl9hY3Q7IC8vIHdlIG5lZWQgdG8gc2V0IGR3IG9mIHRoaXNcbiAgICAgIHZhciBWMiA9IHRoaXMub3V0X2FjdDtcbiAgICAgIHZhciBOID0gVi53Lmxlbmd0aDtcbiAgICAgIFYuZHcgPSBnbG9iYWwuemVyb3MoTik7IC8vIHplcm8gb3V0IGdyYWRpZW50IHdydCBkYXRhXG4gICAgICBmb3IodmFyIGk9MDtpPE47aSsrKSB7XG4gICAgICAgIGlmKFYyLndbaV0gPD0gMCkgVi5kd1tpXSA9IDA7IC8vIHRocmVzaG9sZFxuICAgICAgICBlbHNlIFYuZHdbaV0gPSBWMi5kd1tpXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFBhcmFtc0FuZEdyYWRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIganNvbiA9IHt9O1xuICAgICAganNvbi5vdXRfZGVwdGggPSB0aGlzLm91dF9kZXB0aDtcbiAgICAgIGpzb24ub3V0X3N4ID0gdGhpcy5vdXRfc3g7XG4gICAgICBqc29uLm91dF9zeSA9IHRoaXMub3V0X3N5O1xuICAgICAganNvbi5sYXllcl90eXBlID0gdGhpcy5sYXllcl90eXBlO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcbiAgICBmcm9tSlNPTjogZnVuY3Rpb24oanNvbikge1xuICAgICAgdGhpcy5vdXRfZGVwdGggPSBqc29uLm91dF9kZXB0aDtcbiAgICAgIHRoaXMub3V0X3N4ID0ganNvbi5vdXRfc3g7XG4gICAgICB0aGlzLm91dF9zeSA9IGpzb24ub3V0X3N5O1xuICAgICAgdGhpcy5sYXllcl90eXBlID0ganNvbi5sYXllcl90eXBlOyBcbiAgICB9XG4gIH1cblxuICAvLyBJbXBsZW1lbnRzIFNpZ21vaWQgbm5vbmxpbmVhcml0eSBlbGVtZW50d2lzZVxuICAvLyB4IC0+IDEvKDErZV4oLXgpKVxuICAvLyBzbyB0aGUgb3V0cHV0IGlzIGJldHdlZW4gMCBhbmQgMS5cbiAgdmFyIFNpZ21vaWRMYXllciA9IGZ1bmN0aW9uKG9wdCkge1xuICAgIHZhciBvcHQgPSBvcHQgfHwge307XG5cbiAgICAvLyBjb21wdXRlZFxuICAgIHRoaXMub3V0X3N4ID0gb3B0LmluX3N4O1xuICAgIHRoaXMub3V0X3N5ID0gb3B0LmluX3N5O1xuICAgIHRoaXMub3V0X2RlcHRoID0gb3B0LmluX2RlcHRoO1xuICAgIHRoaXMubGF5ZXJfdHlwZSA9ICdzaWdtb2lkJztcbiAgfVxuICBTaWdtb2lkTGF5ZXIucHJvdG90eXBlID0ge1xuICAgIGZvcndhcmQ6IGZ1bmN0aW9uKFYsIGlzX3RyYWluaW5nKSB7XG4gICAgICB0aGlzLmluX2FjdCA9IFY7XG4gICAgICB2YXIgVjIgPSBWLmNsb25lQW5kWmVybygpO1xuICAgICAgdmFyIE4gPSBWLncubGVuZ3RoO1xuICAgICAgdmFyIFYydyA9IFYyLnc7XG4gICAgICB2YXIgVncgPSBWLnc7XG4gICAgICBmb3IodmFyIGk9MDtpPE47aSsrKSB7IFxuICAgICAgICBWMndbaV0gPSAxLjAvKDEuMCtNYXRoLmV4cCgtVndbaV0pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3V0X2FjdCA9IFYyO1xuICAgICAgcmV0dXJuIHRoaXMub3V0X2FjdDtcbiAgICB9LFxuICAgIGJhY2t3YXJkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBWID0gdGhpcy5pbl9hY3Q7IC8vIHdlIG5lZWQgdG8gc2V0IGR3IG9mIHRoaXNcbiAgICAgIHZhciBWMiA9IHRoaXMub3V0X2FjdDtcbiAgICAgIHZhciBOID0gVi53Lmxlbmd0aDtcbiAgICAgIFYuZHcgPSBnbG9iYWwuemVyb3MoTik7IC8vIHplcm8gb3V0IGdyYWRpZW50IHdydCBkYXRhXG4gICAgICBmb3IodmFyIGk9MDtpPE47aSsrKSB7XG4gICAgICAgIHZhciB2MndpID0gVjIud1tpXTtcbiAgICAgICAgVi5kd1tpXSA9ICB2MndpICogKDEuMCAtIHYyd2kpICogVjIuZHdbaV07XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRQYXJhbXNBbmRHcmFkczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgIGpzb24ub3V0X2RlcHRoID0gdGhpcy5vdXRfZGVwdGg7XG4gICAgICBqc29uLm91dF9zeCA9IHRoaXMub3V0X3N4O1xuICAgICAganNvbi5vdXRfc3kgPSB0aGlzLm91dF9zeTtcbiAgICAgIGpzb24ubGF5ZXJfdHlwZSA9IHRoaXMubGF5ZXJfdHlwZTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0sXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgIHRoaXMub3V0X2RlcHRoID0ganNvbi5vdXRfZGVwdGg7XG4gICAgICB0aGlzLm91dF9zeCA9IGpzb24ub3V0X3N4O1xuICAgICAgdGhpcy5vdXRfc3kgPSBqc29uLm91dF9zeTtcbiAgICAgIHRoaXMubGF5ZXJfdHlwZSA9IGpzb24ubGF5ZXJfdHlwZTsgXG4gICAgfVxuICB9XG5cbiAgLy8gSW1wbGVtZW50cyBNYXhvdXQgbm5vbmxpbmVhcml0eSB0aGF0IGNvbXB1dGVzXG4gIC8vIHggLT4gbWF4KHgpXG4gIC8vIHdoZXJlIHggaXMgYSB2ZWN0b3Igb2Ygc2l6ZSBncm91cF9zaXplLiBJZGVhbGx5IG9mIGNvdXJzZSxcbiAgLy8gdGhlIGlucHV0IHNpemUgc2hvdWxkIGJlIGV4YWN0bHkgZGl2aXNpYmxlIGJ5IGdyb3VwX3NpemVcbiAgdmFyIE1heG91dExheWVyID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgdmFyIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIC8vIHJlcXVpcmVkXG4gICAgdGhpcy5ncm91cF9zaXplID0gdHlwZW9mIG9wdC5ncm91cF9zaXplICE9PSAndW5kZWZpbmVkJyA/IG9wdC5ncm91cF9zaXplIDogMjtcblxuICAgIC8vIGNvbXB1dGVkXG4gICAgdGhpcy5vdXRfc3ggPSBvcHQuaW5fc3g7XG4gICAgdGhpcy5vdXRfc3kgPSBvcHQuaW5fc3k7XG4gICAgdGhpcy5vdXRfZGVwdGggPSBNYXRoLmZsb29yKG9wdC5pbl9kZXB0aCAvIHRoaXMuZ3JvdXBfc2l6ZSk7XG4gICAgdGhpcy5sYXllcl90eXBlID0gJ21heG91dCc7XG5cbiAgICB0aGlzLnN3aXRjaGVzID0gZ2xvYmFsLnplcm9zKHRoaXMub3V0X3N4KnRoaXMub3V0X3N5KnRoaXMub3V0X2RlcHRoKTsgLy8gdXNlZnVsIGZvciBiYWNrcHJvcFxuICB9XG4gIE1heG91dExheWVyLnByb3RvdHlwZSA9IHtcbiAgICBmb3J3YXJkOiBmdW5jdGlvbihWLCBpc190cmFpbmluZykge1xuICAgICAgdGhpcy5pbl9hY3QgPSBWO1xuICAgICAgdmFyIE4gPSB0aGlzLm91dF9kZXB0aDsgXG4gICAgICB2YXIgVjIgPSBuZXcgVm9sKHRoaXMub3V0X3N4LCB0aGlzLm91dF9zeSwgdGhpcy5vdXRfZGVwdGgsIDAuMCk7XG5cbiAgICAgIC8vIG9wdGltaXphdGlvbiBicmFuY2guIElmIHdlJ3JlIG9wZXJhdGluZyBvbiAxRCBhcnJheXMgd2UgZG9udCBoYXZlXG4gICAgICAvLyB0byB3b3JyeSBhYm91dCBrZWVwaW5nIHRyYWNrIG9mIHgseSxkIGNvb3JkaW5hdGVzIGluc2lkZVxuICAgICAgLy8gaW5wdXQgdm9sdW1lcy4gSW4gY29udm5ldHMgd2UgZG8gOihcbiAgICAgIGlmKHRoaXMub3V0X3N4ID09PSAxICYmIHRoaXMub3V0X3N5ID09PSAxKSB7XG4gICAgICAgIGZvcih2YXIgaT0wO2k8TjtpKyspIHtcbiAgICAgICAgICB2YXIgaXggPSBpICogdGhpcy5ncm91cF9zaXplOyAvLyBiYXNlIGluZGV4IG9mZnNldFxuICAgICAgICAgIHZhciBhID0gVi53W2l4XTtcbiAgICAgICAgICB2YXIgYWkgPSAwO1xuICAgICAgICAgIGZvcih2YXIgaj0xO2o8dGhpcy5ncm91cF9zaXplO2orKykge1xuICAgICAgICAgICAgdmFyIGEyID0gVi53W2l4K2pdO1xuICAgICAgICAgICAgaWYoYTIgPiBhKSB7XG4gICAgICAgICAgICAgIGEgPSBhMjtcbiAgICAgICAgICAgICAgYWkgPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBWMi53W2ldID0gYTtcbiAgICAgICAgICB0aGlzLnN3aXRjaGVzW2ldID0gaXggKyBhaTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG49MDsgLy8gY291bnRlciBmb3Igc3dpdGNoZXNcbiAgICAgICAgZm9yKHZhciB4PTA7eDxWLnN4O3grKykge1xuICAgICAgICAgIGZvcih2YXIgeT0wO3k8Vi5zeTt5KyspIHtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wO2k8TjtpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGl4ID0gaSAqIHRoaXMuZ3JvdXBfc2l6ZTtcbiAgICAgICAgICAgICAgdmFyIGEgPSBWLmdldCh4LCB5LCBpeCk7XG4gICAgICAgICAgICAgIHZhciBhaSA9IDA7XG4gICAgICAgICAgICAgIGZvcih2YXIgaj0xO2o8dGhpcy5ncm91cF9zaXplO2orKykge1xuICAgICAgICAgICAgICAgIHZhciBhMiA9IFYuZ2V0KHgsIHksIGl4K2opO1xuICAgICAgICAgICAgICAgIGlmKGEyID4gYSkge1xuICAgICAgICAgICAgICAgICAgYSA9IGEyO1xuICAgICAgICAgICAgICAgICAgYWkgPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBWMi5zZXQoeCx5LGksYSk7XG4gICAgICAgICAgICAgIHRoaXMuc3dpdGNoZXNbbl0gPSBpeCArIGFpO1xuICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIHRoaXMub3V0X2FjdCA9IFYyO1xuICAgICAgcmV0dXJuIHRoaXMub3V0X2FjdDtcbiAgICB9LFxuICAgIGJhY2t3YXJkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBWID0gdGhpcy5pbl9hY3Q7IC8vIHdlIG5lZWQgdG8gc2V0IGR3IG9mIHRoaXNcbiAgICAgIHZhciBWMiA9IHRoaXMub3V0X2FjdDtcbiAgICAgIHZhciBOID0gdGhpcy5vdXRfZGVwdGg7XG4gICAgICBWLmR3ID0gZ2xvYmFsLnplcm9zKFYudy5sZW5ndGgpOyAvLyB6ZXJvIG91dCBncmFkaWVudCB3cnQgZGF0YVxuXG4gICAgICAvLyBwYXNzIHRoZSBncmFkaWVudCB0aHJvdWdoIHRoZSBhcHByb3ByaWF0ZSBzd2l0Y2hcbiAgICAgIGlmKHRoaXMub3V0X3N4ID09PSAxICYmIHRoaXMub3V0X3N5ID09PSAxKSB7XG4gICAgICAgIGZvcih2YXIgaT0wO2k8TjtpKyspIHtcbiAgICAgICAgICB2YXIgY2hhaW5fZ3JhZCA9IFYyLmR3W2ldO1xuICAgICAgICAgIFYuZHdbdGhpcy5zd2l0Y2hlc1tpXV0gPSBjaGFpbl9ncmFkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBibGVoIG9rYXksIGxldHMgZG8gdGhpcyB0aGUgaGFyZCB3YXlcbiAgICAgICAgdmFyIG49MDsgLy8gY291bnRlciBmb3Igc3dpdGNoZXNcbiAgICAgICAgZm9yKHZhciB4PTA7eDxWMi5zeDt4KyspIHtcbiAgICAgICAgICBmb3IodmFyIHk9MDt5PFYyLnN5O3krKykge1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7aTxOO2krKykge1xuICAgICAgICAgICAgICB2YXIgY2hhaW5fZ3JhZCA9IFYyLmdldF9ncmFkKHgseSxpKTtcbiAgICAgICAgICAgICAgVi5zZXRfZ3JhZCh4LHksdGhpcy5zd2l0Y2hlc1tuXSxjaGFpbl9ncmFkKTtcbiAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UGFyYW1zQW5kR3JhZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBqc29uID0ge307XG4gICAgICBqc29uLm91dF9kZXB0aCA9IHRoaXMub3V0X2RlcHRoO1xuICAgICAganNvbi5vdXRfc3ggPSB0aGlzLm91dF9zeDtcbiAgICAgIGpzb24ub3V0X3N5ID0gdGhpcy5vdXRfc3k7XG4gICAgICBqc29uLmxheWVyX3R5cGUgPSB0aGlzLmxheWVyX3R5cGU7XG4gICAgICBqc29uLmdyb3VwX3NpemUgPSB0aGlzLmdyb3VwX3NpemU7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuICAgIGZyb21KU09OOiBmdW5jdGlvbihqc29uKSB7XG4gICAgICB0aGlzLm91dF9kZXB0aCA9IGpzb24ub3V0X2RlcHRoO1xuICAgICAgdGhpcy5vdXRfc3ggPSBqc29uLm91dF9zeDtcbiAgICAgIHRoaXMub3V0X3N5ID0ganNvbi5vdXRfc3k7XG4gICAgICB0aGlzLmxheWVyX3R5cGUgPSBqc29uLmxheWVyX3R5cGU7IFxuICAgICAgdGhpcy5ncm91cF9zaXplID0ganNvbi5ncm91cF9zaXplO1xuICAgICAgdGhpcy5zd2l0Y2hlcyA9IGdsb2JhbC56ZXJvcyh0aGlzLmdyb3VwX3NpemUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGEgaGVscGVyIGZ1bmN0aW9uLCBzaW5jZSB0YW5oIGlzIG5vdCB5ZXQgcGFydCBvZiBFQ01BU2NyaXB0LiBXaWxsIGJlIGluIHY2LlxuICBmdW5jdGlvbiB0YW5oKHgpIHtcbiAgICB2YXIgeSA9IE1hdGguZXhwKDIgKiB4KTtcbiAgICByZXR1cm4gKHkgLSAxKSAvICh5ICsgMSk7XG4gIH1cbiAgLy8gSW1wbGVtZW50cyBUYW5oIG5ub25saW5lYXJpdHkgZWxlbWVudHdpc2VcbiAgLy8geCAtPiB0YW5oKHgpIFxuICAvLyBzbyB0aGUgb3V0cHV0IGlzIGJldHdlZW4gLTEgYW5kIDEuXG4gIHZhciBUYW5oTGF5ZXIgPSBmdW5jdGlvbihvcHQpIHtcbiAgICB2YXIgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgLy8gY29tcHV0ZWRcbiAgICB0aGlzLm91dF9zeCA9IG9wdC5pbl9zeDtcbiAgICB0aGlzLm91dF9zeSA9IG9wdC5pbl9zeTtcbiAgICB0aGlzLm91dF9kZXB0aCA9IG9wdC5pbl9kZXB0aDtcbiAgICB0aGlzLmxheWVyX3R5cGUgPSAndGFuaCc7XG4gIH1cbiAgVGFuaExheWVyLnByb3RvdHlwZSA9IHtcbiAgICBmb3J3YXJkOiBmdW5jdGlvbihWLCBpc190cmFpbmluZykge1xuICAgICAgdGhpcy5pbl9hY3QgPSBWO1xuICAgICAgdmFyIFYyID0gVi5jbG9uZUFuZFplcm8oKTtcbiAgICAgIHZhciBOID0gVi53Lmxlbmd0aDtcbiAgICAgIGZvcih2YXIgaT0wO2k8TjtpKyspIHsgXG4gICAgICAgIFYyLndbaV0gPSB0YW5oKFYud1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLm91dF9hY3QgPSBWMjtcbiAgICAgIHJldHVybiB0aGlzLm91dF9hY3Q7XG4gICAgfSxcbiAgICBiYWNrd2FyZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgViA9IHRoaXMuaW5fYWN0OyAvLyB3ZSBuZWVkIHRvIHNldCBkdyBvZiB0aGlzXG4gICAgICB2YXIgVjIgPSB0aGlzLm91dF9hY3Q7XG4gICAgICB2YXIgTiA9IFYudy5sZW5ndGg7XG4gICAgICBWLmR3ID0gZ2xvYmFsLnplcm9zKE4pOyAvLyB6ZXJvIG91dCBncmFkaWVudCB3cnQgZGF0YVxuICAgICAgZm9yKHZhciBpPTA7aTxOO2krKykge1xuICAgICAgICB2YXIgdjJ3aSA9IFYyLndbaV07XG4gICAgICAgIFYuZHdbaV0gPSAoMS4wIC0gdjJ3aSAqIHYyd2kpICogVjIuZHdbaV07XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRQYXJhbXNBbmRHcmFkczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgIGpzb24ub3V0X2RlcHRoID0gdGhpcy5vdXRfZGVwdGg7XG4gICAgICBqc29uLm91dF9zeCA9IHRoaXMub3V0X3N4O1xuICAgICAganNvbi5vdXRfc3kgPSB0aGlzLm91dF9zeTtcbiAgICAgIGpzb24ubGF5ZXJfdHlwZSA9IHRoaXMubGF5ZXJfdHlwZTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0sXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgIHRoaXMub3V0X2RlcHRoID0ganNvbi5vdXRfZGVwdGg7XG4gICAgICB0aGlzLm91dF9zeCA9IGpzb24ub3V0X3N4O1xuICAgICAgdGhpcy5vdXRfc3kgPSBqc29uLm91dF9zeTtcbiAgICAgIHRoaXMubGF5ZXJfdHlwZSA9IGpzb24ubGF5ZXJfdHlwZTsgXG4gICAgfVxuICB9XG4gIFxuICBnbG9iYWwuVGFuaExheWVyID0gVGFuaExheWVyO1xuICBnbG9iYWwuTWF4b3V0TGF5ZXIgPSBNYXhvdXRMYXllcjtcbiAgZ2xvYmFsLlJlbHVMYXllciA9IFJlbHVMYXllcjtcbiAgZ2xvYmFsLlNpZ21vaWRMYXllciA9IFNpZ21vaWRMYXllcjtcblxufSkoY29udm5ldGpzKTtcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIFZvbCA9IGdsb2JhbC5Wb2w7IC8vIGNvbnZlbmllbmNlXG5cbiAgLy8gQW4gaW5lZmZpY2llbnQgZHJvcG91dCBsYXllclxuICAvLyBOb3RlIHRoaXMgaXMgbm90IG1vc3QgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uIHNpbmNlIHRoZSBsYXllciBiZWZvcmVcbiAgLy8gY29tcHV0ZWQgYWxsIHRoZXNlIGFjdGl2YXRpb25zIGFuZCBub3cgd2UncmUganVzdCBnb2luZyB0byBkcm9wIHRoZW0gOihcbiAgLy8gc2FtZSBnb2VzIGZvciBiYWNrd2FyZCBwYXNzLiBBbHNvLCBpZiB3ZSB3YW50ZWQgdG8gYmUgZWZmaWNpZW50IGF0IHRlc3QgdGltZVxuICAvLyB3ZSBjb3VsZCBlcXVpdmFsZW50bHkgYmUgY2xldmVyIGFuZCB1cHNjYWxlIGR1cmluZyB0cmFpbiBhbmQgY29weSBwb2ludGVycyBkdXJpbmcgdGVzdFxuICAvLyB0b2RvOiBtYWtlIG1vcmUgZWZmaWNpZW50LlxuICB2YXIgRHJvcG91dExheWVyID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgdmFyIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIC8vIGNvbXB1dGVkXG4gICAgdGhpcy5vdXRfc3ggPSBvcHQuaW5fc3g7XG4gICAgdGhpcy5vdXRfc3kgPSBvcHQuaW5fc3k7XG4gICAgdGhpcy5vdXRfZGVwdGggPSBvcHQuaW5fZGVwdGg7XG4gICAgdGhpcy5sYXllcl90eXBlID0gJ2Ryb3BvdXQnO1xuICAgIHRoaXMuZHJvcF9wcm9iID0gdHlwZW9mIG9wdC5kcm9wX3Byb2IgIT09ICd1bmRlZmluZWQnID8gb3B0LmRyb3BfcHJvYiA6IDAuNTtcbiAgICB0aGlzLmRyb3BwZWQgPSBnbG9iYWwuemVyb3ModGhpcy5vdXRfc3gqdGhpcy5vdXRfc3kqdGhpcy5vdXRfZGVwdGgpO1xuICB9XG4gIERyb3BvdXRMYXllci5wcm90b3R5cGUgPSB7XG4gICAgZm9yd2FyZDogZnVuY3Rpb24oViwgaXNfdHJhaW5pbmcpIHtcbiAgICAgIHRoaXMuaW5fYWN0ID0gVjtcbiAgICAgIGlmKHR5cGVvZihpc190cmFpbmluZyk9PT0ndW5kZWZpbmVkJykgeyBpc190cmFpbmluZyA9IGZhbHNlOyB9IC8vIGRlZmF1bHQgaXMgcHJlZGljdGlvbiBtb2RlXG4gICAgICB2YXIgVjIgPSBWLmNsb25lKCk7XG4gICAgICB2YXIgTiA9IFYudy5sZW5ndGg7XG4gICAgICBpZihpc190cmFpbmluZykge1xuICAgICAgICAvLyBkbyBkcm9wb3V0XG4gICAgICAgIGZvcih2YXIgaT0wO2k8TjtpKyspIHtcbiAgICAgICAgICBpZihNYXRoLnJhbmRvbSgpPHRoaXMuZHJvcF9wcm9iKSB7IFYyLndbaV09MDsgdGhpcy5kcm9wcGVkW2ldID0gdHJ1ZTsgfSAvLyBkcm9wIVxuICAgICAgICAgIGVsc2Uge3RoaXMuZHJvcHBlZFtpXSA9IGZhbHNlO31cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2NhbGUgdGhlIGFjdGl2YXRpb25zIGR1cmluZyBwcmVkaWN0aW9uXG4gICAgICAgIGZvcih2YXIgaT0wO2k8TjtpKyspIHsgVjIud1tpXSo9dGhpcy5kcm9wX3Byb2I7IH1cbiAgICAgIH1cbiAgICAgIHRoaXMub3V0X2FjdCA9IFYyO1xuICAgICAgcmV0dXJuIHRoaXMub3V0X2FjdDsgLy8gZHVtbXkgaWRlbnRpdHkgZnVuY3Rpb24gZm9yIG5vd1xuICAgIH0sXG4gICAgYmFja3dhcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIFYgPSB0aGlzLmluX2FjdDsgLy8gd2UgbmVlZCB0byBzZXQgZHcgb2YgdGhpc1xuICAgICAgdmFyIGNoYWluX2dyYWQgPSB0aGlzLm91dF9hY3Q7XG4gICAgICB2YXIgTiA9IFYudy5sZW5ndGg7XG4gICAgICBWLmR3ID0gZ2xvYmFsLnplcm9zKE4pOyAvLyB6ZXJvIG91dCBncmFkaWVudCB3cnQgZGF0YVxuICAgICAgZm9yKHZhciBpPTA7aTxOO2krKykge1xuICAgICAgICBpZighKHRoaXMuZHJvcHBlZFtpXSkpIHsgXG4gICAgICAgICAgVi5kd1tpXSA9IGNoYWluX2dyYWQuZHdbaV07IC8vIGNvcHkgb3ZlciB0aGUgZ3JhZGllbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UGFyYW1zQW5kR3JhZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBqc29uID0ge307XG4gICAgICBqc29uLm91dF9kZXB0aCA9IHRoaXMub3V0X2RlcHRoO1xuICAgICAganNvbi5vdXRfc3ggPSB0aGlzLm91dF9zeDtcbiAgICAgIGpzb24ub3V0X3N5ID0gdGhpcy5vdXRfc3k7XG4gICAgICBqc29uLmxheWVyX3R5cGUgPSB0aGlzLmxheWVyX3R5cGU7XG4gICAgICBqc29uLmRyb3BfcHJvYiA9IHRoaXMuZHJvcF9wcm9iO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcbiAgICBmcm9tSlNPTjogZnVuY3Rpb24oanNvbikge1xuICAgICAgdGhpcy5vdXRfZGVwdGggPSBqc29uLm91dF9kZXB0aDtcbiAgICAgIHRoaXMub3V0X3N4ID0ganNvbi5vdXRfc3g7XG4gICAgICB0aGlzLm91dF9zeSA9IGpzb24ub3V0X3N5O1xuICAgICAgdGhpcy5sYXllcl90eXBlID0ganNvbi5sYXllcl90eXBlOyBcbiAgICAgIHRoaXMuZHJvcF9wcm9iID0ganNvbi5kcm9wX3Byb2I7XG4gICAgfVxuICB9XG4gIFxuXG4gIGdsb2JhbC5Ecm9wb3V0TGF5ZXIgPSBEcm9wb3V0TGF5ZXI7XG59KShjb252bmV0anMpO1xuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIFZvbCA9IGdsb2JhbC5Wb2w7IC8vIGNvbnZlbmllbmNlXG4gIFxuICAvLyBhIGJpdCBleHBlcmltZW50YWwgbGF5ZXIgZm9yIG5vdy4gSSB0aGluayBpdCB3b3JrcyBidXQgSSdtIG5vdCAxMDAlXG4gIC8vIHRoZSBncmFkaWVudCBjaGVjayBpcyBhIGJpdCBmdW5reS4gSSdsbCBsb29rIGludG8gdGhpcyBhIGJpdCBsYXRlci5cbiAgLy8gTG9jYWwgUmVzcG9uc2UgTm9ybWFsaXphdGlvbiBpbiB3aW5kb3csIGFsb25nIGRlcHRocyBvZiB2b2x1bWVzXG4gIHZhciBMb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbkxheWVyID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgdmFyIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIC8vIHJlcXVpcmVkXG4gICAgdGhpcy5rID0gb3B0Lms7XG4gICAgdGhpcy5uID0gb3B0Lm47XG4gICAgdGhpcy5hbHBoYSA9IG9wdC5hbHBoYTtcbiAgICB0aGlzLmJldGEgPSBvcHQuYmV0YTtcblxuICAgIC8vIGNvbXB1dGVkXG4gICAgdGhpcy5vdXRfc3ggPSBvcHQuaW5fc3g7XG4gICAgdGhpcy5vdXRfc3kgPSBvcHQuaW5fc3k7XG4gICAgdGhpcy5vdXRfZGVwdGggPSBvcHQuaW5fZGVwdGg7XG4gICAgdGhpcy5sYXllcl90eXBlID0gJ2xybic7XG5cbiAgICAvLyBjaGVja3NcbiAgICBpZih0aGlzLm4lMiA9PT0gMCkgeyBjb25zb2xlLmxvZygnV0FSTklORyBuIHNob3VsZCBiZSBvZGQgZm9yIExSTiBsYXllcicpOyB9XG4gIH1cbiAgTG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25MYXllci5wcm90b3R5cGUgPSB7XG4gICAgZm9yd2FyZDogZnVuY3Rpb24oViwgaXNfdHJhaW5pbmcpIHtcbiAgICAgIHRoaXMuaW5fYWN0ID0gVjtcblxuICAgICAgdmFyIEEgPSBWLmNsb25lQW5kWmVybygpO1xuICAgICAgdGhpcy5TX2NhY2hlXyA9IFYuY2xvbmVBbmRaZXJvKCk7XG4gICAgICB2YXIgbjIgPSBNYXRoLmZsb29yKHRoaXMubi8yKTtcbiAgICAgIGZvcih2YXIgeD0wO3g8Vi5zeDt4KyspIHtcbiAgICAgICAgZm9yKHZhciB5PTA7eTxWLnN5O3krKykge1xuICAgICAgICAgIGZvcih2YXIgaT0wO2k8Vi5kZXB0aDtpKyspIHtcblxuICAgICAgICAgICAgdmFyIGFpID0gVi5nZXQoeCx5LGkpO1xuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgaW4gYSB3aW5kb3cgb2Ygc2l6ZSBuXG4gICAgICAgICAgICB2YXIgZGVuID0gMC4wO1xuICAgICAgICAgICAgZm9yKHZhciBqPU1hdGgubWF4KDAsaS1uMik7ajw9TWF0aC5taW4oaStuMixWLmRlcHRoLTEpO2orKykge1xuICAgICAgICAgICAgICB2YXIgYWEgPSBWLmdldCh4LHksaik7XG4gICAgICAgICAgICAgIGRlbiArPSBhYSphYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbiAqPSB0aGlzLmFscGhhIC8gdGhpcy5uO1xuICAgICAgICAgICAgZGVuICs9IHRoaXMuaztcbiAgICAgICAgICAgIHRoaXMuU19jYWNoZV8uc2V0KHgseSxpLGRlbik7IC8vIHdpbGwgYmUgdXNlZnVsIGZvciBiYWNrcHJvcFxuICAgICAgICAgICAgZGVuID0gTWF0aC5wb3coZGVuLCB0aGlzLmJldGEpO1xuICAgICAgICAgICAgQS5zZXQoeCx5LGksYWkvZGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5vdXRfYWN0ID0gQTtcbiAgICAgIHJldHVybiB0aGlzLm91dF9hY3Q7IC8vIGR1bW15IGlkZW50aXR5IGZ1bmN0aW9uIGZvciBub3dcbiAgICB9LFxuICAgIGJhY2t3YXJkOiBmdW5jdGlvbigpIHsgXG4gICAgICAvLyBldmFsdWF0ZSBncmFkaWVudCB3cnQgZGF0YVxuICAgICAgdmFyIFYgPSB0aGlzLmluX2FjdDsgLy8gd2UgbmVlZCB0byBzZXQgZHcgb2YgdGhpc1xuICAgICAgVi5kdyA9IGdsb2JhbC56ZXJvcyhWLncubGVuZ3RoKTsgLy8gemVybyBvdXQgZ3JhZGllbnQgd3J0IGRhdGFcbiAgICAgIHZhciBBID0gdGhpcy5vdXRfYWN0OyAvLyBjb21wdXRlZCBpbiBmb3J3YXJkIHBhc3MgXG5cbiAgICAgIHZhciBuMiA9IE1hdGguZmxvb3IodGhpcy5uLzIpO1xuICAgICAgZm9yKHZhciB4PTA7eDxWLnN4O3grKykge1xuICAgICAgICBmb3IodmFyIHk9MDt5PFYuc3k7eSsrKSB7XG4gICAgICAgICAgZm9yKHZhciBpPTA7aTxWLmRlcHRoO2krKykge1xuXG4gICAgICAgICAgICB2YXIgY2hhaW5fZ3JhZCA9IHRoaXMub3V0X2FjdC5nZXRfZ3JhZCh4LHksaSk7XG4gICAgICAgICAgICB2YXIgUyA9IHRoaXMuU19jYWNoZV8uZ2V0KHgseSxpKTtcbiAgICAgICAgICAgIHZhciBTQiA9IE1hdGgucG93KFMsIHRoaXMuYmV0YSk7XG4gICAgICAgICAgICB2YXIgU0IyID0gU0IqU0I7XG5cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBpbiBhIHdpbmRvdyBvZiBzaXplIG5cbiAgICAgICAgICAgIGZvcih2YXIgaj1NYXRoLm1heCgwLGktbjIpO2o8PU1hdGgubWluKGkrbjIsVi5kZXB0aC0xKTtqKyspIHsgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB2YXIgYWogPSBWLmdldCh4LHksaik7IFxuICAgICAgICAgICAgICB2YXIgZyA9IC1haip0aGlzLmJldGEqTWF0aC5wb3coUyx0aGlzLmJldGEtMSkqdGhpcy5hbHBoYS90aGlzLm4qMiphajtcbiAgICAgICAgICAgICAgaWYoaj09PWkpIGcrPSBTQjtcbiAgICAgICAgICAgICAgZyAvPSBTQjI7XG4gICAgICAgICAgICAgIGcgKj0gY2hhaW5fZ3JhZDtcbiAgICAgICAgICAgICAgVi5hZGRfZ3JhZCh4LHksaixnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UGFyYW1zQW5kR3JhZHM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0sXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBqc29uID0ge307XG4gICAgICBqc29uLmsgPSB0aGlzLms7XG4gICAgICBqc29uLm4gPSB0aGlzLm47XG4gICAgICBqc29uLmFscGhhID0gdGhpcy5hbHBoYTsgLy8gbm9ybWFsaXplIGJ5IHNpemVcbiAgICAgIGpzb24uYmV0YSA9IHRoaXMuYmV0YTtcbiAgICAgIGpzb24ub3V0X3N4ID0gdGhpcy5vdXRfc3g7IFxuICAgICAganNvbi5vdXRfc3kgPSB0aGlzLm91dF9zeTtcbiAgICAgIGpzb24ub3V0X2RlcHRoID0gdGhpcy5vdXRfZGVwdGg7XG4gICAgICBqc29uLmxheWVyX3R5cGUgPSB0aGlzLmxheWVyX3R5cGU7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuICAgIGZyb21KU09OOiBmdW5jdGlvbihqc29uKSB7XG4gICAgICB0aGlzLmsgPSBqc29uLms7XG4gICAgICB0aGlzLm4gPSBqc29uLm47XG4gICAgICB0aGlzLmFscGhhID0ganNvbi5hbHBoYTsgLy8gbm9ybWFsaXplIGJ5IHNpemVcbiAgICAgIHRoaXMuYmV0YSA9IGpzb24uYmV0YTtcbiAgICAgIHRoaXMub3V0X3N4ID0ganNvbi5vdXRfc3g7IFxuICAgICAgdGhpcy5vdXRfc3kgPSBqc29uLm91dF9zeTtcbiAgICAgIHRoaXMub3V0X2RlcHRoID0ganNvbi5vdXRfZGVwdGg7XG4gICAgICB0aGlzLmxheWVyX3R5cGUgPSBqc29uLmxheWVyX3R5cGU7XG4gICAgfVxuICB9XG4gIFxuXG4gIGdsb2JhbC5Mb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbkxheWVyID0gTG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25MYXllcjtcbn0pKGNvbnZuZXRqcyk7XG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgVm9sID0gZ2xvYmFsLlZvbDsgLy8gY29udmVuaWVuY2VcblxuICAvLyB0cmFuc2Zvcm1zIHgtPiBbeCwgeF9pKnhfaiBmb3JhbGwgaSxqXVxuICAvLyBzbyB0aGUgZnVsbHkgY29ubmVjdGVkIGxheWVyIGFmdGVycyB3aWxsIGVzc2VudGlhbGx5IGJlIGRvaW5nIHRlbnNvciBtdWx0aXBsaWVzXG4gIHZhciBRdWFkVHJhbnNmb3JtTGF5ZXIgPSBmdW5jdGlvbihvcHQpIHtcbiAgICB2YXIgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgLy8gY29tcHV0ZWRcbiAgICB0aGlzLm91dF9zeCA9IG9wdC5pbl9zeDtcbiAgICB0aGlzLm91dF9zeSA9IG9wdC5pbl9zeTtcbiAgICAvLyBsaW5lYXIgdGVybXMsIGFuZCB0aGVuIHF1YWRyYXRpYyB0ZXJtcywgb2Ygd2hpY2ggdGhlcmUgYXJlIDEvMipuKihuKzEpLFxuICAgIC8vIChvZmZkaWFnb25hbHMgYW5kIHRoZSBkaWFnb25hbCB0b3RhbCkgYW5kIGFyaXRobWV0aWMgc2VyaWVzLlxuICAgIC8vIEFjdHVhbGx5IG5ldmVyIG1pbmQsIGxldHMgbm90IGJlIGZhbmN5IGhlcmUgeWV0IGFuZCBqdXN0IGluY2x1ZGVcbiAgICAvLyB0ZXJtcyB4X2l4X2ogYW5kIHhfanhfaSB0d2ljZS4gSGFsZiBhcyBlZmZpY2llbnQgYnV0IG11Y2ggbGVzc1xuICAgIC8vIGhlYWRhY2hlLlxuICAgIHRoaXMub3V0X2RlcHRoID0gb3B0LmluX2RlcHRoICsgb3B0LmluX2RlcHRoICogb3B0LmluX2RlcHRoO1xuICAgIHRoaXMubGF5ZXJfdHlwZSA9ICdxdWFkdHJhbnNmb3JtJztcblxuICB9XG4gIFF1YWRUcmFuc2Zvcm1MYXllci5wcm90b3R5cGUgPSB7XG4gICAgZm9yd2FyZDogZnVuY3Rpb24oViwgaXNfdHJhaW5pbmcpIHtcbiAgICAgIHRoaXMuaW5fYWN0ID0gVjtcbiAgICAgIHZhciBOID0gdGhpcy5vdXRfZGVwdGg7XG4gICAgICB2YXIgTmkgPSBWLmRlcHRoO1xuICAgICAgdmFyIFYyID0gbmV3IFZvbCh0aGlzLm91dF9zeCwgdGhpcy5vdXRfc3ksIHRoaXMub3V0X2RlcHRoLCAwLjApO1xuICAgICAgZm9yKHZhciB4PTA7eDxWLnN4O3grKykge1xuICAgICAgICBmb3IodmFyIHk9MDt5PFYuc3k7eSsrKSB7XG4gICAgICAgICAgZm9yKHZhciBpPTA7aTxOO2krKykge1xuICAgICAgICAgICAgaWYoaTxOaSkge1xuICAgICAgICAgICAgICBWMi5zZXQoeCx5LGksVi5nZXQoeCx5LGkpKTsgLy8gY29weSB0aGVzZSBvdmVyIChsaW5lYXIgdGVybXMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaTAgPSBNYXRoLmZsb29yKChpLU5pKS9OaSk7XG4gICAgICAgICAgICAgIHZhciBpMSA9IChpLU5pKSAtIGkwKk5pO1xuICAgICAgICAgICAgICBWMi5zZXQoeCx5LGksVi5nZXQoeCx5LGkwKSAqIFYuZ2V0KHgseSxpMSkpOyAvLyBxdWFkcmF0aWNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub3V0X2FjdCA9IFYyO1xuICAgICAgcmV0dXJuIHRoaXMub3V0X2FjdDsgLy8gZHVtbXkgaWRlbnRpdHkgZnVuY3Rpb24gZm9yIG5vd1xuICAgIH0sXG4gICAgYmFja3dhcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIFYgPSB0aGlzLmluX2FjdDtcbiAgICAgIFYuZHcgPSBnbG9iYWwuemVyb3MoVi53Lmxlbmd0aCk7IC8vIHplcm8gb3V0IGdyYWRpZW50IHdydCBkYXRhXG4gICAgICB2YXIgVjIgPSB0aGlzLm91dF9hY3Q7XG4gICAgICB2YXIgTiA9IHRoaXMub3V0X2RlcHRoO1xuICAgICAgdmFyIE5pID0gVi5kZXB0aDtcbiAgICAgIGZvcih2YXIgeD0wO3g8Vi5zeDt4KyspIHtcbiAgICAgICAgZm9yKHZhciB5PTA7eTxWLnN5O3krKykge1xuICAgICAgICAgIGZvcih2YXIgaT0wO2k8TjtpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFpbl9ncmFkID0gVjIuZ2V0X2dyYWQoeCx5LGkpO1xuICAgICAgICAgICAgaWYoaTxOaSkge1xuICAgICAgICAgICAgICBWLmFkZF9ncmFkKHgseSxpLGNoYWluX2dyYWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGkwID0gTWF0aC5mbG9vcigoaS1OaSkvTmkpO1xuICAgICAgICAgICAgICB2YXIgaTEgPSAoaS1OaSkgLSBpMCpOaTtcbiAgICAgICAgICAgICAgVi5hZGRfZ3JhZCh4LHksaTAsVi5nZXQoeCx5LGkxKSpjaGFpbl9ncmFkKTtcbiAgICAgICAgICAgICAgVi5hZGRfZ3JhZCh4LHksaTEsVi5nZXQoeCx5LGkwKSpjaGFpbl9ncmFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFBhcmFtc0FuZEdyYWRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIganNvbiA9IHt9O1xuICAgICAganNvbi5vdXRfZGVwdGggPSB0aGlzLm91dF9kZXB0aDtcbiAgICAgIGpzb24ub3V0X3N4ID0gdGhpcy5vdXRfc3g7XG4gICAgICBqc29uLm91dF9zeSA9IHRoaXMub3V0X3N5O1xuICAgICAganNvbi5sYXllcl90eXBlID0gdGhpcy5sYXllcl90eXBlO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcbiAgICBmcm9tSlNPTjogZnVuY3Rpb24oanNvbikge1xuICAgICAgdGhpcy5vdXRfZGVwdGggPSBqc29uLm91dF9kZXB0aDtcbiAgICAgIHRoaXMub3V0X3N4ID0ganNvbi5vdXRfc3g7XG4gICAgICB0aGlzLm91dF9zeSA9IGpzb24ub3V0X3N5O1xuICAgICAgdGhpcy5sYXllcl90eXBlID0ganNvbi5sYXllcl90eXBlOyBcbiAgICB9XG4gIH1cbiAgXG5cbiAgZ2xvYmFsLlF1YWRUcmFuc2Zvcm1MYXllciA9IFF1YWRUcmFuc2Zvcm1MYXllcjtcbn0pKGNvbnZuZXRqcyk7XG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgVm9sID0gZ2xvYmFsLlZvbDsgLy8gY29udmVuaWVuY2VcbiAgXG4gIC8vIE5ldCBtYW5hZ2VzIGEgc2V0IG9mIGxheWVyc1xuICAvLyBGb3Igbm93IGNvbnN0cmFpbnRzOiBTaW1wbGUgbGluZWFyIG9yZGVyIG9mIGxheWVycywgZmlyc3QgbGF5ZXIgaW5wdXQgbGFzdCBsYXllciBhIGNvc3QgbGF5ZXJcbiAgdmFyIE5ldCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICB9XG5cbiAgTmV0LnByb3RvdHlwZSA9IHtcbiAgICBcbiAgICAvLyB0YWtlcyBhIGxpc3Qgb2YgbGF5ZXIgZGVmaW5pdGlvbnMgYW5kIGNyZWF0ZXMgdGhlIG5ldHdvcmsgbGF5ZXIgb2JqZWN0c1xuICAgIG1ha2VMYXllcnM6IGZ1bmN0aW9uKGRlZnMpIHtcblxuICAgICAgLy8gZmV3IGNoZWNrcyBmb3Igbm93XG4gICAgICBpZihkZWZzLmxlbmd0aDwyKSB7Y29uc29sZS5sb2coJ0VSUk9SISBGb3Igbm93IGF0IGxlYXN0IGhhdmUgaW5wdXQgYW5kIHNvZnRtYXggbGF5ZXJzLicpO31cbiAgICAgIGlmKGRlZnNbMF0udHlwZSAhPT0gJ2lucHV0Jykge2NvbnNvbGUubG9nKCdFUlJPUiEgRm9yIG5vdyBmaXJzdCBsYXllciBzaG91bGQgYmUgaW5wdXQuJyk7fVxuXG4gICAgICAvLyBkZXN1Z2FyIHN5bnRhY3RpYyBmb3IgYWRkaW5nIGFjdGl2YXRpb25zIGFuZCBkcm9wb3V0c1xuICAgICAgdmFyIGRlc3VnYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld19kZWZzID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wO2k8ZGVmcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgdmFyIGRlZiA9IGRlZnNbaV07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoZGVmLnR5cGU9PT0nc29mdG1heCcgfHwgZGVmLnR5cGU9PT0nc3ZtJykge1xuICAgICAgICAgICAgLy8gYWRkIGFuIGZjIGxheWVyIGhlcmUsIHRoZXJlIGlzIG5vIHJlYXNvbiB0aGUgdXNlciBzaG91bGRcbiAgICAgICAgICAgIC8vIGhhdmUgdG8gd29ycnkgYWJvdXQgdGhpcyBhbmQgd2UgYWxtb3N0IGFsd2F5cyB3YW50IHRvXG4gICAgICAgICAgICBuZXdfZGVmcy5wdXNoKHt0eXBlOidmYycsIG51bV9uZXVyb25zOiBkZWYubnVtX2NsYXNzZXN9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZihkZWYudHlwZT09PSdyZWdyZXNzaW9uJykge1xuICAgICAgICAgICAgLy8gYWRkIGFuIGZjIGxheWVyIGhlcmUsIHRoZXJlIGlzIG5vIHJlYXNvbiB0aGUgdXNlciBzaG91bGRcbiAgICAgICAgICAgIC8vIGhhdmUgdG8gd29ycnkgYWJvdXQgdGhpcyBhbmQgd2UgYWxtb3N0IGFsd2F5cyB3YW50IHRvXG4gICAgICAgICAgICBuZXdfZGVmcy5wdXNoKHt0eXBlOidmYycsIG51bV9uZXVyb25zOiBkZWYubnVtX25ldXJvbnN9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZigoZGVmLnR5cGU9PT0nZmMnIHx8IGRlZi50eXBlPT09J2NvbnYnKSBcbiAgICAgICAgICAgICAgJiYgdHlwZW9mKGRlZi5iaWFzX3ByZWYpID09PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICBkZWYuYmlhc19wcmVmID0gMC4wO1xuICAgICAgICAgICAgaWYodHlwZW9mIGRlZi5hY3RpdmF0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBkZWYuYWN0aXZhdGlvbiA9PT0gJ3JlbHUnKSB7XG4gICAgICAgICAgICAgIGRlZi5iaWFzX3ByZWYgPSAwLjE7IC8vIHJlbHVzIGxpa2UgYSBiaXQgb2YgcG9zaXRpdmUgYmlhcyB0byBnZXQgZ3JhZGllbnRzIGVhcmx5XG4gICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIHRlY2huaWNhbGx5IHBvc3NpYmxlIHRoYXQgYSByZWx1IHVuaXQgd2lsbCBuZXZlciB0dXJuIG9uIChieSBjaGFuY2UpXG4gICAgICAgICAgICAgIC8vIGFuZCB3aWxsIG5ldmVyIGdldCBhbnkgZ3JhZGllbnQgYW5kIG5ldmVyIGNvbnRyaWJ1dGUgYW55IGNvbXB1dGF0aW9uLiBEZWFkIHJlbHUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKHR5cGVvZiBkZWYudGVuc29yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gYXBwbHkgcXVhZHJhdGljIHRyYW5zZm9ybSBzbyB0aGF0IHRoZSB1cGNvbWluZyBtdWx0aXBseSB3aWxsIGluY2x1ZGVcbiAgICAgICAgICAgIC8vIHF1YWRyYXRpYyB0ZXJtcywgZXF1aXZhbGVudCB0byBkb2luZyBhIHRlbnNvciBwcm9kdWN0XG4gICAgICAgICAgICBpZihkZWYudGVuc29yKSB7XG4gICAgICAgICAgICAgIG5ld19kZWZzLnB1c2goe3R5cGU6ICdxdWFkdHJhbnNmb3JtJ30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld19kZWZzLnB1c2goZGVmKTtcblxuICAgICAgICAgIGlmKHR5cGVvZiBkZWYuYWN0aXZhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmKGRlZi5hY3RpdmF0aW9uPT09J3JlbHUnKSB7IG5ld19kZWZzLnB1c2goe3R5cGU6J3JlbHUnfSk7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5hY3RpdmF0aW9uPT09J3NpZ21vaWQnKSB7IG5ld19kZWZzLnB1c2goe3R5cGU6J3NpZ21vaWQnfSk7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5hY3RpdmF0aW9uPT09J3RhbmgnKSB7IG5ld19kZWZzLnB1c2goe3R5cGU6J3RhbmgnfSk7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZi5hY3RpdmF0aW9uPT09J21heG91dCcpIHtcbiAgICAgICAgICAgICAgLy8gY3JlYXRlIG1heG91dCBhY3RpdmF0aW9uLCBhbmQgcGFzcyBhbG9uZyBncm91cCBzaXplLCBpZiBwcm92aWRlZFxuICAgICAgICAgICAgICB2YXIgZ3MgPSBkZWYuZ3JvdXBfc2l6ZSAhPT0gJ3VuZGVmaW5lZCcgPyBkZWYuZ3JvdXBfc2l6ZSA6IDI7XG4gICAgICAgICAgICAgIG5ld19kZWZzLnB1c2goe3R5cGU6J21heG91dCcsIGdyb3VwX3NpemU6Z3N9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyBjb25zb2xlLmxvZygnRVJST1IgdW5zdXBwb3J0ZWQgYWN0aXZhdGlvbiAnICsgZGVmLmFjdGl2YXRpb24pOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHR5cGVvZiBkZWYuZHJvcF9wcm9iICE9PSAndW5kZWZpbmVkJyAmJiBkZWYudHlwZSAhPT0gJ2Ryb3BvdXQnKSB7XG4gICAgICAgICAgICBuZXdfZGVmcy5wdXNoKHt0eXBlOidkcm9wb3V0JywgZHJvcF9wcm9iOiBkZWYuZHJvcF9wcm9ifSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld19kZWZzO1xuICAgICAgfVxuICAgICAgZGVmcyA9IGRlc3VnYXIoZGVmcyk7XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgbGF5ZXJzXG4gICAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgICAgZm9yKHZhciBpPTA7aTxkZWZzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgdmFyIGRlZiA9IGRlZnNbaV07XG4gICAgICAgIGlmKGk+MCkge1xuICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5sYXllcnNbaS0xXTtcbiAgICAgICAgICBkZWYuaW5fc3ggPSBwcmV2Lm91dF9zeDtcbiAgICAgICAgICBkZWYuaW5fc3kgPSBwcmV2Lm91dF9zeTtcbiAgICAgICAgICBkZWYuaW5fZGVwdGggPSBwcmV2Lm91dF9kZXB0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaChkZWYudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2ZjJzogdGhpcy5sYXllcnMucHVzaChuZXcgZ2xvYmFsLkZ1bGx5Q29ubkxheWVyKGRlZikpOyBicmVhaztcbiAgICAgICAgICBjYXNlICdscm4nOiB0aGlzLmxheWVycy5wdXNoKG5ldyBnbG9iYWwuTG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25MYXllcihkZWYpKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZHJvcG91dCc6IHRoaXMubGF5ZXJzLnB1c2gobmV3IGdsb2JhbC5Ecm9wb3V0TGF5ZXIoZGVmKSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2lucHV0JzogdGhpcy5sYXllcnMucHVzaChuZXcgZ2xvYmFsLklucHV0TGF5ZXIoZGVmKSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NvZnRtYXgnOiB0aGlzLmxheWVycy5wdXNoKG5ldyBnbG9iYWwuU29mdG1heExheWVyKGRlZikpOyBicmVhaztcbiAgICAgICAgICBjYXNlICdyZWdyZXNzaW9uJzogdGhpcy5sYXllcnMucHVzaChuZXcgZ2xvYmFsLlJlZ3Jlc3Npb25MYXllcihkZWYpKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY29udic6IHRoaXMubGF5ZXJzLnB1c2gobmV3IGdsb2JhbC5Db252TGF5ZXIoZGVmKSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Bvb2wnOiB0aGlzLmxheWVycy5wdXNoKG5ldyBnbG9iYWwuUG9vbExheWVyKGRlZikpOyBicmVhaztcbiAgICAgICAgICBjYXNlICdyZWx1JzogdGhpcy5sYXllcnMucHVzaChuZXcgZ2xvYmFsLlJlbHVMYXllcihkZWYpKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2lnbW9pZCc6IHRoaXMubGF5ZXJzLnB1c2gobmV3IGdsb2JhbC5TaWdtb2lkTGF5ZXIoZGVmKSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhbmgnOiB0aGlzLmxheWVycy5wdXNoKG5ldyBnbG9iYWwuVGFuaExheWVyKGRlZikpOyBicmVhaztcbiAgICAgICAgICBjYXNlICdtYXhvdXQnOiB0aGlzLmxheWVycy5wdXNoKG5ldyBnbG9iYWwuTWF4b3V0TGF5ZXIoZGVmKSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3F1YWR0cmFuc2Zvcm0nOiB0aGlzLmxheWVycy5wdXNoKG5ldyBnbG9iYWwuUXVhZFRyYW5zZm9ybUxheWVyKGRlZikpOyBicmVhaztcbiAgICAgICAgICBjYXNlICdzdm0nOiB0aGlzLmxheWVycy5wdXNoKG5ldyBnbG9iYWwuU1ZNTGF5ZXIoZGVmKSk7IGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IGNvbnNvbGUubG9nKCdFUlJPUjogVU5SRUNPR05JWkVEIExBWUVSIFRZUEUhJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gZm9yd2FyZCBwcm9wIHRoZSBuZXR3b3JrLiBBIHRyYWluZXIgd2lsbCBwYXNzIGluIGlzX3RyYWluaW5nID0gdHJ1ZVxuICAgIGZvcndhcmQ6IGZ1bmN0aW9uKFYsIGlzX3RyYWluaW5nKSB7XG4gICAgICBpZih0eXBlb2YoaXNfdHJhaW5pbmcpPT09J3VuZGVmaW5lZCcpIGlzX3RyYWluaW5nID0gZmFsc2U7XG4gICAgICB2YXIgYWN0ID0gdGhpcy5sYXllcnNbMF0uZm9yd2FyZChWLCBpc190cmFpbmluZyk7XG4gICAgICBmb3IodmFyIGk9MTtpPHRoaXMubGF5ZXJzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgYWN0ID0gdGhpcy5sYXllcnNbaV0uZm9yd2FyZChhY3QsIGlzX3RyYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Q7XG4gICAgfSxcbiAgICBcbiAgICAvLyBiYWNrcHJvcDogY29tcHV0ZSBncmFkaWVudHMgd3J0IGFsbCBwYXJhbWV0ZXJzXG4gICAgYmFja3dhcmQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHZhciBOID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuICAgICAgdmFyIGxvc3MgPSB0aGlzLmxheWVyc1tOLTFdLmJhY2t3YXJkKHkpOyAvLyBsYXN0IGxheWVyIGFzc3VtZWQgc29mdG1heFxuICAgICAgZm9yKHZhciBpPU4tMjtpPj0wO2ktLSkgeyAvLyBmaXJzdCBsYXllciBhc3N1bWVkIGlucHV0XG4gICAgICAgIHRoaXMubGF5ZXJzW2ldLmJhY2t3YXJkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9zcztcbiAgICB9LFxuICAgIGdldFBhcmFtc0FuZEdyYWRzOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGFjY3VtdWxhdGUgcGFyYW1ldGVycyBhbmQgZ3JhZGllbnRzIGZvciB0aGUgZW50aXJlIG5ldHdvcmtcbiAgICAgIHZhciByZXNwb25zZSA9IFtdO1xuICAgICAgZm9yKHZhciBpPTA7aTx0aGlzLmxheWVycy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIHZhciBsYXllcl9yZXBvbnNlID0gdGhpcy5sYXllcnNbaV0uZ2V0UGFyYW1zQW5kR3JhZHMoKTtcbiAgICAgICAgZm9yKHZhciBqPTA7ajxsYXllcl9yZXBvbnNlLmxlbmd0aDtqKyspIHtcbiAgICAgICAgICByZXNwb25zZS5wdXNoKGxheWVyX3JlcG9uc2Vbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbiAgICBnZXRQcmVkaWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBTID0gdGhpcy5sYXllcnNbdGhpcy5sYXllcnMubGVuZ3RoLTFdOyAvLyBzb2Z0bWF4IGxheWVyXG4gICAgICB2YXIgcCA9IFMub3V0X2FjdC53O1xuICAgICAgdmFyIG1heHYgPSBwWzBdO1xuICAgICAgdmFyIG1heGkgPSAwO1xuICAgICAgZm9yKHZhciBpPTE7aTxwLmxlbmd0aDtpKyspIHtcbiAgICAgICAgaWYocFtpXSA+IG1heHYpIHsgbWF4diA9IHBbaV07IG1heGkgPSBpO31cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhpO1xuICAgIH0sXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBqc29uID0ge307XG4gICAgICBqc29uLmxheWVycyA9IFtdO1xuICAgICAgZm9yKHZhciBpPTA7aTx0aGlzLmxheWVycy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIGpzb24ubGF5ZXJzLnB1c2godGhpcy5sYXllcnNbaV0udG9KU09OKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcbiAgICBmcm9tSlNPTjogZnVuY3Rpb24oanNvbikge1xuICAgICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICAgIGZvcih2YXIgaT0wO2k8anNvbi5sYXllcnMubGVuZ3RoO2krKykge1xuICAgICAgICB2YXIgTGogPSBqc29uLmxheWVyc1tpXVxuICAgICAgICB2YXIgdCA9IExqLmxheWVyX3R5cGU7XG4gICAgICAgIHZhciBMO1xuICAgICAgICBpZih0PT09J2lucHV0JykgeyBMID0gbmV3IGdsb2JhbC5JbnB1dExheWVyKCk7IH1cbiAgICAgICAgaWYodD09PSdyZWx1JykgeyBMID0gbmV3IGdsb2JhbC5SZWx1TGF5ZXIoKTsgfVxuICAgICAgICBpZih0PT09J3NpZ21vaWQnKSB7IEwgPSBuZXcgZ2xvYmFsLlNpZ21vaWRMYXllcigpOyB9XG4gICAgICAgIGlmKHQ9PT0ndGFuaCcpIHsgTCA9IG5ldyBnbG9iYWwuVGFuaExheWVyKCk7IH1cbiAgICAgICAgaWYodD09PSdkcm9wb3V0JykgeyBMID0gbmV3IGdsb2JhbC5Ecm9wb3V0TGF5ZXIoKTsgfVxuICAgICAgICBpZih0PT09J2NvbnYnKSB7IEwgPSBuZXcgZ2xvYmFsLkNvbnZMYXllcigpOyB9XG4gICAgICAgIGlmKHQ9PT0ncG9vbCcpIHsgTCA9IG5ldyBnbG9iYWwuUG9vbExheWVyKCk7IH1cbiAgICAgICAgaWYodD09PSdscm4nKSB7IEwgPSBuZXcgZ2xvYmFsLkxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uTGF5ZXIoKTsgfVxuICAgICAgICBpZih0PT09J3NvZnRtYXgnKSB7IEwgPSBuZXcgZ2xvYmFsLlNvZnRtYXhMYXllcigpOyB9XG4gICAgICAgIGlmKHQ9PT0ncmVncmVzc2lvbicpIHsgTCA9IG5ldyBnbG9iYWwuUmVncmVzc2lvbkxheWVyKCk7IH1cbiAgICAgICAgaWYodD09PSdmYycpIHsgTCA9IG5ldyBnbG9iYWwuRnVsbHlDb25uTGF5ZXIoKTsgfVxuICAgICAgICBpZih0PT09J21heG91dCcpIHsgTCA9IG5ldyBnbG9iYWwuTWF4b3V0TGF5ZXIoKTsgfVxuICAgICAgICBpZih0PT09J3F1YWR0cmFuc2Zvcm0nKSB7IEwgPSBuZXcgZ2xvYmFsLlF1YWRUcmFuc2Zvcm1MYXllcigpOyB9XG4gICAgICAgIGlmKHQ9PT0nc3ZtJykgeyBMID0gbmV3IGdsb2JhbC5TVk1MYXllcigpOyB9XG4gICAgICAgIEwuZnJvbUpTT04oTGopO1xuICAgICAgICB0aGlzLmxheWVycy5wdXNoKEwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcblxuICBnbG9iYWwuTmV0ID0gTmV0O1xufSkoY29udm5ldGpzKTtcbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBWb2wgPSBnbG9iYWwuVm9sOyAvLyBjb252ZW5pZW5jZVxuXG4gIHZhciBUcmFpbmVyID0gZnVuY3Rpb24obmV0LCBvcHRpb25zKSB7XG5cbiAgICB0aGlzLm5ldCA9IG5ldDtcblxuICAgIHZhciBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmxlYXJuaW5nX3JhdGUgPSB0eXBlb2Ygb3B0aW9ucy5sZWFybmluZ19yYXRlICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubGVhcm5pbmdfcmF0ZSA6IDAuMDE7XG4gICAgdGhpcy5sMV9kZWNheSA9IHR5cGVvZiBvcHRpb25zLmwxX2RlY2F5ICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubDFfZGVjYXkgOiAwLjA7XG4gICAgdGhpcy5sMl9kZWNheSA9IHR5cGVvZiBvcHRpb25zLmwyX2RlY2F5ICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubDJfZGVjYXkgOiAwLjA7XG4gICAgdGhpcy5iYXRjaF9zaXplID0gdHlwZW9mIG9wdGlvbnMuYmF0Y2hfc2l6ZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmJhdGNoX3NpemUgOiAxO1xuICAgIHRoaXMubWV0aG9kID0gdHlwZW9mIG9wdGlvbnMubWV0aG9kICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWV0aG9kIDogJ3NnZCc7IC8vIHNnZC9hZGFncmFkL2FkYWRlbHRhL3dpbmRvd2dyYWRcblxuICAgIHRoaXMubW9tZW50dW0gPSB0eXBlb2Ygb3B0aW9ucy5tb21lbnR1bSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1vbWVudHVtIDogMC45O1xuICAgIHRoaXMucm8gPSB0eXBlb2Ygb3B0aW9ucy5ybyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnJvIDogMC45NTsgLy8gdXNlZCBpbiBhZGFkZWx0YVxuICAgIHRoaXMuZXBzID0gdHlwZW9mIG9wdGlvbnMuZXBzICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuZXBzIDogMWUtNjsgLy8gdXNlZCBpbiBhZGFkZWx0YVxuXG4gICAgdGhpcy5rID0gMDsgLy8gaXRlcmF0aW9uIGNvdW50ZXJcbiAgICB0aGlzLmdzdW0gPSBbXTsgLy8gbGFzdCBpdGVyYXRpb24gZ3JhZGllbnRzICh1c2VkIGZvciBtb21lbnR1bSBjYWxjdWxhdGlvbnMpXG4gICAgdGhpcy54c3VtID0gW107IC8vIHVzZWQgaW4gYWRhZGVsdGFcbiAgfVxuXG4gIFRyYWluZXIucHJvdG90eXBlID0ge1xuICAgIHRyYWluOiBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5uZXQuZm9yd2FyZCh4LCB0cnVlKTsgLy8gYWxzbyBzZXQgdGhlIGZsYWcgdGhhdCBsZXRzIHRoZSBuZXQga25vdyB3ZSdyZSBqdXN0IHRyYWluaW5nXG4gICAgICB2YXIgZW5kID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB2YXIgZndkX3RpbWUgPSBlbmQgLSBzdGFydDtcblxuICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB2YXIgY29zdF9sb3NzID0gdGhpcy5uZXQuYmFja3dhcmQoeSk7XG4gICAgICB2YXIgbDJfZGVjYXlfbG9zcyA9IDAuMDtcbiAgICAgIHZhciBsMV9kZWNheV9sb3NzID0gMC4wO1xuICAgICAgdmFyIGVuZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdmFyIGJ3ZF90aW1lID0gZW5kIC0gc3RhcnQ7XG4gICAgICBcbiAgICAgIHRoaXMuaysrO1xuICAgICAgaWYodGhpcy5rICUgdGhpcy5iYXRjaF9zaXplID09PSAwKSB7XG5cbiAgICAgICAgdmFyIHBnbGlzdCA9IHRoaXMubmV0LmdldFBhcmFtc0FuZEdyYWRzKCk7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBsaXN0cyBmb3IgYWNjdW11bGF0b3JzLiBXaWxsIG9ubHkgYmUgZG9uZSBvbmNlIG9uIGZpcnN0IGl0ZXJhdGlvblxuICAgICAgICBpZih0aGlzLmdzdW0ubGVuZ3RoID09PSAwICYmICh0aGlzLm1ldGhvZCAhPT0gJ3NnZCcgfHwgdGhpcy5tb21lbnR1bSA+IDAuMCkpIHtcbiAgICAgICAgICAvLyBvbmx5IHZhbmlsbGEgc2dkIGRvZXNudCBuZWVkIGVpdGhlciBsaXN0c1xuICAgICAgICAgIC8vIG1vbWVudHVtIG5lZWRzIGdzdW1cbiAgICAgICAgICAvLyBhZGFncmFkIG5lZWRzIGdzdW1cbiAgICAgICAgICAvLyBhZGFkZWx0YSBuZWVkcyBnc3VtIGFuZCB4c3VtXG4gICAgICAgICAgZm9yKHZhciBpPTA7aTxwZ2xpc3QubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgdGhpcy5nc3VtLnB1c2goZ2xvYmFsLnplcm9zKHBnbGlzdFtpXS5wYXJhbXMubGVuZ3RoKSk7XG4gICAgICAgICAgICBpZih0aGlzLm1ldGhvZCA9PT0gJ2FkYWRlbHRhJykge1xuICAgICAgICAgICAgICB0aGlzLnhzdW0ucHVzaChnbG9iYWwuemVyb3MocGdsaXN0W2ldLnBhcmFtcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMueHN1bS5wdXNoKFtdKTsgLy8gY29uc2VydmUgbWVtb3J5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVyZm9ybSBhbiB1cGRhdGUgZm9yIGFsbCBzZXRzIG9mIHdlaWdodHNcbiAgICAgICAgZm9yKHZhciBpPTA7aTxwZ2xpc3QubGVuZ3RoO2krKykge1xuICAgICAgICAgIHZhciBwZyA9IHBnbGlzdFtpXTsgLy8gcGFyYW0sIGdyYWRpZW50LCBvdGhlciBvcHRpb25zIGluIGZ1dHVyZSAoY3VzdG9tIGxlYXJuaW5nIHJhdGUgZXRjKVxuICAgICAgICAgIHZhciBwID0gcGcucGFyYW1zO1xuICAgICAgICAgIHZhciBnID0gcGcuZ3JhZHM7XG5cbiAgICAgICAgICAvLyBsZWFybmluZyByYXRlIGZvciBzb21lIHBhcmFtZXRlcnMuXG4gICAgICAgICAgdmFyIGwyX2RlY2F5X211bCA9IHR5cGVvZiBwZy5sMl9kZWNheV9tdWwgIT09ICd1bmRlZmluZWQnID8gcGcubDJfZGVjYXlfbXVsIDogMS4wO1xuICAgICAgICAgIHZhciBsMV9kZWNheV9tdWwgPSB0eXBlb2YgcGcubDFfZGVjYXlfbXVsICE9PSAndW5kZWZpbmVkJyA/IHBnLmwxX2RlY2F5X211bCA6IDEuMDtcbiAgICAgICAgICB2YXIgbDJfZGVjYXkgPSB0aGlzLmwyX2RlY2F5ICogbDJfZGVjYXlfbXVsO1xuICAgICAgICAgIHZhciBsMV9kZWNheSA9IHRoaXMubDFfZGVjYXkgKiBsMV9kZWNheV9tdWw7XG5cbiAgICAgICAgICB2YXIgcGxlbiA9IHAubGVuZ3RoO1xuICAgICAgICAgIGZvcih2YXIgaj0wO2o8cGxlbjtqKyspIHtcbiAgICAgICAgICAgIGwyX2RlY2F5X2xvc3MgKz0gbDJfZGVjYXkqcFtqXSpwW2pdLzI7IC8vIGFjY3VtdWxhdGUgd2VpZ2h0IGRlY2F5IGxvc3NcbiAgICAgICAgICAgIGwxX2RlY2F5X2xvc3MgKz0gbDFfZGVjYXkqTWF0aC5hYnMocFtqXSk7XG4gICAgICAgICAgICB2YXIgbDFncmFkID0gbDFfZGVjYXkgKiAocFtqXSA+IDAgPyAxIDogLTEpO1xuICAgICAgICAgICAgdmFyIGwyZ3JhZCA9IGwyX2RlY2F5ICogKHBbal0pO1xuXG4gICAgICAgICAgICB2YXIgZ2lqID0gKGwyZ3JhZCArIGwxZ3JhZCArIGdbal0pIC8gdGhpcy5iYXRjaF9zaXplOyAvLyByYXcgYmF0Y2ggZ3JhZGllbnRcblxuICAgICAgICAgICAgdmFyIGdzdW1pID0gdGhpcy5nc3VtW2ldO1xuICAgICAgICAgICAgdmFyIHhzdW1pID0gdGhpcy54c3VtW2ldO1xuICAgICAgICAgICAgaWYodGhpcy5tZXRob2QgPT09ICdhZGFncmFkJykge1xuICAgICAgICAgICAgICAvLyBhZGFncmFkIHVwZGF0ZVxuICAgICAgICAgICAgICBnc3VtaVtqXSA9IGdzdW1pW2pdICsgZ2lqICogZ2lqO1xuICAgICAgICAgICAgICB2YXIgZHggPSAtIHRoaXMubGVhcm5pbmdfcmF0ZSAvIE1hdGguc3FydChnc3VtaVtqXSArIHRoaXMuZXBzKSAqIGdpajtcbiAgICAgICAgICAgICAgcFtqXSArPSBkeDtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm1ldGhvZCA9PT0gJ3dpbmRvd2dyYWQnKSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgYWRhZ3JhZCBidXQgd2l0aCBhIG1vdmluZyB3aW5kb3cgd2VpZ2h0ZWQgYXZlcmFnZVxuICAgICAgICAgICAgICAvLyBzbyB0aGUgZ3JhZGllbnQgaXMgbm90IGFjY3VtdWxhdGVkIG92ZXIgdGhlIGVudGlyZSBoaXN0b3J5IG9mIHRoZSBydW4uIFxuICAgICAgICAgICAgICAvLyBpdCdzIGFsc28gcmVmZXJyZWQgdG8gYXMgSWRlYSAjMSBpbiBaZWlsZXIgcGFwZXIgb24gQWRhZGVsdGEuIFNlZW1zIHJlYXNvbmFibGUgdG8gbWUhXG4gICAgICAgICAgICAgIGdzdW1pW2pdID0gdGhpcy5ybyAqIGdzdW1pW2pdICsgKDEtdGhpcy5ybykgKiBnaWogKiBnaWo7XG4gICAgICAgICAgICAgIHZhciBkeCA9IC0gdGhpcy5sZWFybmluZ19yYXRlIC8gTWF0aC5zcXJ0KGdzdW1pW2pdICsgdGhpcy5lcHMpICogZ2lqOyAvLyBlcHMgYWRkZWQgZm9yIGJldHRlciBjb25kaXRpb25pbmdcbiAgICAgICAgICAgICAgcFtqXSArPSBkeDtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm1ldGhvZCA9PT0gJ2FkYWRlbHRhJykge1xuICAgICAgICAgICAgICAvLyBhc3N1bWUgYWRhZGVsdGEgaWYgbm90IHNnZCBvciBhZGFncmFkXG4gICAgICAgICAgICAgIGdzdW1pW2pdID0gdGhpcy5ybyAqIGdzdW1pW2pdICsgKDEtdGhpcy5ybykgKiBnaWogKiBnaWo7XG4gICAgICAgICAgICAgIHZhciBkeCA9IC0gTWF0aC5zcXJ0KCh4c3VtaVtqXSArIHRoaXMuZXBzKS8oZ3N1bWlbal0gKyB0aGlzLmVwcykpICogZ2lqO1xuICAgICAgICAgICAgICB4c3VtaVtqXSA9IHRoaXMucm8gKiB4c3VtaVtqXSArICgxLXRoaXMucm8pICogZHggKiBkeDsgLy8geWVzLCB4c3VtIGxhZ3MgYmVoaW5kIGdzdW0gYnkgMS5cbiAgICAgICAgICAgICAgcFtqXSArPSBkeDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGFzc3VtZSBTR0RcbiAgICAgICAgICAgICAgaWYodGhpcy5tb21lbnR1bSA+IDAuMCkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudHVtIHVwZGF0ZVxuICAgICAgICAgICAgICAgIHZhciBkeCA9IHRoaXMubW9tZW50dW0gKiBnc3VtaVtqXSAtIHRoaXMubGVhcm5pbmdfcmF0ZSAqIGdpajsgLy8gc3RlcFxuICAgICAgICAgICAgICAgIGdzdW1pW2pdID0gZHg7IC8vIGJhY2sgdGhpcyB1cCBmb3IgbmV4dCBpdGVyYXRpb24gb2YgbW9tZW50dW1cbiAgICAgICAgICAgICAgICBwW2pdICs9IGR4OyAvLyBhcHBseSBjb3JyZWN0ZWQgZ3JhZGllbnRcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB2YW5pbGxhIHNnZFxuICAgICAgICAgICAgICAgIHBbal0gKz0gIC0gdGhpcy5sZWFybmluZ19yYXRlICogZ2lqO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnW2pdID0gMC4wOyAvLyB6ZXJvIG91dCBncmFkaWVudCBzbyB0aGF0IHdlIGNhbiBiZWdpbiBhY2N1bXVsYXRpbmcgYW5ld1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhcHBlbmRpbmcgc29mdG1heF9sb3NzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYnV0IGZyb20gbm93IG9uIHdlIHdpbGwgYWx3YXlzIHVzZSBjb3N0X2xvc3NcbiAgICAgIC8vIGluIGZ1dHVyZSwgVE9ETzogaGF2ZSB0byBjb21wbGV0ZWx5IHJlZG8gdGhlIHdheSBsb3NzIGlzIGRvbmUgYXJvdW5kIHRoZSBuZXR3b3JrIGFzIGN1cnJlbnRseSBcbiAgICAgIC8vIGxvc3MgaXMgYSBiaXQgb2YgYSBoYWNrLiBJZGVhbGx5LCB1c2VyIHNob3VsZCBzcGVjaWZ5IGFyYml0cmFyeSBudW1iZXIgb2YgbG9zcyBmdW5jdGlvbnMgb24gYW55IGxheWVyXG4gICAgICAvLyBhbmQgaXQgc2hvdWxkIGFsbCBiZSBjb21wdXRlZCBjb3JyZWN0bHkgYW5kIGF1dG9tYXRpY2FsbHkuIFxuICAgICAgcmV0dXJuIHtmd2RfdGltZTogZndkX3RpbWUsIGJ3ZF90aW1lOiBid2RfdGltZSwgXG4gICAgICAgICAgICAgIGwyX2RlY2F5X2xvc3M6IGwyX2RlY2F5X2xvc3MsIGwxX2RlY2F5X2xvc3M6IGwxX2RlY2F5X2xvc3MsXG4gICAgICAgICAgICAgIGNvc3RfbG9zczogY29zdF9sb3NzLCBzb2Z0bWF4X2xvc3M6IGNvc3RfbG9zcywgXG4gICAgICAgICAgICAgIGxvc3M6IGNvc3RfbG9zcyArIGwxX2RlY2F5X2xvc3MgKyBsMl9kZWNheV9sb3NzfVxuICAgIH1cbiAgfVxuICBcbiAgZ2xvYmFsLlRyYWluZXIgPSBUcmFpbmVyO1xuICBnbG9iYWwuU0dEVHJhaW5lciA9IFRyYWluZXI7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG59KShjb252bmV0anMpO1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIHVzZWQgdXRpbGl0aWVzLCBtYWtlIGV4cGxpY2l0IGxvY2FsIHJlZmVyZW5jZXNcbiAgdmFyIHJhbmRmID0gZ2xvYmFsLnJhbmRmO1xuICB2YXIgcmFuZGkgPSBnbG9iYWwucmFuZGk7XG4gIHZhciBOZXQgPSBnbG9iYWwuTmV0O1xuICB2YXIgVHJhaW5lciA9IGdsb2JhbC5UcmFpbmVyO1xuICB2YXIgbWF4bWluID0gZ2xvYmFsLm1heG1pbjtcbiAgdmFyIHJhbmRwZXJtID0gZ2xvYmFsLnJhbmRwZXJtO1xuICB2YXIgd2VpZ2h0ZWRTYW1wbGUgPSBnbG9iYWwud2VpZ2h0ZWRTYW1wbGU7XG4gIHZhciBnZXRvcHQgPSBnbG9iYWwuZ2V0b3B0O1xuICB2YXIgYXJyVW5pcXVlID0gZ2xvYmFsLmFyclVuaXF1ZTtcblxuICAvKlxuICBBIE1hZ2ljTmV0IHRha2VzIGRhdGE6IGEgbGlzdCBvZiBjb252bmV0anMuVm9sKCksIGFuZCBsYWJlbHNcbiAgd2hpY2ggZm9yIG5vdyBhcmUgYXNzdW1lZCB0byBiZSBjbGFzcyBpbmRlY2VzIDAuLksuIE1hZ2ljTmV0IHRoZW46XG4gIC0gY3JlYXRlcyBkYXRhIGZvbGRzIGZvciBjcm9zcy12YWxpZGF0aW9uXG4gIC0gc2FtcGxlcyBjYW5kaWRhdGUgbmV0d29ya3NcbiAgLSBldmFsdWF0ZXMgY2FuZGlkYXRlIG5ldHdvcmtzIG9uIGFsbCBkYXRhIGZvbGRzXG4gIC0gcHJvZHVjZXMgcHJlZGljdGlvbnMgYnkgbW9kZWwtYXZlcmFnaW5nIHRoZSBiZXN0IG5ldHdvcmtzXG4gICovXG4gIHZhciBNYWdpY05ldCA9IGZ1bmN0aW9uKGRhdGEsIGxhYmVscywgb3B0KSB7XG4gICAgdmFyIG9wdCA9IG9wdCB8fCB7fTtcbiAgICBpZih0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHsgZGF0YSA9IFtdOyB9XG4gICAgaWYodHlwZW9mIGxhYmVscyA9PT0gJ3VuZGVmaW5lZCcpIHsgbGFiZWxzID0gW107IH1cblxuICAgIC8vIHJlcXVpcmVkIGlucHV0c1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7IC8vIHN0b3JlIHRoZXNlIHBvaW50ZXJzIHRvIGRhdGFcbiAgICB0aGlzLmxhYmVscyA9IGxhYmVscztcblxuICAgIC8vIG9wdGlvbmFsIGlucHV0c1xuICAgIHRoaXMudHJhaW5fcmF0aW8gPSBnZXRvcHQob3B0LCAndHJhaW5fcmF0aW8nLCAwLjcpO1xuICAgIHRoaXMubnVtX2ZvbGRzID0gZ2V0b3B0KG9wdCwgJ251bV9mb2xkcycsIDEwKTtcbiAgICB0aGlzLm51bV9jYW5kaWRhdGVzID0gZ2V0b3B0KG9wdCwgJ251bV9jYW5kaWRhdGVzJywgNTApOyAvLyB3ZSBldmFsdWF0ZSBzZXZlcmFsIGluIHBhcmFsbGVsXG4gICAgLy8gaG93IG1hbnkgZXBvY2hzIG9mIGRhdGEgdG8gdHJhaW4gZXZlcnkgbmV0d29yaz8gZm9yIGV2ZXJ5IGZvbGQ/XG4gICAgLy8gaGlnaGVyIHZhbHVlcyBtZWFuIGhpZ2hlciBhY2N1cmFjeSBpbiBmaW5hbCByZXN1bHRzLCBidXQgbW9yZSBleHBlbnNpdmVcbiAgICB0aGlzLm51bV9lcG9jaHMgPSBnZXRvcHQob3B0LCAnbnVtX2Vwb2NocycsIDUwKTsgXG4gICAgLy8gbnVtYmVyIG9mIGJlc3QgbW9kZWxzIHRvIGF2ZXJhZ2UgZHVyaW5nIHByZWRpY3Rpb24uIFVzdWFsbHkgaGlnaGVyID0gYmV0dGVyXG4gICAgdGhpcy5lbnNlbWJsZV9zaXplID0gZ2V0b3B0KG9wdCwgJ2Vuc2VtYmxlX3NpemUnLCAxMCk7XG5cbiAgICAvLyBjYW5kaWRhdGUgcGFyYW1ldGVyc1xuICAgIHRoaXMuYmF0Y2hfc2l6ZV9taW4gPSBnZXRvcHQob3B0LCAnYmF0Y2hfc2l6ZV9taW4nLCAxMCk7XG4gICAgdGhpcy5iYXRjaF9zaXplX21heCA9IGdldG9wdChvcHQsICdiYXRjaF9zaXplX21heCcsIDMwMCk7XG4gICAgdGhpcy5sMl9kZWNheV9taW4gPSBnZXRvcHQob3B0LCAnbDJfZGVjYXlfbWluJywgLTQpO1xuICAgIHRoaXMubDJfZGVjYXlfbWF4ID0gZ2V0b3B0KG9wdCwgJ2wyX2RlY2F5X21heCcsIDIpO1xuICAgIHRoaXMubGVhcm5pbmdfcmF0ZV9taW4gPSBnZXRvcHQob3B0LCAnbGVhcm5pbmdfcmF0ZV9taW4nLCAtNCk7XG4gICAgdGhpcy5sZWFybmluZ19yYXRlX21heCA9IGdldG9wdChvcHQsICdsZWFybmluZ19yYXRlX21heCcsIDApO1xuICAgIHRoaXMubW9tZW50dW1fbWluID0gZ2V0b3B0KG9wdCwgJ21vbWVudHVtX21pbicsIDAuOSk7XG4gICAgdGhpcy5tb21lbnR1bV9tYXggPSBnZXRvcHQob3B0LCAnbW9tZW50dW1fbWF4JywgMC45KTtcbiAgICB0aGlzLm5ldXJvbnNfbWluID0gZ2V0b3B0KG9wdCwgJ25ldXJvbnNfbWluJywgNSk7XG4gICAgdGhpcy5uZXVyb25zX21heCA9IGdldG9wdChvcHQsICduZXVyb25zX21heCcsIDMwKTtcblxuICAgIC8vIGNvbXB1dGVkXG4gICAgdGhpcy5mb2xkcyA9IFtdOyAvLyBkYXRhIGZvbGQgaW5kaWNlcywgZ2V0cyBmaWxsZWQgYnkgc2FtcGxlRm9sZHMoKVxuICAgIHRoaXMuY2FuZGlkYXRlcyA9IFtdOyAvLyBjYW5kaWRhdGUgbmV0d29ya3MgdGhhdCBhcmUgYmVpbmcgY3VycmVudGx5IGV2YWx1YXRlZFxuICAgIHRoaXMuZXZhbHVhdGVkX2NhbmRpZGF0ZXMgPSBbXTsgLy8gaGlzdG9yeSBvZiBhbGwgY2FuZGlkYXRlcyB0aGF0IHdlcmUgZnVsbHkgZXZhbHVhdGVkIG9uIGFsbCBmb2xkc1xuICAgIHRoaXMudW5pcXVlX2xhYmVscyA9IGFyclVuaXF1ZShsYWJlbHMpO1xuICAgIHRoaXMuaXRlciA9IDA7IC8vIGl0ZXJhdGlvbiBjb3VudGVyLCBnb2VzIGZyb20gMCAtPiBudW1fZXBvY2hzICogbnVtX3RyYWluaW5nX2RhdGFcbiAgICB0aGlzLmZvbGRpeCA9IDA7IC8vIGluZGV4IG9mIGFjdGl2ZSBmb2xkXG5cbiAgICAvLyBjYWxsYmFja3NcbiAgICB0aGlzLmZpbmlzaF9mb2xkX2NhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLmZpbmlzaF9iYXRjaF9jYWxsYmFjayA9IG51bGw7XG5cbiAgICAvLyBpbml0aWFsaXphdGlvbnNcbiAgICBpZih0aGlzLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zYW1wbGVGb2xkcygpO1xuICAgICAgdGhpcy5zYW1wbGVDYW5kaWRhdGVzKCk7XG4gICAgfVxuICB9O1xuXG4gIE1hZ2ljTmV0LnByb3RvdHlwZSA9IHtcblxuICAgIC8vIHNldHMgdGhpcy5mb2xkcyB0byBhIHNhbXBsaW5nIG9mIHRoaXMubnVtX2ZvbGRzIGZvbGRzXG4gICAgc2FtcGxlRm9sZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIE4gPSB0aGlzLmRhdGEubGVuZ3RoO1xuICAgICAgdmFyIG51bV90cmFpbiA9IE1hdGguZmxvb3IodGhpcy50cmFpbl9yYXRpbyAqIE4pO1xuICAgICAgdGhpcy5mb2xkcyA9IFtdOyAvLyBmbHVzaCBmb2xkcywgaWYgYW55XG4gICAgICBmb3IodmFyIGk9MDtpPHRoaXMubnVtX2ZvbGRzO2krKykge1xuICAgICAgICB2YXIgcCA9IHJhbmRwZXJtKE4pO1xuICAgICAgICB0aGlzLmZvbGRzLnB1c2goe3RyYWluX2l4OiBwLnNsaWNlKDAsIG51bV90cmFpbiksIHRlc3RfaXg6IHAuc2xpY2UobnVtX3RyYWluLCBOKX0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyByZXR1cm5zIGEgcmFuZG9tIGNhbmRpZGF0ZSBuZXR3b3JrXG4gICAgc2FtcGxlQ2FuZGlkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbnB1dF9kZXB0aCA9IHRoaXMuZGF0YVswXS53Lmxlbmd0aDtcbiAgICAgIHZhciBudW1fY2xhc3NlcyA9IHRoaXMudW5pcXVlX2xhYmVscy5sZW5ndGg7XG5cbiAgICAgIC8vIHNhbXBsZSBuZXR3b3JrIHRvcG9sb2d5IGFuZCBoeXBlcnBhcmFtZXRlcnNcbiAgICAgIHZhciBsYXllcl9kZWZzID0gW107XG4gICAgICBsYXllcl9kZWZzLnB1c2goe3R5cGU6J2lucHV0Jywgb3V0X3N4OjEsIG91dF9zeToxLCBvdXRfZGVwdGg6IGlucHV0X2RlcHRofSk7XG4gICAgICB2YXIgbmwgPSB3ZWlnaHRlZFNhbXBsZShbMCwxLDIsM10sIFswLjIsIDAuMywgMC4zLCAwLjJdKTsgLy8gcHJlZmVyIG5ldHMgd2l0aCAxLDIgaGlkZGVuIGxheWVyc1xuICAgICAgZm9yKHZhciBxPTA7cTxubDtxKyspIHtcbiAgICAgICAgdmFyIG5pID0gcmFuZGkodGhpcy5uZXVyb25zX21pbiwgdGhpcy5uZXVyb25zX21heCk7XG4gICAgICAgIHZhciBhY3QgPSBbJ3RhbmgnLCdtYXhvdXQnLCdyZWx1J11bcmFuZGkoMCwzKV07XG4gICAgICAgIGlmKHJhbmRmKDAsMSk8MC41KSB7XG4gICAgICAgICAgdmFyIGRwID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICBsYXllcl9kZWZzLnB1c2goe3R5cGU6J2ZjJywgbnVtX25ldXJvbnM6IG5pLCBhY3RpdmF0aW9uOiBhY3QsIGRyb3BfcHJvYjogZHB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXllcl9kZWZzLnB1c2goe3R5cGU6J2ZjJywgbnVtX25ldXJvbnM6IG5pLCBhY3RpdmF0aW9uOiBhY3R9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGF5ZXJfZGVmcy5wdXNoKHt0eXBlOidzb2Z0bWF4JywgbnVtX2NsYXNzZXM6IG51bV9jbGFzc2VzfSk7XG4gICAgICB2YXIgbmV0ID0gbmV3IE5ldCgpO1xuICAgICAgbmV0Lm1ha2VMYXllcnMobGF5ZXJfZGVmcyk7XG5cbiAgICAgIC8vIHNhbXBsZSB0cmFpbmluZyBoeXBlcnBhcmFtZXRlcnNcbiAgICAgIHZhciBicyA9IHJhbmRpKHRoaXMuYmF0Y2hfc2l6ZV9taW4sIHRoaXMuYmF0Y2hfc2l6ZV9tYXgpOyAvLyBiYXRjaCBzaXplXG4gICAgICB2YXIgbDIgPSBNYXRoLnBvdygxMCwgcmFuZGYodGhpcy5sMl9kZWNheV9taW4sIHRoaXMubDJfZGVjYXlfbWF4KSk7IC8vIGwyIHdlaWdodCBkZWNheVxuICAgICAgdmFyIGxyID0gTWF0aC5wb3coMTAsIHJhbmRmKHRoaXMubGVhcm5pbmdfcmF0ZV9taW4sIHRoaXMubGVhcm5pbmdfcmF0ZV9tYXgpKTsgLy8gbGVhcm5pbmcgcmF0ZVxuICAgICAgdmFyIG1vbSA9IHJhbmRmKHRoaXMubW9tZW50dW1fbWluLCB0aGlzLm1vbWVudHVtX21heCk7IC8vIG1vbWVudHVtLiBMZXRzIGp1c3QgdXNlIDAuOSwgd29ya3Mgb2theSB1c3VhbGx5IDtwXG4gICAgICB2YXIgdHAgPSByYW5kZigwLDEpOyAvLyB0cmFpbmVyIHR5cGVcbiAgICAgIHZhciB0cmFpbmVyX2RlZjtcbiAgICAgIGlmKHRwPDAuMzMpIHtcbiAgICAgICAgdHJhaW5lcl9kZWYgPSB7bWV0aG9kOidhZGFkZWx0YScsIGJhdGNoX3NpemU6YnMsIGwyX2RlY2F5OmwyfTtcbiAgICAgIH0gZWxzZSBpZih0cDwwLjY2KSB7XG4gICAgICAgIHRyYWluZXJfZGVmID0ge21ldGhvZDonYWRhZ3JhZCcsIGxlYXJuaW5nX3JhdGU6IGxyLCBiYXRjaF9zaXplOmJzLCBsMl9kZWNheTpsMn07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFpbmVyX2RlZiA9IHttZXRob2Q6J3NnZCcsIGxlYXJuaW5nX3JhdGU6IGxyLCBtb21lbnR1bTogbW9tLCBiYXRjaF9zaXplOmJzLCBsMl9kZWNheTpsMn07XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciB0cmFpbmVyID0gbmV3IFRyYWluZXIobmV0LCB0cmFpbmVyX2RlZik7XG5cbiAgICAgIHZhciBjYW5kID0ge307XG4gICAgICBjYW5kLmFjYyA9IFtdO1xuICAgICAgY2FuZC5hY2N2ID0gMDsgLy8gdGhpcyB3aWxsIG1haW50YWluZWQgYXMgc3VtKGFjYykgZm9yIGNvbnZlbmllbmNlXG4gICAgICBjYW5kLmxheWVyX2RlZnMgPSBsYXllcl9kZWZzO1xuICAgICAgY2FuZC50cmFpbmVyX2RlZiA9IHRyYWluZXJfZGVmO1xuICAgICAgY2FuZC5uZXQgPSBuZXQ7XG4gICAgICBjYW5kLnRyYWluZXIgPSB0cmFpbmVyO1xuICAgICAgcmV0dXJuIGNhbmQ7XG4gICAgfSxcblxuICAgIC8vIHNldHMgdGhpcy5jYW5kaWRhdGVzIHdpdGggdGhpcy5udW1fY2FuZGlkYXRlcyBjYW5kaWRhdGUgbmV0c1xuICAgIHNhbXBsZUNhbmRpZGF0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jYW5kaWRhdGVzID0gW107IC8vIGZsdXNoLCBpZiBhbnlcbiAgICAgIGZvcih2YXIgaT0wO2k8dGhpcy5udW1fY2FuZGlkYXRlcztpKyspIHtcbiAgICAgICAgdmFyIGNhbmQgPSB0aGlzLnNhbXBsZUNhbmRpZGF0ZSgpO1xuICAgICAgICB0aGlzLmNhbmRpZGF0ZXMucHVzaChjYW5kKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RlcDogZnVuY3Rpb24oKSB7XG4gICAgICBcbiAgICAgIC8vIHJ1biBhbiBleGFtcGxlIHRocm91Z2ggY3VycmVudCBjYW5kaWRhdGVcbiAgICAgIHRoaXMuaXRlcisrO1xuXG4gICAgICAvLyBzdGVwIGFsbCBjYW5kaWRhdGVzIG9uIGEgcmFuZG9tIGRhdGEgcG9pbnRcbiAgICAgIHZhciBmb2xkID0gdGhpcy5mb2xkc1t0aGlzLmZvbGRpeF07IC8vIGFjdGl2ZSBmb2xkXG4gICAgICB2YXIgZGF0YWl4ID0gZm9sZC50cmFpbl9peFtyYW5kaSgwLCBmb2xkLnRyYWluX2l4Lmxlbmd0aCldO1xuICAgICAgZm9yKHZhciBrPTA7azx0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoO2srKykge1xuICAgICAgICB2YXIgeCA9IHRoaXMuZGF0YVtkYXRhaXhdO1xuICAgICAgICB2YXIgbCA9IHRoaXMubGFiZWxzW2RhdGFpeF07XG4gICAgICAgIHRoaXMuY2FuZGlkYXRlc1trXS50cmFpbmVyLnRyYWluKHgsIGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcm9jZXNzIGNvbnNlcXVlbmNlczogc2FtcGxlIG5ldyBmb2xkcywgb3IgY2FuZGlkYXRlc1xuICAgICAgdmFyIGxhc3RpdGVyID0gdGhpcy5udW1fZXBvY2hzICogZm9sZC50cmFpbl9peC5sZW5ndGg7XG4gICAgICBpZih0aGlzLml0ZXIgPj0gbGFzdGl0ZXIpIHtcbiAgICAgICAgLy8gZmluaXNoZWQgZXZhbHVhdGlvbiBvZiB0aGlzIGZvbGQuIEdldCBmaW5hbCB2YWxpZGF0aW9uXG4gICAgICAgIC8vIGFjY3VyYWNpZXMsIHJlY29yZCB0aGVtLCBhbmQgZ28gb24gdG8gbmV4dCBmb2xkLlxuICAgICAgICB2YXIgdmFsX2FjYyA9IHRoaXMuZXZhbFZhbEVycm9ycygpO1xuICAgICAgICBmb3IodmFyIGs9MDtrPHRoaXMuY2FuZGlkYXRlcy5sZW5ndGg7aysrKSB7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzLmNhbmRpZGF0ZXNba107XG4gICAgICAgICAgYy5hY2MucHVzaCh2YWxfYWNjW2tdKTtcbiAgICAgICAgICBjLmFjY3YgKz0gdmFsX2FjY1trXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZXIgPSAwOyAvLyByZXNldCBzdGVwIG51bWJlclxuICAgICAgICB0aGlzLmZvbGRpeCsrOyAvLyBpbmNyZW1lbnQgZm9sZFxuXG4gICAgICAgIGlmKHRoaXMuZmluaXNoX2ZvbGRfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmZpbmlzaF9mb2xkX2NhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmZvbGRpeCA+PSB0aGlzLmZvbGRzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIHdlIGZpbmlzaGVkIGFsbCBmb2xkcyBhcyB3ZWxsISBSZWNvcmQgdGhlc2UgY2FuZGlkYXRlc1xuICAgICAgICAgIC8vIGFuZCBzYW1wbGUgbmV3IG9uZXMgdG8gZXZhbHVhdGUuXG4gICAgICAgICAgZm9yKHZhciBrPTA7azx0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoO2srKykge1xuICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZWRfY2FuZGlkYXRlcy5wdXNoKHRoaXMuY2FuZGlkYXRlc1trXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNvcnQgZXZhbHVhdGVkIGNhbmRpZGF0ZXMgYWNjb3JkaW5nIHRvIGFjY3VyYWN5IGFjaGlldmVkXG4gICAgICAgICAgdGhpcy5ldmFsdWF0ZWRfY2FuZGlkYXRlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgXG4gICAgICAgICAgICByZXR1cm4gKGEuYWNjdiAvIGEuYWNjLmxlbmd0aCkgXG4gICAgICAgICAgICAgICAgID4gKGIuYWNjdiAvIGIuYWNjLmxlbmd0aCkgXG4gICAgICAgICAgICAgICAgID8gLTEgOiAxO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIGFuZCBjbGlwIG9ubHkgdG8gdGhlIHRvcCBmZXcgb25lcyAobGV0cyBwbGFjZSBsaW1pdCBhdCAzKmVuc2VtYmxlX3NpemUpXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZXJlIGFyZSBjb25jZXJucyB3aXRoIGtlZXBpbmcgdGhlc2UgYWxsIGluIG1lbW9yeSBcbiAgICAgICAgICAvLyBpZiBNYWdpY05ldCBpcyBiZWluZyBldmFsdWF0ZWQgZm9yIGEgdmVyeSBsb25nIHRpbWVcbiAgICAgICAgICBpZih0aGlzLmV2YWx1YXRlZF9jYW5kaWRhdGVzLmxlbmd0aCA+IDMgKiB0aGlzLmVuc2VtYmxlX3NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGVkX2NhbmRpZGF0ZXMgPSB0aGlzLmV2YWx1YXRlZF9jYW5kaWRhdGVzLnNsaWNlKDAsIDMgKiB0aGlzLmVuc2VtYmxlX3NpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0aGlzLmZpbmlzaF9iYXRjaF9jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5maW5pc2hfYmF0Y2hfY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zYW1wbGVDYW5kaWRhdGVzKCk7IC8vIGJlZ2luIHdpdGggbmV3IGNhbmRpZGF0ZXNcbiAgICAgICAgICB0aGlzLmZvbGRpeCA9IDA7IC8vIHJlc2V0IHRoaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3ZSB3aWxsIGdvIG9uIHRvIGFub3RoZXIgZm9sZC4gcmVzZXQgYWxsIGNhbmRpZGF0ZXMgbmV0c1xuICAgICAgICAgIGZvcih2YXIgaz0wO2s8dGhpcy5jYW5kaWRhdGVzLmxlbmd0aDtrKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jYW5kaWRhdGVzW2tdO1xuICAgICAgICAgICAgdmFyIG5ldCA9IG5ldyBOZXQoKTtcbiAgICAgICAgICAgIG5ldC5tYWtlTGF5ZXJzKGMubGF5ZXJfZGVmcyk7XG4gICAgICAgICAgICB2YXIgdHJhaW5lciA9IG5ldyBUcmFpbmVyKG5ldCwgYy50cmFpbmVyX2RlZik7XG4gICAgICAgICAgICBjLm5ldCA9IG5ldDtcbiAgICAgICAgICAgIGMudHJhaW5lciA9IHRyYWluZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGV2YWxWYWxFcnJvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gZXZhbHVhdGUgY2FuZGlkYXRlcyBvbiB2YWxpZGF0aW9uIGRhdGEgYW5kIHJldHVybiBwZXJmb3JtYW5jZSBvZiBjdXJyZW50IG5ldHdvcmtzXG4gICAgICAvLyBhcyBzaW1wbGUgbGlzdFxuICAgICAgdmFyIHZhbHMgPSBbXTtcbiAgICAgIHZhciBmb2xkID0gdGhpcy5mb2xkc1t0aGlzLmZvbGRpeF07IC8vIGFjdGl2ZSBmb2xkXG4gICAgICBmb3IodmFyIGs9MDtrPHRoaXMuY2FuZGlkYXRlcy5sZW5ndGg7aysrKSB7XG4gICAgICAgIHZhciBuZXQgPSB0aGlzLmNhbmRpZGF0ZXNba10ubmV0O1xuICAgICAgICB2YXIgdiA9IDAuMDtcbiAgICAgICAgZm9yKHZhciBxPTA7cTxmb2xkLnRlc3RfaXgubGVuZ3RoO3ErKykge1xuICAgICAgICAgIHZhciB4ID0gdGhpcy5kYXRhW2ZvbGQudGVzdF9peFtxXV07XG4gICAgICAgICAgdmFyIGwgPSB0aGlzLmxhYmVsc1tmb2xkLnRlc3RfaXhbcV1dO1xuICAgICAgICAgIG5ldC5mb3J3YXJkKHgpO1xuICAgICAgICAgIHZhciB5aGF0ID0gbmV0LmdldFByZWRpY3Rpb24oKTtcbiAgICAgICAgICB2ICs9ICh5aGF0ID09PSBsID8gMS4wIDogMC4wKTsgLy8gMCAxIGxvc3NcbiAgICAgICAgfVxuICAgICAgICB2IC89IGZvbGQudGVzdF9peC5sZW5ndGg7IC8vIG5vcm1hbGl6ZVxuICAgICAgICB2YWxzLnB1c2godik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFscztcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJucyBwcmVkaWN0aW9uIHNjb3JlcyBmb3IgZ2l2ZW4gdGVzdCBkYXRhIHBvaW50LCBhcyBWb2xcbiAgICAvLyB1c2VzIGFuIGF2ZXJhZ2VkIHByZWRpY3Rpb24gZnJvbSB0aGUgYmVzdCBlbnNlbWJsZV9zaXplIG1vZGVsc1xuICAgIC8vIHggaXMgYSBWb2wuXG4gICAgcHJlZGljdF9zb2Z0OiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAvLyBmb3J3YXJkIHByb3AgdGhlIGJlc3QgbmV0d29ya3NcbiAgICAgIC8vIGFuZCBhY2N1bXVsYXRlIHByb2JhYmlsaXRpZXMgYXQgbGFzdCBsYXllciBpbnRvIGEgYW4gb3V0cHV0IFZvbFxuICAgICAgdmFyIG52ID0gTWF0aC5taW4odGhpcy5lbnNlbWJsZV9zaXplLCB0aGlzLmV2YWx1YXRlZF9jYW5kaWRhdGVzLmxlbmd0aCk7XG4gICAgICBpZihudiA9PT0gMCkgeyByZXR1cm4gbmV3IGNvbnZuZXRqcy5Wb2woMCwwLDApOyB9IC8vIG5vdCBzdXJlIHdoYXQgdG8gZG8gaGVyZT8gd2UncmUgbm90IHJlYWR5IHlldFxuICAgICAgdmFyIHhvdXQsIG47XG4gICAgICBmb3IodmFyIGo9MDtqPG52O2orKykge1xuICAgICAgICB2YXIgbmV0ID0gdGhpcy5ldmFsdWF0ZWRfY2FuZGlkYXRlc1tqXS5uZXQ7XG4gICAgICAgIHZhciB4ID0gbmV0LmZvcndhcmQoZGF0YSk7XG4gICAgICAgIGlmKGo9PT0wKSB7IFxuICAgICAgICAgIHhvdXQgPSB4OyBcbiAgICAgICAgICBuID0geC53Lmxlbmd0aDsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWRkIGl0IG9uXG4gICAgICAgICAgZm9yKHZhciBkPTA7ZDxuO2QrKykge1xuICAgICAgICAgICAgeG91dC53W2RdICs9IHgud1tkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHByb2R1Y2UgYXZlcmFnZVxuICAgICAgZm9yKHZhciBkPTA7ZDxuO2QrKykge1xuICAgICAgICB4b3V0LndbZF0gLz0gbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4b3V0O1xuICAgIH0sXG5cbiAgICBwcmVkaWN0OiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgeG91dCA9IHRoaXMucHJlZGljdF9zb2Z0KGRhdGEpO1xuICAgICAgaWYoeG91dC53Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB2YXIgc3RhdHMgPSBtYXhtaW4oeG91dC53KTtcbiAgICAgICAgdmFyIHByZWRpY3RlZF9sYWJlbCA9IHN0YXRzLm1heGk7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByZWRpY3RlZF9sYWJlbCA9IC0xOyAvLyBlcnJvciBvdXRcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVkaWN0ZWRfbGFiZWw7XG5cbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGR1bXAgdGhlIHRvcCBlbnNlbWJsZV9zaXplIG5ldHdvcmtzIGFzIGEgbGlzdFxuICAgICAgdmFyIG52ID0gTWF0aC5taW4odGhpcy5lbnNlbWJsZV9zaXplLCB0aGlzLmV2YWx1YXRlZF9jYW5kaWRhdGVzLmxlbmd0aCk7XG4gICAgICB2YXIganNvbiA9IHt9O1xuICAgICAganNvbi5uZXRzID0gW107XG4gICAgICBmb3IodmFyIGk9MDtpPG52O2krKykge1xuICAgICAgICBqc29uLm5ldHMucHVzaCh0aGlzLmV2YWx1YXRlZF9jYW5kaWRhdGVzW2ldLm5ldC50b0pTT04oKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgIHRoaXMuZW5zZW1ibGVfc2l6ZSA9IGpzb24ubmV0cy5sZW5ndGg7XG4gICAgICB0aGlzLmV2YWx1YXRlZF9jYW5kaWRhdGVzID0gW107XG4gICAgICBmb3IodmFyIGk9MDtpPHRoaXMuZW5zZW1ibGVfc2l6ZTtpKyspIHtcbiAgICAgICAgdmFyIG5ldCA9IG5ldyBOZXQoKTtcbiAgICAgICAgbmV0LmZyb21KU09OKGpzb24ubmV0c1tpXSk7XG4gICAgICAgIHZhciBkdW1teV9jYW5kaWRhdGUgPSB7fTtcbiAgICAgICAgZHVtbXlfY2FuZGlkYXRlLm5ldCA9IG5ldDtcbiAgICAgICAgdGhpcy5ldmFsdWF0ZWRfY2FuZGlkYXRlcy5wdXNoKGR1bW15X2NhbmRpZGF0ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgIC8vIGNhbGxlZCB3aGVuIGEgZm9sZCBpcyBmaW5pc2hlZCwgd2hpbGUgZXZhbHVhdGluZyBhIGJhdGNoXG4gICAgb25GaW5pc2hGb2xkOiBmdW5jdGlvbihmKSB7IHRoaXMuZmluaXNoX2ZvbGRfY2FsbGJhY2sgPSBmOyB9LFxuICAgIC8vIGNhbGxlZCB3aGVuIGEgYmF0Y2ggb2YgY2FuZGlkYXRlcyBoYXMgZmluaXNoZWQgZXZhbHVhdGluZ1xuICAgIG9uRmluaXNoQmF0Y2g6IGZ1bmN0aW9uKGYpIHsgdGhpcy5maW5pc2hfYmF0Y2hfY2FsbGJhY2sgPSBmOyB9XG4gICAgXG4gIH07XG5cbiAgZ2xvYmFsLk1hZ2ljTmV0ID0gTWFnaWNOZXQ7XG59KShjb252bmV0anMpO1xuKGZ1bmN0aW9uKGxpYikge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luZG93LmpzZmVhdCA9IGxpYjsgLy8gaW4gb3JkaW5hcnkgYnJvd3NlciBhdHRhY2ggbGlicmFyeSB0byB3aW5kb3dcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxpYjsgLy8gaW4gbm9kZWpzXG4gIH1cbn0pKGNvbnZuZXRqcyk7XG5cbn0pKCkiLCIoZnVuY3Rpb24oZ2xvYmFsKXsvKipcbiAqIEBsaWNlbnNlXG4gKiBMby1EYXNoIDIuNC4xIChDdXN0b20gQnVpbGQpIDxodHRwOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gLW8gLi9kaXN0L2xvZGFzaC5qc2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuNS4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZSBFUzUgZW52aXJvbm1lbnRzICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgdG8gcG9vbCBhcnJheXMgYW5kIG9iamVjdHMgdXNlZCBpbnRlcm5hbGx5ICovXG4gIHZhciBhcnJheVBvb2wgPSBbXSxcbiAgICAgIG9iamVjdFBvb2wgPSBbXTtcblxuICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzICovXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gIC8qKiBVc2VkIHRvIHByZWZpeCBrZXlzIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGBfX3Byb3RvX19gIGFuZCBwcm9wZXJ0aWVzIG9uIGBPYmplY3QucHJvdG90eXBlYCAqL1xuICB2YXIga2V5UHJlZml4ID0gK25ldyBEYXRlICsgJyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgd2hlbiBvcHRpbWl6YXRpb25zIGFyZSBlbmFibGVkIGZvciBsYXJnZSBhcnJheXMgKi9cbiAgdmFyIGxhcmdlQXJyYXlTaXplID0gNzU7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heCBzaXplIG9mIHRoZSBgYXJyYXlQb29sYCBhbmQgYG9iamVjdFBvb2xgICovXG4gIHZhciBtYXhQb29sU2l6ZSA9IDQwO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBhbmQgdGVzdCB3aGl0ZXNwYWNlICovXG4gIHZhciB3aGl0ZXNwYWNlID0gKFxuICAgIC8vIHdoaXRlc3BhY2VcbiAgICAnIFxcdFxceDBCXFxmXFx4QTBcXHVmZWZmJyArXG5cbiAgICAvLyBsaW5lIHRlcm1pbmF0b3JzXG4gICAgJ1xcblxcclxcdTIwMjhcXHUyMDI5JyArXG5cbiAgICAvLyB1bmljb2RlIGNhdGVnb3J5IFwiWnNcIiBzcGFjZSBzZXBhcmF0b3JzXG4gICAgJ1xcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDAnXG4gICk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZSAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIEVTNiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAqIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWxpdGVyYWxzLXN0cmluZy1saXRlcmFsc1xuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCByZWdleHAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMgKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdGVkIG5hbWVkIGZ1bmN0aW9ucyAqL1xuICB2YXIgcmVGdW5jTmFtZSA9IC9eXFxzKmZ1bmN0aW9uWyBcXG5cXHJcXHRdK1xcdy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggXCJpbnRlcnBvbGF0ZVwiIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UgYW5kIHplcm9zIHRvIGJlIHJlbW92ZWQgKi9cbiAgdmFyIHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlICsgJ10qMCsoPz0uJCknKTtcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgZnVuY3Rpb25zIGNvbnRhaW5pbmcgYSBgdGhpc2AgcmVmZXJlbmNlICovXG4gIHZhciByZVRoaXMgPSAvXFxidGhpc1xcYi87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdFxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Z1bmN0aW9uJywgJ01hdGgnLCAnTnVtYmVyJywgJ09iamVjdCcsXG4gICAgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnXycsICdhdHRhY2hFdmVudCcsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLFxuICAgICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkgKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IDA7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCBzaG9ydGN1dHMgKi9cbiAgdmFyIGFyZ3NDbGFzcyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlDbGFzcyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBib29sQ2xhc3MgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlQ2xhc3MgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBmdW5jQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgbnVtYmVyQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICByZWdleHBDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBvYmplY3QgY2xhc3NpZmljYXRpb25zIHRoYXQgYF8uY2xvbmVgIHN1cHBvcnRzICovXG4gIHZhciBjbG9uZWFibGVDbGFzc2VzID0ge307XG4gIGNsb25lYWJsZUNsYXNzZXNbZnVuY0NsYXNzXSA9IGZhbHNlO1xuICBjbG9uZWFibGVDbGFzc2VzW2FyZ3NDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2FycmF5Q2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tib29sQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tkYXRlQ2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tudW1iZXJDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW29iamVjdENsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbcmVnZXhwQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tzdHJpbmdDbGFzc10gPSB0cnVlO1xuXG4gIC8qKiBVc2VkIGFzIGFuIGludGVybmFsIGBfLmRlYm91bmNlYCBvcHRpb25zIG9iamVjdCAqL1xuICB2YXIgZGVib3VuY2VPcHRpb25zID0ge1xuICAgICdsZWFkaW5nJzogZmFsc2UsXG4gICAgJ21heFdhaXQnOiAwLFxuICAgICd0cmFpbGluZyc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBfX2JpbmREYXRhX19gICovXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IG51bGwsXG4gICAgJ3dyaXRhYmxlJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdib29sZWFuJzogZmFsc2UsXG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZSxcbiAgICAnbnVtYmVyJzogZmFsc2UsXG4gICAgJ3N0cmluZyc6IGZhbHNlLFxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdCc6ICd0JyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgKi9cbiAgdmFyIHJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KSB8fCB0aGlzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AgKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAgKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYCAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlIGFuZCB1c2UgaXQgYXMgYHJvb3RgICovXG4gIHZhciBmcmVlR2xvYmFsID0gb2JqZWN0VHlwZXNbdHlwZW9mIGdsb2JhbF0gJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXNcbiAgICogb3IgYGZyb21JbmRleGAgY29uc3RyYWludHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb250YWluc2AgZm9yIGNhY2hlIG9iamVjdHMgdGhhdCBtaW1pY3MgdGhlIHJldHVyblxuICAgKiBzaWduYXR1cmUgb2YgYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgMGAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGNhY2hlID0gY2FjaGUuY2FjaGU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlW3ZhbHVlXSA/IDAgOiAtMTtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgIH1cbiAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWU7XG4gICAgY2FjaGUgPSAoY2FjaGUgPSBjYWNoZVt0eXBlXSkgJiYgY2FjaGVba2V5XTtcblxuICAgIHJldHVybiB0eXBlID09ICdvYmplY3QnXG4gICAgICA/IChjYWNoZSAmJiBiYXNlSW5kZXhPZihjYWNoZSwgdmFsdWUpID4gLTEgPyAwIDogLTEpXG4gICAgICA6IChjYWNoZSA/IDAgOiAtMSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGdpdmVuIHZhbHVlIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgY2FjaGVbdmFsdWVdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWUsXG4gICAgICAgICAgdHlwZUNhY2hlID0gY2FjaGVbdHlwZV0gfHwgKGNhY2hlW3R5cGVdID0ge30pO1xuXG4gICAgICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAodHlwZUNhY2hlW2tleV0gfHwgKHR5cGVDYWNoZVtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVDYWNoZVtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5tYXhgIGFuZCBgXy5taW5gIGFzIHRoZSBkZWZhdWx0IGNhbGxiYWNrIHdoZW4gYSBnaXZlblxuICAgKiBjb2xsZWN0aW9uIGlzIGEgc3RyaW5nIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIGNoYXJhY3RlciB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgZ2l2ZW4gY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhckF0Q2FsbGJhY2sodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBzb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgYGNvbGxlY3Rpb25gIGVsZW1lbnRzLCBzdGFibGUgc29ydGluZ1xuICAgKiB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBiYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBhYC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3Igb2YgYDFgIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKGEsIGIpIHtcbiAgICB2YXIgYWMgPSBhLmNyaXRlcmlhLFxuICAgICAgICBiYyA9IGIuY3JpdGVyaWEsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFjLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhY1tpbmRleF0sXG4gICAgICAgICAgb3RoZXIgPSBiY1tpbmRleF07XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gb3RoZXIgfHwgdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgb3RoZXIgfHwgdHlwZW9mIG90aGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgLy8gYGFgIGFuZCBgYmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MFxuICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgb3IgYG51bGxgIGlmIGNhY2hpbmcgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IGFycmF5WzBdLFxuICAgICAgICBtaWQgPSBhcnJheVsobGVuZ3RoIC8gMikgfCAwXSxcbiAgICAgICAgbGFzdCA9IGFycmF5W2xlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdCA9PSAnb2JqZWN0JyAmJlxuICAgICAgICBtaWQgJiYgdHlwZW9mIG1pZCA9PSAnb2JqZWN0JyAmJiBsYXN0ICYmIHR5cGVvZiBsYXN0ID09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IGdldE9iamVjdCgpO1xuICAgIGNhY2hlWydmYWxzZSddID0gY2FjaGVbJ251bGwnXSA9IGNhY2hlWyd0cnVlJ10gPSBjYWNoZVsndW5kZWZpbmVkJ10gPSBmYWxzZTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRPYmplY3QoKTtcbiAgICByZXN1bHQuYXJyYXkgPSBhcnJheTtcbiAgICByZXN1bHQuY2FjaGUgPSBjYWNoZTtcbiAgICByZXN1bHQucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkXG4gICAqIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW21hdGNoXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IGZyb20gdGhlIGFycmF5IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gYXJyYXlQb29sLnBvcCgpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IGZyb20gdGhlIG9iamVjdCBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2JqZWN0IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPYmplY3QoKSB7XG4gICAgcmV0dXJuIG9iamVjdFBvb2wucG9wKCkgfHwge1xuICAgICAgJ2FycmF5JzogbnVsbCxcbiAgICAgICdjYWNoZSc6IG51bGwsXG4gICAgICAnY3JpdGVyaWEnOiBudWxsLFxuICAgICAgJ2ZhbHNlJzogZmFsc2UsXG4gICAgICAnaW5kZXgnOiAwLFxuICAgICAgJ251bGwnOiBmYWxzZSxcbiAgICAgICdudW1iZXInOiBudWxsLFxuICAgICAgJ29iamVjdCc6IG51bGwsXG4gICAgICAncHVzaCc6IG51bGwsXG4gICAgICAnc3RyaW5nJzogbnVsbCxcbiAgICAgICd0cnVlJzogZmFsc2UsXG4gICAgICAndW5kZWZpbmVkJzogZmFsc2UsXG4gICAgICAndmFsdWUnOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYmFjayB0byB0aGUgYXJyYXkgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VBcnJheShhcnJheSkge1xuICAgIGFycmF5Lmxlbmd0aCA9IDA7XG4gICAgaWYgKGFycmF5UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgYXJyYXlQb29sLnB1c2goYXJyYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gb2JqZWN0IGJhY2sgdG8gdGhlIG9iamVjdCBwb29sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byByZWxlYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsZWFzZU9iamVjdChvYmplY3QpIHtcbiAgICB2YXIgY2FjaGUgPSBvYmplY3QuY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICB9XG4gICAgb2JqZWN0LmFycmF5ID0gb2JqZWN0LmNhY2hlID0gb2JqZWN0LmNyaXRlcmlhID0gb2JqZWN0Lm9iamVjdCA9IG9iamVjdC5udW1iZXIgPSBvYmplY3Quc3RyaW5nID0gb2JqZWN0LnZhbHVlID0gbnVsbDtcbiAgICBpZiAob2JqZWN0UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgb2JqZWN0UG9vbC5wdXNoKG9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNsaWNlcyB0aGUgYGNvbGxlY3Rpb25gIGZyb20gdGhlIGBzdGFydGAgaW5kZXggdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLFxuICAgKiB0aGUgYGVuZGAgaW5kZXguXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlIGxpc3RzXG4gICAqIGluIElFIDwgOSBhbmQgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIGluZGV4LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0IHx8IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBnaXZlbiBjb250ZXh0IG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIC8vIEF2b2lkIGlzc3VlcyB3aXRoIHNvbWUgRVMzIGVudmlyb25tZW50cyB0aGF0IGF0dGVtcHQgdG8gdXNlIHZhbHVlcywgbmFtZWRcbiAgICAvLyBhZnRlciBidWlsdC1pbiBjb25zdHJ1Y3RvcnMgbGlrZSBgT2JqZWN0YCwgZm9yIHRoZSBjcmVhdGlvbiBvZiBsaXRlcmFscy5cbiAgICAvLyBFUzUgY2xlYXJzIHRoaXMgdXAgYnkgc3RhdGluZyB0aGF0IGxpdGVyYWxzIG11c3QgdXNlIGJ1aWx0LWluIGNvbnN0cnVjdG9ycy5cbiAgICAvLyBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxMS4xLjUuXG4gICAgY29udGV4dCA9IGNvbnRleHQgPyBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKSA6IHJvb3Q7XG5cbiAgICAvKiogTmF0aXZlIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMgKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBCb29sZWFuID0gY29udGV4dC5Cb29sZWFuLFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE51bWJlciA9IGNvbnRleHQuTnVtYmVyLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGBBcnJheWAgbWV0aG9kIHJlZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBOb3JtYWxseSBgQXJyYXkucHJvdG90eXBlYCB3b3VsZCBzdWZmaWNlLCBob3dldmVyLCB1c2luZyBhbiBhcnJheSBsaXRlcmFsXG4gICAgICogYXZvaWRzIGlzc3VlcyBpbiBOYXJ3aGFsLlxuICAgICAqL1xuICAgIHZhciBhcnJheVJlZiA9IFtdO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBub0NvbmZsaWN0YCAqL1xuICAgIHZhciBvbGREYXNoID0gY29udGV4dC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgW1tDbGFzc11dIG9mIHZhbHVlcyAqL1xuICAgIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZSAqL1xuICAgIHZhciByZU5hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgU3RyaW5nKHRvU3RyaW5nKVxuICAgICAgICAucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKVxuICAgICAgICAucmVwbGFjZSgvdG9TdHJpbmd8IGZvciBbXlxcXV0rL2csICcuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgKi9cbiAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgY2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2YgPSBpc05hdGl2ZShnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgICAgIHB1c2ggPSBhcnJheVJlZi5wdXNoLFxuICAgICAgICBzZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0LFxuICAgICAgICBzcGxpY2UgPSBhcnJheVJlZi5zcGxpY2UsXG4gICAgICAgIHVuc2hpZnQgPSBhcnJheVJlZi51bnNoaWZ0O1xuXG4gICAgLyoqIFVzZWQgdG8gc2V0IG1ldGEgZGF0YSBvbiBmdW5jdGlvbnMgKi9cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJRSA4IG9ubHkgYWNjZXB0cyBET00gZWxlbWVudHNcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvID0ge30sXG4gICAgICAgICAgICBmdW5jID0gaXNOYXRpdmUoZnVuYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgZnVuYyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMobywgbywgbykgJiYgZnVuYztcbiAgICAgIH0gY2F0Y2goZSkgeyB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKSk7XG5cbiAgICAvKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyBmb3IgbWV0aG9kcyB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcyAqL1xuICAgIHZhciBuYXRpdmVDcmVhdGUgPSBpc05hdGl2ZShuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlKSAmJiBuYXRpdmVDcmVhdGUsXG4gICAgICAgIG5hdGl2ZUlzQXJyYXkgPSBpc05hdGl2ZShuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSkgJiYgbmF0aXZlSXNBcnJheSxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVJc05hTiA9IGNvbnRleHQuaXNOYU4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBpc05hdGl2ZShuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMpICYmIG5hdGl2ZUtleXMsXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCBhIGJ1aWx0LWluIGNvbnN0cnVjdG9yIGJ5IFtbQ2xhc3NdXSAqL1xuICAgIHZhciBjdG9yQnlDbGFzcyA9IHt9O1xuICAgIGN0b3JCeUNsYXNzW2FycmF5Q2xhc3NdID0gQXJyYXk7XG4gICAgY3RvckJ5Q2xhc3NbYm9vbENsYXNzXSA9IEJvb2xlYW47XG4gICAgY3RvckJ5Q2xhc3NbZGF0ZUNsYXNzXSA9IERhdGU7XG4gICAgY3RvckJ5Q2xhc3NbZnVuY0NsYXNzXSA9IEZ1bmN0aW9uO1xuICAgIGN0b3JCeUNsYXNzW29iamVjdENsYXNzXSA9IE9iamVjdDtcbiAgICBjdG9yQnlDbGFzc1tudW1iZXJDbGFzc10gPSBOdW1iZXI7XG4gICAgY3RvckJ5Q2xhc3NbcmVnZXhwQ2xhc3NdID0gUmVnRXhwO1xuICAgIGN0b3JCeUNsYXNzW3N0cmluZ0NsYXNzXSA9IFN0cmluZztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gZW5hYmxlIGludHVpdGl2ZVxuICAgICAqIG1ldGhvZCBjaGFpbmluZy5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIExvLURhc2ggbWV0aG9kcywgd3JhcHBlcnMgYWxzbyBoYXZlIHRoZSBmb2xsb3dpbmcgYEFycmF5YCBtZXRob2RzOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLCBgc3BsaWNlYCxcbiAgICAgKiBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXNzaWduYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNoYWluYCwgYGNvbXBhY3RgLFxuICAgICAqIGBjb21wb3NlYCwgYGNvbmNhdGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsIGBjcmVhdGVDYWxsYmFja2AsIGBjdXJyeWAsXG4gICAgICogYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLFxuICAgICAqIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsXG4gICAgICogYGZ1bmN0aW9uc2AsIGBncm91cEJ5YCwgYGluZGV4QnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW52ZXJ0YCxcbiAgICAgKiBgaW52b2tlYCwgYGtleXNgLCBgbWFwYCwgYG1heGAsIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1pbmAsIGBvYmplY3RgLCBgb21pdGAsXG4gICAgICogYG9uY2VgLCBgcGFpcnNgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGlja2AsIGBwbHVja2AsIGBwdWxsYCwgYHB1c2hgLFxuICAgICAqIGByYW5nZWAsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aW1lc2AsIGB0b0FycmF5YCwgYHRyYW5zZm9ybWAsXG4gICAgICogYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsIGB1bnppcGAsIGB2YWx1ZXNgLCBgd2hlcmVgLCBgd2l0aG91dGAsIGB3cmFwYCxcbiAgICAgKiBhbmQgYHppcGBcbiAgICAgKlxuICAgICAqIFRoZSBub24tY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgY2xvbmVgLCBgY2xvbmVEZWVwYCwgYGNvbnRhaW5zYCwgYGVzY2FwZWAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG4gICAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBoYXNgLCBgaWRlbnRpdHlgLFxuICAgICAqIGBpbmRleE9mYCwgYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNCb29sZWFuYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLFxuICAgICAqIGBpc0VtcHR5YCwgYGlzRXF1YWxgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLFxuICAgICAqIGBpc09iamVjdGAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGpvaW5gLFxuICAgICAqIGBsYXN0SW5kZXhPZmAsIGBtaXhpbmAsIGBub0NvbmZsaWN0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCxcbiAgICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVzdWx0YCwgYHNoaWZ0YCwgYHNpemVgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBydW5JbkNvbnRleHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGFuZCBgdmFsdWVgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBmdW5jdGlvbnMgYGZpcnN0YCBhbmQgYGxhc3RgIHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGBuYCBpc1xuICAgICAqIHByb3ZpZGVkLCBvdGhlcndpc2UgdGhleSByZXR1cm4gdW53cmFwcGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluaW5nIGNhbiBiZSBlbmFibGVkIGJ5IHVzaW5nIHRoZSBgXy5jaGFpbmAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZVxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICogbnVtO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICAvLyBkb24ndCB3cmFwIGlmIGFscmVhZHkgd3JhcHBlZCwgZXZlbiBpZiB3cmFwcGVkIGJ5IGEgZGlmZmVyZW50IGBsb2Rhc2hgIGNvbnN0cnVjdG9yXG4gICAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpXG4gICAgICAgPyB2YWx1ZVxuICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZmFzdCBwYXRoIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoYWluQWxsIEEgZmxhZyB0byBlbmFibGUgY2hhaW5pbmcgZm9yIGFsbCBtZXRob2RzXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBgbmV3IGxvZGFzaFdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBsb2Rhc2hgXG4gICAgbG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBsb2Rhc2gucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHVzZWQgdG8gZmxhZyBlbnZpcm9ubWVudHMgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0ID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgZnVuY3Rpb25zIGNhbiBiZSBkZWNvbXBpbGVkIGJ5IGBGdW5jdGlvbiN0b1N0cmluZ2BcbiAgICAgKiAoYWxsIGJ1dCBQUzMgYW5kIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycyAmIGF2b2lkZWQgaW4gV2luZG93cyA4IGFwcHMpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNEZWNvbXAgPSAhaXNOYXRpdmUoY29udGV4dC5XaW5SVEVycm9yKSAmJiByZVRoaXMudGVzdChydW5JbkNvbnRleHQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBMby1EYXNoIGFyZSBzaW1pbGFyIHRvIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlXG4gICAgICogZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogLzwlLShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IC88JShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5iaW5kYCB0aGF0IGNyZWF0ZXMgdGhlIGJvdW5kIGZ1bmN0aW9uIGFuZFxuICAgICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQmluZChiaW5kRGF0YSkge1xuICAgICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XTtcblxuICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgIC8vIGBGdW5jdGlvbiNiaW5kYCBzcGVjXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjVcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgLy8gYXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IGRlb3B0aW1pemF0aW9ucyBieSB1c2luZyBgc2xpY2VgIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGxgIGFuZCBub3QgYXNzaWduaW5nIGBhcmd1bWVudHNgIHRvIGFcbiAgICAgICAgICAvLyB2YXJpYWJsZSBhcyBhIHRlcm5hcnkgZXhwcmVzc2lvblxuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvclxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMlxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGBuZXcgYm91bmRgIGlzIGFuIGluc3RhbmNlIG9mIGBmdW5jYFxuICAgICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW5zcGVjdCBbW0NsYXNzXV1cbiAgICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmIChpc09iaikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIGlmICghY2xvbmVhYmxlQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0gY3RvckJ5Q2xhc3NbY2xhc3NOYW1lXTtcbiAgICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcigrdmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgICAgICByZXN1bHQgPSBjdG9yKHZhbHVlLnNvdXJjZSwgcmVGbGFncy5leGVjKHZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gdmFsdWUubGFzdEluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZVxuICAgICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaXNBcnIgPyBjdG9yKHZhbHVlLmxlbmd0aCkgOiB7fTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0FyciA/IHNsaWNlKHZhbHVlKSA6IGFzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gYWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYFxuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5kZXgnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbmRleCA9IHZhbHVlLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5wdXQnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbnB1dCA9IHZhbHVlLmlucHV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGZvciBzaGFsbG93IGNsb25lXG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gYWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAvLyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24ob2JqVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShvYmpWYWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QocHJvdG90eXBlKSA/IG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpIDoge307XG4gICAgfVxuICAgIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB3aXRob3V0IGBPYmplY3QuY3JlYXRlYFxuICAgIGlmICghbmF0aXZlQ3JlYXRlKSB7XG4gICAgICBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9iamVjdDtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGNvbnRleHQuT2JqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICB9KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZUNhbGxiYWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNyZWF0aW5nXG4gICAgICogXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIG5vIGB0aGlzQXJnYCBvciBhbHJlYWR5IGJvdW5kIGJ5IGBGdW5jdGlvbiNiaW5kYFxuICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8ICEoJ3Byb3RvdHlwZScgaW4gZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmICh0eXBlb2YgYmluZERhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgYmluZERhdGEgPSAhZnVuYy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGJpbmREYXRhID0gYmluZERhdGEgfHwgIXN1cHBvcnQuZnVuY0RlY29tcDtcbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBmblRvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgaWYgKCFzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgICAgYmluZERhdGEgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICBiaW5kRGF0YSA9IHJlVGhpcy50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgICBzZXRCaW5kRGF0YShmdW5jLCBiaW5kRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyBgdGhpc2AgcmVmZXJlbmNlcyBvciBgZnVuY2AgaXMgYm91bmRcbiAgICAgIGlmIChiaW5kRGF0YSA9PT0gZmFsc2UgfHwgKGJpbmREYXRhICE9PSB0cnVlICYmIGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGEsIGIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmQoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZVdyYXBwZXJgIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBlciBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZVdyYXBwZXIoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgYml0bWFzayA9IGJpbmREYXRhWzFdLFxuICAgICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgICAgcGFydGlhbFJpZ2h0QXJncyA9IGJpbmREYXRhWzNdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XSxcbiAgICAgICAgICBhcml0eSA9IGJpbmREYXRhWzVdO1xuXG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcztcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzIHx8IGlzQ3VycnkpIHtcbiAgICAgICAgICBhcmdzIHx8IChhcmdzID0gc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MpIHtcbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0N1cnJ5ICYmIGFyZ3MubGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgIGJpdG1hc2sgfD0gMTYgJiB+MzI7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZVdyYXBwZXIoW2Z1bmMsIChpc0N1cnJ5Qm91bmQgPyBiaXRtYXNrIDogYml0bWFzayAmIH4zKSwgYXJncywgbnVsbCwgdGhpc0FyZywgYXJpdHldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJncyB8fCAoYXJncyA9IGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChpc0JpbmRLZXkpIHtcbiAgICAgICAgICBmdW5jID0gdGhpc0JpbmRpbmdba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRpZmZlcmVuY2VgIHRoYXQgYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICBpc0xhcmdlID0gbGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmIGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICAgIHZhbHVlcyA9IGNhY2hlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VPYmplY3QodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3Q9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cyBhbmQgYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGlzU3RyaWN0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUZsYXR0ZW4odmFsdWUsIGlzU2hhbGxvdywgaXNTdHJpY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsSW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgdmFsTGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICByZXNJbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgICByZXN1bHQubGVuZ3RoICs9IHZhbExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKyt2YWxJbmRleCA8IHZhbExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAsIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNBcmdgIGJpbmRpbmcsXG4gICAgICogdGhhdCBhbGxvd3MgcGFydGlhbCBcIl8ud2hlcmVcIiBzdHlsZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXNXaGVyZT1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBhYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbChhLCBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIC8vIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB3aGVuIGNvbXBhcmluZyBvYmplY3RzLCBgYWAgaGFzIGF0IGxlYXN0IHRoZSBwcm9wZXJ0aWVzIG9mIGBiYFxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhhLCBiKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIC8vIHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgIHJldHVybiBhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYik7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhLFxuICAgICAgICAgIG90aGVyVHlwZSA9IHR5cGVvZiBiO1xuXG4gICAgICAvLyBleGl0IGVhcmx5IGZvciB1bmxpa2UgcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgaWYgKGEgPT09IGEgJiZcbiAgICAgICAgICAhKGEgJiYgb2JqZWN0VHlwZXNbdHlwZV0pICYmXG4gICAgICAgICAgIShiICYmIG9iamVjdFR5cGVzW290aGVyVHlwZV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXZvaWRpbmcgRVMzJ3MgRnVuY3Rpb24jY2FsbCBiZWhhdmlvclxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNFxuICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG4gICAgICAvLyBjb21wYXJlIFtbQ2xhc3NdXSBuYW1lc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSksXG4gICAgICAgICAgb3RoZXJDbGFzcyA9IHRvU3RyaW5nLmNhbGwoYik7XG5cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IG9iamVjdENsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyQ2xhc3MgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIG90aGVyQ2xhc3MgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChjbGFzc05hbWUgIT0gb3RoZXJDbGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgLy8gY29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgcmV0dXJuICthID09ICtiO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgICAgLy8gdHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIChhICE9ICthKVxuICAgICAgICAgICAgPyBiICE9ICtiXG4gICAgICAgICAgICAvLyBidXQgdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgICAgICAgIDogKGEgPT0gMCA/ICgxIC8gYSA9PSAxIC8gYikgOiBhID09ICtiKTtcblxuICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgKGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40KVxuICAgICAgICAgIC8vIHRyZWF0IHN0cmluZyBwcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCBpbnN0YW5jZXMgYXMgZXF1YWxcbiAgICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBjbGFzc05hbWUgPT0gYXJyYXlDbGFzcztcbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgLy8gdW53cmFwIGFueSBgbG9kYXNoYCB3cmFwcGVkIHZhbHVlc1xuICAgICAgICB2YXIgYVdyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgYldyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChhV3JhcHBlZCB8fCBiV3JhcHBlZCkge1xuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhV3JhcHBlZCA/IGEuX193cmFwcGVkX18gOiBhLCBiV3JhcHBlZCA/IGIuX193cmFwcGVkX18gOiBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4aXQgZm9yIGZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICAgIGlmIChjbGFzc05hbWUgIT0gb2JqZWN0Q2xhc3MpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgT3BlcmEsIGBhcmd1bWVudHNgIG9iamVjdHMgaGF2ZSBgQXJyYXlgIGNvbnN0cnVjdG9yc1xuICAgICAgICB2YXIgY3RvckEgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgY3RvckIgPSBiLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIG5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsXG4gICAgICAgIGlmIChjdG9yQSAhPSBjdG9yQiAmJlxuICAgICAgICAgICAgICAhKGlzRnVuY3Rpb24oY3RvckEpICYmIGN0b3JBIGluc3RhbmNlb2YgY3RvckEgJiYgaXNGdW5jdGlvbihjdG9yQikgJiYgY3RvckIgaW5zdGFuY2VvZiBjdG9yQikgJiZcbiAgICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFzc3VtZSBjeWNsaWMgc3RydWN0dXJlcyBhcmUgZXF1YWxcbiAgICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMgc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xXG4gICAgICAvLyBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEyLjMpXG4gICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzaXplID0gMDtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIC8vIGFkZCBgYWAgYW5kIGBiYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgc3RhY2tCLnB1c2goYik7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAvLyBjb21wYXJlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeVxuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgc2l6ZSA9IGIubGVuZ3RoO1xuICAgICAgICByZXN1bHQgPSBzaXplID09IGxlbmd0aDtcblxuICAgICAgICBpZiAocmVzdWx0IHx8IGlzV2hlcmUpIHtcbiAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gYltzaXplXTtcblxuICAgICAgICAgICAgaWYgKGlzV2hlcmUpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbaW5kZXhdLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbc2l6ZV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBkZWVwIGNvbXBhcmUgb2JqZWN0cyB1c2luZyBgZm9ySW5gLCBpbnN0ZWFkIG9mIGBmb3JPd25gLCB0byBhdm9pZCBgT2JqZWN0LmtleXNgXG4gICAgICAgIC8vIHdoaWNoLCBpbiB0aGlzIGNhc2UsIGlzIG1vcmUgY29zdGx5XG4gICAgICAgIGZvckluKGIsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGIpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpICYmIGJhc2VJc0VxdWFsKGFba2V5XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNXaGVyZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBib3RoIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICAgICAgICAgIGZvckluKGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGEpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gYHNpemVgIHdpbGwgYmUgYC0xYCBpZiBgYWAgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGBiYFxuICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IC0tc2l6ZSA+IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAoaXNBcnJheShzb3VyY2UpID8gZm9yRWFjaCA6IGZvck93bikoc291cmNlLCBmdW5jdGlvbihzb3VyY2UsIGtleSkge1xuICAgICAgICB2YXIgZm91bmQsXG4gICAgICAgICAgICBpc0FycixcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoKGlzQXJyID0gaXNBcnJheShzb3VyY2UpKSB8fCBpc1BsYWluT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbWVyZ2luZyBwcmV2aW91c2x5IG1lcmdlZCBjeWNsaWMgc291cmNlc1xuICAgICAgICAgIHZhciBzdGFja0xlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHN0YWNrTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmICgoZm91bmQgPSBzdGFja0Fbc3RhY2tMZW5ndGhdID09IHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdGFja0Jbc3RhY2tMZW5ndGhdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgdmFyIGlzU2hhbGxvdztcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgaWYgKChpc1NoYWxsb3cgPSB0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXJyXG4gICAgICAgICAgICAgICAgPyAoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdKVxuICAgICAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgYHNvdXJjZWAgYW5kIGFzc29jaWF0ZWQgYHZhbHVlYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgICAgICAgIHN0YWNrQS5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBzdGFja0IucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICBiYXNlTWVyZ2UodmFsdWUsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHZhciBpc0xhcmdlID0gIWlzU29ydGVkICYmIGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gKGNhbGxiYWNrIHx8IGlzTGFyZ2UpID8gZ2V0QXJyYXkoKSA6IHJlc3VsdDtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUoc2Vlbik7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIHNlZW4gPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1NvcnRlZFxuICAgICAgICAgICAgICA/ICFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IGNvbXB1dGVkXG4gICAgICAgICAgICAgIDogaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgaXNMYXJnZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbi5hcnJheSk7XG4gICAgICAgIHJlbGVhc2VPYmplY3Qoc2Vlbik7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhIGNvbGxlY3Rpb24sIGNyZWF0aW5nIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIGEgY2FsbGJhY2suIFRoZSBnaXZlbiBgc2V0dGVyYCBmdW5jdGlvbiBzZXRzIHRoZSBrZXlzIGFuZCB2YWx1ZXNcbiAgICAgKiBvZiB0aGUgY29tcG9zZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIHNldHRlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgXG4gICAgICogd2l0aCBhbiBvcHRpb25hbCBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIG1ldGhvZCBmbGFncyB0byBjb21wb3NlLlxuICAgICAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAgICAgKiAgMSAtIGBfLmJpbmRgXG4gICAgICogIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICA0IC0gYF8uY3VycnlgXG4gICAgICogIDggLSBgXy5jdXJyeWAgKGJvdW5kKVxuICAgICAqICAxNiAtIGBfLnBhcnRpYWxgXG4gICAgICogIDMyIC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsQXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2VcbiAgICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbFJpZ2h0QXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZVxuICAgICAqICBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiAxLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgOCxcbiAgICAgICAgICBpc1BhcnRpYWwgPSBiaXRtYXNrICYgMTYsXG4gICAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBiaXRtYXNrICYgMzI7XG5cbiAgICAgIGlmICghaXNCaW5kS2V5ICYmICFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsICYmICFwYXJ0aWFsQXJncy5sZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+MTY7XG4gICAgICAgIGlzUGFydGlhbCA9IHBhcnRpYWxBcmdzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQgJiYgIXBhcnRpYWxSaWdodEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfjMyO1xuICAgICAgICBpc1BhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodEFyZ3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBiaW5kRGF0YSA9IGZ1bmMgJiYgZnVuYy5fX2JpbmREYXRhX187XG4gICAgICBpZiAoYmluZERhdGEgJiYgYmluZERhdGEgIT09IHRydWUpIHtcbiAgICAgICAgLy8gY2xvbmUgYGJpbmREYXRhYFxuICAgICAgICBiaW5kRGF0YSA9IHNsaWNlKGJpbmREYXRhKTtcbiAgICAgICAgaWYgKGJpbmREYXRhWzJdKSB7XG4gICAgICAgICAgYmluZERhdGFbMl0gPSBzbGljZShiaW5kRGF0YVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmREYXRhWzNdKSB7XG4gICAgICAgICAgYmluZERhdGFbM10gPSBzbGljZShiaW5kRGF0YVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGB0aGlzQmluZGluZ2AgaXMgbm90IHByZXZpb3VzbHkgYm91bmRcbiAgICAgICAgaWYgKGlzQmluZCAmJiAhKGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs0XSA9IHRoaXNBcmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGlmIHByZXZpb3VzbHkgYm91bmQgYnV0IG5vdCBjdXJyZW50bHkgKHN1YnNlcXVlbnQgY3VycmllZCBmdW5jdGlvbnMpXG4gICAgICAgIGlmICghaXNCaW5kICYmIGJpbmREYXRhWzFdICYgMSkge1xuICAgICAgICAgIGJpdG1hc2sgfD0gODtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgY3VycmllZCBhcml0eSBpZiBub3QgeWV0IHNldFxuICAgICAgICBpZiAoaXNDdXJyeSAmJiAhKGJpbmREYXRhWzFdICYgNCkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs1XSA9IGFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIGxlZnQgYXJndW1lbnRzXG4gICAgICAgIGlmIChpc1BhcnRpYWwpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KGJpbmREYXRhWzJdIHx8IChiaW5kRGF0YVsyXSA9IFtdKSwgcGFydGlhbEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQpIHtcbiAgICAgICAgICB1bnNoaWZ0LmFwcGx5KGJpbmREYXRhWzNdIHx8IChiaW5kRGF0YVszXSA9IFtdKSwgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgZmxhZ3NcbiAgICAgICAgYmluZERhdGFbMV0gfD0gYml0bWFzaztcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIuYXBwbHkobnVsbCwgYmluZERhdGEpO1xuICAgICAgfVxuICAgICAgLy8gZmFzdCBwYXRoIGZvciBgXy5iaW5kYFxuICAgICAgdmFyIGNyZWF0ZXIgPSAoYml0bWFzayA9PSAxIHx8IGJpdG1hc2sgPT09IDE3KSA/IGJhc2VCaW5kIDogYmFzZUNyZWF0ZVdyYXBwZXI7XG4gICAgICByZXR1cm4gY3JlYXRlcihbZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sRXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUluZGV4T2ZgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKHJlc3VsdCA9IGxvZGFzaC5pbmRleE9mKSA9PT0gaW5kZXhPZiA/IGJhc2VJbmRleE9mIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyAmJiByZU5hdGl2ZS50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB0aGlzYCBiaW5kaW5nIGRhdGEgb24gYSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc2V0IGRhdGEgb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgVGhlIGRhdGEgYXJyYXkgdG8gc2V0LlxuICAgICAqL1xuICAgIHZhciBzZXRCaW5kRGF0YSA9ICFkZWZpbmVQcm9wZXJ0eSA/IG5vb3AgOiBmdW5jdGlvbihmdW5jLCB2YWx1ZSkge1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgZGVmaW5lUHJvcGVydHkoZnVuYywgJ19fYmluZERhdGFfXycsIGRlc2NyaXB0b3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBpc1BsYWluT2JqZWN0YCB3aGljaCBjaGVja3MgaWYgYSBnaXZlbiB2YWx1ZVxuICAgICAqIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciwgYXNzdW1pbmcgb2JqZWN0cyBjcmVhdGVkXG4gICAgICogYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgdGhhdFxuICAgICAqIHRoZXJlIGFyZSBubyBgT2JqZWN0LnByb3RvdHlwZWAgZXh0ZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIGN0b3IsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAvLyBhdm9pZCBub24gT2JqZWN0IG9iamVjdHMsIGBhcmd1bWVudHNgIG9iamVjdHMsIGFuZCBET00gZWxlbWVudHNcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSB8fFxuICAgICAgICAgIChjdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIGlzRnVuY3Rpb24oY3RvcikgJiYgIShjdG9yIGluc3RhbmNlb2YgY3RvcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgZm9ySW4odmFsdWUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJyB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sVW5lc2NhcGVzW21hdGNoXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJndW1lbnRzKGFyZ3VtZW50cyk7IH0pKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc0NsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJyYXkoYXJndW1lbnRzKTsgfSkoKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MgfHwgZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBwcm9kdWNlcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBnaXZlbiBvYmplY3QncyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgdmFyIHNoaW1LZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIShvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0XSkpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGZvciAoaW5kZXggaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYWJsZSwgaW5kZXgpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtleXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gWydvbmUnLCAndHdvJywgJ3RocmVlJ10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllczpcbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgYD5gIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlIGA+YCBhbmQgYC9gXG4gICAgICogZG9uJ3QgcmVxdWlyZSBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZyB1bmxlc3MgdGhleSdyZSBwYXJ0XG4gICAgICogb2YgYSB0YWcgb3IgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKVxuICAgICAqL1xuICAgIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgIFwiJ1wiOiAnJiMzOTsnXG4gICAgfTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzICovXG4gICAgdmFyIGh0bWxVbmVzY2FwZXMgPSBpbnZlcnQoaHRtbEVzY2FwZXMpO1xuXG4gICAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzICovXG4gICAgdmFyIHJlRXNjYXBlZEh0bWwgPSBSZWdFeHAoJygnICsga2V5cyhodG1sVW5lc2NhcGVzKS5qb2luKCd8JykgKyAnKScsICdnJyksXG4gICAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cCgnWycgKyBrZXlzKGh0bWxFc2NhcGVzKS5qb2luKCcnKSArICddJywgJ2cnKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgd2lsbCBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICAgKiBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiBhc3NpZ25lZCB2YWx1ZXMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ25hbWUnOiAnZnJlZCcgfSwgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgYSA9PSAndW5kZWZpbmVkJyA/IGIgOiBhO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIGRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcbiAgICAgIGlmIChhcmdzTGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soYXJnc1stLWFyZ3NMZW5ndGggLSAxXSwgYXJnc1thcmdzTGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnc0xlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tYXJnc0xlbmd0aF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayA/IGNhbGxiYWNrKHJlc3VsdFtpbmRleF0sIGl0ZXJhYmxlW2luZGV4XSkgOiBpdGVyYWJsZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIG5lc3RlZCBvYmplY3RzIHdpbGwgYWxzb1xuICAgICAqIGJlIGNsb25lZCwgb3RoZXJ3aXNlIHRoZXkgd2lsbCBiZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKGNoYXJhY3RlcnMpO1xuICAgICAqIHNoYWxsb3dbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lKGNoYXJhY3RlcnMsIHRydWUpO1xuICAgICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubWl4aW4oe1xuICAgICAqICAgJ2Nsb25lJzogXy5wYXJ0aWFsUmlnaHQoXy5jbG9uZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgcmV0dXJuIF8uaXNFbGVtZW50KHZhbHVlKSA/IHZhbHVlLmNsb25lTm9kZShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICogICB9KVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZShkb2N1bWVudC5ib2R5KTtcbiAgICAgKiBjbG9uZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMgd2l0aG91dCB1c2luZyB0aGVpciBgaW5kZXhgXG4gICAgICAvLyBhbmQgYGNvbGxlY3Rpb25gIGFyZ3VtZW50cyBmb3IgYGlzRGVlcGAgYW5kIGBjYWxsYmFja2BcbiAgICAgIGlmICh0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0RlZXAgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gaXNEZWVwO1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlXG4gICAgICogZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlIHN0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtLiBGdW5jdGlvbnNcbiAgICAgKiBhbmQgRE9NIG5vZGVzIGFyZSAqKm5vdCoqIGNsb25lZC4gVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZFxuICAgICAqIG9iamVjdHMgY3JlYXRlZCBieSBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuXG4gICAgICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAoY2hhcmFjdGVycyk7XG4gICAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnbm9kZSc6IGVsZW1lbnRcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZURlZXAodmlldywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjbG9uZS5ub2RlID09IHZpZXcubm9kZTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIHRydWUsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBwcm92aWRlZCBpdHMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgYXNzaWduZWRcbiAgICAgKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwgeyAnY29uc3RydWN0b3InOiBDaXJjbGUgfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA/IGFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBPbmNlIGFcbiAgICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgZGVmYXVsdHMgb2YgdGhlIHNhbWUgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgd2l0aG91dCB1c2luZyBpdHNcbiAgICAgKiAgYGtleWAgYW5kIGBvYmplY3RgIGFyZ3VtZW50cyBhcyBzb3VyY2VzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIF8uZGVmYXVsdHMob2JqZWN0LCB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2luZGV4XSA9PSAndW5kZWZpbmVkJykgcmVzdWx0W2luZGV4XSA9IGl0ZXJhYmxlW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiB7ICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgICdmcmVkJzogeyAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6IHsgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6IHsgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zIGBwZWJibGVzYCwgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyBgYmFybmV5YFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yT3duUmlnaHQob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LFxuICAgICAqIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBTaGFwZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHRoaXMueCArPSB4O1xuICAgICAqICAgdGhpcy55ICs9IHk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ3gnLCAneScsIGFuZCAnbW92ZScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBjb2xsZWN0aW9uLCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIW9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHJldHVybiByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ21vdmUnLCAneScsIGFuZCAneCcgYXNzdW1pbmcgYF8uZm9ySW4gYCBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcblxuICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHBhaXJzLnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDtcbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2socGFpcnNbbGVuZ3RoLS1dLCBwYWlyc1tsZW5ndGhdLCBvYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2tcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieVxuICAgICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93bih7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCcgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvck93biA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gY29sbGVjdGlvbiwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCFvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQoeyAnMCc6ICd6ZXJvJywgJzEnOiAnb25lJywgJ2xlbmd0aCc6IDIgfSwgZnVuY3Rpb24obnVtLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnbGVuZ3RoJywgJzEnLCBhbmQgJzAnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnMCcsICcxJywgYW5kICdsZW5ndGgnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc29ydGVkIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9mIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgbWV0aG9kc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKF8pO1xuICAgICAqIC8vID0+IFsnYWxsJywgJ2FueScsICdiaW5kJywgJ2JpbmRBbGwnLCAnY2xvbmUnLCAnY29tcGFjdCcsICdjb21wb3NlJywgLi4uXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG5hbWUgZXhpc3RzIGFzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLFxuICAgICAqIGluc3RlYWQgb2YgYW4gaW5oZXJpdGVkIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYga2V5IGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGFzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCAnYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPyBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZlcnQoeyAnZmlyc3QnOiAnZnJlZCcsICdzZWNvbmQnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogJ2ZpcnN0JywgJ2Jhcm5leSc6ICdzZWNvbmQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnQob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtvYmplY3Rba2V5XV0gPSBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYm9vbENsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZGF0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZGF0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBkYXRlQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBcnJheXMsIHN0cmluZ3MsIG9yIGBhcmd1bWVudHNgIG9iamVjdHMgd2l0aCBhXG4gICAgICogbGVuZ3RoIG9mIGAwYCBhbmQgb2JqZWN0cyB3aXRoIG5vIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGNvbnNpZGVyZWRcbiAgICAgKiBcImVtcHR5XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgnJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgaWYgKChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcyB8fCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IGFyZ3NDbGFzcyApIHx8XG4gICAgICAgICAgKGNsYXNzTmFtZSA9PSBvYmplY3RDbGFzcyAmJiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSkpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3JPd24odmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudCB0byBlYWNoIG90aGVyLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiB0byBjb21wYXJlIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY29tcGFyaXNvbnMgd2lsbFxuICAgICAqIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAoYSwgYikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgY29weSA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PSBjb3B5O1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBjb3B5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgd29yZHMgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXJXb3JkcyA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKHdvcmRzLCBvdGhlcldvcmRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICB2YXIgcmVHcmVldCA9IC9eKD86aGVsbG98aGkpJC9pLFxuICAgICAqICAgICAgIGFHcmVldCA9IF8uaXNTdHJpbmcoYSkgJiYgcmVHcmVldC50ZXN0KGEpLFxuICAgICAqICAgICAgIGJHcmVldCA9IF8uaXNTdHJpbmcoYikgJiYgcmVHcmVldC50ZXN0KGIpO1xuICAgICAqXG4gICAgICogICByZXR1cm4gKGFHcmVldCB8fCBiR3JlZXQpID8gKGFHcmVldCA9PSBiR3JlZXQpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKGEsIGIsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwoYSwgYiwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMsIG9yIGNhbiBiZSBjb2VyY2VkIHRvLCBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzRmluaXRlYCB3aGljaCB3aWxsIHJldHVybiB0cnVlIGZvclxuICAgICAqIGJvb2xlYW5zIGFuZCBlbXB0eSBzdHJpbmdzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuNS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGZpbml0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKC0xMDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSh0cnVlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSkgJiYgIW5hdGl2ZUlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3QuXG4gICAgICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIHRoZSBFQ01BU2NyaXB0IGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0XG4gICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDhcbiAgICAgIC8vIGFuZCBhdm9pZCBhIFY4IGJ1Z1xuICAgICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MVxuICAgICAgcmV0dXJuICEhKHZhbHVlICYmIG9iamVjdFR5cGVzW3R5cGVvZiB2YWx1ZV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc05hTmAgd2hpY2ggd2lsbCByZXR1cm4gYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtZXJpYyB2YWx1ZXMuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi40LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBgTmFOYCBhcyBhIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGZcbiAgICAgIC8vIChwZXJmb3JtIHRoZSBbW0NsYXNzXV0gY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZSBob3N0IG9iamVjdHMgaW4gSUUpXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogTm90ZTogYE5hTmAgaXMgY29uc2lkZXJlZCBhIG51bWJlci4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OC41LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcig4LjQgKiA1KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlckNsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IFNoYXBlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaXNQbGFpbk9iamVjdCA9ICFnZXRQcm90b3R5cGVPZiA/IHNoaW1Jc1BsYWluT2JqZWN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YsXG4gICAgICAgICAgb2JqUHJvdG8gPSBpc05hdGl2ZSh2YWx1ZU9mKSAmJiAob2JqUHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZU9mKSkgJiYgZ2V0UHJvdG90eXBlT2Yob2JqUHJvdG8pO1xuXG4gICAgICByZXR1cm4gb2JqUHJvdG9cbiAgICAgICAgPyAodmFsdWUgPT0gb2JqUHJvdG8gfHwgZ2V0UHJvdG90eXBlT2YodmFsdWUpID09IG9ialByb3RvKVxuICAgICAgICA6IHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9mcmVkLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cENsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZCBieVxuICAgICAqIHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJvdWdoIHRoZSBjYWxsYmFjay5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdmFsdWVzIG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogM30gLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdmcmVkJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXBWYWx1ZXMoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIHdpbGwgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuIElmIGEgY2FsbGJhY2sgaXNcbiAgICAgKiBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uXG4gICAgICogYW5kIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIHdpbGxcbiAgICAgKiBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbmFtZXMgPSB7XG4gICAgICogICAnY2hhcmFjdGVycyc6IFtcbiAgICAgKiAgICAgeyAnbmFtZSc6ICdiYXJuZXknIH0sXG4gICAgICogICAgIHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqICAgXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYWdlcyA9IHtcbiAgICAgKiAgICdjaGFyYWN0ZXJzJzogW1xuICAgICAqICAgICB7ICdhZ2UnOiAzNiB9LFxuICAgICAqICAgICB7ICdhZ2UnOiA0MCB9XG4gICAgICogICBdXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UobmFtZXMsIGFnZXMpO1xuICAgICAqIC8vID0+IHsgJ2NoYXJhY3RlcnMnOiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1dIH1cbiAgICAgKlxuICAgICAqIHZhciBmb29kID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYXBwbGUnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydiZWV0J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyRm9vZCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2JhbmFuYSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UoZm9vZCwgb3RoZXJGb29kLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICByZXR1cm4gXy5pc0FycmF5KGEpID8gYS5jb25jYXQoYikgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZnJ1aXRzJzogWydhcHBsZScsICdiYW5hbmEnXSwgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnLCAnY2Fycm90XSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2Uob2JqZWN0KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSAyO1xuXG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYW5kIGBjb2xsZWN0aW9uYCBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgYXJnc1syXSAhPSAnbnVtYmVyJykge1xuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPiAzICYmIHR5cGVvZiBhcmdzW2xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGFyZ3NbLS1sZW5ndGggLSAxXSwgYXJnc1tsZW5ndGgtLV0sIDIpO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzW2xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tbGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHZhciBzb3VyY2VzID0gc2xpY2UoYXJndW1lbnRzLCAxLCBsZW5ndGgpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgc3RhY2tBID0gZ2V0QXJyYXkoKSxcbiAgICAgICAgICBzdGFja0IgPSBnZXRBcnJheSgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2VzW2luZGV4XSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGBvYmplY3RgIGV4Y2x1ZGluZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgb21pdHRpbmcgdGhlIHByb3BlcnRpZXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXlcbiAgICAgKiBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi5zdHJpbmd8c3RyaW5nW119IFtjYWxsYmFja10gVGhlIHByb3BlcnRpZXMgdG8gb21pdCBvciB0aGVcbiAgICAgKiAgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aG91dCB0aGUgb21pdHRlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm9taXQoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ub21pdCh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcic7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHByb3BzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzID0gYmFzZURpZmZlcmVuY2UocHJvcHMsIGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpKTtcblxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmICghY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIGFuIG9iamVjdCdzIGtleS12YWx1ZSBwYWlycyxcbiAgICAgKiBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBuZXcgYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhaXJzKHsgJ2Jhcm5leSc6IDM2LCAnZnJlZCc6IDQwIH0pO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBjb21wb3NlZCBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgcGlja2luZyB0aGUgcHJvcGVydGllcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleVxuICAgICAqIGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLnN0cmluZ3xzdHJpbmdbXX0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gcGljaywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5waWNrKHsgJ25hbWUnOiAnZnJlZCcsICdfdXNlcmlkJzogJ2ZyZWQxJyB9LCAnbmFtZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5waWNrKHsgJ25hbWUnOiAnZnJlZCcsICdfdXNlcmlkJzogJ2ZyZWQxJyB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5LmNoYXJBdCgwKSAhPSAnXyc7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBwcm9wcyA9IGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpLFxuICAgICAgICAgICAgbGVuZ3RoID0gaXNPYmplY3Qob2JqZWN0KSA/IHByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWAgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgdGhyb3VnaCBhIGNhbGxiYWNrLCB3aXRoIGVhY2ggY2FsbGJhY2sgZXhlY3V0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czsgKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzcXVhcmVzID0gXy50cmFuc2Zvcm0oWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXSwgZnVuY3Rpb24ocmVzdWx0LCBudW0pIHtcbiAgICAgKiAgIG51bSAqPSBudW07XG4gICAgICogICBpZiAobnVtICUgMikge1xuICAgICAqICAgICByZXR1cm4gcmVzdWx0LnB1c2gobnVtKSA8IDM7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDksIDI1XVxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG51bSwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG51bSAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICBwcm90byA9IGN0b3IgJiYgY3Rvci5wcm90b3R5cGU7XG5cbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGJhc2VDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuICAgICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gb2JqZWN0W3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXhlcywgb3Iga2V5cywgb2YgdGhlXG4gICAgICogYGNvbGxlY3Rpb25gLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgaW5kZXhlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdfHN0cmluZ3xzdHJpbmdbXSl9IFtpbmRleF0gVGhlIGluZGV4ZXMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogICB0byByZXRyaWV2ZSwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgKiAgcHJvdmlkZWQgaW5kZXhlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hdChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddLCBbMCwgMiwgNF0pO1xuICAgICAqIC8vID0+IFsnYScsICdjJywgJ2UnXVxuICAgICAqXG4gICAgICogXy5hdChbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXSwgMCwgMik7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF0KGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBiYXNlRmxhdHRlbihhcmdzLCB0cnVlLCBmYWxzZSwgMSksXG4gICAgICAgICAgbGVuZ3RoID0gKGFyZ3NbMl0gJiYgYXJnc1syXVthcmdzWzFdXSA9PT0gY29sbGVjdGlvbikgPyAxIDogcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNvbGxlY3Rpb25bcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgcHJlc2VudCBpbiBhIGNvbGxlY3Rpb24gdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGluY2x1ZGVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHRhcmdldGAgZWxlbWVudCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoJ3BlYmJsZXMnLCAnZWInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgbGVuZ3RoICsgZnJvbUluZGV4KSA6IGZyb21JbmRleCkgfHwgMDtcbiAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpID4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmVzdWx0ID0gKGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbi5pbmRleE9mKHRhcmdldCwgZnJvbUluZGV4KSA6IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpKSA+IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCsraW5kZXggPj0gZnJvbUluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gIShyZXN1bHQgPSB2YWx1ZSA9PT0gdGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0rKyA6IHJlc3VsdFtrZXldID0gMSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgdmFsdWUgZm9yICoqYWxsKiogZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYWxsXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gISFjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSAhIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgc2VsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBldmVucyA9IF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqIC8vID0+IFsyLCA0LCA2XVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0XG4gICAgICogdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRldGVjdCwgZmluZFdoZXJlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCBleGVjdXRpbmcgdGhlIGNhbGxiYWNrIGZvciBlYWNoXG4gICAgICogZWxlbWVudC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnlcbiAgICAgKiBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogTm90ZTogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgYGxlbmd0aGAgcHJvcGVydHlcbiAgICAgKiBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgYF8uZm9ySW5gIG9yIGBfLmZvck93bmBcbiAgICAgKiBtYXkgYmUgdXNlZCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoKGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KS5qb2luKCcsJyk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyAnMSwyLDMnXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLmZvckVhY2hSaWdodChmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgZnJvbSByaWdodCB0byBsZWZ0IGFuZCByZXR1cm5zICczLDIsMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2xlbmd0aF0sIGxlbmd0aCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBrZXkgPSBwcm9wcyA/IHByb3BzWy0tbGVuZ3RoXSA6IC0tbGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjb2xsZWN0aW9uW2tleV0sIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGEgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSA6IHJlc3VsdFtrZXldID0gW10pLnB1c2godmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGdpdmVuIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBrZXlzID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlzLCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlzLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5LmNvZGUpOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4QnkoY2hhcmFjdGVycywgZnVuY3Rpb24oa2V5KSB7IHRoaXMuZnJvbUNoYXJDb2RlKGtleS5jb2RlKTsgfSwgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGluZGV4QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBuYW1lZCBieSBgbWV0aG9kTmFtZWAgb24gZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmBcbiAgICAgKiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiB3aWxsIGJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uIGl0XG4gICAgICogd2lsbCBiZSBpbnZva2VkIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2UoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZShjb2xsZWN0aW9uLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgbWV0aG9kTmFtZSA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IChpc0Z1bmMgPyBtZXRob2ROYW1lIDogdmFsdWVbbWV0aG9kTmFtZV0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGNvbGxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgNiwgOV1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChjaGFyYWN0ZXJzLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgY29sbGVjdGlvbi4gSWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkgb3JcbiAgICAgKiBmYWxzZXkgYC1JbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1heChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXgoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGNvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhcmd1bWVudCBhcyBhIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2NhbGxiYWNrXSA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50ID4gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBhIGNvbGxlY3Rpb24uIElmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5IG9yXG4gICAgICogZmFsc2V5IGBJbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhcmd1bWVudCBhcyBhIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2NhbGxiYWNrXSA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50IDwgY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSBhbGwgZWxlbWVudHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBwbHVjay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soY2hhcmFjdGVycywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICB2YXIgcGx1Y2sgPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGEgY29sbGVjdGlvbiB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjaywgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogY2FsbGJhY2sgZXhlY3V0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzIGV4ZWN1dGlvbi4gSWZcbiAgICAgKiBgYWNjdW11bGF0b3JgIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiB3aWxsIGJlXG4gICAgICogdXNlZCBhcyB0aGUgaW5pdGlhbCBgYWNjdW11bGF0b3JgIHZhbHVlLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czsgKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkbCwgaW5qZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3VtID0gXy5yZWR1Y2UoWzEsIDIsIDNdLCBmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVkID0gXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbnVtICogMztcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgaWYgKCFjb2xsZWN0aW9uKSByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB2YXIgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG5vYWNjdW0pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNvbGxlY3Rpb25bKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBub2FjY3VtXG4gICAgICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgICAgOiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxpc3QgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICogdmFyIGZsYXQgPSBfLnJlZHVjZVJpZ2h0KGxpc3QsIGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuICAgICAgZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgIDogY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBhXG4gICAgICogY29sbGVjdGlvbiB0aGF0IHRoZSBjYWxsYmFjayBkb2VzICoqbm90KiogcmV0dXJuIHRydWV5IGZvci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IGZhaWxlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvZGRzID0gXy5yZWplY3QoWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZWplY3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgcmFuZG9tIGVsZW1lbnQgb3IgYG5gIHJhbmRvbSBlbGVtZW50cyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gQWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgXG4gICAgICogIHdpdGhvdXQgdXNpbmcgdGhlaXIgYGluZGV4YCBhcmd1bWVudHMgYXMgYG5gLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIHNhbXBsZShzKSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uICYmIHR5cGVvZiBjb2xsZWN0aW9uLmxlbmd0aCAhPSAnbnVtYmVyJykge1xuICAgICAgICBjb2xsZWN0aW9uID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb25bYmFzZVJhbmRvbSgwLCBjb2xsZWN0aW9uLmxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzaHVmZmxlKGNvbGxlY3Rpb24pO1xuICAgICAgcmVzdWx0Lmxlbmd0aCA9IG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZSBGaXNoZXItWWF0ZXNcbiAgICAgKiBzaHVmZmxlLiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBzaHVmZmxlZCBjb2xsZWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDQsIDUsIDZdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgNiwgMywgNSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbSgwLCArK2luZGV4KTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdFtyYW5kXTtcbiAgICAgICAgcmVzdWx0W3JhbmRdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBgY29sbGVjdGlvbi5sZW5ndGhgIGZvciBhcnJheXNcbiAgICAgKiBhbmQgYXJyYXktbGlrZSBvYmplY3RzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYGNvbGxlY3Rpb24ubGVuZ3RoYCBvciBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnVleSB2YWx1ZSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGFcbiAgICAgKiBjb2xsZWN0aW9uLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGEgcGFzc2luZyB2YWx1ZSBhbmRcbiAgICAgKiBkb2VzIG5vdCBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFueVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKChyZXN1bHQgPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgd2lsbCBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgc29ydCBvcmRlclxuICAgICAqIG9mIGVxdWFsIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjb2xsZWN0aW9uXG4gICAgICogd2lsbCBiZSBzb3J0ZWQgYnkgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBzb3J0ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLnNpbihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLnNpbihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAyNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDMwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5zb3J0QnkoY2hhcmFjdGVycywgJ2FnZScpLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMjZdLCBbJ2ZyZWQnLCAzMF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICpcbiAgICAgKiAvLyBzb3J0aW5nIGJ5IG11bHRpcGxlIHByb3BlcnRpZXNcbiAgICAgKiBfLm1hcChfLnNvcnRCeShjaGFyYWN0ZXJzLCBbJ25hbWUnLCAnYWdlJ10pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPSA+IFtbJ2Jhcm5leScsIDI2XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGNhbGxiYWNrKSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFsrK2luZGV4XSA9IGdldE9iamVjdCgpO1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBvYmplY3QuY3JpdGVyaWEgPSBtYXAoY2FsbGJhY2ssIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKG9iamVjdC5jcml0ZXJpYSA9IGdldEFycmF5KCkpWzBdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSk7XG5cbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICByZXN1bHQuc29ydChjb21wYXJlQXNjZW5kaW5nKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0W2xlbmd0aF07XG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gb2JqZWN0LnZhbHVlO1xuICAgICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgICAgcmVsZWFzZUFycmF5KG9iamVjdC5jcml0ZXJpYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsZWFzZU9iamVjdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgYGNvbGxlY3Rpb25gIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTsgfSkoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBvZiBlYWNoIGVsZW1lbnQgaW4gYSBgY29sbGVjdGlvbmAgdG8gdGhlIGdpdmVuXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIGdpdmVuIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLndoZXJlKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ3BldHMnOiBbJ2hvcHB5J10gfV1cbiAgICAgKlxuICAgICAqIF8ud2hlcmUoY2hhcmFjdGVycywgeyAncGV0cyc6IFsnZGlubyddIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1dXG4gICAgICovXG4gICAgdmFyIHdoZXJlID0gZmlsdGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGFsbCBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZyBzdHJpY3RcbiAgICAgKiBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5cyBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzEsIDIsIDMsIDQsIDVdLCBbNSwgMiwgMTBdKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaWZmZXJlbmNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDIwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA+IDMwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb3IgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmdcbiAgICAgKiBhcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBoZWFkLCB0YWtlXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maXJzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpcnN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXJzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgMCwgbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBuKSwgbGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkgKHRoZSBuZXN0aW5nIGNhbiBiZSB0byBhbnkgZGVwdGgpLiBJZiBgaXNTaGFsbG93YFxuICAgICAqIGlzIHRydWV5LCB0aGUgYXJyYXkgd2lsbCBvbmx5IGJlIGZsYXR0ZW5lZCBhIHNpbmdsZSBsZXZlbC4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgaXMgcGFzc2VkIHRocm91Z2ggdGhlIGNhbGxiYWNrIGJlZm9yZVxuICAgICAqIGZsYXR0ZW5pbmcuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTaGFsbG93PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhIHNpbmdsZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgW1s0XV1dO1xuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzMCwgJ3BldHMnOiBbJ2hvcHB5J10gfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmxhdHRlbihjaGFyYWN0ZXJzLCAncGV0cycpO1xuICAgICAqIC8vID0+IFsnaG9wcHknLCAnYmFieSBwdXNzJywgJ2Rpbm8nXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgaXNTaGFsbG93ICE9ICdib29sZWFuJyAmJiBpc1NoYWxsb3cgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gKHR5cGVvZiBpc1NoYWxsb3cgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbaXNTaGFsbG93XSA9PT0gYXJyYXkpID8gbnVsbCA6IGlzU2hhbGxvdztcbiAgICAgICAgaXNTaGFsbG93ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBhcnJheSA9IG1hcChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYXJyYXkgaXMgYWxyZWFkeSBzb3J0ZWRcbiAgICAgKiBwcm92aWRpbmcgYHRydWVgIGZvciBgZnJvbUluZGV4YCB3aWxsIHJ1biBhIGZhc3RlciBiaW5hcnkgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbSBvciBgdHJ1ZWBcbiAgICAgKiAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAxLCAyLCAyLCAzLCAzXSwgMiwgdHJ1ZSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXggfHwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaW5kZXggPSBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gYXJyYXlbaW5kZXhdID09PSB2YWx1ZSA/IGluZGV4IDogLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhXG4gICAgICogY2FsbGJhY2sgaXMgcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIGV4Y2x1ZGVkIGZyb21cbiAgICAgKiB0aGUgcmVzdWx0IGFzIGxvbmcgYXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZFxuICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFjaz0xXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uaW5pdGlhbChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uaW5pdGlhbChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICduYScgfSksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogY2FsbGJhY2sgfHwgbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgMCwgbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBsZW5ndGggLSBuKSwgbGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHByZXNlbnQgaW4gYWxsIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgY2FjaGVzID0gZ2V0QXJyYXkoKSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIHRydXN0SW5kZXhPZiA9IGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHNlZW4gPSBnZXRBcnJheSgpO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBjYWNoZXMucHVzaCh0cnVzdEluZGV4T2YgJiYgdmFsdWUubGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmXG4gICAgICAgICAgICBjcmVhdGVDYWNoZShhcmdzSW5kZXggPyBhcmdzW2FyZ3NJbmRleF0gOiBzZWVuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBhcnJheSA9IGFyZ3NbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzWzBdO1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKHNlZW4sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgYXJnc0luZGV4ID0gYXJnc0xlbmd0aDtcbiAgICAgICAgICAoY2FjaGUgfHwgc2VlbikucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgd2hpbGUgKC0tYXJnc0luZGV4KSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlc1thcmdzSW5kZXhdO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihhcmdzW2FyZ3NJbmRleF0sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0xlbmd0aF07XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoY2FjaGVzKTtcbiAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmcgYXMgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmxhc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmxhc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoaW5kZXgtLSAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbmF0aXZlTWF4KDAsIGxlbmd0aCAtIG4pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZFxuICAgICAqIGFzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgaW5kZXggKyBmcm9tSW5kZXgpIDogbmF0aXZlTWluKGZyb21JbmRleCwgaW5kZXggLSAxKSkgKyAxO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm92aWRlZCB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvclxuICAgICAqIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgMSwgMiwgM107XG4gICAgICogXy5wdWxsKGFycmF5LCAyLCAzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbChhcnJheSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleC0tLCAxKTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0byBidXQgbm90IGluY2x1ZGluZyBgZW5kYC4gSWYgYHN0YXJ0YCBpcyBsZXNzIHRoYW4gYHN0b3BgIGFcbiAgICAgKiB6ZXJvLWxlbmd0aCByYW5nZSBpcyBjcmVhdGVkIHVubGVzcyBhIG5lZ2F0aXZlIGBzdGVwYCBpcyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyByYW5nZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgICAgc3RlcCA9IHR5cGVvZiBzdGVwID09ICdudW1iZXInID8gc3RlcCA6ICgrc3RlcCB8fCAxKTtcblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICAvLyB1c2UgYEFycmF5KGxlbmd0aClgIHNvIGVuZ2luZXMgbGlrZSBDaGFrcmEgYW5kIFY4IGF2b2lkIHNsb3dlciBtb2Rlc1xuICAgICAgLy8gaHR0cDovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoMCwgY2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgdGhhdCB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmluaXRpYWxgIHRoaXMgbWV0aG9kIGdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvclxuICAgICAqIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwcm92aWRlZCBlbGVtZW50c1xuICAgICAqIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tIHRoZSByZXN1bHQgYXMgbG9uZyBhcyB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRyb3AsIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFjaz0xXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogbmF0aXZlTWF4KDAsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaCBhIHZhbHVlXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYSBnaXZlbiBzb3J0ZWQgYXJyYXkgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIHNvcnRcbiAgICAgKiBvcmRlciBvZiB0aGUgYXJyYXkuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3JcbiAgICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG4gICAgICogY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzIwLCAzMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDIwIH0sIHsgJ3gnOiAzMCB9LCB7ICd4JzogNTAgfV0sIHsgJ3gnOiA0MCB9LCAneCcpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBkaWN0ID0ge1xuICAgICAqICAgJ3dvcmRUb051bWJlcic6IHsgJ3R3ZW50eSc6IDIwLCAndGhpcnR5JzogMzAsICdmb3VydHknOiA0MCwgJ2ZpZnR5JzogNTAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIGRpY3Qud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gdGhpcy53b3JkVG9OdW1iZXJbd29yZF07XG4gICAgICogfSwgZGljdCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IGxvdztcblxuICAgICAgLy8gZXhwbGljaXRseSByZWZlcmVuY2UgYGlkZW50aXR5YCBmb3IgYmV0dGVyIGlubGluaW5nIGluIEZpcmVmb3hcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpIDogaWRlbnRpdHk7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlKTtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgICAgKGNhbGxiYWNrKGFycmF5W21pZF0pIDwgdmFsdWUpXG4gICAgICAgICAgPyBsb3cgPSBtaWQgKyAxXG4gICAgICAgICAgOiBoaWdoID0gbWlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA1LCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaW9uKCkge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICAgICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIHNvcnRlZCwgcHJvdmlkaW5nXG4gICAgICogYHRydWVgIGZvciBgaXNTb3J0ZWRgIHdpbGwgdXNlIGEgZmFzdGVyIGFsZ29yaXRobS4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZFxuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmUgdW5pcXVlbmVzc1xuICAgICAqIGlzIGNvbXB1dGVkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuaXF1ZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLCAxLCAzLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDEsIDIsIDIsIDNdLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udW5pcShbJ0EnLCAnYicsICdDJywgJ2EnLCAnQicsICdjJ10sIGZ1bmN0aW9uKGxldHRlcikgeyByZXR1cm4gbGV0dGVyLnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgICAqIC8vID0+IFsnQScsICdiJywgJ0MnXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLjUsIDMsIDEuNSwgMiwgMy41XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFsxLCAyLjUsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8ganVnZ2xlIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCAhPSAnYm9vbGVhbicgJiYgaXNTb3J0ZWQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gKHR5cGVvZiBpc1NvcnRlZCAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tpc1NvcnRlZF0gPT09IGFycmF5KSA/IG51bGwgOiBpc1NvcnRlZDtcbiAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgcHJvdmlkZWQgdmFsdWVzIHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3JcbiAgICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAwLCAzLCAxLCA0XSwgMCwgMSk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aG91dChhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIHN5bW1ldHJpYyBkaWZmZXJlbmNlIG9mIHRoZSBwcm92aWRlZCBhcnJheXMuXG4gICAgICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0pO1xuICAgICAqIC8vID0+IFszLCA1LCA0XVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDVdLCBbMiwgMywgNV0sIFszLCA0LCA1XSk7XG4gICAgICogLy8gPT4gWzEsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24geG9yKCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXkpIHx8IGlzQXJndW1lbnRzKGFycmF5KSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRcbiAgICAgICAgICAgID8gYmFzZVVuaXEoYmFzZURpZmZlcmVuY2UocmVzdWx0LCBhcnJheSkuY29uY2F0KGJhc2VEaWZmZXJlbmNlKGFycmF5LCByZXN1bHQpKSlcbiAgICAgICAgICAgIDogYXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgfHwgW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuemlwXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gQXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAzMCwgdHJ1ZV0sIFsnYmFybmV5JywgNDAsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXAoKSB7XG4gICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50cyA6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gbWF4KHBsdWNrKGFycmF5LCAnbGVuZ3RoJykpIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBwbHVjayhhcnJheSwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBmcm9tIGFycmF5cyBvZiBga2V5c2AgYW5kIGB2YWx1ZXNgLiBQcm92aWRlXG4gICAgICogZWl0aGVyIGEgc2luZ2xlIHR3byBkaW1lbnNpb25hbCBhcnJheSwgaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gXG4gICAgICogb3IgdHdvIGFycmF5cywgb25lIG9mIGBrZXlzYCBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgb2JqZWN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgVGhlIGFycmF5IG9mIGtleXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgZ2l2ZW4ga2V5cyBhbmRcbiAgICAgKiAgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBrZXlzID8ga2V5cy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBpZiAoIXZhbHVlcyAmJiBsZW5ndGggJiYgIWlzQXJyYXkoa2V5c1swXSkpIHtcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgcmVzdWx0W2tleVswXV0gPSBrZXlbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyBgZnVuY2AsIHdpdGggIHRoZSBgdGhpc2AgYmluZGluZyBhbmRcbiAgICAgKiBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIG9ubHkgYWZ0ZXIgYmVpbmcgY2FsbGVkIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBiZWZvcmVcbiAgICAgKiAgYGZ1bmNgIGlzIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnRG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdEb25lIHNhdmluZyEnLCBhZnRlciBhbGwgc2F2ZXMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kYCBhcmd1bWVudHMgdG8gdGhvc2VcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMgPSBfLmJpbmQoZnVuYywgeyAnbmFtZSc6ICdmcmVkJyB9LCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChmdW5jLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBjcmVhdGVXcmFwcGVyKGZ1bmMsIDE3LCBzbGljZShhcmd1bWVudHMsIDIpLCBudWxsLCB0aGlzQXJnKVxuICAgICAgICA6IGNyZWF0ZVdyYXBwZXIoZnVuYywgMSwgbnVsbCwgbnVsbCwgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC4gTWV0aG9kIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgbWV0aG9kIG5hbWVzLiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkIGFsbCB0aGUgZnVuY3Rpb24gcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgIHdpbGwgYmUgYm91bmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gW21ldGhvZE5hbWVdIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvXG4gICAgICogIGJpbmQsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpOyB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3KTtcbiAgICAgKiBqUXVlcnkoJyNkb2NzJykub24oJ2NsaWNrJywgdmlldy5vbkNsaWNrKTtcbiAgICAgKiAvLyA9PiBsb2dzICdjbGlja2VkIGRvY3MnLCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRBbGwob2JqZWN0KSB7XG4gICAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpIDogZnVuY3Rpb25zKG9iamVjdCksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBmdW5jc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgMSwgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYFxuICAgICAqIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZEtleWAgYXJndW1lbnRzIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBib3VuZFxuICAgICAqIGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvXG4gICAgICogcmVmZXJlbmNlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuXG4gICAgICogU2VlIGh0dHA6Ly9taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnbmFtZSc6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLm5hbWUgKyAnISc7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kS2V5KG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBjcmVhdGVXcmFwcGVyKGtleSwgMTksIHNsaWNlKGFyZ3VtZW50cywgMiksIG51bGwsIG9iamVjdClcbiAgICAgICAgOiBjcmVhdGVXcmFwcGVyKGtleSwgMywgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyxcbiAgICAgKiB3aGVyZSBlYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgICAgKiBGb3IgZXhhbXBsZSwgY29tcG9zaW5nIHRoZSBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgcHJvZHVjZXMgYGYoZyhoKCkpKWAuXG4gICAgICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gW2Z1bmNdIEZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhbE5hbWVNYXAgPSB7XG4gICAgICogICAncGViYmxlcyc6ICdwZW5lbG9wZSdcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZvcm1hdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgKiAgIG5hbWUgPSByZWFsTmFtZU1hcFtuYW1lLnRvTG93ZXJDYXNlKCldIHx8IG5hbWU7XG4gICAgICogICByZXR1cm4gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZm9ybWF0dGVkKSB7XG4gICAgICogICByZXR1cm4gJ0hpeWEgJyArIGZvcm1hdHRlZCArICchJztcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIHdlbGNvbWUgPSBfLmNvbXBvc2UoZ3JlZXQsIGZvcm1hdCk7XG4gICAgICogd2VsY29tZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdIaXlhIFBlbmVsb3BlISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlKCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jc1tsZW5ndGhdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgYXJncyA9IFtmdW5jc1tsZW5ndGhdLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgb25lIG9yIG1vcmUgYXJndW1lbnRzIG9mIGBmdW5jYCB0aGF0IHdoZW5cbiAgICAgKiBpbnZva2VkIGVpdGhlciBleGVjdXRlcyBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGFsbCBgZnVuY2AgYXJndW1lbnRzXG4gICAgICogaGF2ZSBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIG9mIHRoZVxuICAgICAqIHJlbWFpbmluZyBgZnVuY2AgYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgY2FuIGJlIHNwZWNpZmllZFxuICAgICAqIGlmIGBmdW5jLmxlbmd0aGAgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgY29uc29sZS5sb2coYSArIGIgKyBjKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSkge1xuICAgICAgYXJpdHkgPSB0eXBlb2YgYXJpdHkgPT0gJ251bWJlcicgPyBhcml0eSA6ICgrYXJpdHkgfHwgZnVuYy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgNCwgbnVsbCwgbnVsbCwgbnVsbCwgYXJpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZGVsYXkgdGhlIGV4ZWN1dGlvbiBvZiBgZnVuY2AgdW50aWwgYWZ0ZXJcbiAgICAgKiBgd2FpdGAgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBpbnZva2VkLlxuICAgICAqIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb25cbiAgICAgKiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XSBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4XG4gICAgICogdmFyIGxhenlMYXlvdXQgPSBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKTtcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgbGF6eUxheW91dCk7XG4gICAgICpcbiAgICAgKiAvLyBleGVjdXRlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICAgICAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBlbnN1cmUgYGJhdGNoTG9nYCBpcyBleGVjdXRlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICAgICAqICAgJ21heFdhaXQnOiAxMDAwXG4gICAgICogfSwgZmFsc2UpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgd2FpdCA9IG5hdGl2ZU1heCgwLCB3YWl0KSB8fCAwO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgKG5hdGl2ZU1heCh3YWl0LCBvcHRpb25zLm1heFdhaXQpIHx8IDApO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHZhciBkZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdygpIC0gc3RhbXApO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGV4ZWN1dGluZyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuXG4gICAgICogQWRkaXRpb25hbCBhcmd1bWVudHMgd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7IGNvbnNvbGUubG9nKHRleHQpOyB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyBsb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG9yIG1vcmUgbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmZXIoZnVuYykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGV4ZWN1dGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gbG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWxheShmdW5jLCB3YWl0KSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHRcbiAgICAgKiBiYXNlZCBvbiB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlXG4gICAgICogZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBUaGUgYGZ1bmNgIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBUaGUgcmVzdWx0IGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIEEgZnVuY3Rpb24gdXNlZCB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6aW5nIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmlib25hY2NpID0gXy5tZW1vaXplKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuIDwgMiA/IG4gOiBmaWJvbmFjY2kobiAtIDEpICsgZmlib25hY2NpKG4gLSAyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZpYm9uYWNjaSg5KVxuICAgICAqIC8vID0+IDM0XG4gICAgICpcbiAgICAgKiB2YXIgZGF0YSA9IHtcbiAgICAgKiAgICdmcmVkJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gbW9kaWZ5aW5nIHRoZSByZXN1bHQgY2FjaGVcbiAgICAgKiB2YXIgZ2V0ID0gXy5tZW1vaXplKGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGRhdGFbbmFtZV07IH0sIF8uaWRlbnRpdHkpO1xuICAgICAqIGdldCgncGViYmxlcycpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKlxuICAgICAqIGdldC5jYWNoZS5wZWJibGVzLm5hbWUgPSAncGVuZWxvcGUnO1xuICAgICAqIGdldCgncGViYmxlcycpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAncGVuZWxvcGUnLCAnYWdlJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGUsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXlQcmVmaXggKyBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSlcbiAgICAgICAgICA/IGNhY2hlW2tleV1cbiAgICAgICAgICA6IChjYWNoZVtrZXldID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICAgIG1lbW9pemVkLmNhY2hlID0ge307XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBleGVjdXRlIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHMgdG9cbiAgICAgKiB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBjYWxsLiBUaGUgYGZ1bmNgIGlzIGV4ZWN1dGVkXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gYGluaXRpYWxpemVgIGV4ZWN1dGVzIGBjcmVhdGVBcHBsaWNhdGlvbmAgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgdmFyIHJhbixcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmFuKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGBmdW5jYCB2YXJpYWJsZSBzbyB0aGUgZnVuY3Rpb24gbWF5IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggYW55IGFkZGl0aW9uYWxcbiAgICAgKiBgcGFydGlhbGAgYXJndW1lbnRzIHByZXBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLiBUaGlzXG4gICAgICogbWV0aG9kIGlzIHNpbWlsYXIgdG8gYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHsgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTsgfTtcbiAgICAgKiB2YXIgaGkgPSBfLnBhcnRpYWwoZ3JlZXQsICdoaScpO1xuICAgICAqIGhpKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCAxNiwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBgcGFydGlhbGAgYXJndW1lbnRzIGFyZVxuICAgICAqIGFwcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzRGVlcCA9IF8ucGFydGlhbFJpZ2h0KF8ubWVyZ2UsIF8uZGVmYXVsdHMpO1xuICAgICAqXG4gICAgICogdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAndmFyaWFibGUnOiAnZGF0YScsXG4gICAgICogICAnaW1wb3J0cyc6IHsgJ2pxJzogJCB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzRGVlcChvcHRpb25zLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuICAgICAqXG4gICAgICogb3B0aW9ucy52YXJpYWJsZVxuICAgICAqIC8vID0+ICdkYXRhJ1xuICAgICAqXG4gICAgICogb3B0aW9ucy5pbXBvcnRzXG4gICAgICogLy8gPT4geyAnXyc6IF8sICdqcSc6ICQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxSaWdodChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCAzMiwgbnVsbCwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gZXhlY3V0ZWQsIHdpbGwgb25seSBjYWxsIHRoZSBgZnVuY2AgZnVuY3Rpb25cbiAgICAgKiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG9cbiAgICAgKiBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZVxuICAgICAqIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGxcbiAgICAgKiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAgYGZ1bmNgIHdpbGwgYmUgY2FsbGVkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIHRocm90dGxlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBleGVjdXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCk7XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBleGVjdXRlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXNcbiAgICAgKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VPcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgZGVib3VuY2VPcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICAgICAgZGVib3VuY2VPcHRpb25zLnRyYWlsaW5nID0gdHJhaWxpbmc7XG5cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCBkZWJvdW5jZU9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24gYXMgaXRzXG4gICAgICogZmlyc3QgYXJndW1lbnQuIEFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgZXhlY3V0ZWQgd2l0aFxuICAgICAqIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnRnJlZCwgV2lsbWEsICYgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5GcmVkLCBXaWxtYSwgJmFtcDsgUGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIod3JhcHBlciwgMTYsIFt2YWx1ZV0pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcbiAgICAgKiBnZXR0ZXIoKSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgY2FsbGJhY2sgYm91bmQgdG8gYW4gb3B0aW9uYWwgYHRoaXNBcmdgLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eVxuICAgICAqIG5hbWUgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuXG4gICAgICogSWYgYGZ1bmNgIGlzIGFuIG9iamVjdCB0aGUgY3JlYXRlZCBjYWxsYmFjayB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzXG4gICAgICogdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50IG9iamVjdCBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3cmFwIHRvIGNyZWF0ZSBjdXN0b20gY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIF8uY3JlYXRlQ2FsbGJhY2sgPSBfLndyYXAoXy5jcmVhdGVDYWxsYmFjaywgZnVuY3Rpb24oZnVuYywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgKiAgIHZhciBtYXRjaCA9IC9eKC4rPylfXyhbZ2xddCkoLispJC8uZXhlYyhjYWxsYmFjayk7XG4gICAgICogICByZXR1cm4gIW1hdGNoID8gZnVuYyhjYWxsYmFjaywgdGhpc0FyZykgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgICAgcmV0dXJuIG1hdGNoWzJdID09ICdndCcgPyBvYmplY3RbbWF0Y2hbMV1dID4gbWF0Y2hbM10gOiBvYmplY3RbbWF0Y2hbMV1dIDwgbWF0Y2hbM107XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgJ2FnZV9fZ3QzOCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZnVuYztcbiAgICAgIGlmIChmdW5jID09IG51bGwgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpO1xuICAgICAgfVxuICAgICAgLy8gaGFuZGxlIFwiXy5wbHVja1wiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgIGlmICh0eXBlICE9ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eShmdW5jKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGtleXMoZnVuYyksXG4gICAgICAgICAga2V5ID0gcHJvcHNbMF0sXG4gICAgICAgICAgYSA9IGZ1bmNba2V5XTtcblxuICAgICAgLy8gaGFuZGxlIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgIGlmIChwcm9wcy5sZW5ndGggPT0gMSAmJiBhID09PSBhICYmICFpc09iamVjdChhKSkge1xuICAgICAgICAvLyBmYXN0IHBhdGggdGhlIGNvbW1vbiBjYXNlIG9mIHByb3ZpZGluZyBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZVxuICAgICAgICAvLyBwcm9wZXJ0eSBjb250YWluaW5nIGEgcHJpbWl0aXZlIHZhbHVlXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICB2YXIgYiA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIHJldHVybiBhID09PSBiICYmIChhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYikpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gYmFzZUlzRXF1YWwob2JqZWN0W3Byb3BzW2xlbmd0aF1dLCBmdW5jW3Byb3BzW2xlbmd0aF1dLCBudWxsLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBgJmAsIGA8YCwgYD5gLCBgXCJgLCBhbmQgYCdgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdGcmVkLCBXaWxtYSwgJiBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIFdpbG1hLCAmYW1wOyBQZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgPT0gbnVsbCA/ICcnIDogU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uIG1ldGhvZHMgd2lsbCBiZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciB0aGUgZnVuY3Rpb25zIGFkZGVkIGFyZSBjaGFpbmFibGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICdjYXBpdGFsaXplJzogY2FwaXRhbGl6ZSB9KTtcbiAgICAgKiBfLmNhcGl0YWxpemUoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS5jYXBpdGFsaXplKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAnY2FwaXRhbGl6ZSc6IGNhcGl0YWxpemUgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gc291cmNlICYmIGZ1bmN0aW9ucyhzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZSB8fCAoIW9wdGlvbnMgJiYgIW1ldGhvZE5hbWVzLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgY3RvciA9IGxvZGFzaFdyYXBwZXI7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gbG9kYXNoO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGZ1bmN0aW9ucyhzb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykge1xuICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgICB9XG4gICAgICB2YXIgY3RvciA9IG9iamVjdCxcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKGN0b3IpO1xuXG4gICAgICBmb3JFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gb2JqZWN0W21ldGhvZE5hbWVdID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgY3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgICAgICBhcmdzID0gW3ZhbHVlXTtcblxuICAgICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHJlc3VsdCAmJiBpc09iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGN0b3IocmVzdWx0KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSAnXycgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgY29udGV4dC5fID0gb2xkRGFzaDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbm8tb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIF8ubm9vcChvYmplY3QpID09PSB1bmRlZmluZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBubyBvcGVyYXRpb24gcGVyZm9ybWVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgVW5peCBlcG9jaFxuICAgICAqICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3RhbXAgPSBfLm5vdygpO1xuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7IH0pO1xuICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqL1xuICAgIHZhciBub3cgPSBpc05hdGl2ZShub3cgPSBEYXRlLm5vdykgJiYgbm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAgICogSWYgYHJhZGl4YCBpcyBgdW5kZWZpbmVkYCBvciBgMGAgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgdGhlXG4gICAgICogYHZhbHVlYCBpcyBhIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBhdm9pZHMgZGlmZmVyZW5jZXMgaW4gbmF0aXZlIEVTMyBhbmQgRVM1IGBwYXJzZUludGBcbiAgICAgKiBpbXBsZW1lbnRhdGlvbnMuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jRS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXhdIFRoZSByYWRpeCB1c2VkIHRvIGludGVycHJldCB0aGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbmV3IGludGVnZXIgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqL1xuICAgIHZhciBwYXJzZUludCA9IG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2UgKyAnMDgnKSA9PSA4ID8gbmF0aXZlUGFyc2VJbnQgOiBmdW5jdGlvbih2YWx1ZSwgcmFkaXgpIHtcbiAgICAgIC8vIEZpcmVmb3ggPCAyMSBhbmQgT3BlcmEgPCAxNSBmb2xsb3cgdGhlIEVTMyBzcGVjaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgYHBhcnNlSW50YFxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KGlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UocmVMZWFkaW5nU3BhY2VzQW5kWmVyb3MsICcnKSA6IHZhbHVlLCByYWRpeCB8fCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFwiXy5wbHVja1wiIHN0eWxlIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIHRoZSBga2V5YCB2YWx1ZSBvZiBhXG4gICAgICogZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBnZXROYW1lID0gXy5wcm9wZXJ0eSgnbmFtZScpO1xuICAgICAqXG4gICAgICogXy5tYXAoY2hhcmFjdGVycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShjaGFyYWN0ZXJzLCBnZXROYW1lKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShrZXkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIHRydWV5IG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzIGFcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXIgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmc9ZmFsc2VdIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgZmxvYXRpbmcpIHtcbiAgICAgIHZhciBub01pbiA9IG1pbiA9PSBudWxsLFxuICAgICAgICAgIG5vTWF4ID0gbWF4ID09IG51bGw7XG5cbiAgICAgIGlmIChmbG9hdGluZyA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWluID09ICdib29sZWFuJyAmJiBub01heCkge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWluO1xuICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5vTWF4ICYmIHR5cGVvZiBtYXggPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtYXg7XG4gICAgICAgICAgbm9NYXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9NaW4gJiYgbm9NYXgpIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICAgIH1cbiAgICAgIG1pbiA9ICttaW4gfHwgMDtcbiAgICAgIGlmIChub01heCkge1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSArbWF4IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbWluICUgMSB8fCBtYXggJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obWluICsgKHJhbmQgKiAobWF4IC0gbWluICsgcGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArJycpLmxlbmd0aCAtIDEpKSkpLCBtYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obWluLCBtYXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eSBga2V5YCBvbiBgb2JqZWN0YC4gSWYgYGtleWAgaXMgYSBmdW5jdGlvblxuICAgICAqIGl0IHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgb2JqZWN0YCBhbmQgaXRzIHJlc3VsdCByZXR1cm5lZCxcbiAgICAgKiBlbHNlIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZXR1cm5lZC4gSWYgYG9iamVjdGAgaXMgZmFsc2V5IHRoZW4gYHVuZGVmaW5lZGBcbiAgICAgKiBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdjaGVlc2UnOiAnY3J1bXBldHMnLFxuICAgICAqICAgJ3N0dWZmJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHJldHVybiAnbm9uc2Vuc2UnO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdjaGVlc2UnKTtcbiAgICAgKiAvLyA9PiAnY3J1bXBldHMnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdzdHVmZicpO1xuICAgICAqIC8vID0+ICdub25zZW5zZSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSA/IG9iamVjdFtrZXldKCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1pY3JvLXRlbXBsYXRpbmcgbWV0aG9kIHRoYXQgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzXG4gICAgICogd2hpdGVzcGFjZSwgYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQsIGBfLnRlbXBsYXRlYCB1dGlsaXplcyBzb3VyY2VVUkxzIGZvciBlYXNpZXJcbiAgICAgKiBkZWJ1Z2dpbmcuIFNlZSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZTpcbiAgICAgKiBodHRwOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWU6XG4gICAgICogaHR0cDovL2RldmVsb3Blci5jaHJvbWUuY29tL3N0YWJsZS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsLmh0bWxcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlXSBUaGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBsb2NhbCB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZVVSTF0gVGhlIHNvdXJjZVVSTCBvZiB0aGUgdGVtcGxhdGUncyBjb21waWxlZCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufHN0cmluZ30gUmV0dXJucyBhIGNvbXBpbGVkIGZ1bmN0aW9uIHdoZW4gbm8gYGRhdGFgIG9iamVjdFxuICAgICAqICBpcyBnaXZlbiwgZWxzZSBpdCByZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ25hbWUnOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIEhUTUwgaW4gZGF0YSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+JywgeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGxpc3QgPSAnPCUgXy5mb3JFYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBFUzYgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyAkeyBuYW1lIH0nLCB7ICduYW1lJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgbmFtZSk7ICU+IScsIHsgJ25hbWUnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgICogICAnaW50ZXJwb2xhdGUnOiAve3soW1xcc1xcU10rPyl9fS9nXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8udGVtcGxhdGUoJ2hlbGxvIHt7IG5hbWUgfX0hJywgeyAnbmFtZSc6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBqUXVlcnlcbiAgICAgKiB2YXIgbGlzdCA9ICc8JSBqcS5lYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSBuYW1lICU+JywgbnVsbCwgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IGZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3JcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLm5hbWUgJT4hJywgbnVsbCwgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAgIHZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZTtcbiAgICAgKiAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLm5hbWUgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAgIHJldHVybiBfX3A7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgLy8gYmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy9cbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1RcbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0IHx8ICcnKTtcblxuICAgICAgLy8gYXZvaWQgbWlzc2luZyBkZXBlbmRlbmNpZXMgd2hlbiBgaXRlcmF0b3JUZW1wbGF0ZWAgaXMgbm90IGRlZmluZWRcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgc2V0dGluZ3MpO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gdmFsdWVzKGltcG9ydHMpO1xuXG4gICAgICB2YXIgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gY29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICB0ZXh0LnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIGVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFsc1xuICAgICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyByZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0c1xuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIHJlcXVpcmVzIHJldHVybmluZyB0aGUgYG1hdGNoYFxuICAgICAgICAvLyBzdHJpbmcgaW4gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gaWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkLCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpblxuICAgICAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZSxcbiAgICAgICAgICBoYXNWYXJpYWJsZSA9IHZhcmlhYmxlO1xuXG4gICAgICBpZiAoIWhhc1ZhcmlhYmxlKSB7XG4gICAgICAgIHZhcmlhYmxlID0gJ29iaic7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoICgnICsgdmFyaWFibGUgKyAnKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5nc1xuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBmcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArIHZhcmlhYmxlICsgJykge1xcbicgK1xuICAgICAgICAoaGFzVmFyaWFibGUgPyAnJyA6IHZhcmlhYmxlICsgJyB8fCAoJyArIHZhcmlhYmxlICsgJyA9IHt9KTtcXG4nKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJycsIF9fZSA9IF8uZXNjYXBlXCIgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICdcXG4vKlxcbi8vIyBzb3VyY2VVUkw9JyArIChvcHRpb25zLnNvdXJjZVVSTCB8fCAnL2xvZGFzaC90ZW1wbGF0ZS9zb3VyY2VbJyArICh0ZW1wbGF0ZUNvdW50ZXIrKykgKyAnXScpICsgJ1xcbiovJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uKGltcG9ydHNLZXlzLCAncmV0dXJuICcgKyBzb3VyY2UgKyBzb3VyY2VVUkwpLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0KGRhdGEpO1xuICAgICAgfVxuICAgICAgLy8gcHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kLCBpblxuICAgICAgLy8gc3VwcG9ydGVkIGVudmlyb25tZW50cywgb3IgdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgICAvLyBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2FsbGJhY2sgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHNcbiAgICAgKiBvZiBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGljZVJvbGxzID0gXy50aW1lcygzLCBfLnBhcnRpYWwoXy5yYW5kb20sIDEsIDYpKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikgeyBtYWdlLmNhc3RTcGVsbChuKTsgfSk7XG4gICAgICogLy8gPT4gY2FsbHMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lcywgcGFzc2luZyBgbmAgb2YgYDBgLCBgMWAsIGFuZCBgMmAgcmVzcGVjdGl2ZWx5XG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgdGhpcy5jYXN0KG4pOyB9LCBtYWdlKTtcbiAgICAgKiAvLyA9PiBhbHNvIGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgbiA9IChuID0gK24pID4gLTEgPyBuIDogMDtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYCB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ0ZyZWQsIEJhcm5leSAmYW1wOyBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIEJhcm5leSAmIFBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwcm92aWRlZCB0aGUgSUQgd2lsbCBiZSBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiBTdHJpbmcocHJlZml4ID09IG51bGwgPyAnJyA6IHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgd2l0aCBleHBsaWNpdFxuICAgICAqIG1ldGhvZCBjaGFpbmluZyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfLmNoYWluKGNoYXJhY3RlcnMpXG4gICAgICogICAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAgIC5tYXAoZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIubmFtZSArICcgaXMgJyArIGNoci5hZ2U7IH0pXG4gICAgICogICAgIC5maXJzdCgpXG4gICAgICogICAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgICAgdmFsdWUuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBpbnRlcmNlcHRvcmAgd2l0aCB0aGUgYHZhbHVlYCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHRoZW5cbiAgICAgKiByZXR1cm5zIGB2YWx1ZWAuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZFxuICAgICAqIGNoYWluIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW5cbiAgICAgKiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzLCA0XSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkgeyBhcnJheS5wb3AoKTsgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBleHBsaWNpdCBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5maXJzdCgpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKGNoYXJhY3RlcnMpLmNoYWluKClcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAucGljaygnYWdlJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgYHRvU3RyaW5nYCByZXN1bHQgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nIHJlc3VsdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnRvU3RyaW5nKCk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb1N0cmluZygpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZU9mXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdmFsdWVcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlT2YoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWVPZigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fd3JhcHBlZF9fO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbXBvc2UgPSBjb21wb3NlO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jcmVhdGVDYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5kZXhCeSA9IGluZGV4Qnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGx1Y2sgPSBwbHVjaztcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICAgIGxvZGFzaC5kcm9wID0gcmVzdDtcbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuICAgIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5vYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG4gICAgbG9kYXNoLnVuaXF1ZSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuemlwID0gemlwO1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0byBgbG9kYXNoLnByb3RvdHlwZWBcbiAgICBtaXhpbihsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNvbnRhaW5zID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gICAgbG9kYXNoLmFueSA9IHNvbWU7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5pbmNsdWRlID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmluamVjdCA9IHJlZHVjZTtcblxuICAgIG1peGluKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9XG4gICAgICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCksIGZhbHNlKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLnRha2UgPSBmaXJzdDtcbiAgICBsb2Rhc2guaGVhZCA9IGZpcnN0O1xuXG4gICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNhbGxiYWNrYWJsZSA9IG1ldGhvZE5hbWUgIT09ICdzYW1wbGUnO1xuICAgICAgaWYgKCFsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV09IGZ1bmN0aW9uKG4sIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmModGhpcy5fX3dyYXBwZWRfXywgbiwgZ3VhcmQpO1xuXG4gICAgICAgICAgcmV0dXJuICFjaGFpbkFsbCAmJiAobiA9PSBudWxsIHx8IChndWFyZCAmJiAhKGNhbGxiYWNrYWJsZSAmJiB0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSkpXG4gICAgICAgICAgICA/IHJlc3VsdFxuICAgICAgICAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSAnMi40LjEnO1xuXG4gICAgLy8gYWRkIFwiQ2hhaW5pbmdcIiBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXJcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9TdHJpbmcgPSB3cmFwcGVyVG9TdHJpbmc7XG4gICAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZU9mO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IHdyYXBwZXJWYWx1ZU9mO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXNcbiAgICBmb3JFYWNoKFsnam9pbicsICdwb3AnLCAnc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGNoYWluQWxsXG4gICAgICAgICAgPyBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKVxuICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0aGUgZXhpc3Rpbmcgd3JhcHBlZCB2YWx1ZVxuICAgIGZvckVhY2goWydwdXNoJywgJ3JldmVyc2UnLCAnc29ydCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIG5ldyB3cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydjb25jYXQnLCAnc2xpY2UnLCAnc3BsaWNlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgbG9kYXNoV3JhcHBlcihmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyksIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gZXhwb3NlIExvLURhc2hcbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBzb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvLURhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3QgZXZlbiB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCBpblxuICAgIC8vIGNhc2UgTG8tRGFzaCBpcyBsb2FkZWQgd2l0aCBhIFJlcXVpcmVKUyBzaGltIGNvbmZpZy5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9hcGkuaHRtbCNjb25maWctc2hpbVxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBkZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KU1xuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgfVxuICAgIC8vIGluIE5hcndoYWwgb3IgUmhpbm8gLXJlcXVpcmVcbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuXG59KSh3aW5kb3cpIiwiXG52YXIgQ2FudmFzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDYW52YXMgKHcsIGgpIHtcbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gIGNhbnZhcy53aWR0aCA9IHcgfHwgMzAwXG4gIGNhbnZhcy5oZWlnaHQgPSBoIHx8IDE1MFxuICByZXR1cm4gY2FudmFzXG59XG5cbkNhbnZhcy5JbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG4gIHJldHVybiBpbWdcbn1cblxuXG5cbiIsIiQgPSByZXF1aXJlICdqcXVlcnknXG5BViA9IHdpbmRvdy5BVlxuYWN0UGFsZXR0ZSA9IHJlcXVpcmUgJ2FjdC1qcydcbmdpbXBQYWxldHRlID0gcmVxdWlyZSAnLi4vbGliL2dpbXAtcGFsZXR0ZS5jb2ZmZWUnXG5EaWFsb2dWaWV3ID0gcmVxdWlyZSAnLi9kaWFsb2ctdmlldy5jb2ZmZWUnXG5cbmRvd25sb2FkID0gKGZpbGVuYW1lLCBjb250ZW50KSAtPlxuICAgICRhID0gJChcIlwiXCI8YSBocmVmPVwiI3tjb250ZW50fVwiIGRvd25sb2FkPVwiI3tmaWxlbmFtZX1cIj48L2E+XCJcIlwiKVxuICAgIGEgPSAkYVswXVxuICAgICQoJ2JvZHknKS5hcHBlbmQoJGEpXG5cbiAgICAjIG5vdGUgdGhhdCAkYS5jbGljaygpIHdvbid0IHdvcmtcbiAgICAjIHNldFRpbWVvdXQgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgPGE+IG5lZWRzIHRvIGJlIGNsaWNrYWJsZVxuICAgICMgc2VlIGFsc286IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE0MDMyOTUvanMtY2xpY2stZXZlbnQtbmVlZHMtc2V0dGltZW91dC10by10cmlnZ2VyLWNsaWNrLWV2ZW50XG4gICAgc2V0VGltZW91dCAoLT5cbiAgICAgICAgYS5jbGljaygpXG4gICAgICAgICRhLnJlbW92ZSgpXG4gICAgKSwgMFxuXG5nZW5lcmF0ZUZpbGVuYW1lID0gLT5cbiAgICB1c2VyID0gQVYuVXNlci5jdXJyZW50KClcbiAgICB1c2VybmFtZSA9IGlmIHVzZXIgdGhlbiB1c2VyLmF0dHJpYnV0ZXMudXNlcm5hbWUgKyAnQCdlbHNlICcnXG4gICAgbmFtZSA9IHVzZXJuYW1lICsgJ2NvY29sb3VyLmNvbSAtICcgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpXG5cbmNsYXNzIERldGFpbFZpZXdcblxuICAgIGNvbnN0cnVjdG9yOiAoY29sb3JzKSAtPlxuICAgICAgICBodG1sID0gXCJcIlwiXG4gICAgICAgICAgICA8ZGl2IGlkPVwicGFsZXR0ZS1kZXRhaWxcIj5cbiAgICAgICAgICAgICAgICA8aDI+RG93bmxvYWQgUGFsZXR0ZTwvaDI+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cInBhbGV0dGUtZGV0YWlsLWNvbG9yc1wiPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPSdmYSBmYS1kb3dubG9hZCBidXR0b24gZG93bmxvYWQtYWN0Jz5BZG9iZSBDb2xvciBUYWJsZTwvaT5cbiAgICAgICAgICAgICAgICA8YnI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9J2ZhIGZhLWRvd25sb2FkIGJ1dHRvbiBkb3dubG9hZC1naW1wJyB0aXRsZT0nU2F2ZSBpdCBpbiB+Ly5naW1wLTIuOC9wYWxldHRlcy8gYW5kIHJlc3RhcnQgR0lNUC4nPkdpbXAgUGFsZXR0ZTwvaT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBcIlwiXCJcbiAgICAgICAgJHZpZXcgPSAkKGh0bWwpXG5cbiAgICAgICAgJHZpZXcuZmluZCgnLmRvd25sb2FkLWFjdCcpLm9uICdjbGljaycsIC0+XG4gICAgICAgICAgICBuYW1lID0gZ2VuZXJhdGVGaWxlbmFtZSgpXG4gICAgICAgICAgICBhY3RQYWxldHRlIGNvbG9ycywgKGVyciwgY29udGVudCkgLT5cbiAgICAgICAgICAgICAgICBkb3dubG9hZCBuYW1lICsgJy5hY3QnLCBjb250ZW50XG5cbiAgICAgICAgJHZpZXcuZmluZCgnLmRvd25sb2FkLWdpbXAnKS5vbiAnY2xpY2snLCAtPlxuICAgICAgICAgICAgbmFtZSA9IGdlbmVyYXRlRmlsZW5hbWUoKVxuICAgICAgICAgICAgY29udGVudCA9IGdpbXBQYWxldHRlKG5hbWUsIGNvbG9ycylcbiAgICAgICAgICAgIGNvbnRlbnQgPSAnZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLTgsJyArIGVuY29kZVVSSUNvbXBvbmVudChjb250ZW50KVxuICAgICAgICAgICAgZG93bmxvYWQgbmFtZSArICcuZ3BsJywgY29udGVudFxuXG4gICAgICAgICR2aWV3LmZpbmQoJyNwYWxldHRlLWRldGFpbC1jb2xvcnMnKS5odG1sIGNvbG9ycy5tYXAoKGNvbG9yKSAtPlxuICAgICAgICAgICAgcmdiID0gY29sb3Iuam9pbignLCAnKVxuICAgICAgICAgICAgaGV4ID0gJyMnICsgKGNvbG9yLm1hcCAoZCkgLT4gZC50b1N0cmluZygxNikpLmpvaW4oJycpXG4gICAgICAgICAgICBcIlwiXCI8ZGl2IGNsYXNzPVwiY29sb3JcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYm94XCIgc3R5bGU9XCJiYWNrZ3JvdW5kOiAje2hleH1cIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAje2hleH0gKCN7cmdifSk8L2Rpdj5cbiAgICAgICAgICAgIFwiXCJcIlxuICAgICAgICApLmpvaW4oJycpXG5cbiAgICAgICAgbmV3IERpYWxvZ1ZpZXcoJHZpZXcpXG5cbm1vZHVsZS5leHBvcnRzID0gRGV0YWlsVmlld1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgQ0lFNzY7XG5cbiAgQ0lFNzYgPSBmdW5jdGlvbihsYWIxLCBsYWIyKSB7XG4gICAgdmFyIHN1bTtcbiAgICBzdW0gPSAwO1xuICAgIGxhYjEuZm9yRWFjaChmdW5jdGlvbih2YWwsIGkpIHtcbiAgICAgIHJldHVybiBzdW0gKz0gTWF0aC5wb3codmFsIC0gbGFiMltpXSwgMik7XG4gICAgfSk7XG4gICAgcmV0dXJuIE1hdGguc3FydChzdW0pO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gQ0lFNzY7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBzZWVkcztcblxuICBzZWVkcyA9IFwiMjQwLDI0OCwyNTVcXG4yNTAsMjM1LDIxNVxcbjAsMjU1LDI1NVxcbjEyNywyNTUsMjEyXFxuMjQwLDI1NSwyNTVcXG4yNDUsMjQ1LDIyMFxcbjI1NSwyMjgsMTk2XFxuMCwwLDBcXG4yNTUsMjM1LDIwNVxcbjAsMCwyNTVcXG4xMzgsNDMsMjI2XFxuMTY1LDQyLDQyXFxuMjIyLDE4NCwxMzVcXG45NSwxNTgsMTYwXFxuMTI3LDI1NSwwXFxuMjEwLDEwNSwzMFxcbjI1NSwxMjcsODBcXG4xMDAsMTQ5LDIzN1xcbjI1NSwyNDgsMjIwXFxuMjIwLDIwLDYwXFxuMCwyNTUsMjU1XFxuMCwwLDEzOVxcbjAsMTM5LDEzOVxcbjE4NCwxMzQsMTFcXG4xNjksMTY5LDE2OVxcbjAsMTAwLDBcXG4xNjksMTY5LDE2OVxcbjE4OSwxODMsMTA3XFxuMTM5LDAsMTM5XFxuODUsMTA3LDQ3XFxuMjU1LDE0MCwwXFxuMTUzLDUwLDIwNFxcbjEzOSwwLDBcXG4yMzMsMTUwLDEyMlxcbjE0MywxODgsMTQzXFxuNzIsNjEsMTM5XFxuNDcsNzksNzlcXG40Nyw3OSw3OVxcbjAsMjA2LDIwOVxcbjE0OCwwLDIxMVxcbjI1NSwyMCwxNDdcXG4wLDE5MSwyNTVcXG4xMDUsMTA1LDEwNVxcbjEwNSwxMDUsMTA1XFxuMzAsMTQ0LDI1NVxcbjE3OCwzNCwzNFxcbjI1NSwyNTAsMjQwXFxuMzQsMTM5LDM0XFxuMjU1LDAsMjU1XFxuMjIwLDIyMCwyMjBcXG4yNDgsMjQ4LDI1NVxcbjI1NSwyMTUsMFxcbjIxOCwxNjUsMzJcXG4xMjgsMTI4LDEyOFxcbjAsMTI4LDBcXG4xNzMsMjU1LDQ3XFxuMTI4LDEyOCwxMjhcXG4yNDAsMjU1LDI0MFxcbjI1NSwxMDUsMTgwXFxuMjA1LDkyLDkyXFxuNzUsMCwxMzBcXG4yNTUsMjU1LDI0MFxcbjI0MCwyMzAsMTQwXFxuMjMwLDIzMCwyNTBcXG4yNTUsMjQwLDI0NVxcbjEyNCwyNTIsMFxcbjI1NSwyNTAsMjA1XFxuMTczLDIxNiwyMzBcXG4yNDAsMTI4LDEyOFxcbjIyNCwyNTUsMjU1XFxuMjUwLDI1MCwyMTBcXG4yMTEsMjExLDIxMVxcbjE0NCwyMzgsMTQ0XFxuMjExLDIxMSwyMTFcXG4yNTUsMTgyLDE5M1xcbjI1NSwxNjAsMTIyXFxuMzIsMTc4LDE3MFxcbjEzNSwyMDYsMjUwXFxuMTE5LDEzNiwxNTNcXG4xMTksMTM2LDE1M1xcbjE3NiwxOTYsMjIyXFxuMjU1LDI1NSwyMjRcXG4wLDI1NSwwXFxuNTAsMjA1LDUwXFxuMjUwLDI0MCwyMzBcXG4yNTUsMCwyNTVcXG4xMjgsMCwwXFxuMTAyLDIwNSwxNzBcXG4wLDAsMjA1XFxuMTg2LDg1LDIxMVxcbjE0NywxMTIsMjE5XFxuNjAsMTc5LDExM1xcbjEyMywxMDQsMjM4XFxuMCwyNTAsMTU0XFxuNzIsMjA5LDIwNFxcbjE5OSwyMSwxMzNcXG4yNSwyNSwxMTJcXG4yNDUsMjU1LDI1MFxcbjI1NSwyMjgsMjI1XFxuMjU1LDIyOCwxODFcXG4yNTUsMjIyLDE3M1xcbjAsMCwxMjhcXG4yNTMsMjQ1LDIzMFxcbjEyOCwxMjgsMFxcbjEwNywxNDIsMzVcXG4yNTUsMTY1LDBcXG4yNTUsNjksMFxcbjIxOCwxMTIsMjE0XFxuMjM4LDIzMiwxNzBcXG4xNTIsMjUxLDE1MlxcbjE3NSwyMzgsMjM4XFxuMjE5LDExMiwxNDdcXG4yNTUsMjM5LDIxM1xcbjI1NSwyMTgsMTg1XFxuMjA1LDEzMyw2M1xcbjI1NSwxOTIsMjAzXFxuMjIxLDE2MCwyMjFcXG4xNzYsMjI0LDIzMFxcbjEyOCwwLDEyOFxcbjI1NSwwLDBcXG4xODgsMTQzLDE0M1xcbjY1LDEwNSwyMjVcXG4xMzksNjksMTlcXG4yNTAsMTI4LDExNFxcbjI0NCwxNjQsOTZcXG40NiwxMzksODdcXG4yNTUsMjQ1LDIzOFxcbjE2MCw4Miw0NVxcbjE5MiwxOTIsMTkyXFxuMTM1LDIwNiwyMzVcXG4xMDYsOTAsMjA1XFxuMTEyLDEyOCwxNDRcXG4xMTIsMTI4LDE0NFxcbjI1NSwyNTAsMjUwXFxuMCwyNTUsMTI3XFxuNzAsMTMwLDE4MFxcbjIxMCwxODAsMTQwXFxuMCwxMjgsMTI4XFxuMjE2LDE5MSwyMTZcXG4yNTUsOTksNzFcXG42NCwyMjQsMjA4XFxuMjM4LDEzMCwyMzhcXG4yNDUsMjIyLDE3OVxcbjI1NSwyNTUsMjU1XFxuMjQ1LDI0NSwyNDVcXG4yNTUsMjU1LDBcXG4xNTQsMjA1LDUwXCI7XG5cbiAgc2VlZHMgPSBzZWVkcy5zcGxpdChcIlxcblwiKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiBsaW5lLnNwbGl0KFwiLFwiKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBzZWVkcztcblxufSkuY2FsbCh0aGlzKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jb3JlLmpzJylcbnJlcXVpcmUoJy4vbGliL2RvbmUuanMnKVxucmVxdWlyZSgnLi9saWIvZXM2LWV4dGVuc2lvbnMuanMnKVxucmVxdWlyZSgnLi9saWIvbm9kZS1leHRlbnNpb25zLmpzJykiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL21hdGguanMnKTtcbiIsInZhciBjb252ZXJzaW9ucyA9IHJlcXVpcmUoXCIuL2NvbnZlcnNpb25zXCIpO1xuXG52YXIgY29udmVydCA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIG5ldyBDb252ZXJ0ZXIoKTtcbn1cblxuZm9yICh2YXIgZnVuYyBpbiBjb252ZXJzaW9ucykge1xuICAvLyBleHBvcnQgUmF3IHZlcnNpb25zXG4gIGNvbnZlcnRbZnVuYyArIFwiUmF3XCJdID0gIChmdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gYWNjZXB0IGFycmF5IG9yIHBsYWluIGFyZ3NcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNvbnZlcnNpb25zW2Z1bmNdKGFyZyk7XG4gICAgfVxuICB9KShmdW5jKTtcblxuICB2YXIgcGFpciA9IC8oXFx3KykyKFxcdyspLy5leGVjKGZ1bmMpLFxuICAgICAgZnJvbSA9IHBhaXJbMV0sXG4gICAgICB0byA9IHBhaXJbMl07XG5cbiAgLy8gZXhwb3J0IHJnYjJoc2wgYW5kIFtcInJnYlwiXVtcImhzbFwiXVxuICBjb252ZXJ0W2Zyb21dID0gY29udmVydFtmcm9tXSB8fCB7fTtcblxuICBjb252ZXJ0W2Zyb21dW3RvXSA9IGNvbnZlcnRbZnVuY10gPSAoZnVuY3Rpb24oZnVuYykgeyBcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgXG4gICAgICB2YXIgdmFsID0gY29udmVyc2lvbnNbZnVuY10oYXJnKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09IFwic3RyaW5nXCIgfHwgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB2YWw7IC8vIGtleXdvcmRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspXG4gICAgICAgIHZhbFtpXSA9IE1hdGgucm91bmQodmFsW2ldKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9KShmdW5jKTtcbn1cblxuXG4vKiBDb252ZXJ0ZXIgZG9lcyBsYXp5IGNvbnZlcnNpb24gYW5kIGNhY2hpbmcgKi9cbnZhciBDb252ZXJ0ZXIgPSBmdW5jdGlvbigpIHtcbiAgIHRoaXMuY29udnMgPSB7fTtcbn07XG5cbi8qIEVpdGhlciBnZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSBvclxuICBzZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSwgZGVwZW5kaW5nIG9uIGFyZ3MgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUucm91dGVTcGFjZSA9IGZ1bmN0aW9uKHNwYWNlLCBhcmdzKSB7XG4gICB2YXIgdmFsdWVzID0gYXJnc1swXTtcbiAgIGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY29sb3IucmdiKClcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcyhzcGFjZSk7XG4gICB9XG4gICAvLyBjb2xvci5yZ2IoMTAsIDEwLCAxMClcbiAgIGlmICh0eXBlb2YgdmFsdWVzID09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpOyAgICAgICAgXG4gICB9XG5cbiAgIHJldHVybiB0aGlzLnNldFZhbHVlcyhzcGFjZSwgdmFsdWVzKTtcbn07XG4gIFxuLyogU2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UsIGludmFsaWRhdGluZyBjYWNoZSAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSwgdmFsdWVzKSB7XG4gICB0aGlzLnNwYWNlID0gc3BhY2U7XG4gICB0aGlzLmNvbnZzID0ge307XG4gICB0aGlzLmNvbnZzW3NwYWNlXSA9IHZhbHVlcztcbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyogR2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UuIElmIHRoZXJlJ3MgYWxyZWFkeVxuICBhIGNvbnZlcnNpb24gZm9yIHRoZSBzcGFjZSwgZmV0Y2ggaXQsIG90aGVyd2lzZVxuICBjb21wdXRlIGl0ICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlKSB7XG4gICB2YXIgdmFscyA9IHRoaXMuY29udnNbc3BhY2VdO1xuICAgaWYgKCF2YWxzKSB7XG4gICAgICB2YXIgZnNwYWNlID0gdGhpcy5zcGFjZSxcbiAgICAgICAgICBmcm9tID0gdGhpcy5jb252c1tmc3BhY2VdO1xuICAgICAgdmFscyA9IGNvbnZlcnRbZnNwYWNlXVtzcGFjZV0oZnJvbSk7XG5cbiAgICAgIHRoaXMuY29udnNbc3BhY2VdID0gdmFscztcbiAgIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG5bXCJyZ2JcIiwgXCJoc2xcIiwgXCJoc3ZcIiwgXCJjbXlrXCIsIFwia2V5d29yZFwiXS5mb3JFYWNoKGZ1bmN0aW9uKHNwYWNlKSB7XG4gICBDb252ZXJ0ZXIucHJvdG90eXBlW3NwYWNlXSA9IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvdXRlU3BhY2Uoc3BhY2UsIGFyZ3VtZW50cyk7XG4gICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0OyIsIi8vIFRoZXJlIGlzIG5vIHZlcnNpb24gbnVtYmVyIHdyaXR0ZW4gaW4gdGhlIGZpbGUuXG4vLyBUaGUgZmlsZSBjb250YWlucyAyNTYgUkdCIGNvbG9ycy5cbi8vIFRoZSBmaXJzdCBjb2xvciBpbiB0aGUgdGFibGUgaXMgaW5kZXggemVyby5cbi8vIFRoZXJlIGFyZSB0aHJlZSBieXRlcyBwZXIgY29sb3IgaW4gdGhlIG9yZGVyIFJlZCwgR3JlZW4sIEJsdWUuXG5cbnZhciBnZW5lcmF0ZSA9IGZ1bmN0aW9uKGNvbG9ycywgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheSgyNTYgKiAzICsgMiAqIDIpO1xuICAgIHZhciBpLCBjb2xvcjtcbiAgICBmb3IoaSA9IDA7IGkgPCAyNTYgKiAzOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSAwO1xuICAgIH1cbiAgICBmb3IoaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29sb3IgPSBjb2xvcnNbaV07XG4gICAgICAgIGFycmF5WzMgKiBpXSA9IGNvbG9yWzBdOyAvLyBSXG4gICAgICAgIGFycmF5WzMgKiBpICsgMV0gPSBjb2xvclsxXTsgLy8gR1xuICAgICAgICBhcnJheVszICogaSArIDJdID0gY29sb3JbMl07IC8vIEJcbiAgICB9XG4gICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYXJyYXldLCB7dHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn0pO1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihldikge1xuICAgICAgICB2YXIgZXJyID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyLCBldi50YXJnZXQucmVzdWx0KTtcbiAgICB9O1xuICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZTtcbiIsIi8qIE1JVCBsaWNlbnNlICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZ2IyaHNsOiByZ2IyaHNsLFxuICByZ2IyaHN2OiByZ2IyaHN2LFxuICByZ2IyaHdiOiByZ2IyaHdiLFxuICByZ2IyY215azogcmdiMmNteWssXG4gIHJnYjJrZXl3b3JkOiByZ2Iya2V5d29yZCxcbiAgcmdiMnh5ejogcmdiMnh5eixcbiAgcmdiMmxhYjogcmdiMmxhYixcbiAgcmdiMmxjaDogcmdiMmxjaCxcblxuICBoc2wycmdiOiBoc2wycmdiLFxuICBoc2wyaHN2OiBoc2wyaHN2LFxuICBoc2wyaHdiOiBoc2wyaHdiLFxuICBoc2wyY215azogaHNsMmNteWssXG4gIGhzbDJrZXl3b3JkOiBoc2wya2V5d29yZCxcblxuICBoc3YycmdiOiBoc3YycmdiLFxuICBoc3YyaHNsOiBoc3YyaHNsLFxuICBoc3YyaHdiOiBoc3YyaHdiLFxuICBoc3YyY215azogaHN2MmNteWssXG4gIGhzdjJrZXl3b3JkOiBoc3Yya2V5d29yZCxcblxuICBod2IycmdiOiBod2IycmdiLFxuICBod2IyaHNsOiBod2IyaHNsLFxuICBod2IyaHN2OiBod2IyaHN2LFxuICBod2IyY215azogaHdiMmNteWssXG4gIGh3YjJrZXl3b3JkOiBod2Iya2V5d29yZCxcblxuICBjbXlrMnJnYjogY215azJyZ2IsXG4gIGNteWsyaHNsOiBjbXlrMmhzbCxcbiAgY215azJoc3Y6IGNteWsyaHN2LFxuICBjbXlrMmh3YjogY215azJod2IsXG4gIGNteWsya2V5d29yZDogY215azJrZXl3b3JkLFxuXG4gIGtleXdvcmQycmdiOiBrZXl3b3JkMnJnYixcbiAga2V5d29yZDJoc2w6IGtleXdvcmQyaHNsLFxuICBrZXl3b3JkMmhzdjoga2V5d29yZDJoc3YsXG4gIGtleXdvcmQyaHdiOiBrZXl3b3JkMmh3YixcbiAga2V5d29yZDJjbXlrOiBrZXl3b3JkMmNteWssXG4gIGtleXdvcmQybGFiOiBrZXl3b3JkMmxhYixcbiAga2V5d29yZDJ4eXo6IGtleXdvcmQyeHl6LFxuXG4gIHh5ejJyZ2I6IHh5ejJyZ2IsXG4gIHh5ejJsYWI6IHh5ejJsYWIsXG4gIHh5ejJsY2g6IHh5ejJsY2gsXG5cbiAgbGFiMnh5ejogbGFiMnh5eixcbiAgbGFiMnJnYjogbGFiMnJnYixcbiAgbGFiMmxjaDogbGFiMmxjaCxcblxuICBsY2gybGFiOiBsY2gybGFiLFxuICBsY2gyeHl6OiBsY2gyeHl6LFxuICBsY2gycmdiOiBsY2gycmdiXG59XG5cblxuZnVuY3Rpb24gcmdiMmhzbChyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0vMjU1LFxuICAgICAgZyA9IHJnYlsxXS8yNTUsXG4gICAgICBiID0gcmdiWzJdLzI1NSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgIGgsIHMsIGw7XG5cbiAgaWYgKG1heCA9PSBtaW4pXG4gICAgaCA9IDA7XG4gIGVsc2UgaWYgKHIgPT0gbWF4KVxuICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGcgPT0gbWF4KVxuICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICBlbHNlIGlmIChiID09IG1heClcbiAgICBoID0gNCArIChyIC0gZykvIGRlbHRhO1xuXG4gIGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cbiAgaWYgKGggPCAwKVxuICAgIGggKz0gMzYwO1xuXG4gIGwgPSAobWluICsgbWF4KSAvIDI7XG5cbiAgaWYgKG1heCA9PSBtaW4pXG4gICAgcyA9IDA7XG4gIGVsc2UgaWYgKGwgPD0gMC41KVxuICAgIHMgPSBkZWx0YSAvIChtYXggKyBtaW4pO1xuICBlbHNlXG4gICAgcyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXG4gIHJldHVybiBbaCwgcyAqIDEwMCwgbCAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJoc3YocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLFxuICAgICAgZyA9IHJnYlsxXSxcbiAgICAgIGIgPSByZ2JbMl0sXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCB2O1xuXG4gIGlmIChtYXggPT0gMClcbiAgICBzID0gMDtcbiAgZWxzZVxuICAgIHMgPSAoZGVsdGEvbWF4ICogMTAwMCkvMTA7XG5cbiAgaWYgKG1heCA9PSBtaW4pXG4gICAgaCA9IDA7XG4gIGVsc2UgaWYgKHIgPT0gbWF4KVxuICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGcgPT0gbWF4KVxuICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICBlbHNlIGlmIChiID09IG1heClcbiAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICB2ID0gKChtYXggLyAyNTUpICogMTAwMCkgLyAxMDtcblxuICByZXR1cm4gW2gsIHMsIHZdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHdiKHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgaCA9IHJnYjJoc2wocmdiKVswXVxuICAgICAgdyA9IDEvMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpXG4gICAgICBiID0gMSAtIDEvMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG4gIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJjbXlrKHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1LFxuICAgICAgYywgbSwgeSwgaztcblxuICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gIGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gayk7XG4gIG0gPSAoMSAtIGcgLSBrKSAvICgxIC0gayk7XG4gIHkgPSAoMSAtIGIgLSBrKSAvICgxIC0gayk7XG4gIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KHJnYildO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1O1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cbiAgdmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG4gIHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuICB2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuICByZXR1cm4gW3ggKiAxMDAsIHkgKjEwMCwgeiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJsYWIocmdiKSB7XG4gIHZhciB4eXogPSByZ2IyeHl6KHJnYiksXG4gICAgICAgIHggPSB4eXpbMF0sXG4gICAgICAgIHkgPSB4eXpbMV0sXG4gICAgICAgIHogPSB4eXpbMl0sXG4gICAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiByZ2IybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2gocmdiMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJyZ2IoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdIC8gMzYwLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICB0MSwgdDIsIHQzLCByZ2IsIHZhbDtcblxuICBpZiAocyA9PSAwKSB7XG4gICAgdmFsID0gbCAqIDI1NTtcbiAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgaWYgKGwgPCAwLjUpXG4gICAgdDIgPSBsICogKDEgKyBzKTtcbiAgZWxzZVxuICAgIHQyID0gbCArIHMgLSBsICogcztcbiAgdDEgPSAyICogbCAtIHQyO1xuXG4gIHJnYiA9IFswLCAwLCAwXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB0MyA9IGggKyAxIC8gMyAqIC0gKGkgLSAxKTtcbiAgICB0MyA8IDAgJiYgdDMrKztcbiAgICB0MyA+IDEgJiYgdDMtLTtcblxuICAgIGlmICg2ICogdDMgPCAxKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgZWxzZSBpZiAoMiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQyO1xuICAgIGVsc2UgaWYgKDMgKiB0MyA8IDIpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG4gICAgZWxzZVxuICAgICAgdmFsID0gdDE7XG5cbiAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gIH1cblxuICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoc2wyaHN2KGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgc3YsIHY7XG4gIGwgKj0gMjtcbiAgcyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgdiA9IChsICsgcykgLyAyO1xuICBzdiA9ICgyICogcykgLyAobCArIHMpO1xuICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHNsMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHNsMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0gLyA2MCxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuICB2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpLFxuICAgICAgcCA9IDI1NSAqIHYgKiAoMSAtIHMpLFxuICAgICAgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpLFxuICAgICAgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpLFxuICAgICAgdiA9IDI1NSAqIHY7XG5cbiAgc3dpdGNoKGhpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFt2LCB0LCBwXTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW3EsIHYsIHBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbcCwgdiwgdF07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFtwLCBxLCB2XTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gW3QsIHAsIHZdO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHN2MmhzbChoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIHNsLCBsO1xuXG4gIGwgPSAoMiAtIHMpICogdjtcbiAgc2wgPSBzICogdjtcbiAgc2wgLz0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIGwgLz0gMjtcbiAgcmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIGhzdjJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3Yihoc3YycmdiKGFyZ3MpKVxufVxuXG5mdW5jdGlvbiBoc3YyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc3YycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHN2MmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHN2MnJnYihhcmdzKSk7XG59XG5cbi8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jaHdiLXRvLXJnYlxuZnVuY3Rpb24gaHdiMnJnYihod2IpIHtcbiAgdmFyIGggPSBod2JbMF0gLyAzNjAsXG4gICAgICB3aCA9IGh3YlsxXSAvIDEwMCxcbiAgICAgIGJsID0gaHdiWzJdIC8gMTAwLFxuICAgICAgcmF0aW8gPSB3aCArIGJsLFxuICAgICAgaSwgdiwgZiwgbjtcblxuICAvLyB3aCArIGJsIGNhbnQgYmUgPiAxXG4gIGlmIChyYXRpbyA+IDEpIHtcbiAgICB3aCAvPSByYXRpbztcbiAgICBibCAvPSByYXRpbztcbiAgfVxuXG4gIGkgPSBNYXRoLmZsb29yKDYgKiBoKTtcbiAgdiA9IDEgLSBibDtcbiAgZiA9IDYgKiBoIC0gaTtcbiAgaWYgKChpICYgMHgwMSkgIT0gMCkge1xuICAgIGYgPSAxIC0gZjtcbiAgfVxuICBuID0gd2ggKyBmICogKHYgLSB3aCk7ICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuXG4gIHN3aXRjaCAoaSkge1xuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSA2OlxuICAgIGNhc2UgMDogciA9IHY7IGcgPSBuOyBiID0gd2g7IGJyZWFrO1xuICAgIGNhc2UgMTogciA9IG47IGcgPSB2OyBiID0gd2g7IGJyZWFrO1xuICAgIGNhc2UgMjogciA9IHdoOyBnID0gdjsgYiA9IG47IGJyZWFrO1xuICAgIGNhc2UgMzogciA9IHdoOyBnID0gbjsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNDogciA9IG47IGcgPSB3aDsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNTogciA9IHY7IGcgPSB3aDsgYiA9IG47IGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gaHdiMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2IyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2Iya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJyZ2IoY215aykge1xuICB2YXIgYyA9IGNteWtbMF0gLyAxMDAsXG4gICAgICBtID0gY215a1sxXSAvIDEwMCxcbiAgICAgIHkgPSBjbXlrWzJdIC8gMTAwLFxuICAgICAgayA9IGNteWtbM10gLyAxMDAsXG4gICAgICByLCBnLCBiO1xuXG4gIHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcbiAgZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuICBiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIGNteWsyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmhzdihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHN2KGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3YihjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChjbXlrMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24geHl6MnJnYih4eXopIHtcbiAgdmFyIHggPSB4eXpbMF0gLyAxMDAsXG4gICAgICB5ID0geHl6WzFdIC8gMTAwLFxuICAgICAgeiA9IHh5elsyXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9ICh4ICogMy4yNDA2KSArICh5ICogLTEuNTM3MikgKyAoeiAqIC0wLjQ5ODYpO1xuICBnID0gKHggKiAtMC45Njg5KSArICh5ICogMS44NzU4KSArICh6ICogMC4wNDE1KTtcbiAgYiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cbiAgLy8gYXNzdW1lIHNSR0JcbiAgciA9IHIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3cociwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IHIgPSAociAqIDEyLjkyKTtcblxuICBnID0gZyA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhnLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogZyA9IChnICogMTIuOTIpO1xuXG4gIGIgPSBiID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBiID0gKGIgKiAxMi45Mik7XG5cbiAgciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCAxKTtcbiAgZyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGcpLCAxKTtcbiAgYiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGIpLCAxKTtcblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiB4eXoybGFiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSxcbiAgICAgIHkgPSB4eXpbMV0sXG4gICAgICB6ID0geHl6WzJdLFxuICAgICAgbCwgYSwgYjtcblxuICB4IC89IDk1LjA0NztcbiAgeSAvPSAxMDA7XG4gIHogLz0gMTA4Ljg4MztcblxuICB4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMS8zKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcbiAgeSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEvMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG4gIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxLzMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG4gIGwgPSAoMTE2ICogeSkgLSAxNjtcbiAgYSA9IDUwMCAqICh4IC0geSk7XG4gIGIgPSAyMDAgKiAoeSAtIHopO1xuXG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIHh5ejJsY2goYXJncykge1xuICByZXR1cm4gbGFiMmxjaCh4eXoybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eihsYWIpIHtcbiAgdmFyIGwgPSBsYWJbMF0sXG4gICAgICBhID0gbGFiWzFdLFxuICAgICAgYiA9IGxhYlsyXSxcbiAgICAgIHgsIHksIHosIHkyO1xuXG4gIGlmIChsIDw9IDgpIHtcbiAgICB5ID0gKGwgKiAxMDApIC8gOTAzLjM7XG4gICAgeTIgPSAoNy43ODcgKiAoeSAvIDEwMCkpICsgKDE2IC8gMTE2KTtcbiAgfSBlbHNlIHtcbiAgICB5ID0gMTAwICogTWF0aC5wb3coKGwgKyAxNikgLyAxMTYsIDMpO1xuICAgIHkyID0gTWF0aC5wb3coeSAvIDEwMCwgMS8zKTtcbiAgfVxuXG4gIHggPSB4IC8gOTUuMDQ3IDw9IDAuMDA4ODU2ID8geCA9ICg5NS4wNDcgKiAoKGEgLyA1MDApICsgeTIgLSAoMTYgLyAxMTYpKSkgLyA3Ljc4NyA6IDk1LjA0NyAqIE1hdGgucG93KChhIC8gNTAwKSArIHkyLCAzKTtcblxuICB6ID0geiAvIDEwOC44ODMgPD0gMC4wMDg4NTkgPyB6ID0gKDEwOC44ODMgKiAoeTIgLSAoYiAvIDIwMCkgLSAoMTYgLyAxMTYpKSkgLyA3Ljc4NyA6IDEwOC44ODMgKiBNYXRoLnBvdyh5MiAtIChiIC8gMjAwKSwgMyk7XG5cbiAgcmV0dXJuIFt4LCB5LCB6XTtcbn1cblxuZnVuY3Rpb24gbGFiMmxjaChsYWIpIHtcbiAgdmFyIGwgPSBsYWJbMF0sXG4gICAgICBhID0gbGFiWzFdLFxuICAgICAgYiA9IGxhYlsyXSxcbiAgICAgIGhyLCBoLCBjO1xuXG4gIGhyID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgaCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMzYwO1xuICB9XG4gIGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gIHJldHVybiBbbCwgYywgaF07XG59XG5cbmZ1bmN0aW9uIGxhYjJyZ2IoYXJncykge1xuICByZXR1cm4geHl6MnJnYihsYWIyeHl6KGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGNoMmxhYihsY2gpIHtcbiAgdmFyIGwgPSBsY2hbMF0sXG4gICAgICBjID0gbGNoWzFdLFxuICAgICAgaCA9IGxjaFsyXSxcbiAgICAgIGEsIGIsIGhyO1xuXG4gIGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuICBhID0gYyAqIE1hdGguY29zKGhyKTtcbiAgYiA9IGMgKiBNYXRoLnNpbihocik7XG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIGxjaDJ4eXooYXJncykge1xuICByZXR1cm4gbGFiMnh5eihsY2gybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGNoMnJnYihhcmdzKSB7XG4gIHJldHVybiBsYWIycmdiKGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMnJnYihrZXl3b3JkKSB7XG4gIHJldHVybiBjc3NLZXl3b3Jkc1trZXl3b3JkXTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3Yoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJsYWIoYXJncykge1xuICByZXR1cm4gcmdiMmxhYihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyeHl6KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJ4eXooa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG52YXIgY3NzS2V5d29yZHMgPSB7XG4gIGFsaWNlYmx1ZTogIFsyNDAsMjQ4LDI1NV0sXG4gIGFudGlxdWV3aGl0ZTogWzI1MCwyMzUsMjE1XSxcbiAgYXF1YTogWzAsMjU1LDI1NV0sXG4gIGFxdWFtYXJpbmU6IFsxMjcsMjU1LDIxMl0sXG4gIGF6dXJlOiAgWzI0MCwyNTUsMjU1XSxcbiAgYmVpZ2U6ICBbMjQ1LDI0NSwyMjBdLFxuICBiaXNxdWU6IFsyNTUsMjI4LDE5Nl0sXG4gIGJsYWNrOiAgWzAsMCwwXSxcbiAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsMjM1LDIwNV0sXG4gIGJsdWU6IFswLDAsMjU1XSxcbiAgYmx1ZXZpb2xldDogWzEzOCw0MywyMjZdLFxuICBicm93bjogIFsxNjUsNDIsNDJdLFxuICBidXJseXdvb2Q6ICBbMjIyLDE4NCwxMzVdLFxuICBjYWRldGJsdWU6ICBbOTUsMTU4LDE2MF0sXG4gIGNoYXJ0cmV1c2U6IFsxMjcsMjU1LDBdLFxuICBjaG9jb2xhdGU6ICBbMjEwLDEwNSwzMF0sXG4gIGNvcmFsOiAgWzI1NSwxMjcsODBdLFxuICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwxNDksMjM3XSxcbiAgY29ybnNpbGs6IFsyNTUsMjQ4LDIyMF0sXG4gIGNyaW1zb246ICBbMjIwLDIwLDYwXSxcbiAgY3lhbjogWzAsMjU1LDI1NV0sXG4gIGRhcmtibHVlOiBbMCwwLDEzOV0sXG4gIGRhcmtjeWFuOiBbMCwxMzksMTM5XSxcbiAgZGFya2dvbGRlbnJvZDogIFsxODQsMTM0LDExXSxcbiAgZGFya2dyYXk6IFsxNjksMTY5LDE2OV0sXG4gIGRhcmtncmVlbjogIFswLDEwMCwwXSxcbiAgZGFya2dyZXk6IFsxNjksMTY5LDE2OV0sXG4gIGRhcmtraGFraTogIFsxODksMTgzLDEwN10sXG4gIGRhcmttYWdlbnRhOiAgWzEzOSwwLDEzOV0sXG4gIGRhcmtvbGl2ZWdyZWVuOiBbODUsMTA3LDQ3XSxcbiAgZGFya29yYW5nZTogWzI1NSwxNDAsMF0sXG4gIGRhcmtvcmNoaWQ6IFsxNTMsNTAsMjA0XSxcbiAgZGFya3JlZDogIFsxMzksMCwwXSxcbiAgZGFya3NhbG1vbjogWzIzMywxNTAsMTIyXSxcbiAgZGFya3NlYWdyZWVuOiBbMTQzLDE4OCwxNDNdLFxuICBkYXJrc2xhdGVibHVlOiAgWzcyLDYxLDEzOV0sXG4gIGRhcmtzbGF0ZWdyYXk6ICBbNDcsNzksNzldLFxuICBkYXJrc2xhdGVncmV5OiAgWzQ3LDc5LDc5XSxcbiAgZGFya3R1cnF1b2lzZTogIFswLDIwNiwyMDldLFxuICBkYXJrdmlvbGV0OiBbMTQ4LDAsMjExXSxcbiAgZGVlcHBpbms6IFsyNTUsMjAsMTQ3XSxcbiAgZGVlcHNreWJsdWU6ICBbMCwxOTEsMjU1XSxcbiAgZGltZ3JheTogIFsxMDUsMTA1LDEwNV0sXG4gIGRpbWdyZXk6ICBbMTA1LDEwNSwxMDVdLFxuICBkb2RnZXJibHVlOiBbMzAsMTQ0LDI1NV0sXG4gIGZpcmVicmljazogIFsxNzgsMzQsMzRdLFxuICBmbG9yYWx3aGl0ZTogIFsyNTUsMjUwLDI0MF0sXG4gIGZvcmVzdGdyZWVuOiAgWzM0LDEzOSwzNF0sXG4gIGZ1Y2hzaWE6ICBbMjU1LDAsMjU1XSxcbiAgZ2FpbnNib3JvOiAgWzIyMCwyMjAsMjIwXSxcbiAgZ2hvc3R3aGl0ZTogWzI0OCwyNDgsMjU1XSxcbiAgZ29sZDogWzI1NSwyMTUsMF0sXG4gIGdvbGRlbnJvZDogIFsyMTgsMTY1LDMyXSxcbiAgZ3JheTogWzEyOCwxMjgsMTI4XSxcbiAgZ3JlZW46ICBbMCwxMjgsMF0sXG4gIGdyZWVueWVsbG93OiAgWzE3MywyNTUsNDddLFxuICBncmV5OiBbMTI4LDEyOCwxMjhdLFxuICBob25leWRldzogWzI0MCwyNTUsMjQwXSxcbiAgaG90cGluazogIFsyNTUsMTA1LDE4MF0sXG4gIGluZGlhbnJlZDogIFsyMDUsOTIsOTJdLFxuICBpbmRpZ286IFs3NSwwLDEzMF0sXG4gIGl2b3J5OiAgWzI1NSwyNTUsMjQwXSxcbiAga2hha2k6ICBbMjQwLDIzMCwxNDBdLFxuICBsYXZlbmRlcjogWzIzMCwyMzAsMjUwXSxcbiAgbGF2ZW5kZXJibHVzaDogIFsyNTUsMjQwLDI0NV0sXG4gIGxhd25ncmVlbjogIFsxMjQsMjUyLDBdLFxuICBsZW1vbmNoaWZmb246IFsyNTUsMjUwLDIwNV0sXG4gIGxpZ2h0Ymx1ZTogIFsxNzMsMjE2LDIzMF0sXG4gIGxpZ2h0Y29yYWw6IFsyNDAsMTI4LDEyOF0sXG4gIGxpZ2h0Y3lhbjogIFsyMjQsMjU1LDI1NV0sXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLDI1MCwyMTBdLFxuICBsaWdodGdyYXk6ICBbMjExLDIxMSwyMTFdLFxuICBsaWdodGdyZWVuOiBbMTQ0LDIzOCwxNDRdLFxuICBsaWdodGdyZXk6ICBbMjExLDIxMSwyMTFdLFxuICBsaWdodHBpbms6ICBbMjU1LDE4MiwxOTNdLFxuICBsaWdodHNhbG1vbjogIFsyNTUsMTYwLDEyMl0sXG4gIGxpZ2h0c2VhZ3JlZW46ICBbMzIsMTc4LDE3MF0sXG4gIGxpZ2h0c2t5Ymx1ZTogWzEzNSwyMDYsMjUwXSxcbiAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c2xhdGVncmV5OiBbMTE5LDEzNiwxNTNdLFxuICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwxOTYsMjIyXSxcbiAgbGlnaHR5ZWxsb3c6ICBbMjU1LDI1NSwyMjRdLFxuICBsaW1lOiBbMCwyNTUsMF0sXG4gIGxpbWVncmVlbjogIFs1MCwyMDUsNTBdLFxuICBsaW5lbjogIFsyNTAsMjQwLDIzMF0sXG4gIG1hZ2VudGE6ICBbMjU1LDAsMjU1XSxcbiAgbWFyb29uOiBbMTI4LDAsMF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsMjA1LDE3MF0sXG4gIG1lZGl1bWJsdWU6IFswLDAsMjA1XSxcbiAgbWVkaXVtb3JjaGlkOiBbMTg2LDg1LDIxMV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NywxMTIsMjE5XSxcbiAgbWVkaXVtc2VhZ3JlZW46IFs2MCwxNzksMTEzXSxcbiAgbWVkaXVtc2xhdGVibHVlOiAgWzEyMywxMDQsMjM4XSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46ICBbMCwyNTAsMTU0XSxcbiAgbWVkaXVtdHVycXVvaXNlOiAgWzcyLDIwOSwyMDRdLFxuICBtZWRpdW12aW9sZXRyZWQ6ICBbMTk5LDIxLDEzM10sXG4gIG1pZG5pZ2h0Ymx1ZTogWzI1LDI1LDExMl0sXG4gIG1pbnRjcmVhbTogIFsyNDUsMjU1LDI1MF0sXG4gIG1pc3R5cm9zZTogIFsyNTUsMjI4LDIyNV0sXG4gIG1vY2Nhc2luOiBbMjU1LDIyOCwxODFdLFxuICBuYXZham93aGl0ZTogIFsyNTUsMjIyLDE3M10sXG4gIG5hdnk6IFswLDAsMTI4XSxcbiAgb2xkbGFjZTogIFsyNTMsMjQ1LDIzMF0sXG4gIG9saXZlOiAgWzEyOCwxMjgsMF0sXG4gIG9saXZlZHJhYjogIFsxMDcsMTQyLDM1XSxcbiAgb3JhbmdlOiBbMjU1LDE2NSwwXSxcbiAgb3JhbmdlcmVkOiAgWzI1NSw2OSwwXSxcbiAgb3JjaGlkOiBbMjE4LDExMiwyMTRdLFxuICBwYWxlZ29sZGVucm9kOiAgWzIzOCwyMzIsMTcwXSxcbiAgcGFsZWdyZWVuOiAgWzE1MiwyNTEsMTUyXSxcbiAgcGFsZXR1cnF1b2lzZTogIFsxNzUsMjM4LDIzOF0sXG4gIHBhbGV2aW9sZXRyZWQ6ICBbMjE5LDExMiwxNDddLFxuICBwYXBheWF3aGlwOiBbMjU1LDIzOSwyMTNdLFxuICBwZWFjaHB1ZmY6ICBbMjU1LDIxOCwxODVdLFxuICBwZXJ1OiBbMjA1LDEzMyw2M10sXG4gIHBpbms6IFsyNTUsMTkyLDIwM10sXG4gIHBsdW06IFsyMjEsMTYwLDIyMV0sXG4gIHBvd2RlcmJsdWU6IFsxNzYsMjI0LDIzMF0sXG4gIHB1cnBsZTogWzEyOCwwLDEyOF0sXG4gIHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTNdLFxuICByZWQ6ICBbMjU1LDAsMF0sXG4gIHJvc3licm93bjogIFsxODgsMTQzLDE0M10sXG4gIHJveWFsYmx1ZTogIFs2NSwxMDUsMjI1XSxcbiAgc2FkZGxlYnJvd246ICBbMTM5LDY5LDE5XSxcbiAgc2FsbW9uOiBbMjUwLDEyOCwxMTRdLFxuICBzYW5keWJyb3duOiBbMjQ0LDE2NCw5Nl0sXG4gIHNlYWdyZWVuOiBbNDYsMTM5LDg3XSxcbiAgc2Vhc2hlbGw6IFsyNTUsMjQ1LDIzOF0sXG4gIHNpZW5uYTogWzE2MCw4Miw0NV0sXG4gIHNpbHZlcjogWzE5MiwxOTIsMTkyXSxcbiAgc2t5Ymx1ZTogIFsxMzUsMjA2LDIzNV0sXG4gIHNsYXRlYmx1ZTogIFsxMDYsOTAsMjA1XSxcbiAgc2xhdGVncmF5OiAgWzExMiwxMjgsMTQ0XSxcbiAgc2xhdGVncmV5OiAgWzExMiwxMjgsMTQ0XSxcbiAgc25vdzogWzI1NSwyNTAsMjUwXSxcbiAgc3ByaW5nZ3JlZW46ICBbMCwyNTUsMTI3XSxcbiAgc3RlZWxibHVlOiAgWzcwLDEzMCwxODBdLFxuICB0YW46ICBbMjEwLDE4MCwxNDBdLFxuICB0ZWFsOiBbMCwxMjgsMTI4XSxcbiAgdGhpc3RsZTogIFsyMTYsMTkxLDIxNl0sXG4gIHRvbWF0bzogWzI1NSw5OSw3MV0sXG4gIHR1cnF1b2lzZTogIFs2NCwyMjQsMjA4XSxcbiAgdmlvbGV0OiBbMjM4LDEzMCwyMzhdLFxuICB3aGVhdDogIFsyNDUsMjIyLDE3OV0sXG4gIHdoaXRlOiAgWzI1NSwyNTUsMjU1XSxcbiAgd2hpdGVzbW9rZTogWzI0NSwyNDUsMjQ1XSxcbiAgeWVsbG93OiBbMjU1LDI1NSwwXSxcbiAgeWVsbG93Z3JlZW46ICBbMTU0LDIwNSw1MF1cbn07XG5cbnZhciByZXZlcnNlS2V5d29yZHMgPSB7fTtcbmZvciAodmFyIGtleSBpbiBjc3NLZXl3b3Jkcykge1xuICByZXZlcnNlS2V5d29yZHNbSlNPTi5zdHJpbmdpZnkoY3NzS2V5d29yZHNba2V5XSldID0ga2V5O1xufVxuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsY0NlbnRlciwgY2FsY0NsdXN0ZXJzLCBjYWxjRGlzdGFuY2UsIGNvbG9yLCBzZWVkcztcblxuICBjb2xvciA9IHJlcXVpcmUoXCJjb2xvci1jb252ZXJ0XCIpO1xuXG4gIGNhbGNEaXN0YW5jZSA9IHJlcXVpcmUoXCIuL0NJRTc2LmpzXCIpO1xuXG4gIHNlZWRzID0gcmVxdWlyZShcIi4vc2VlZHMuanNcIik7XG5cbiAgY2FsY0NlbnRlciA9IGZ1bmN0aW9uKGxhYnMpIHtcbiAgICB2YXIgQSwgQiwgTCwgZCwgbGFiLCBsZW4sIG1pbkRpc3RhbmNlLCBuZXdDZW50ZXIsIF9pLCBfbGVuLCBfcmVmO1xuICAgIF9yZWYgPSBbMCwgMCwgMF0sIEwgPSBfcmVmWzBdLCBBID0gX3JlZlsxXSwgQiA9IF9yZWZbMl07XG4gICAgbGFicy5mb3JFYWNoKGZ1bmN0aW9uKGxhYikge1xuICAgICAgTCArPSBsYWJbMF07XG4gICAgICBBICs9IGxhYlsxXTtcbiAgICAgIHJldHVybiBCICs9IGxhYlsyXTtcbiAgICB9KTtcbiAgICBsZW4gPSBsYWJzLmxlbmd0aDtcbiAgICBMIC89IGxlbjtcbiAgICBBIC89IGxlbjtcbiAgICBCIC89IGxlbjtcbiAgICBtaW5EaXN0YW5jZSA9IG51bGw7XG4gICAgbmV3Q2VudGVyID0gbnVsbDtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGxhYnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGxhYiA9IGxhYnNbX2ldO1xuICAgICAgZCA9IGNhbGNEaXN0YW5jZShbTCwgQSwgQl0sIGxhYik7XG4gICAgICBpZiAoKG5ld0NlbnRlciA9PSBudWxsKSB8fCAoZCA+IG1pbkRpc3RhbmNlKSkge1xuICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XG4gICAgICAgIG5ld0NlbnRlciA9IGxhYjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0NlbnRlcjtcbiAgfTtcblxuICBjYWxjQ2x1c3RlcnMgPSBmdW5jdGlvbihwaXhlbHMsIGNvbmZpZykge1xuICAgIHZhciBjZW50ZXJzLCBjbHVzdGVycywgZW5kLCBpdGVyLCBsb2csIHJlbW92ZUVtcHR5Q2x1c3RlcnMsIHN0YXJ0LCB1c2VSYW5kb21QaXhlbHM7XG4gICAgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIGxvZyA9IGZ1bmN0aW9uKHRpdGxlLCBjb2xvcnMpIHtcbiAgICAgIGlmIChjb2xvcnMgPT0gbnVsbCkge1xuICAgICAgICBjb2xvcnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjb25maWcubG9nID09PSBcImZ1bmN0aW9uXCIgPyBjb25maWcubG9nKHRpdGxlLCBjb2xvcnMubWFwKGZ1bmN0aW9uKGxhYikge1xuICAgICAgICAgIHJldHVybiBjb2xvci5sYWIycmdiKGxhYik7XG4gICAgICAgIH0pKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBpeGVscyA9IHBpeGVscy5tYXAoZnVuY3Rpb24ocmdiYSkge1xuICAgICAgdmFyIGEsIGIsIGcsIHIsIHJnYjtcbiAgICAgIHIgPSByZ2JhWzBdLCBnID0gcmdiYVsxXSwgYiA9IHJnYmFbMl0sIGEgPSByZ2JhWzNdO1xuICAgICAgcmdiID0gW3IsIGcsIGJdO1xuICAgICAgaWYgKGEgIT09IDI1NSkge1xuICAgICAgICBhIC89IDI1NTtcbiAgICAgICAgcmdiID0gcmdiLm1hcChmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgcmV0dXJuIDI1NSAqICgxIC0gYSkgKyBlbGVtICogYTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sb3IucmdiMmxhYihyZ2IpO1xuICAgIH0pO1xuICAgIGNlbnRlcnMgPSBzZWVkcy5tYXAoZnVuY3Rpb24ocmdiKSB7XG4gICAgICByZXR1cm4gY29sb3IucmdiMmxhYihyZ2IpO1xuICAgIH0pO1xuICAgIGxvZyhcIlNlZWRzXCIsIGNlbnRlcnMpO1xuICAgIGNsdXN0ZXJzID0gbnVsbDtcbiAgICBpdGVyID0gZnVuY3Rpb24ocmVtb3ZlRW1wdHlDbHVzdGVycywgdXNlUmFuZG9tUGl4ZWxzKSB7XG4gICAgICB2YXIgaSwgbWluRGlzdGFuY2UsIG1pbkluZGV4LCBwaXhlbCwgX2ksIF9qLCBfbGVuLCBfcmVmO1xuICAgICAgaWYgKHJlbW92ZUVtcHR5Q2x1c3RlcnMgPT0gbnVsbCkge1xuICAgICAgICByZW1vdmVFbXB0eUNsdXN0ZXJzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh1c2VSYW5kb21QaXhlbHMgPT0gbnVsbCkge1xuICAgICAgICB1c2VSYW5kb21QaXhlbHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2x1c3RlcnMgPSBbXTtcbiAgICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZiA9IGNlbnRlcnMubGVuZ3RoOyAwIDw9IF9yZWYgPyBfaSA8IF9yZWYgOiBfaSA+IF9yZWY7IGkgPSAwIDw9IF9yZWYgPyArK19pIDogLS1faSkge1xuICAgICAgICBjbHVzdGVyc1tpXSA9IFtdO1xuICAgICAgfVxuICAgICAgZm9yIChfaiA9IDAsIF9sZW4gPSBwaXhlbHMubGVuZ3RoOyBfaiA8IF9sZW47IF9qKyspIHtcbiAgICAgICAgcGl4ZWwgPSBwaXhlbHNbX2pdO1xuICAgICAgICBtaW5JbmRleCA9IG51bGw7XG4gICAgICAgIG1pbkRpc3RhbmNlID0gbnVsbDtcbiAgICAgICAgY2VudGVycy5mb3JFYWNoKGZ1bmN0aW9uKGNlbnRlciwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgZDtcbiAgICAgICAgICBkID0gY2FsY0Rpc3RhbmNlKGNlbnRlciwgcGl4ZWwpO1xuICAgICAgICAgIGlmICgobWluRGlzdGFuY2UgPT0gbnVsbCkgfHwgKGQgPCBtaW5EaXN0YW5jZSkpIHtcbiAgICAgICAgICAgIG1pbkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gbWluRGlzdGFuY2UgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNsdXN0ZXJzW21pbkluZGV4XS5wdXNoKHBpeGVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmVFbXB0eUNsdXN0ZXJzKSB7XG4gICAgICAgIGNsdXN0ZXJzID0gY2x1c3RlcnMuZmlsdGVyKGZ1bmN0aW9uKGNsdXN0ZXJQaXhlbHMpIHtcbiAgICAgICAgICByZXR1cm4gY2x1c3RlclBpeGVscy5sZW5ndGggPiAwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNlbnRlcnMgPSBjbHVzdGVycy5tYXAoZnVuY3Rpb24oY2x1c3RlclBpeGVscykge1xuICAgICAgICByZXR1cm4gY2FsY0NlbnRlcihjbHVzdGVyUGl4ZWxzKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHVzZVJhbmRvbVBpeGVscykge1xuICAgICAgICB3aGlsZSAoY2VudGVycy5sZW5ndGggPCBjb25maWcubWluQ291bnQpIHtcbiAgICAgICAgICBjZW50ZXJzLnB1c2gocGl4ZWxzW3BhcnNlSW50KE1hdGgucmFuZG9tKCkgKiBwaXhlbHMubGVuZ3RoKV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9nKFwiTmV3IENsdXN0ZXJzXCIsIGNlbnRlcnMpO1xuICAgIH07XG4gICAgaXRlcigpO1xuICAgIGl0ZXIoKTtcbiAgICBpdGVyKCk7XG4gICAgaXRlcihyZW1vdmVFbXB0eUNsdXN0ZXJzID0gZmFsc2UsIHVzZVJhbmRvbVBpeGVscyA9IGZhbHNlKTtcbiAgICBjZW50ZXJzID0gY2VudGVycy5tYXAoZnVuY3Rpb24obGFiKSB7XG4gICAgICByZXR1cm4gY29sb3IubGFiMnJnYihsYWIpO1xuICAgIH0pO1xuICAgIGVuZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgbG9nKFwiQ2FsYyBcIiArIGNlbnRlcnMubGVuZ3RoICsgXCIgY2x1c3RlcnMgaW4gXCIgKyAoZW5kIC0gc3RhcnQpICsgXCJtc1wiKTtcbiAgICByZXR1cm4gY2VudGVycy5tYXAoZnVuY3Rpb24oY2VudGVyLCBpKSB7XG4gICAgICB2YXIgd2VpZ2h0O1xuICAgICAgd2VpZ2h0ID0gY2x1c3RlcnNbaV0ubGVuZ3RoIC8gcGl4ZWxzLmxlbmd0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbG9yOiBjZW50ZXIsXG4gICAgICAgIHdlaWdodDogd2VpZ2h0XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gY2FsY0NsdXN0ZXJzO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENsb25lIGFuIG9iamVjdFxuICpcbiAqICAgICBjbG9uZSh4KVxuICpcbiAqIENhbiBjbG9uZSBhbnkgcHJpbWl0aXZlIHR5cGUsIGFycmF5LCBhbmQgb2JqZWN0LlxuICogSWYgeCBoYXMgYSBmdW5jdGlvbiBjbG9uZSwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgdG8gY2xvbmUgdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm4geyp9IGNsb25lXG4gKi9cbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSh4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG5cbiAgLy8gaW1tdXRhYmxlIHByaW1pdGl2ZSB0eXBlc1xuICBpZiAodHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgLy8gdXNlIGNsb25lIGZ1bmN0aW9uIG9mIHRoZSBvYmplY3Qgd2hlbiBhdmFpbGFibGVcbiAgaWYgKHR5cGVvZiB4LmNsb25lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHguY2xvbmUoKTtcbiAgfVxuXG4gIC8vIGFycmF5XG4gIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIHgubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNsb25lKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh4IGluc3RhbmNlb2YgTnVtYmVyKSAgcmV0dXJuIG5ldyBOdW1iZXIoeC52YWx1ZU9mKCkpO1xuICBpZiAoeCBpbnN0YW5jZW9mIFN0cmluZykgIHJldHVybiBuZXcgU3RyaW5nKHgudmFsdWVPZigpKTtcbiAgaWYgKHggaW5zdGFuY2VvZiBCb29sZWFuKSByZXR1cm4gbmV3IEJvb2xlYW4oeC52YWx1ZU9mKCkpO1xuICBpZiAoeCBpbnN0YW5jZW9mIERhdGUpICAgIHJldHVybiBuZXcgRGF0ZSh4LnZhbHVlT2YoKSk7XG4gIGlmICh4IGluc3RhbmNlb2YgUmVnRXhwKSAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb25lICcgKyB4KTsgIC8vIFRPRE86IGNsb25lIGEgUmVnRXhwXG5cbiAgLy8gb2JqZWN0XG4gIHZhciBtID0ge307XG4gIGZvciAodmFyIGtleSBpbiB4KSB7XG4gICAgaWYgKHguaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgbVtrZXldID0gY2xvbmUoeFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG07XG59O1xuXG4vKipcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRGVlcCBleHRlbmQgYW4gb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnRzLmRlZXBFeHRlbmQgPSBmdW5jdGlvbiBkZWVwRXh0ZW5kIChhLCBiKSB7XG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBBcnJheXMgdG8gZGVlcEV4dGVuZFxuICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kJyk7XG4gIH1cblxuICBmb3IgKHZhciBwcm9wIGluIGIpIHtcbiAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgIGRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBEZWVwIHRlc3QgZXF1YWxpdHkgb2YgYWxsIGZpZWxkcyBpbiB0d28gcGFpcnMgb2YgYXJyYXlzIG9yIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5IHwgT2JqZWN0fSBhXG4gKiBAcGFyYW0ge0FycmF5IHwgT2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwgKGEsIGIpIHtcbiAgdmFyIHByb3AsIGksIGxlbjtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWV4cG9ydHMuZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGIpIHx8ICEoYiBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHByb3AgaW4gYSkge1xuICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbmZpbHRlcmVkRm9ySW5Mb29wXG4gICAgICBpZiAoIWV4cG9ydHMuZGVlcEVxdWFsKGFbcHJvcF0sIGJbcHJvcF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wIGluIGIpIHtcbiAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW5maWx0ZXJlZEZvckluTG9vcFxuICAgICAgaWYgKCFleHBvcnRzLmRlZXBFcXVhbChhW3Byb3BdLCBiW3Byb3BdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAodHlwZW9mIGEgPT09IHR5cGVvZiBiKSAmJiAoYSA9PSBiKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdmFsdWUgaXMgYSBOdW1iZXJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzTnVtYmVyXG4gKi9cbmV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSB8fCAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBudW1iZXIgaXMgaW50ZWdlclxuICogQHBhcmFtIHtOdW1iZXIgfCBCb29sZWFufSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNJbnRlZ2VyXG4gKi9cbmV4cG9ydHMuaXNJbnRlZ2VyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSA9PSBNYXRoLnJvdW5kKHZhbHVlKSk7XG4gIC8vIE5vdGU6IHdlIHVzZSA9PSwgbm90ID09PSwgYXMgd2UgY2FuIGhhdmUgQm9vbGVhbnMgYXMgd2VsbFxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHNpZ24gb2YgYSBudW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24oeCkge1xuICBpZiAoeCA+IDApIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBlbHNlIGlmICh4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIHRvIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBTeW50YXg6XG4gKlxuICogICAgZm9ybWF0KHZhbHVlKVxuICogICAgZm9ybWF0KHZhbHVlLCBvcHRpb25zKVxuICogICAgZm9ybWF0KHZhbHVlLCBwcmVjaXNpb24pXG4gKiAgICBmb3JtYXQodmFsdWUsIGZuKVxuICpcbiAqIFdoZXJlOlxuICpcbiAqICAgIHtOdW1iZXJ9IHZhbHVlICAgVGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICogICAge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3Qgd2l0aCBmb3JtYXR0aW5nIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBub3RhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyIG5vdGF0aW9uLiBDaG9vc2UgZnJvbTpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdmaXhlZCcgICAgICAgICAgQWx3YXlzIHVzZSByZWd1bGFyIG51bWJlciBub3RhdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgJzEyMy40MCcgYW5kICcxNDAwMDAwMCdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdleHBvbmVudGlhbCcgICAgQWx3YXlzIHVzZSBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgJzEuMjM0ZSsyJyBhbmQgJzEuNGUrNydcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdhdXRvJyAoZGVmYXVsdCkgUmVndWxhciBudW1iZXIgbm90YXRpb24gZm9yIG51bWJlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2aW5nIGFuIGFic29sdXRlIHZhbHVlIGJldHdlZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMsIGFuZCB1c2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50aWFsIG5vdGF0aW9uIGVsc2V3aGVyZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTG93ZXIgYm91bmQgaXMgaW5jbHVkZWQsIHVwcGVyIGJvdW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGV4Y2x1ZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSAnMTIzLjQnIGFuZCAnMS40ZTcnLlxuICogICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBwcmVjaXNpb24gICBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDE2IHRvIHJvdW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBkaWdpdHMgb2YgdGhlIG51bWJlci5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gY2FzZSBvZiBub3RhdGlvbnMgJ2V4cG9uZW50aWFsJyBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG8nLCBgcHJlY2lzaW9uYCBkZWZpbmVzIHRoZSB0b3RhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIHJldHVybmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gY2FzZSBvZiBub3RhdGlvbiAnZml4ZWQnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgcHJlY2lzaW9uYCBkZWZpbmVzIHRoZSBudW1iZXIgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnQgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LCBhbmQgaXMgMCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBleHBvbmVudGlhbCBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcGFyYW1ldGVycyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbG93ZXIgYW5kIHtOdW1iZXJ9IHVwcGVyLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGJ5IG5vdGF0aW9uICdhdXRvJyB0byBkZXRlcm1pbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0byByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWVzIGFyZSBgbG93ZXI9MWUtM2AgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB1cHBlcj0xZTVgLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IGFwcGxpY2FibGUgZm9yIG5vdGF0aW9uIGBhdXRvYC5cbiAqICAgIHtGdW5jdGlvbn0gZm4gICAgQSBjdXN0b20gZm9ybWF0dGluZyBmdW5jdGlvbi4gQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgIGJ1aWx0LWluIG5vdGF0aW9ucy4gRnVuY3Rpb24gYGZuYCBpcyBjYWxsZWQgd2l0aCBgdmFsdWVgIGFzXG4gKiAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlciBhbmQgbXVzdCByZXR1cm4gYSBzdHJpbmcuIElzIHVzZWZ1bCBmb3IgZXhhbXBsZSB0b1xuICogICAgICAgICAgICAgICAgICAgICBmb3JtYXQgYWxsIHZhbHVlcyBpbnNpZGUgYSBtYXRyaXggaW4gYSBwYXJ0aWN1bGFyIHdheS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICBmb3JtYXQoNi40KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzYuNCdcbiAqICAgIGZvcm1hdCgxMjQwMDAwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnMS4yNGU2J1xuICogICAgZm9ybWF0KDEvMyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwLjMzMzMzMzMzMzMzMzMzMzMnXG4gKiAgICBmb3JtYXQoMS8zLCAzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAuMzMzJ1xuICogICAgZm9ybWF0KDIxMzg1LCAyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICcyMTAwMCdcbiAqICAgIGZvcm1hdCgxMi4wNzEsIHtub3RhdGlvbjogJ2ZpeGVkJ30pOyAgICAgICAgICAgICAgICAvLyAnMTInXG4gKiAgICBmb3JtYXQoMi4zLCAgICB7bm90YXRpb246ICdmaXhlZCcsIHByZWNpc2lvbjogMn0pOyAgLy8gJzIuMzAnXG4gKiAgICBmb3JtYXQoNTIuOCwgICB7bm90YXRpb246ICdleHBvbmVudGlhbCd9KTsgICAgICAgICAgLy8gJzUuMjhlKzEnXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdCB8IEZ1bmN0aW9uIHwgTnVtYmVyfSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyIFRoZSBmb3JtYXR0ZWQgdmFsdWVcbiAqL1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBoYW5kbGUgZm9ybWF0KHZhbHVlLCBmbilcbiAgICByZXR1cm4gb3B0aW9ucyh2YWx1ZSk7XG4gIH1cblxuICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlc1xuICBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuICdJbmZpbml0eSc7XG4gIH1cbiAgZWxzZSBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiAnLUluZmluaXR5JztcbiAgfVxuICBlbHNlIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ05hTic7XG4gIH1cblxuICAvLyBkZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9uc1xuICB2YXIgbm90YXRpb24gPSAnYXV0byc7XG4gIHZhciBwcmVjaXNpb24gPSB1bmRlZmluZWQ7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBkZXRlcm1pbmUgbm90YXRpb24gZnJvbSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMubm90YXRpb24pIHtcbiAgICAgIG5vdGF0aW9uID0gb3B0aW9ucy5ub3RhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgcHJlY2lzaW9uIGZyb20gb3B0aW9uc1xuICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9wdGlvbnMpKSB7XG4gICAgICBwcmVjaXNpb24gPSBvcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLnByZWNpc2lvbikge1xuICAgICAgcHJlY2lzaW9uID0gb3B0aW9ucy5wcmVjaXNpb247XG4gICAgfVxuICB9XG5cbiAgLy8gaGFuZGxlIHRoZSB2YXJpb3VzIG5vdGF0aW9uc1xuICBzd2l0Y2ggKG5vdGF0aW9uKSB7XG4gICAgY2FzZSAnZml4ZWQnOlxuICAgICAgcmV0dXJuIGV4cG9ydHMudG9GaXhlZCh2YWx1ZSwgcHJlY2lzaW9uKTtcblxuICAgIGNhc2UgJ2V4cG9uZW50aWFsJzpcbiAgICAgIHJldHVybiBleHBvcnRzLnRvRXhwb25lbnRpYWwodmFsdWUsIHByZWNpc2lvbik7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIC8vIGRldGVybWluZSBsb3dlciBhbmQgdXBwZXIgYm91bmQgZm9yIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgdXBwZXIgYW5kIGxvd2VyIHRvIGJlIEJpZ051bWJlcnMgdGhlbXNlbHZlc1xuICAgICAgdmFyIGxvd2VyID0gMWUtMztcbiAgICAgIHZhciB1cHBlciA9IDFlNTtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXhwb25lbnRpYWwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXhwb25lbnRpYWwubG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxvd2VyID0gb3B0aW9ucy5leHBvbmVudGlhbC5sb3dlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5leHBvbmVudGlhbC51cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXBwZXIgPSBvcHRpb25zLmV4cG9uZW50aWFsLnVwcGVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2UgemVyb1xuICAgICAgaWYgKHZhbHVlID09PSAwKSByZXR1cm4gJzAnO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gb3V0cHV0IGV4cG9uZW50aWFsIG5vdGF0aW9uXG4gICAgICB2YXIgc3RyO1xuICAgICAgdmFyIGFicyA9IE1hdGguYWJzKHZhbHVlKTtcbiAgICAgIGlmIChhYnMgPj0gbG93ZXIgJiYgYWJzIDwgdXBwZXIpIHtcbiAgICAgICAgLy8gbm9ybWFsIG51bWJlciBub3RhdGlvblxuICAgICAgICAvLyBOb3RlOiBJRTcgZG9lcyBub3QgYWxsb3cgdmFsdWUudG9QcmVjaXNpb24odW5kZWZpbmVkKVxuICAgICAgICB2YXIgdmFsdWVTdHIgPSBwcmVjaXNpb24gP1xuICAgICAgICAgICAgdmFsdWUudG9QcmVjaXNpb24oTWF0aC5taW4ocHJlY2lzaW9uLCAyMSkpIDpcbiAgICAgICAgICAgIHZhbHVlLnRvUHJlY2lzaW9uKCk7XG4gICAgICAgIHN0ciA9IHBhcnNlRmxvYXQodmFsdWVTdHIpICsgJyc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gZXhwb25lbnRpYWwgbm90YXRpb25cbiAgICAgICAgc3RyID0gZXhwb3J0cy50b0V4cG9uZW50aWFsKHZhbHVlLCBwcmVjaXNpb24pO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb3MgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvKChcXC5cXGQqPykoMCspKSgkfGUpLywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGlnaXRzID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YXIgZSA9IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgcmV0dXJuIChkaWdpdHMgIT09ICcuJykgPyBkaWdpdHMgKyBlIDogZTtcbiAgICAgIH0pO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub3RhdGlvbiBcIicgKyBub3RhdGlvbiArICdcIi4gJyArXG4gICAgICAgICAgJ0Nob29zZSBcImF1dG9cIiwgXCJleHBvbmVudGlhbFwiLCBvciBcImZpeGVkXCIuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRm9ybWF0IGEgbnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uLiBMaWtlICcxLjIzZSs1JywgJzIuM2UrMCcsICczLjUwMGUtMydcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcmVjaXNpb25dICBOdW1iZXIgb2YgZGlnaXRzIGluIGZvcm1hdHRlZCBvdXRwdXQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBwcm92aWRlZCwgdGhlIG1heGltdW0gYXZhaWxhYmxlIGRpZ2l0c1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB1c2VkLlxuICogQHJldHVybnMge3N0cmluZ30gc3RyXG4gKi9cbmV4cG9ydHMudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgaWYgKHByZWNpc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvRXhwb25lbnRpYWwoTWF0aC5taW4ocHJlY2lzaW9uIC0gMSwgMjApKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUudG9FeHBvbmVudGlhbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcm1hdCBhIG51bWJlciB3aXRoIGZpeGVkIG5vdGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gW3ByZWNpc2lvbj0wXSAgICAgICAgT3B0aW9uYWwgbnVtYmVyIG9mIGRlY2ltYWxzIGFmdGVyIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgcG9pbnQuIFplcm8gYnkgZGVmYXVsdC5cbiAqL1xuZXhwb3J0cy50b0ZpeGVkID0gZnVuY3Rpb24odmFsdWUsIHByZWNpc2lvbikge1xuICByZXR1cm4gdmFsdWUudG9GaXhlZChNYXRoLm1pbihwcmVjaXNpb24sIDIwKSk7XG59O1xuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIGEgbnVtYmVyLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICogICAyLjM0IHJldHVybnMgM1xuICogICAwLjAwMzQgcmV0dXJucyAyXG4gKiAgIDEyMC41ZSszMCByZXR1cm5zIDRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge051bWJlcn0gZGlnaXRzICAgTnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xuICovXG5leHBvcnRzLmRpZ2l0cyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVxuICAgICAgLnRvRXhwb25lbnRpYWwoKVxuICAgICAgLnJlcGxhY2UoL2UuKiQvLCAnJykgICAgICAgICAgLy8gcmVtb3ZlIGV4cG9uZW50aWFsIG5vdGF0aW9uXG4gICAgICAucmVwbGFjZSggL14wXFwuPzAqfFxcLi8sICcnKSAgIC8vIHJlbW92ZSBkZWNpbWFsIHBvaW50IGFuZCBsZWFkaW5nIHplcm9zXG4gICAgICAubGVuZ3RoXG59O1xuXG4vKipcbiAqIE1pbmltdW0gbnVtYmVyIGFkZGVkIHRvIG9uZSB0aGF0IG1ha2VzIHRoZSByZXN1bHQgZGlmZmVyZW50IHRoYW4gb25lXG4gKi9cbmV4cG9ydHMuREJMX0VQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAyLjIyMDQ0NjA0OTI1MDMxMzA4MDg0NzI2MzMzNjE4MTZFLTE2O1xuXG4vKipcbiAqIENvbXBhcmVzIHR3byBmbG9hdGluZyBwb2ludCBudW1iZXJzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHggICAgICAgICAgRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICogQHBhcmFtIHtOdW1iZXJ9IHkgICAgICAgICAgU2Vjb25kIHZhbHVlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZXBzaWxvbl0gIFRoZSBtYXhpbXVtIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB4IGFuZCB5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBlcHNpbG9uIGlzIHVuZGVmaW5lZCBvciBudWxsLCB0aGUgZnVuY3Rpb24gd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdCB3aGV0aGVyIHggYW5kIHkgYXJlIGV4YWN0bHkgZXF1YWwuXG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSB0d28gbnVtYmVycyBhcmUgZXF1YWxcbiovXG5leHBvcnRzLm5lYXJseUVxdWFsID0gZnVuY3Rpb24oeCwgeSwgZXBzaWxvbikge1xuICAvLyBpZiBlcHNpbG9uIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB0ZXN0IHdoZXRoZXIgeCBhbmQgeSBhcmUgZXhhY3RseSBlcXVhbFxuICBpZiAoZXBzaWxvbiA9PSBudWxsKSByZXR1cm4geCA9PSB5O1xuXG4gIC8vIHVzZSBcIj09XCIgb3BlcmF0b3IsIGhhbmRsZXMgaW5maW5pdGllc1xuICBpZiAoeCA9PSB5KSByZXR1cm4gdHJ1ZTtcblxuICAvLyBOYU5cbiAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gYXQgdGhpcyBwb2ludCB4IGFuZCB5IHNob3VsZCBiZSBmaW5pdGVcbiAgaWYoaXNGaW5pdGUoeCkgJiYgaXNGaW5pdGUoeSkpIHtcbiAgICAvLyBjaGVjayBudW1iZXJzIGFyZSB2ZXJ5IGNsb3NlLCBuZWVkZWQgd2hlbiBjb21wYXJpbmcgbnVtYmVycyBuZWFyIHplcm9cbiAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHggLSB5KTtcbiAgICBpZiAoZGlmZiA8IGV4cG9ydHMuREJMX0VQU0lMT04pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHVzZSByZWxhdGl2ZSBlcnJvclxuICAgICAgcmV0dXJuIGRpZmYgPD0gTWF0aC5tYXgoTWF0aC5hYnMoeCksIE1hdGguYWJzKHkpKSAqIGVwc2lsb247XG4gICAgfVxuICB9XG5cbiAgLy8gSW5maW5pdGUgYW5kIE51bWJlciBvciBuZWdhdGl2ZSBJbmZpbml0ZSBhbmQgcG9zaXRpdmUgSW5maW5pdGUgY2FzZXNcbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIFJlc3VsdFNldCBjb250YWlucyBhIGxpc3Qgb3IgcmVzdWx0c1xuICogQHBhcmFtIHtBcnJheX0gZW50cmllc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJlc3VsdFNldChlbnRyaWVzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXN1bHRTZXQpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIHRoaXMuZW50cmllcyA9IGVudHJpZXMgfHwgW107XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgd2l0aCByZXN1bHRzIGhvbGQgYnkgdGhpcyBSZXN1bHRTZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gZW50cmllc1xuICovXG5SZXN1bHRTZXQucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmVudHJpZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZ2lmaWVkIHJlc3VsdHMgb2YgdGhlIFJlc3VsdFNldFxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nXG4gKi9cblJlc3VsdFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnWycgKyB0aGlzLmVudHJpZXMuam9pbignLCAnKSArICddJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzdWx0U2V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIC8qKlxuICAgKiBXcmFwIGFueSB2YWx1ZSBpbiBhIFNlbGVjdG9yLCBhbGxvd2luZyB0byBwZXJmb3JtIGNoYWluZWQgb3BlcmF0aW9ucyBvblxuICAgKiB0aGUgdmFsdWUuXG4gICAqXG4gICAqIEFsbCBtZXRob2RzIGF2YWlsYWJsZSBpbiB0aGUgbWF0aC5qcyBsaWJyYXJ5IGNhbiBiZSBjYWxsZWQgdXBvbiB0aGUgc2VsZWN0b3IsXG4gICAqIGFuZCB0aGVuIHdpbGwgYmUgZXZhbHVhdGVkIHdpdGggdGhlIHZhbHVlIGl0c2VsZiBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICogVGhlIHNlbGVjdG9yIGNhbiBiZSBjbG9zZWQgYnkgZXhlY3V0aW5nIGBzZWxlY3Rvci5kb25lKClgLCB3aGljaCByZXR1cm5zXG4gICAqIHRoZSBmaW5hbCB2YWx1ZS5cbiAgICpcbiAgICogVGhlIFNlbGVjdG9yIGhhcyBhIG51bWJlciBvZiBzcGVjaWFsIGZ1bmN0aW9uczpcbiAgICpcbiAgICogLSBgZG9uZSgpYCAgICAgRmluYWxpemUgdGhlIGNoYWluZWQgb3BlcmF0aW9uIGFuZCByZXR1cm4gdGhlIHNlbGVjdG9ycyB2YWx1ZS5cbiAgICogLSBgdmFsdWVPZigpYCAgVGhlIHNhbWUgYXMgYGRvbmUoKWBcbiAgICogLSBgdG9TdHJpbmcoKWAgRXhlY3V0ZXMgYG1hdGguZm9ybWF0KClgIG9udG8gdGhlIHNlbGVjdG9ycyB2YWx1ZSwgcmV0dXJuaW5nXG4gICAqICAgICAgICAgICAgICAgIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnNlbGVjdCh2YWx1ZSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLnNlbGVjdCgzKVxuICAgKiAgICAgICAgIC5hZGQoNClcbiAgICogICAgICAgICAuc3VidHJhY3QoMilcbiAgICogICAgICAgICAuZG9uZSgpOyAgICAgLy8gNVxuICAgKlxuICAgKiAgICAgbWF0aC5zZWxlY3QoIFtbMSwgMl0sIFszLCA0XV0gKVxuICAgKiAgICAgICAgIC5zZXQoWzEsIDFdLCA4KVxuICAgKiAgICAgICAgIC5tdWx0aXBseSgzKVxuICAgKiAgICAgICAgIC5kb25lKCk7ICAgICAvLyBbWzI0LCA2XSwgWzksIDEyXV1cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbdmFsdWVdICAgQSB2YWx1ZSBvZiBhbnkgdHlwZSBvbiB3aGljaCB0byBzdGFydCBhIGNoYWluZWQgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJuIHttYXRoLmNoYWluaW5nLlNlbGVjdG9yfSBUaGUgY3JlYXRlZCBzZWxlY3RvclxuICAgKi9cbiAgbWF0aC5zZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QodmFsdWUpIHtcbiAgICAvLyBUT0RPOiBjaGVjayBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgcmV0dXJuIG5ldyBtYXRoLmNoYWluaW5nLlNlbGVjdG9yKHZhbHVlKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcblxuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYSBtYXRyaXggb3IgYSAgbGlzdCB3aXRoIHZhbHVlcy5cbiAgICogVGhlIHN0YW5kYXJkIGRldmlhdGlvbnMgaXMgZGVmaW5lZCBhcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhcmlhbmNlOlxuICAgKiBgc3RkKEEpID0gc3FydCh2YXIoQSkpYC5cbiAgICogSW4gY2FzZSBvZiBhIChtdWx0aSBkaW1lbnNpb25hbCkgYXJyYXkgb3IgbWF0cml4LCB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uXG4gICAqIG92ZXIgYWxsIGVsZW1lbnRzIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICpcbiAgICogT3B0aW9uYWxseSwgdGhlIHR5cGUgb2Ygbm9ybWFsaXphdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGFzIHNlY29uZFxuICAgKiBwYXJhbWV0ZXIuIFRoZSBwYXJhbWV0ZXIgYG5vcm1hbGl6YXRpb25gIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gICAqXG4gICAqIC0gJ3VuYmlhc2VkJyAoZGVmYXVsdCkgVGhlIHN1bSBvZiBzcXVhcmVkIGVycm9ycyBpcyBkaXZpZGVkIGJ5IChuIC0gMSlcbiAgICogLSAndW5jb3JyZWN0ZWQnICAgICAgICBUaGUgc3VtIG9mIHNxdWFyZWQgZXJyb3JzIGlzIGRpdmlkZWQgYnkgblxuICAgKiAtICdiaWFzZWQnICAgICAgICAgICAgIFRoZSBzdW0gb2Ygc3F1YXJlZCBlcnJvcnMgaXMgZGl2aWRlZCBieSAobiArIDEpXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGguc3RkKGEsIGIsIGMsIC4uLilcbiAgICogICAgIG1hdGguc3RkKEEpXG4gICAqICAgICBtYXRoLnN0ZChBLCBub3JtYWxpemF0aW9uKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGguc3RkKDIsIDQsIDYpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMlxuICAgKiAgICAgbWF0aC5zdGQoWzIsIDQsIDYsIDhdKTsgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAyLjU4MTk4ODg5NzQ3MTYxMVxuICAgKiAgICAgbWF0aC5zdGQoWzIsIDQsIDYsIDhdLCAndW5jb3JyZWN0ZWQnKTsgLy8gcmV0dXJucyAyLjIzNjA2Nzk3NzQ5OTc5XG4gICAqICAgICBtYXRoLnN0ZChbMiwgNCwgNiwgOF0sICdiaWFzZWQnKTsgICAgICAvLyByZXR1cm5zIDJcbiAgICpcbiAgICogICAgIG1hdGguc3RkKFtbMSwgMiwgM10sIFs0LCA1LCA2XV0pOyAgICAgIC8vIHJldHVybnMgMS44NzA4Mjg2OTMzODY5NzA3XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBtZWFuLCBtZWRpYW4sIG1heCwgbWluLCBwcm9kLCBzdW0sIHZhclxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4fSBhcnJheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIEEgc2luZ2xlIG1hdHJpeCBvciBvciBtdWx0aXBsZSBzY2FsYXIgdmFsdWVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbm9ybWFsaXphdGlvbj0ndW5iaWFzZWQnXVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIERldGVybWluZXMgaG93IHRvIG5vcm1hbGl6ZSB0aGUgdmFyaWFuY2UuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgQ2hvb3NlICd1bmJpYXNlZCcgKGRlZmF1bHQpLCAndW5jb3JyZWN0ZWQnLCBvciAnYmlhc2VkJy5cbiAgICogQHJldHVybiB7Kn0gVGhlIHN0YW5kYXJkIGRldmlhdGlvblxuICAgKi9cbiAgbWF0aC5zdGQgPSBmdW5jdGlvbiBzdGQoYXJyYXksIG5vcm1hbGl6YXRpb24pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Z1bmN0aW9uIHN0ZCByZXF1aXJlcyBvbmUgb3IgbW9yZSBwYXJhbWV0ZXJzICgwIHByb3ZpZGVkKScpO1xuICAgIH1cblxuICAgIHZhciB2YXJpYW5jZSA9IG1hdGhbJ3ZhciddLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIG1hdGguc3FydCh2YXJpYW5jZSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpXG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2VcblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdmFyIHNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50aGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzXG4gIHNlbGYudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9KVxufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJylcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKVxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpXG4gIHZhciBzdGF0ZSA9IG51bGxcbiAgdmFyIHZhbHVlID0gbnVsbFxuICB2YXIgZGVmZXJyZWRzID0gW11cbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gbmV3IHNlbGYuY29uc3RydWN0b3IoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBoYW5kbGUobmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdCkpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZShkZWZlcnJlZCkge1xuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgZGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgYXNhcChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjYiA9IHN0YXRlID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkXG4gICAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgICAgKHN0YXRlID8gZGVmZXJyZWQucmVzb2x2ZSA6IGRlZmVycmVkLnJlamVjdCkodmFsdWUpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIHJldFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gY2IodmFsdWUpXG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHJldClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZShuZXdWYWx1ZSkge1xuICAgIHRyeSB7IC8vUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKVxuICAgICAgaWYgKG5ld1ZhbHVlICYmICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuXG4gICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRvUmVzb2x2ZSh0aGVuLmJpbmQobmV3VmFsdWUpLCByZXNvbHZlLCByZWplY3QpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlID0gdHJ1ZVxuICAgICAgdmFsdWUgPSBuZXdWYWx1ZVxuICAgICAgZmluYWxlKClcbiAgICB9IGNhdGNoIChlKSB7IHJlamVjdChlKSB9XG4gIH1cblxuICBmdW5jdGlvbiByZWplY3QobmV3VmFsdWUpIHtcbiAgICBzdGF0ZSA9IGZhbHNlXG4gICAgdmFsdWUgPSBuZXdWYWx1ZVxuICAgIGZpbmFsZSgpXG4gIH1cblxuICBmdW5jdGlvbiBmaW5hbGUoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlZmVycmVkcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgIGhhbmRsZShkZWZlcnJlZHNbaV0pXG4gICAgZGVmZXJyZWRzID0gbnVsbFxuICB9XG5cbiAgZG9SZXNvbHZlKGZuLCByZXNvbHZlLCByZWplY3QpXG59XG5cblxuZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0KXtcbiAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbFxuICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsXG4gIHRoaXMucmVzb2x2ZSA9IHJlc29sdmVcbiAgdGhpcy5yZWplY3QgPSByZWplY3Rcbn1cblxuLyoqXG4gKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICovXG5mdW5jdGlvbiBkb1Jlc29sdmUoZm4sIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgZm4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICBkb25lID0gdHJ1ZVxuICAgICAgb25GdWxmaWxsZWQodmFsdWUpXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKGRvbmUpIHJldHVyblxuICAgICAgZG9uZSA9IHRydWVcbiAgICAgIG9uUmVqZWN0ZWQocmVhc29uKVxuICAgIH0pXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGRvbmUpIHJldHVyblxuICAgIGRvbmUgPSB0cnVlXG4gICAgb25SZWplY3RlZChleClcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vL1RoaXMgZmlsZSBjb250YWlucyB0aGUgRVM2IGV4dGVuc2lvbnMgdG8gdGhlIGNvcmUgUHJvbWlzZXMvQSsgQVBJXG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJylcbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZVxuXG4vKiBTdGF0aWMgRnVuY3Rpb25zICovXG5cbmZ1bmN0aW9uIFZhbHVlUHJvbWlzZSh2YWx1ZSkge1xuICB0aGlzLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpc1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNvbHZlKG9uRnVsZmlsbGVkKHZhbHVlKSlcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblZhbHVlUHJvbWlzZS5wcm90b3R5cGUgPSBQcm9taXNlLnByb3RvdHlwZVxuXG52YXIgVFJVRSA9IG5ldyBWYWx1ZVByb21pc2UodHJ1ZSlcbnZhciBGQUxTRSA9IG5ldyBWYWx1ZVByb21pc2UoZmFsc2UpXG52YXIgTlVMTCA9IG5ldyBWYWx1ZVByb21pc2UobnVsbClcbnZhciBVTkRFRklORUQgPSBuZXcgVmFsdWVQcm9taXNlKHVuZGVmaW5lZClcbnZhciBaRVJPID0gbmV3IFZhbHVlUHJvbWlzZSgwKVxudmFyIEVNUFRZU1RSSU5HID0gbmV3IFZhbHVlUHJvbWlzZSgnJylcblxuUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiB2YWx1ZVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIE5VTExcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBVTkRFRklORURcbiAgaWYgKHZhbHVlID09PSB0cnVlKSByZXR1cm4gVFJVRVxuICBpZiAodmFsdWUgPT09IGZhbHNlKSByZXR1cm4gRkFMU0VcbiAgaWYgKHZhbHVlID09PSAwKSByZXR1cm4gWkVST1xuICBpZiAodmFsdWUgPT09ICcnKSByZXR1cm4gRU1QVFlTVFJJTkdcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHRoZW4gPSB2YWx1ZS50aGVuXG4gICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHRoZW4uYmluZCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlamVjdChleClcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBWYWx1ZVByb21pc2UodmFsdWUpXG59XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycilcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pXG4gICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoXG4gICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwodmFsLCBmdW5jdGlvbiAodmFsKSB7IHJlcyhpLCB2YWwpIH0sIHJlamVjdClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcmdzW2ldID0gdmFsXG4gICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJlamVjdChleClcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXMoaSwgYXJnc1tpXSlcbiAgICB9XG4gIH0pXG59XG5cblByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IFxuICAgIHJlamVjdCh2YWx1ZSk7XG4gIH0pO1xufVxuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IFxuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0pXG4gIH0pO1xufVxuXG4vKiBQcm90b3R5cGUgTWV0aG9kcyAqL1xuXG5Qcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgsIGNvbmZpZykge1xuICB2YXIgYmlnbnVtYmVyID0gcmVxdWlyZSgnLi91dGlsL2JpZ251bWJlcicpO1xuICB2YXIgQ29tcGxleCA9IHJlcXVpcmUoJy4vdHlwZS9Db21wbGV4Jyk7XG4gIHZhciBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgQmlnTnVtYmVyIGVcbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gUmV0dXJucyBlXG4gICAqL1xuICBmdW5jdGlvbiBiaWdFKCkge1xuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKDEpLmV4cCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBCaWdOdW1iZXIgZ29sZGVuIHJhdGlvLCBwaGkgPSAoMStzcXJ0KDUpKS8yXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IFJldHVybnMgcGhpXG4gICAqL1xuICBmdW5jdGlvbiBiaWdQaGkoKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoMSkucGx1cyhuZXcgQmlnTnVtYmVyKDUpLnNxcnQoKSkuZGl2KDIpO1xuICB9XG5cbiAgLyoqXG4gICAqIGFyY3Rhbih4KSA9IHggLSB4XjMvMyArIHheNS81IC0geF43LzcgKyB4XjkvOSAtIC4uLlxuICAgKiAgICAgICAgICAgPSB4IC0geF4yKnheMS8zICsgeF4yKnheMy81IC0geF4yKnheNS83ICsgeF4yKnheNy85IC0gLi4uXG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSB4XG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IGFyYyB0YW5nZW50IG9mIHhcbiAgICovXG4gIGZ1bmN0aW9uIGFyY3Rhbih4KSB7XG4gICAgdmFyIHkgPSB4O1xuICAgIHZhciB5UHJldiA9IE5hTjtcbiAgICB2YXIgeDIgPSB4LnRpbWVzKHgpO1xuICAgIHZhciBudW0gPSB4O1xuICAgIHZhciBzaWduID0gLTE7XG5cbiAgICBmb3IgKHZhciBrID0gMzsgIXkuZXF1YWxzKHlQcmV2KTsgayArPSAyKSB7XG4gICAgICBudW0gPSBudW0udGltZXMoeDIpO1xuXG4gICAgICB5UHJldiA9IHk7XG4gICAgICB5ID0gKHNpZ24gPiAwKSA/IHkucGx1cyhudW0uZGl2KGspKSA6IHkubWludXMobnVtLmRpdihrKSk7XG4gICAgICBzaWduID0gLXNpZ247XG4gICAgfVxuXG4gICAgcmV0dXJuIHk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIEJpZ051bWJlciBwaS5cbiAgICpcbiAgICogVXNlcyBNYWNoaW4ncyBmb3JtdWxhOiBwaSAvIDQgPSA0ICogYXJjdGFuKDEgLyA1KSAtIGFyY3RhbigxIC8gMjM5KVxuICAgKiBodHRwOi8vbWlsYW4ubWlsYW5vdmljLm9yZy9tYXRoL2VuZ2xpc2gvcGkvbWFjaGluLmh0bWxcbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gUmV0dXJucyBwaVxuICAgKi9cbiAgZnVuY3Rpb24gYmlnUGkoKSB7XG4gICAgLy8gd2UgY2FsY3VsYXRlIHBpIHdpdGggYSBmZXcgZGVjaW1hbCBwbGFjZXMgZXh0cmEgdG8gcHJldmVudCByb3VuZCBvZmYgaXNzdWVzXG4gICAgdmFyIEJpZyA9IEJpZ051bWJlci5jb25zdHJ1Y3Rvcih7cHJlY2lzaW9uOiBCaWdOdW1iZXIucHJlY2lzaW9uICsgNH0pO1xuICAgIHZhciBwaTR0aCA9IG5ldyBCaWcoNCkudGltZXMoYXJjdGFuKG5ldyBCaWcoMSkuZGl2KDUpKSlcbiAgICAgICAgLm1pbnVzKGFyY3RhbihuZXcgQmlnKDEpLmRpdigyMzkpKSk7XG5cbiAgICAvLyB0aGUgZmluYWwgcGkgaGFzIHRoZSByZXF1ZXN0ZWQgbnVtYmVyIG9mIGRlY2ltYWxzXG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoNCkudGltZXMocGk0dGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBCaWdOdW1iZXIgdGF1LCB0YXUgPSAyICogcGlcbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gUmV0dXJucyB0YXVcbiAgICovXG4gIGZ1bmN0aW9uIGJpZ1RhdSgpIHtcbiAgICAvLyB3ZSBjYWxjdWxhdGUgcGkgYXQgYSBzbGlnaHRseSBoaWdoZXIgcHJlY2lzaW9uIHRoYW4gY29uZmlndXJlZCB0byBwcmV2ZW50IHJvdW5kIG9mZiBlcnJvcnNcbiAgICAvLyB3aGVuIG11bHRpcGx5aW5nIGJ5IHR3byBpbiB0aGUgZW5kXG4gICAgQmlnTnVtYmVyLmNvbmZpZyh7cHJlY2lzaW9uOiBjb25maWcucHJlY2lzaW9uICsgMn0pO1xuXG4gICAgdmFyIHBpID0gYmlnUGkoKTtcblxuICAgIEJpZ051bWJlci5jb25maWcoe3ByZWNpc2lvbjogY29uZmlnLnByZWNpc2lvbn0pO1xuXG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoMikudGltZXMocGkpO1xuICB9XG5cbiAgdmFyIGJpZyA9IGNvbmZpZy5udW1iZXIgPT09ICdiaWdudW1iZXInO1xuXG4gIC8vIFRPRE86IGluIGNhc2Ugb2Ygc3VwcG9ydCBmb3IgZGVmaW5lUHJvcGVydHksIHdlIGNhbiBsYXp5IGV2YWx1YXRlIHRoZSBCaWdOdW1iZXIgY29uc3RhbnRzIGJ5IGNyZWF0aW5nIHRoZW0gYXMgcHJvcGVydGllcyAoY2FsY3VsYXRpb24gb2YgUEkgaXMgc2xvdyBmb3IgZXhhbXBsZSlcbiAgbWF0aC5waSAgICAgICAgICA9IGJpZyA/IGJpZ1BpKCkgIDogTWF0aC5QSTtcbiAgbWF0aC50YXUgICAgICAgICA9IGJpZyA/IGJpZ1RhdSgpIDogTWF0aC5QSSAqIDI7XG4gIG1hdGguZSAgICAgICAgICAgPSBiaWcgPyBiaWdFKCkgICA6IE1hdGguRTtcbiAgbWF0aC5waGkgICAgICAgICA9IGJpZyA/IGJpZ1BoaSgpIDogMS42MTgwMzM5ODg3NDk4OTQ4NDgyMDQ1ODY4MzQzNjU2MzgxMTc3MjAzMDkxNzk4MDU3NjI4NjIxMzU0NTsgLy8gZ29sZGVuIHJhdGlvLCAoMStzcXJ0KDUpKS8yXG5cbiAgbWF0aC5pICAgICAgICAgICA9IG5ldyBDb21wbGV4KDAsIDEpO1xuXG4gIG1hdGhbJ0luZmluaXR5J10gPSBJbmZpbml0eTtcbiAgbWF0aFsnTmFOJ10gICAgICA9IE5hTjtcbiAgbWF0aFsndHJ1ZSddICAgICA9IHRydWU7XG4gIG1hdGhbJ2ZhbHNlJ10gICAgPSBmYWxzZTtcbiAgbWF0aFsnbnVsbCddICAgICA9IG51bGw7XG4gIG1hdGhbJ3VuaW5pdGlhbGl6ZWQnXSA9IHJlcXVpcmUoJy4vdXRpbC9hcnJheScpLlVOSU5JVElBTElaRUQ7XG5cbiAgLy8gdXBwZXJjYXNlIGNvbnN0YW50cyAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBidWlsdC1pbiBNYXRoKVxuICBtYXRoLkUgICAgICAgICAgID0gbWF0aC5lO1xuICBtYXRoLkxOMiAgICAgICAgID0gYmlnID8gbmV3IEJpZ051bWJlcigyKS5sbigpICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLkxOMjtcbiAgbWF0aC5MTjEwICAgICAgICA9IGJpZyA/IG5ldyBCaWdOdW1iZXIoMTApLmxuKCkgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5MTjEwO1xuICBtYXRoLkxPRzJFICAgICAgID0gYmlnID8gbmV3IEJpZ051bWJlcigxKS5kaXYobmV3IEJpZ051bWJlcigyKS5sbigpKSAgOiBNYXRoLkxPRzJFO1xuICBtYXRoLkxPRzEwRSAgICAgID0gYmlnID8gbmV3IEJpZ051bWJlcigxKS5kaXYobmV3IEJpZ051bWJlcigxMCkubG4oKSkgOiBNYXRoLkxPRzEwRTtcbiAgbWF0aC5QSSAgICAgICAgICA9IG1hdGgucGk7XG4gIG1hdGguU1FSVDFfMiAgICAgPSBiaWcgPyBuZXcgQmlnTnVtYmVyKDAuNSkuc3FydCgpICAgICAgICAgICAgICAgICAgICA6IE1hdGguU1FSVDFfMjtcbiAgbWF0aC5TUVJUMiAgICAgICA9IGJpZyA/IG5ldyBCaWdOdW1iZXIoMikuc3FydCgpICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5TUVJUMjtcblxuICAvLyBtZXRhIGluZm9ybWF0aW9uXG4gIG1hdGgudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy9UaGlzIGZpbGUgY29udGFpbnMgdGhlbi9wcm9taXNlIHNwZWNpZmljIGV4dGVuc2lvbnMgdGhhdCBhcmUgb25seSB1c2VmdWwgZm9yIG5vZGUuanMgaW50ZXJvcFxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpXG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2VcblxuLyogU3RhdGljIEZ1bmN0aW9ucyAqL1xuXG5Qcm9taXNlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChmbiwgYXJndW1lbnRDb3VudCkge1xuICBhcmd1bWVudENvdW50ID0gYXJndW1lbnRDb3VudCB8fCBJbmZpbml0eVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB3aGlsZSAoYXJncy5sZW5ndGggJiYgYXJncy5sZW5ndGggPiBhcmd1bWVudENvdW50KSB7XG4gICAgICAgIGFyZ3MucG9wKClcbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycilcbiAgICAgICAgZWxzZSByZXNvbHZlKHJlcylcbiAgICAgIH0pXG4gICAgICB2YXIgcmVzID0gZm4uYXBwbHkoc2VsZiwgYXJncylcbiAgICAgIGlmIChyZXMgJiYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXMgPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXNvbHZlKHJlcylcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5Qcm9taXNlLm5vZGVpZnkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICB2YXIgY2FsbGJhY2sgPSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nID8gYXJncy5wb3AoKSA6IG51bGxcbiAgICB2YXIgY3R4ID0gdGhpc1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKS5ub2RlaWZ5KGNhbGxiYWNrLCBjdHgpXG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgcmVqZWN0KGV4KSB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGV4KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpc1xuXG4gIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBudWxsLCB2YWx1ZSlcbiAgICB9KVxuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZXJyKVxuICAgIH0pXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvYmplY3QgPSByZXF1aXJlKCcuL3V0aWwvb2JqZWN0Jyk7XG52YXIgZGlnaXRzID0gcmVxdWlyZSgnLi91dGlsL251bWJlcicpLmRpZ2l0cztcblxuLyoqXG4gKiBtYXRoLmpzIGZhY3RvcnkgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIEF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBtYXRyaXhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBzdHJpbmcgJ21hdHJpeCcgKGRlZmF1bHQpIG9yICdhcnJheScuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBudW1iZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBzdHJpbmcgJ251bWJlcicgKGRlZmF1bHQpIG9yICdiaWdudW1iZXInXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBwcmVjaXNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgZm9yIEJpZ051bWJlcnMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdCBhcHBsaWNhYmxlIGZvciBOdW1iZXJzLlxuICovXG5mdW5jdGlvbiBjcmVhdGUgKGNvbmZpZykge1xuICAvLyBzaW1wbGUgdGVzdCBmb3IgRVM1IHN1cHBvcnRcbiAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFUzUgbm90IHN1cHBvcnRlZCBieSB0aGlzIEphdmFTY3JpcHQgZW5naW5lLiAnICtcbiAgICAgICAgJ1BsZWFzZSBsb2FkIHRoZSBlczUtc2hpbSBhbmQgZXM1LXNoYW0gbGlicmFyeSBmb3IgY29tcGF0aWJpbGl0eS4nKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBuYW1lc3BhY2VcbiAgdmFyIG1hdGggPSB7fTtcblxuICAvLyBjcmVhdGUgY29uZmlndXJhdGlvbiBvcHRpb25zLiBUaGVzZSBhcmUgcHJpdmF0ZVxuICB2YXIgX2NvbmZpZyA9IHtcbiAgICAvLyB0eXBlIG9mIGRlZmF1bHQgbWF0cml4IG91dHB1dC4gQ2hvb3NlICdtYXRyaXgnIChkZWZhdWx0KSBvciAnYXJyYXknXG4gICAgbWF0cml4OiAnbWF0cml4JyxcblxuICAgIC8vIHR5cGUgb2YgZGVmYXVsdCBudW1iZXIgb3V0cHV0LiBDaG9vc2UgJ251bWJlcicgKGRlZmF1bHQpIG9yICdiaWdudW1iZXInXG4gICAgbnVtYmVyOiAnbnVtYmVyJyxcblxuICAgIC8vIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgaW4gQmlnTnVtYmVyc1xuICAgIHByZWNpc2lvbjogNjQsXG5cbiAgICAvLyBtaW5pbXVtIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gY29tcGFyZWQgdmFsdWVzLFxuICAgIC8vIHVzZWQgYnkgYWxsIGNvbXBhcmlzb24gZnVuY3Rpb25zXG4gICAgZXBzaWxvbjogMWUtMTRcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgbWF0aC5qcywgYW5kIGdldCBjdXJyZW50IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gbWF0cml4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBzdHJpbmcgJ21hdHJpeCcgKGRlZmF1bHQpIG9yICdhcnJheScuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG51bWJlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgc3RyaW5nICdudW1iZXInIChkZWZhdWx0KSBvciAnYmlnbnVtYmVyJ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBwcmVjaXNpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBmb3IgQmlnTnVtYmVycy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3QgYXBwbGljYWJsZSBmb3IgTnVtYmVycy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIG1hdGguY29uZmlnID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgICBvYmplY3QuZGVlcEV4dGVuZChfY29uZmlnLCBvcHRpb25zKTtcblxuICAgICAgaWYgKG9wdGlvbnMucHJlY2lzaW9uKSB7XG4gICAgICAgIG1hdGgudHlwZS5CaWdOdW1iZXIuY29uZmlnKHtcbiAgICAgICAgICBwcmVjaXNpb246IG9wdGlvbnMucHJlY2lzaW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyByZWxvYWQgdGhlIGNvbnN0YW50cyAodGhleSBkZXBlbmQgb24gb3B0aW9uIG51bWJlciBhbmQgcHJlY2lzaW9uKVxuICAgICAgLy8gdGhpcyBtdXN0IGJlIGRvbmUgYWZ0ZXIgbWF0aC50eXBlLkJpZ051bWJlci5jb25maWcgaXMgYXBwbGllZFxuICAgICAgcmVxdWlyZSgnLi9jb25zdGFudHMnKShtYXRoLCBfY29uZmlnKTtcblxuICAgICAgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgc2V0dGluZyBzb21lIGRheSAoZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDAuMTcuMClcbiAgICAgIGlmIChvcHRpb25zLm51bWJlciAmJiBvcHRpb25zLm51bWJlci5kZWZhdWx0VHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldHRpbmcgYG51bWJlci5kZWZhdWx0VHlwZWAgaXMgZGVwcmVjYXRlZC4gVXNlIGBudW1iZXJgIGluc3RlYWQuJylcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgc2V0dGluZyBzb21lIGRheSAoZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDAuMTcuMClcbiAgICAgIGlmIChvcHRpb25zLm51bWJlciAmJiBvcHRpb25zLm51bWJlci5wcmVjaXNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5nIGBudW1iZXIucHJlY2lzaW9uYCBpcyBkZXByZWNhdGVkLiBVc2UgYHByZWNpc2lvbmAgaW5zdGVhZC4nKVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBzZXR0aW5nIHNvbWUgZGF5IChkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC4xNy4wKVxuICAgICAgaWYgKG9wdGlvbnMubWF0cml4ICYmIG9wdGlvbnMubWF0cml4LmRlZmF1bHRUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0dGluZyBgbWF0cml4LmRlZmF1bHRUeXBlYCBpcyBkZXByZWNhdGVkLiBVc2UgYG1hdHJpeGAgaW5zdGVhZC4nKVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCBzZXR0aW5nIHNvbWUgZGF5IChkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC4xNS4wKVxuICAgICAgaWYgKG9wdGlvbnMubWF0cml4ICYmIG9wdGlvbnMubWF0cml4WydkZWZhdWx0J10pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5nIGBtYXRyaXguZGVmYXVsdGAgaXMgZGVwcmVjYXRlZC4gVXNlIGBtYXRyaXhgIGluc3RlYWQuJylcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgc2V0dGluZyBzb21lIGRheSAoZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDAuMjAuMClcbiAgICAgIGlmIChvcHRpb25zLmRlY2ltYWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0dGluZyBgZGVjaW1hbHNgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgcHJlY2lzaW9uYCBpbnN0ZWFkLicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGEgY2xvbmUgb2YgdGhlIHNldHRpbmdzXG4gICAgcmV0dXJuIG9iamVjdC5jbG9uZShfY29uZmlnKTtcbiAgfTtcblxuICAvKipcbiAgICogbWF0aC5qcyBmYWN0b3J5IGZ1bmN0aW9uLiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIG1hdGguanNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIEF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG1hdHJpeFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgc3RyaW5nICdtYXRyaXgnIChkZWZhdWx0KSBvciAnYXJyYXknLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBudW1iZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHN0cmluZyAnbnVtYmVyJyAoZGVmYXVsdCkgb3IgJ2JpZ251bWJlcidcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gcHJlY2lzaW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgZm9yIEJpZ051bWJlcnMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90IGFwcGxpY2FibGUgZm9yIE51bWJlcnMuXG4gICAqL1xuICBtYXRoLmNyZWF0ZSA9IGNyZWF0ZTtcblxuICAvLyBjcmVhdGUgYSBuZXcgQmlnTnVtYmVyIGZhY3RvcnkgZm9yIHRoaXMgaW5zdGFuY2Ugb2YgbWF0aC5qc1xuICB2YXIgQmlnTnVtYmVyID0gcmVxdWlyZSgnZGVjaW1hbC5qcycpLmNvbnN0cnVjdG9yKCk7XG5cbiAgLy8gZXh0ZW5kIEJpZ051bWJlciB3aXRoIGEgZnVuY3Rpb24gY2xvbmVcbiAgaWYgKHR5cGVvZiBCaWdOdW1iZXIucHJvdG90eXBlLmNsb25lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLyoqXG4gICAgICogQ2xvbmUgYSBiaWdudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtCaWdOdW1iZXJ9IGNsb25lXG4gICAgICovXG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodGhpcyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGV4dGVuZCBCaWdOdW1iZXIgd2l0aCBhIGZ1bmN0aW9uIGNvbnZlcnRcbiAgaWYgKHR5cGVvZiBCaWdOdW1iZXIuY29udmVydCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8qKlxuICAgICAqIFRyeSB0byBjb252ZXJ0IGEgTnVtYmVyIGluIHRvIGEgQmlnTnVtYmVyLlxuICAgICAqIElmIHRoZSBudW1iZXIgaGFzIDE1IG9yIG1vciBzaWduaWZpY2FudCBkaWdpdHMsIHRoZSBOdW1iZXIgY2Fubm90IGJlXG4gICAgICogY29udmVydGVkIHRvIEJpZ051bWJlciBhbmQgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIG51bWJlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyXG4gICAgICogQHJldHVybiB7QmlnTnVtYmVyIHwgTnVtYmVyfSBiaWdudW1iZXJcbiAgICAgKi9cbiAgICBCaWdOdW1iZXIuY29udmVydCA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgaWYgKGRpZ2l0cyhudW1iZXIpID4gMTUpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihudW1iZXIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGZ1bmN0aW9uIGNvbnZlcnQgdG8gQmlnTnVtYmVyOiBmdW5jdGlvbiBhbHJlYWR5IGV4aXN0cycpO1xuICB9XG5cbiAgLy8gZXJyb3JzXG4gIG1hdGguZXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2luZGV4Jyk7XG5cbiAgLy8gdHlwZXMgKE1hdHJpeCwgQ29tcGxleCwgVW5pdCwgLi4uKVxuICBtYXRoLnR5cGUgPSB7fTtcbiAgbWF0aC50eXBlLkNvbXBsZXggPSByZXF1aXJlKCcuL3R5cGUvQ29tcGxleCcpO1xuICBtYXRoLnR5cGUuUmFuZ2UgPSByZXF1aXJlKCcuL3R5cGUvUmFuZ2UnKTtcbiAgbWF0aC50eXBlLkluZGV4ID0gcmVxdWlyZSgnLi90eXBlL0luZGV4Jyk7XG4gIG1hdGgudHlwZS5NYXRyaXggPSByZXF1aXJlKCcuL3R5cGUvTWF0cml4Jyk7XG4gIG1hdGgudHlwZS5Vbml0ID0gcmVxdWlyZSgnLi90eXBlL1VuaXQnKTtcbiAgbWF0aC50eXBlLkhlbHAgPSByZXF1aXJlKCcuL3R5cGUvSGVscCcpO1xuICBtYXRoLnR5cGUuUmVzdWx0U2V0ID0gcmVxdWlyZSgnLi90eXBlL1Jlc3VsdFNldCcpO1xuICBtYXRoLnR5cGUuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xuXG4gIG1hdGguY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vdHlwZS9jb2xsZWN0aW9uJyk7XG5cbiAgLy8gZXhwcmVzc2lvbiAocGFyc2UsIFBhcnNlciwgbm9kZXMsIGRvY3MpXG4gIG1hdGguZXhwcmVzc2lvbiA9IHt9O1xuICBtYXRoLmV4cHJlc3Npb24ubm9kZSA9IHJlcXVpcmUoJy4vZXhwcmVzc2lvbi9ub2RlL2luZGV4Jyk7XG4gIG1hdGguZXhwcmVzc2lvbi5wYXJzZSA9IHJlcXVpcmUoJy4vZXhwcmVzc2lvbi9wYXJzZScpO1xuICBtYXRoLmV4cHJlc3Npb24uUGFyc2VyID0gcmVxdWlyZSgnLi9leHByZXNzaW9uL1BhcnNlcicpO1xuICBtYXRoLmV4cHJlc3Npb24uZG9jcyA9IHJlcXVpcmUoJy4vZXhwcmVzc2lvbi9kb2NzL2luZGV4Jyk7XG5cbiAgLy8gZXhwcmVzc2lvbiBwYXJzZXJcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9leHByZXNzaW9uL2NvbXBpbGUnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9leHByZXNzaW9uL2V2YWwnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9leHByZXNzaW9uL2hlbHAnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9leHByZXNzaW9uL3BhcnNlJykobWF0aCwgX2NvbmZpZyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gYXJpdGhtZXRpY1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvYWJzJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9hZGQnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2NlaWwnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2N1YmUnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2RpdmlkZScpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvZG90RGl2aWRlJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9kb3RNdWx0aXBseScpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvZG90UG93JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9leHAnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2ZpeCcpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvZmxvb3InKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2djZCcpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvbGNtJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2xvZzEwJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9tb2QnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL211bHRpcGx5JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9ub3JtJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9wb3cnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL3JvdW5kJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9zaWduJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9zcXJ0JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9zcXVhcmUnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL3N1YnRyYWN0JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy91bmFyeU1pbnVzJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy91bmFyeVBsdXMnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL3hnY2QnKShtYXRoLCBfY29uZmlnKTtcblxuICAvLyBmdW5jdGlvbnMgLSByZWxhdGlvbmFsXG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9jb21wYXJlJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9kZWVwRXF1YWwnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2VxdWFsJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9sYXJnZXInKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2xhcmdlckVxJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9zbWFsbGVyJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9zbWFsbGVyRXEnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL3VuZXF1YWwnKShtYXRoLCBfY29uZmlnKTtcblxuICAvLyBmdW5jdGlvbnMgLSBjb21wbGV4XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vY29tcGxleC9hcmcnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21wbGV4L2NvbmonKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21wbGV4L3JlJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vY29tcGxleC9pbScpKG1hdGgsIF9jb25maWcpO1xuXG4gIC8vIGZ1bmN0aW9ucyAtIGNvbnN0cnVjdGlvblxuICByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9iaWdudW1iZXInKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vYm9vbGVhbicpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9jb21wbGV4JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vY29uc3RydWN0aW9uL2luZGV4JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vY29uc3RydWN0aW9uL21hdHJpeCcpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9udW1iZXInKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vcGFyc2VyJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vY29uc3RydWN0aW9uL3NlbGVjdCcpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9zdHJpbmcnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vdW5pdCcpKG1hdGgsIF9jb25maWcpO1xuXG4gIC8vIGZ1bmN0aW9ucyAtIG1hdHJpeFxuICByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9jb25jYXQnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvZGV0JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L2RpYWcnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvZXllJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L2ZsYXR0ZW4nKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvaW52JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L29uZXMnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvcmFuZ2UnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvcmVzaXplJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L3NpemUnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvc3F1ZWV6ZScpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9zdWJzZXQnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvdHJhbnNwb3NlJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L3plcm9zJykobWF0aCwgX2NvbmZpZyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gcHJvYmFiaWxpdHlcbiAgLy9yZXF1aXJlKCcuL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L2Rpc3RyaWJ1dGlvbicpKG1hdGgsIF9jb25maWcpOyAvLyBUT0RPOiByZXRoaW5rIG1hdGguZGlzdHJpYnV0aW9uXG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvZmFjdG9yaWFsJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvcmFuZG9tJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvcmFuZG9tSW50JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvcGlja1JhbmRvbScpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L3Blcm11dGF0aW9ucycpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L2NvbWJpbmF0aW9ucycpKG1hdGgsIF9jb25maWcpO1xuXG4gIC8vIGZ1bmN0aW9ucyAtIHN0YXRpc3RpY3NcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9zdGF0aXN0aWNzL21pbicpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWF4JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9tZWFuJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9tZWRpYW4nKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9zdGF0aXN0aWNzL3Byb2QnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi9zdGF0aXN0aWNzL3N0ZCcpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3Mvc3VtJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy92YXInKShtYXRoLCBfY29uZmlnKTtcblxuICAvLyBmdW5jdGlvbnMgLSB0cmlnb25vbWV0cnlcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNvcycpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2luJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2F0YW4nKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbjInKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY29zJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Nvc2gnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY290JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NvdGgnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY3NjJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NzY2gnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2VjJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3NlY2gnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2luJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3NpbmgnKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvdGFuJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3RhbmgnKShtYXRoLCBfY29uZmlnKTtcblxuICAvLyBmdW5jdGlvbnMgLSB1bml0c1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3VuaXRzL3RvJykobWF0aCwgX2NvbmZpZyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gdXRpbHNcbiAgcmVxdWlyZSgnLi9mdW5jdGlvbi91dGlscy9jbG9uZScpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2ZpbHRlcicpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2Zvcm1hdCcpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2ltcG9ydCcpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL21hcCcpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL3ByaW50JykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdXRpbHMvc29ydCcpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL3R5cGVvZicpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2ZvckVhY2gnKShtYXRoLCBfY29uZmlnKTtcblxuICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC4yNS4wLCByZW1vdmUgc29tZSBkYXkuXG4gIG1hdGguaWZFbHNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gaWZFbHNlIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgY29uZGl0aW9uYWwgb3BlcmF0b3IgaW5zdGVhZC4nKTtcbiAgfTtcblxuICAvLyBjb25zdGFudHNcbiAgcmVxdWlyZSgnLi9jb25zdGFudHMnKShtYXRoLCBfY29uZmlnKTtcblxuICAvLyBhdHRhY2ggdHJhbnNmb3JtIGZ1bmN0aW9ucyAoZm9yIGNvbnZlcnRpbmcgb25lLWJhc2VkIGluZGljZXMgdG8gemVyby1iYXNlZClcbiAgcmVxdWlyZSgnLi9leHByZXNzaW9uL3RyYW5zZm9ybS9jb25jYXQudHJhbnNmb3JtJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZXhwcmVzc2lvbi90cmFuc2Zvcm0vZmlsdGVyLnRyYW5zZm9ybScpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2V4cHJlc3Npb24vdHJhbnNmb3JtL2ZvckVhY2gudHJhbnNmb3JtJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZXhwcmVzc2lvbi90cmFuc2Zvcm0vaW5kZXgudHJhbnNmb3JtJykobWF0aCwgX2NvbmZpZyk7XG4gIHJlcXVpcmUoJy4vZXhwcmVzc2lvbi90cmFuc2Zvcm0vbWFwLnRyYW5zZm9ybScpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2V4cHJlc3Npb24vdHJhbnNmb3JtL21heC50cmFuc2Zvcm0nKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9leHByZXNzaW9uL3RyYW5zZm9ybS9tZWFuLnRyYW5zZm9ybScpKG1hdGgsIF9jb25maWcpO1xuICByZXF1aXJlKCcuL2V4cHJlc3Npb24vdHJhbnNmb3JtL21pbi50cmFuc2Zvcm0nKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9leHByZXNzaW9uL3RyYW5zZm9ybS9yYW5nZS50cmFuc2Zvcm0nKShtYXRoLCBfY29uZmlnKTtcbiAgcmVxdWlyZSgnLi9leHByZXNzaW9uL3RyYW5zZm9ybS9zdWJzZXQudHJhbnNmb3JtJykobWF0aCwgX2NvbmZpZyk7XG5cbiAgLy8gc2VsZWN0b3IgKHdlIGluaXRpYWxpemUgYWZ0ZXIgYWxsIGZ1bmN0aW9ucyBhcmUgbG9hZGVkKVxuICBtYXRoLmNoYWluaW5nID0ge307XG4gIG1hdGguY2hhaW5pbmcuU2VsZWN0b3IgPSByZXF1aXJlKCcuL2NoYWluaW5nL1NlbGVjdG9yJykobWF0aCwgX2NvbmZpZyk7XG5cbiAgLy8gYXBwbHkgcHJvdmlkZWQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gIG1hdGguY29uZmlnKF9jb25maWcpOyAvLyBhcHBseSB0aGUgZGVmYXVsdCBvcHRpb25zXG4gIG1hdGguY29uZmlnKGNvbmZpZyk7ICAvLyBhcHBseSBjdXN0b20gb3B0aW9uc1xuXG4gIC8vIHJldHVybiB0aGUgbmV3IGluc3RhbmNlXG4gIHJldHVybiBtYXRoO1xufVxuXG4vLyBjcmVhdGUgYSBkZWZhdWx0IGluc3RhbmNlIG9mIG1hdGguanNcbnZhciBtYXRoID0gY3JlYXRlKCk7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cubWF0aGpzID0gbWF0aDsgLy8gVE9ETzogZGVwcmVjYXRlIHRoZSBtYXRoanMgbmFtZXNwYWNlIHNvbWUgZGF5IChyZXBsYWNlZCB3aXRoICdtYXRoJyBzaW5jZSB2ZXJzaW9uIDAuMjUuMClcbn1cblxuLy8gZXhwb3J0IHRoZSBkZWZhdWx0IGluc3RhbmNlXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGg7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5Bcmd1bWVudHNFcnJvciA9IHJlcXVpcmUoJy4vQXJndW1lbnRzRXJyb3InKTtcbmV4cG9ydHMuRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuL0RpbWVuc2lvbkVycm9yJyk7XG5leHBvcnRzLkluZGV4RXJyb3IgPSByZXF1aXJlKCcuL0luZGV4RXJyb3InKTtcbmV4cG9ydHMuVW5zdXBwb3J0ZWRUeXBlRXJyb3IgPSByZXF1aXJlKCcuL1Vuc3VwcG9ydGVkVHlwZUVycm9yJyk7XG5cbi8vIFRPRE86IGltcGxlbWVudCBhbiBJbnZhbGlkVmFsdWVFcnJvcj9cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2luZGV4JyksXG4gICAgVW5pdCA9IHJlcXVpcmUoJy4vVW5pdCcpLFxuICAgIG51bWJlciA9IHV0aWwubnVtYmVyLFxuXG4gICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICBpc1VuaXQgPSBVbml0LmlzVW5pdCxcbiAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBDb21wbGV4XG4gKlxuICogQSBjb21wbGV4IHZhbHVlIGNhbiBiZSBjb25zdHJ1Y3RlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAgICAgdmFyIGEgPSBuZXcgQ29tcGxleCgpO1xuICogICAgIHZhciBiID0gbmV3IENvbXBsZXgocmUsIGltKTtcbiAqICAgICB2YXIgYyA9IENvbXBsZXgucGFyc2Uoc3RyKTtcbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICogICAgIHZhciBhID0gbmV3IENvbXBsZXgoMywgLTQpOyAgICAgIC8vIDMgLSA0aVxuICogICAgIGEucmUgPSA1OyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgPSA1IC0gNGlcbiAqICAgICB2YXIgaSA9IGEuaW07ICAgICAgICAgICAgICAgICAgICAvLyAtNDtcbiAqICAgICB2YXIgYiA9IENvbXBsZXgucGFyc2UoJzIgKyA2aScpOyAvLyAyICsgNmlcbiAqICAgICB2YXIgYyA9IG5ldyBDb21wbGV4KCk7ICAgICAgICAgICAvLyAwICsgMGlcbiAqICAgICB2YXIgZCA9IG1hdGguYWRkKGEsIGIpOyAgICAgICAgICAvLyA1ICsgMmlcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gcmUgICAgICAgVGhlIHJlYWwgcGFydCBvZiB0aGUgY29tcGxleCB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtpbV0gICAgIFRoZSBpbWFnaW5hcnkgcGFydCBvZiB0aGUgY29tcGxleCB2YWx1ZVxuICovXG5mdW5jdGlvbiBDb21wbGV4KHJlLCBpbSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tcGxleCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICB9XG5cbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgdGhpcy5yZSA9IDA7XG4gICAgICB0aGlzLmltID0gMDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZigncmUnIGluIGFyZyAmJiAnaW0nIGluIGFyZykge1xuICAgICAgICAgIHZhciBjb25zdHJ1Y3QgPSBuZXcgQ29tcGxleChhcmcucmUsIGFyZy5pbSk7IC8vIHBhc3Mgb24gaW5wdXQgdmFsaWRhdGlvblxuICAgICAgICAgIHRoaXMucmUgPSBjb25zdHJ1Y3QucmU7XG4gICAgICAgICAgdGhpcy5pbSA9IGNvbnN0cnVjdC5pbTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICgncicgaW4gYXJnICYmICdwaGknIGluIGFyZykge1xuICAgICAgICAgIHZhciBjb25zdHJ1Y3QgPSBDb21wbGV4LmZyb21Qb2xhcihhcmcuciwgYXJnLnBoaSk7XG4gICAgICAgICAgdGhpcy5yZSA9IGNvbnN0cnVjdC5yZTtcbiAgICAgICAgICB0aGlzLmltID0gY29uc3RydWN0LmltO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IFxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdPYmplY3Qgd2l0aCB0aGUgcmUgYW5kIGltIG9yIHIgYW5kIHBoaSBwcm9wZXJ0aWVzIGV4cGVjdGVkLicpO1xuXG4gICAgY2FzZSAyOlxuICAgICAgaWYgKCFpc051bWJlcihyZSkgfHwgIWlzTnVtYmVyKGltKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUd28gbnVtYmVycyBleHBlY3RlZCBpbiBDb21wbGV4IGNvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlID0gcmU7XG4gICAgICB0aGlzLmltID0gaW07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ09uZSwgdHdvIG9yIHRocmVlIGFyZ3VtZW50cyBleHBlY3RlZCBpbiBDb21wbGV4IGNvbnN0cnVjdG9yJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdmFsdWUgaXMgYSBDb21wbGV4IHZhbHVlXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc0NvbXBsZXhcbiAqL1xuQ29tcGxleC5pc0NvbXBsZXggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIENvbXBsZXgpO1xufTtcblxuLy8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlIHBhcnNlclxudmFyIHRleHQsIGluZGV4LCBjO1xuXG5mdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgd2hpbGUgKGMgPT0gJyAnIHx8IGMgPT0gJ1xcdCcpIHtcbiAgICBuZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNEaWdpdERvdCAoYykge1xuICByZXR1cm4gKChjID49ICcwJyAmJiBjIDw9ICc5JykgfHwgYyA9PSAnLicpO1xufVxuXG5mdW5jdGlvbiBpc0RpZ2l0IChjKSB7XG4gIHJldHVybiAoKGMgPj0gJzAnICYmIGMgPD0gJzknKSk7XG59XG5cbmZ1bmN0aW9uIG5leHQoKSB7XG4gIGluZGV4Kys7XG4gIGMgPSB0ZXh0LmNoYXJBdChpbmRleCk7XG59XG5cbmZ1bmN0aW9uIHJldmVydChvbGRJbmRleCkge1xuICBpbmRleCA9IG9sZEluZGV4O1xuICBjID0gdGV4dC5jaGFyQXQoaW5kZXgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU51bWJlciAoKSB7XG4gIHZhciBudW1iZXIgPSAnJztcbiAgdmFyIG9sZEluZGV4O1xuICBvbGRJbmRleCA9IGluZGV4O1xuXG4gIGlmIChjID09ICcrJykge1xuICAgIG5leHQoKTtcbiAgfVxuICBlbHNlIGlmIChjID09ICctJykge1xuICAgIG51bWJlciArPSBjO1xuICAgIG5leHQoKTtcbiAgfVxuXG4gIGlmICghaXNEaWdpdERvdChjKSkge1xuICAgIC8vIGEgKyBvciAtIG11c3QgYmUgZm9sbG93ZWQgYnkgYSBkaWdpdFxuICAgIHJldmVydChvbGRJbmRleCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBnZXQgbnVtYmVyLCBjYW4gaGF2ZSBhIHNpbmdsZSBkb3RcbiAgaWYgKGMgPT0gJy4nKSB7XG4gICAgbnVtYmVyICs9IGM7XG4gICAgbmV4dCgpO1xuICAgIGlmICghaXNEaWdpdChjKSkge1xuICAgICAgLy8gdGhpcyBpcyBubyBsZWdhbCBudW1iZXIsIGl0IGlzIGp1c3QgYSBkb3RcbiAgICAgIHJldmVydChvbGRJbmRleCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgd2hpbGUgKGlzRGlnaXQoYykpIHtcbiAgICAgIG51bWJlciArPSBjO1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgICBpZiAoYyA9PSAnLicpIHtcbiAgICAgIG51bWJlciArPSBjO1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEaWdpdChjKSkge1xuICAgIG51bWJlciArPSBjO1xuICAgIG5leHQoKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBleHBvbmVudGlhbCBub3RhdGlvbiBsaWtlIFwiMi4zZS00XCIgb3IgXCIxLjIzZTUwXCJcbiAgaWYgKGMgPT0gJ0UnIHx8IGMgPT0gJ2UnKSB7XG4gICAgbnVtYmVyICs9IGM7XG4gICAgbmV4dCgpO1xuXG4gICAgaWYgKGMgPT0gJysnIHx8IGMgPT0gJy0nKSB7XG4gICAgICBudW1iZXIgKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICAvLyBTY2llbnRpZmljIG5vdGF0aW9uIE1VU1QgYmUgZm9sbG93ZWQgYnkgYW4gZXhwb25lbnRcbiAgICBpZiAoIWlzRGlnaXQoYykpIHtcbiAgICAgIC8vIHRoaXMgaXMgbm8gbGVnYWwgbnVtYmVyLCBleHBvbmVudCBpcyBtaXNzaW5nLlxuICAgICAgcmV2ZXJ0KG9sZEluZGV4KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlIChpc0RpZ2l0KGMpKSB7XG4gICAgICBudW1iZXIgKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbXBsZXggKCkge1xuICAvLyBjaGVjayBmb3IgJ2knLCAnLWknLCAnK2knXG4gIHZhciBjbmV4dCA9IHRleHQuY2hhckF0KGluZGV4ICsgMSk7XG4gIGlmIChjID09ICdJJyB8fCBjID09ICdpJykge1xuICAgIG5leHQoKTtcbiAgICByZXR1cm4gJzEnO1xuICB9XG4gIGVsc2UgaWYgKChjID09ICcrJyB8fCBjID09ICctJykgJiYgKGNuZXh0ID09ICdJJyB8fCBjbmV4dCA9PSAnaScpKSB7XG4gICAgdmFyIG51bWJlciA9IChjID09ICcrJykgPyAnMScgOiAnLTEnO1xuICAgIG5leHQoKTtcbiAgICBuZXh0KCk7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgY29tcGxleCBudW1iZXIgZnJvbSBhIHN0cmluZy4gRm9yIGV4YW1wbGUgQ29tcGxleC5wYXJzZShcIjIgKyAzaVwiKVxuICogd2lsbCByZXR1cm4gYSBDb21wbGV4IHZhbHVlIHdoZXJlIHJlID0gMiwgaW0gPSAzLlxuICogUmV0dXJucyBudWxsIGlmIHByb3ZpZGVkIHN0cmluZyBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgY29tcGxleCBudW1iZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7Q29tcGxleCB8IG51bGx9IGNvbXBsZXhcbiAqL1xuQ29tcGxleC5wYXJzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdGV4dCA9IHN0cjtcbiAgaW5kZXggPSAtMTtcbiAgYyA9ICcnO1xuXG4gIGlmICghaXNTdHJpbmcodGV4dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG5leHQoKTtcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgdmFyIGZpcnN0ID0gcGFyc2VOdW1iZXIoKTtcbiAgaWYgKGZpcnN0KSB7XG4gICAgaWYgKGMgPT0gJ0knIHx8IGMgPT0gJ2knKSB7XG4gICAgICAvLyBwdXJlIGltYWdpbmFyeSBudW1iZXJcbiAgICAgIG5leHQoKTtcbiAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICBpZiAoYykge1xuICAgICAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQuIG5vdCBnb29kLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAsIE51bWJlcihmaXJzdCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggYW5kIHJlYWwgcGFydFxuICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgIHZhciBzZXBhcmF0b3IgPSBjO1xuICAgICAgaWYgKHNlcGFyYXRvciAhPSAnKycgJiYgc2VwYXJhdG9yICE9ICctJykge1xuICAgICAgICAvLyBwdXJlIHJlYWwgbnVtYmVyXG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kLiBub3QgZ29vZC5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChOdW1iZXIoZmlyc3QpLCAwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBjb21wbGV4IGFuZCByZWFsIHBhcnRcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICB2YXIgc2Vjb25kID0gcGFyc2VOdW1iZXIoKTtcbiAgICAgICAgaWYgKHNlY29uZCkge1xuICAgICAgICAgIGlmIChjICE9ICdJJyAmJiBjICE9ICdpJykge1xuICAgICAgICAgICAgLy8gJ2knIG1pc3NpbmcgYXQgdGhlIGVuZCBvZiB0aGUgY29tcGxleCBudW1iZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2Vjb25kID0gcGFyc2VDb21wbGV4KCk7XG4gICAgICAgICAgaWYgKCFzZWNvbmQpIHtcbiAgICAgICAgICAgIC8vIGltYWdpbmFyeSBudW1iZXIgbWlzc2luZyBhZnRlciBzZXBhcmF0b3JcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT0gJy0nKSB7XG4gICAgICAgICAgaWYgKHNlY29uZFswXSA9PSAnLScpIHtcbiAgICAgICAgICAgIHNlY29uZCA9ICAnKycgKyBzZWNvbmQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlY29uZCA9ICctJyArIHNlY29uZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kLiBub3QgZ29vZC5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChOdW1iZXIoZmlyc3QpLCBOdW1iZXIoc2Vjb25kKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGNoZWNrIGZvciAnaScsICctaScsICcraSdcbiAgICBmaXJzdCA9IHBhcnNlQ29tcGxleCgpO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIC8vIGdhcmJhZ2UgYXQgdGhlIGVuZC4gbm90IGdvb2QuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoMCwgTnVtYmVyKGZpcnN0KSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGNvbXBsZXggbnVtYmVyIGZyb20gcG9sYXIgY29vcmRpbmF0ZXNcbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAgQ29tcGxleC5mcm9tUG9sYXIocjogTnVtYmVyLCBwaGk6IE51bWJlcikgOiBDb21wbGV4XG4gKiAgICAgQ29tcGxleC5mcm9tUG9sYXIoe3I6IE51bWJlciwgcGhpOiBOdW1iZXJ9KSA6IENvbXBsZXhcbiAqXG4gKiBAcGFyYW0geyp9IGFyZ3MuLi5cbiAqIEByZXR1cm4ge0NvbXBsZXh9XG4gKi9cbkNvbXBsZXguZnJvbVBvbGFyID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBDb21wbGV4LmZyb21Qb2xhcihhcmcuciwgYXJnLnBoaSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBoYXMgdG8gYmUgYW4gb2JqZWN0IHdpdGggciBhbmQgcGhpIGtleXMuJyk7XG5cbiAgICBjYXNlIDI6XG4gICAgICB2YXIgciA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgcGhpID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYoaXNOdW1iZXIocikpIHtcbiAgICAgICAgaWYgKGlzVW5pdChwaGkpICYmIHBoaS5oYXNCYXNlKFVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcbiAgICAgICAgICAvLyBjb252ZXJ0IHVuaXQgdG8gYSBudW1iZXIgaW4gcmFkaWFuc1xuICAgICAgICAgIHBoaSA9IHBoaS50b051bWJlcigncmFkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihpc051bWJlcihwaGkpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHIgKiBNYXRoLmNvcyhwaGkpLCByICogTWF0aC5zaW4ocGhpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQaGkgaXMgbm90IGEgbnVtYmVyIG5vciBhbiBhbmdsZSB1bml0LicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmFkaXVzIHIgaXMgbm90IGEgbnVtYmVyLicpO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiBmdW5jdGlvbiBmcm9tUG9sYXInKTtcbiAgfVxufTtcblxuLypcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGNvbXBsZXggbnVtYmVyIGluIHBvbGFyIG5vdGF0aW9uXG4gKiBUaGUgYW5nbGUgcGhpIHdpbGwgYmUgc2V0IGluIHRoZSBpbnRlcnZhbCBvZiBbLXBpLCBwaV0uXG4gKiBAcmV0dXJuIHt7cjogbnVtYmVyLCBwaGk6IG51bWJlcn19IFJldHVybnMgYW5kIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgciBhbmQgcGhpLlxuICovXG5Db21wbGV4LnByb3RvdHlwZS50b1BvbGFyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcjogTWF0aC5zcXJ0KHRoaXMucmUgKiB0aGlzLnJlICsgdGhpcy5pbSAqIHRoaXMuaW0pLFxuICAgIHBoaTogTWF0aC5hdGFuMih0aGlzLmltLCB0aGlzLnJlKVxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjb21wbGV4IHZhbHVlXG4gKiBAcmV0dXJuIHtDb21wbGV4fSBjbG9uZVxuICovXG5Db21wbGV4LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBDb21wbGV4KHRoaXMucmUsIHRoaXMuaW0pO1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhpcyBjb21wbGV4IG51bWJlciBlcXVhbHMgYW4gb3RoZXIgY29tcGxleCB2YWx1ZS5cbiAqIFR3byBjb21wbGV4IG51bWJlcnMgYXJlIGVxdWFsIHdoZW4gYm90aCB0aGVpciByZWFsIGFuZCBpbWFnaW5hcnkgcGFydHNcbiAqIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7Q29tcGxleH0gb3RoZXJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlzRXF1YWxcbiAqL1xuQ29tcGxleC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHJldHVybiAodGhpcy5yZSA9PT0gb3RoZXIucmUpICYmICh0aGlzLmltID09PSBvdGhlci5pbSk7XG59O1xuXG4vKipcbiAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tcGxleCBudW1iZXIsXG4gKiB3aXRoIG9wdGlvbmFsIGZvcm1hdHRpbmcgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0IHwgTnVtYmVyIHwgRnVuY3Rpb259IFtvcHRpb25zXSAgRm9ybWF0dGluZyBvcHRpb25zLiBTZWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliL3V0aWwvbnVtYmVyOmZvcm1hdCBmb3IgYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiBvZiB0aGUgYXZhaWxhYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0clxuICovXG5Db21wbGV4LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgc3RyID0gJycsXG4gICAgICBzdHJSZSA9IG51bWJlci5mb3JtYXQodGhpcy5yZSwgb3B0aW9ucyksXG4gICAgICBzdHJJbSA9IG51bWJlci5mb3JtYXQodGhpcy5pbSwgb3B0aW9ucyk7XG5cbiAgaWYgKHRoaXMuaW0gPT0gMCkge1xuICAgIC8vIHJlYWwgdmFsdWVcbiAgICBzdHIgPSBzdHJSZTtcbiAgfVxuICBlbHNlIGlmICh0aGlzLnJlID09IDApIHtcbiAgICAvLyBwdXJlbHkgY29tcGxleCB2YWx1ZVxuICAgIGlmICh0aGlzLmltID09IDEpIHtcbiAgICAgIHN0ciA9ICdpJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pbSA9PSAtMSkge1xuICAgICAgc3RyID0gJy1pJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdHIgPSBzdHJJbSArICdpJztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gY29tcGxleCB2YWx1ZVxuICAgIGlmICh0aGlzLmltID4gMCkge1xuICAgICAgaWYgKHRoaXMuaW0gPT0gMSkge1xuICAgICAgICBzdHIgPSBzdHJSZSArICcgKyBpJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHIgPSBzdHJSZSArICcgKyAnICsgc3RySW0gKyAnaSc7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMuaW0gPT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyUmUgKyAnIC0gaSc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RyID0gc3RyUmUgKyAnIC0gJyArIHN0ckltLnN1YnN0cmluZygxKSArICdpJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXBsZXggbnVtYmVyLlxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqL1xuQ29tcGxleC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmZvcm1hdCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21wbGV4IG51bWJlci5cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyXG4gKi9cbkNvbXBsZXgucHJvdG90eXBlLnZhbHVlT2YgPSBDb21wbGV4LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gZXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBDb21wbGV4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvaW5kZXgnKTtcblxudmFyIG51bWJlciA9IHV0aWwubnVtYmVyO1xudmFyIHN0cmluZyA9IHV0aWwuc3RyaW5nO1xudmFyIGFycmF5ID0gdXRpbC5hcnJheTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUmFuZ2VcbiAqIENyZWF0ZSBhIHJhbmdlLiBBIHJhbmdlIGhhcyBhIHN0YXJ0LCBzdGVwLCBhbmQgZW5kLCBhbmQgY29udGFpbnMgZnVuY3Rpb25zXG4gKiB0byBpdGVyYXRlIG92ZXIgdGhlIHJhbmdlLlxuICpcbiAqIEEgcmFuZ2UgY2FuIGJlIGNvbnN0cnVjdGVkIGFzOlxuICogICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgZW5kKTtcbiAqICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCk7XG4gKlxuICogVG8gZ2V0IHRoZSByZXN1bHQgb2YgdGhlIHJhbmdlOlxuICogICAgIHJhbmdlLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coeCk7XG4gKiAgICAgfSk7XG4gKiAgICAgcmFuZ2UubWFwKGZ1bmN0aW9uICh4KSB7XG4gKiAgICAgICAgIHJldHVybiBtYXRoLnNpbih4KTtcbiAqICAgICB9KTtcbiAqICAgICByYW5nZS50b0FycmF5KCk7XG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqICAgICB2YXIgYyA9IG5ldyBSYW5nZSgyLCA2KTsgICAgICAgICAvLyAyOjE6NVxuICogICAgIGMudG9BcnJheSgpOyAgICAgICAgICAgICAgICAgICAgIC8vIFsyLCAzLCA0LCA1XVxuICogICAgIHZhciBkID0gbmV3IFJhbmdlKDIsIC0zLCAtMSk7ICAgIC8vIDI6LTE6LTJcbiAqICAgICBkLnRvQXJyYXkoKTsgICAgICAgICAgICAgICAgICAgICAvLyBbMiwgMSwgMCwgLTEsIC0yXVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCAgaW5jbHVkZWQgbG93ZXIgYm91bmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgICAgZXhjbHVkZWQgdXBwZXIgYm91bmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RlcF0gc3RlcCBzaXplLCBkZWZhdWx0IHZhbHVlIGlzIDFcbiAqL1xuZnVuY3Rpb24gUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIGlmIChzdGFydCAhPSBudWxsICYmICFudW1iZXIuaXNOdW1iZXIoc3RhcnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVyIHN0YXJ0IG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoZW5kICE9IG51bGwgJiYgIW51bWJlci5pc051bWJlcihlbmQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVyIGVuZCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHN0ZXAgIT0gbnVsbCAmJiAhbnVtYmVyLmlzTnVtYmVyKHN0ZXApKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVyIHN0ZXAgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG5cbiAgdGhpcy5zdGFydCA9IChzdGFydCAhPSBudWxsKSA/IHBhcnNlRmxvYXQoc3RhcnQpIDogMDtcbiAgdGhpcy5lbmQgICA9IChlbmQgIT0gbnVsbCkgPyBwYXJzZUZsb2F0KGVuZCkgOiAwO1xuICB0aGlzLnN0ZXAgID0gKHN0ZXAgIT0gbnVsbCkgPyBwYXJzZUZsb2F0KHN0ZXApIDogMTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBpbnRvIGEgcmFuZ2UsXG4gKiBUaGUgc3RyaW5nIGNvbnRhaW5zIHRoZSBzdGFydCwgb3B0aW9uYWwgc3RlcCwgYW5kIGVuZCwgc2VwYXJhdGVkIGJ5IGEgY29sb24uXG4gKiBJZiB0aGUgc3RyaW5nIGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCByYW5nZSwgbnVsbCBpcyByZXR1cm5lZC5cbiAqIEZvciBleGFtcGxlIHN0cj0nMDoyOjExJy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1JhbmdlIHwgbnVsbH0gcmFuZ2VcbiAqL1xuUmFuZ2UucGFyc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICghc3RyaW5nLmlzU3RyaW5nKHN0cikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhcmdzID0gc3RyLnNwbGl0KCc6Jyk7XG4gIHZhciBudW1zID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGFyZyk7XG4gIH0pO1xuXG4gIHZhciBpbnZhbGlkID0gbnVtcy5zb21lKGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gaXNOYU4obnVtKTtcbiAgfSk7XG4gIGlmKGludmFsaWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAobnVtcy5sZW5ndGgpIHtcbiAgICBjYXNlIDI6IHJldHVybiBuZXcgUmFuZ2UobnVtc1swXSwgbnVtc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gbmV3IFJhbmdlKG51bXNbMF0sIG51bXNbMl0sIG51bXNbMV0pO1xuICAgIGRlZmF1bHQ6IHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGNsb25lIG9mIHRoZSByYW5nZVxuICogQHJldHVybiB7UmFuZ2V9IGNsb25lXG4gKi9cblJhbmdlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy5zdGVwKTtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyBhIFJhbmdlXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNSYW5nZVxuICovXG5SYW5nZS5pc1JhbmdlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gKG9iamVjdCBpbnN0YW5jZW9mIFJhbmdlKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHNpemUgb2YgdGhlIHJhbmdlLlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIG9uZSBudW1iZXIsIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHJhbmdlLlxuICogQHJldHVybnMge051bWJlcltdfSBzaXplXG4gKi9cblJhbmdlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuID0gMCxcbiAgICAgIHN0YXJ0ID0gdGhpcy5zdGFydCxcbiAgICAgIHN0ZXAgPSB0aGlzLnN0ZXAsXG4gICAgICBlbmQgPSB0aGlzLmVuZCxcbiAgICAgIGRpZmYgPSBlbmQgLSBzdGFydDtcblxuICBpZiAobnVtYmVyLnNpZ24oc3RlcCkgPT0gbnVtYmVyLnNpZ24oZGlmZikpIHtcbiAgICBsZW4gPSBNYXRoLmNlaWwoKGRpZmYpIC8gc3RlcCk7XG4gIH1cbiAgZWxzZSBpZiAoZGlmZiA9PSAwKSB7XG4gICAgbGVuID0gMDtcbiAgfVxuXG4gIGlmIChpc05hTihsZW4pKSB7XG4gICAgbGVuID0gMDtcbiAgfVxuICByZXR1cm4gW2xlbl07XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2VcbiAqIEByZXR1cm4ge051bWJlciB8IHVuZGVmaW5lZH0gbWluXG4gKi9cblJhbmdlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzaXplID0gdGhpcy5zaXplKClbMF07XG5cbiAgaWYgKHNpemUgPiAwKSB7XG4gICAgaWYgKHRoaXMuc3RlcCA+IDApIHtcbiAgICAgIC8vIHBvc2l0aXZlIHN0ZXBcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIG5lZ2F0aXZlIHN0ZXBcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgKHNpemUgLSAxKSAqIHRoaXMuc3RlcDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlXG4gKiBAcmV0dXJuIHtOdW1iZXIgfCB1bmRlZmluZWR9IG1heFxuICovXG5SYW5nZS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSgpWzBdO1xuXG4gIGlmIChzaXplID4gMCkge1xuICAgIGlmICh0aGlzLnN0ZXAgPiAwKSB7XG4gICAgICAvLyBwb3NpdGl2ZSBzdGVwXG4gICAgICByZXR1cm4gdGhpcy5zdGFydCArIChzaXplIC0gMSkgKiB0aGlzLnN0ZXA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gbmVnYXRpdmUgc3RlcFxuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQ7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBFeGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUgaW4gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBUaGUgY2FsbGJhY2sgbWV0aG9kIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQsIHRoZSBpbmRleFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgZWxlbWVudCwgYW5kIHRoZSBNYXRyaXggYmVpbmcgdHJhdmVyc2VkLlxuICovXG5SYW5nZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB2YXIgeCA9IHRoaXMuc3RhcnQ7XG4gIHZhciBzdGVwID0gdGhpcy5zdGVwO1xuICB2YXIgZW5kID0gdGhpcy5lbmQ7XG4gIHZhciBpID0gMDtcblxuICBpZiAoc3RlcCA+IDApIHtcbiAgICB3aGlsZSAoeCA8IGVuZCkge1xuICAgICAgY2FsbGJhY2soeCwgaSwgdGhpcyk7XG4gICAgICB4ICs9IHN0ZXA7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgd2hpbGUgKHggPiBlbmQpIHtcbiAgICAgIGNhbGxiYWNrKHgsIGksIHRoaXMpO1xuICAgICAgeCArPSBzdGVwO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUgaW4gdGhlIFJhbmdlLCBhbmQgcmV0dXJuIHRoZVxuICogcmVzdWx0cyBhcyBhbiBhcnJheVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBUaGUgY2FsbGJhY2sgbWV0aG9kIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQsIHRoZSBpbmRleFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgZWxlbWVudCwgYW5kIHRoZSBNYXRyaXggYmVpbmcgdHJhdmVyc2VkLlxuICogQHJldHVybnMge0FycmF5fSBhcnJheVxuICovXG5SYW5nZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgb2JqKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBvYmopO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gQXJyYXkgd2l0aCBhIGNvcHkgb2YgdGhlIFJhbmdlcyBkYXRhXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gKi9cblJhbmdlLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBwcmltaXRpdmUgdmFsdWUgb2YgdGhlIFJhbmdlLCBhIG9uZSBkaW1lbnNpb25hbCBhcnJheVxuICogQHJldHVybnMge0FycmF5fSBhcnJheVxuICovXG5SYW5nZS5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVE9ETzogaW1wbGVtZW50IGEgY2FjaGluZyBtZWNoYW5pc20gZm9yIHJhbmdlLnZhbHVlT2YoKVxuICByZXR1cm4gdGhpcy50b0FycmF5KCk7XG59O1xuXG4vKipcbiAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmFuZ2UsIHdpdGggb3B0aW9uYWwgZm9ybWF0dGluZyBvcHRpb25zLlxuICogT3V0cHV0IGlzIGZvcm1hdHRlZCBhcyAnc3RhcnQ6c3RlcDplbmQnLCBmb3IgZXhhbXBsZSAnMjo2JyBvciAnMDowLjI6MTEnXG4gKiBAcGFyYW0ge09iamVjdCB8IE51bWJlciB8IEZ1bmN0aW9ufSBbb3B0aW9uc10gIEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYi91dGlsL251bWJlcjpmb3JtYXQgZm9yIGFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gb2YgdGhlIGF2YWlsYWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLlxuICogQHJldHVybnMge1N0cmluZ30gc3RyXG4gKi9cblJhbmdlLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgc3RyID0gbnVtYmVyLmZvcm1hdCh0aGlzLnN0YXJ0LCBvcHRpb25zKTtcblxuICBpZiAodGhpcy5zdGVwICE9IDEpIHtcbiAgICBzdHIgKz0gJzonICsgbnVtYmVyLmZvcm1hdCh0aGlzLnN0ZXAsIG9wdGlvbnMpO1xuICB9XG4gIHN0ciArPSAnOicgKyBudW1iZXIuZm9ybWF0KHRoaXMuZW5kLCBvcHRpb25zKTtcbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByYW5nZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZm9ybWF0KCk7XG59O1xuXG4vLyBleHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvaW5kZXgnKSxcblxuICAgIFJhbmdlID0gcmVxdWlyZSgnLi9SYW5nZScpLFxuXG4gICAgbnVtYmVyID0gdXRpbC5udW1iZXIsXG5cbiAgICBpc051bWJlciA9IG51bWJlci5pc051bWJlcixcbiAgICBpc0ludGVnZXIgPSBudW1iZXIuaXNJbnRlZ2VyLFxuICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIEBDb25zdHJ1Y3RvciBJbmRleFxuICogQ3JlYXRlIGFuIGluZGV4LiBBbiBJbmRleCBjYW4gc3RvcmUgcmFuZ2VzIGhhdmluZyBzdGFydCwgc3RlcCwgYW5kIGVuZFxuICogZm9yIG11bHRpcGxlIGRpbWVuc2lvbnMuXG4gKiBNYXRyaXguZ2V0LCBNYXRyaXguc2V0LCBhbmQgbWF0aC5zdWJzZXQgYWNjZXB0IGFuIEluZGV4IGFzIGlucHV0LlxuICpcbiAqIFVzYWdlOlxuICogICAgIHZhciBpbmRleCA9IG5ldyBJbmRleChyYW5nZTEsIHJhbmdlMiwgLi4uKTtcbiAqXG4gKiBXaGVyZSBlYWNoIHJhbmdlIGNhbiBiZSBhbnkgb2Y6XG4gKiAgICAgQW4gYXJyYXkgW3N0YXJ0LCBlbmRdXG4gKiAgICAgQW4gYXJyYXkgW3N0YXJ0LCBlbmQsIHN0ZXBdXG4gKiAgICAgQSBudW1iZXJcbiAqICAgICBBbiBpbnN0YW5jZSBvZiBSYW5nZVxuICpcbiAqIFRoZSBwYXJhbWV0ZXJzIHN0YXJ0LCBlbmQsIGFuZCBzdGVwIG11c3QgYmUgaW50ZWdlciBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7Li4uKn0gcmFuZ2VzXG4gKi9cbmZ1bmN0aW9uIEluZGV4KHJhbmdlcykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5kZXgpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIHRoaXMuX3JhbmdlcyA9IFtdO1xuICB0aGlzLl9pc1NjYWxhciA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgICB0aGlzLl9yYW5nZXMucHVzaChhcmcpO1xuICAgICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheShhcmcpKSB7XG4gICAgICB0aGlzLl9yYW5nZXMucHVzaChfY3JlYXRlUmFuZ2UoYXJnKSk7XG4gICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc051bWJlcihhcmcpKSB7XG4gICAgICB0aGlzLl9yYW5nZXMucHVzaChfY3JlYXRlUmFuZ2UoW2FyZywgYXJnICsgMV0pKTtcbiAgICB9XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHN1cHBvcnQgZm9yIHdpbGRjYXJkICcqJ1xuICAgIGVsc2Uge1xuICAgICAgdmFyIHByaW1pdGl2ZSA9IGFyZy52YWx1ZU9mKCk7IC8vIGZvciBleGFtcGxlIHR1cm4gYSBNYXRyaXggaW50byBhbiBBcnJheVxuICAgICAgaWYgKGlzQXJyYXkocHJpbWl0aXZlKSkge1xuICAgICAgICB0aGlzLl9yYW5nZXMucHVzaChfY3JlYXRlUmFuZ2UocHJpbWl0aXZlKSk7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmFuZ2VzIG11c3QgYmUgYW4gQXJyYXksIE51bWJlciwgb3IgUmFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBhcmd1bWVudCBpbnRvIGEgcmFuZ2UgYW5kIHZhbGlkYXRlIHRoZSByYW5nZVxuICogQHBhcmFtIHtBcnJheX0gYXJnICBBbiBhcnJheSB3aXRoIFtzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcl0gYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsIGEgdGhpcmQgZWxlbWVudCBzdGVwOk51bWJlclxuICogQHJldHVybiB7UmFuZ2V9IHJhbmdlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfY3JlYXRlUmFuZ2UoYXJnKSB7XG4gIC8vIFRPRE86IG1ha2UgZnVuY3Rpb24gX2NyZWF0ZVJhbmdlIHNpbXBsZXIvZmFzdGVyXG5cbiAgLy8gdGVzdCB3aGV0aGVyIGFsbCBhcmd1bWVudHMgYXJlIGludGVnZXJzXG4gIHZhciBudW0gPSBhcmcubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgaWYgKCFpc051bWJlcihhcmdbaV0pIHx8ICFpc0ludGVnZXIoYXJnW2ldKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5kZXggcGFyYW1ldGVycyBtdXN0IGJlIGludGVnZXIgbnVtYmVycycpO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAoYXJnLmxlbmd0aCkge1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoYXJnWzBdLCBhcmdbMV0pOyAvLyBzdGFydCwgZW5kXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShhcmdbMF0sIGFyZ1sxXSwgYXJnWzJdKTsgLy8gc3RhcnQsIGVuZCwgc3RlcFxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUT0RPOiBpbXByb3ZlIGVycm9yIG1lc3NhZ2VcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiBJbmRleCAoMiBvciAzIGV4cGVjdGVkKScpO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhlIGluZGV4XG4gKiBAcmV0dXJuIHtJbmRleH0gY2xvbmVcbiAqL1xuSW5kZXgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW5kZXggPSBuZXcgSW5kZXgoKTtcbiAgaW5kZXguX3JhbmdlcyA9IHV0aWwub2JqZWN0LmNsb25lKHRoaXMuX3Jhbmdlcyk7XG4gIGluZGV4Ll9pc1NjYWxhciA9IHRoaXMuX2lzU2NhbGFyO1xuICByZXR1cm4gaW5kZXg7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgYW4gSW5kZXhcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc0luZGV4XG4gKi9cbkluZGV4LmlzSW5kZXggPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiAob2JqZWN0IGluc3RhbmNlb2YgSW5kZXgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5kZXggZnJvbSBhbiBhcnJheSB3aXRoIHJhbmdlcy9udW1iZXJzXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheSB8IE51bWJlcj59IHJhbmdlc1xuICogQHJldHVybiB7SW5kZXh9IGluZGV4XG4gKiBAcHJpdmF0ZVxuICovXG5JbmRleC5jcmVhdGUgPSBmdW5jdGlvbiAocmFuZ2VzKSB7XG4gIHZhciBpbmRleCA9IG5ldyBJbmRleCgpO1xuICBJbmRleC5hcHBseShpbmRleCwgcmFuZ2VzKTtcbiAgcmV0dXJuIGluZGV4O1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgc2l6ZSBvZiB0aGUgaW5kZXgsIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZm9yIGVhY2ggZGltZW5zaW9uLlxuICogQHJldHVybnMge051bWJlcltdfSBzaXplXG4gKi9cbkluZGV4LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2l6ZSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuX3Jhbmdlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2VzW2ldO1xuXG4gICAgc2l6ZVtpXSA9IHJhbmdlLnNpemUoKVswXTtcbiAgfVxuXG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heGltdW0gdmFsdWUgZm9yIGVhY2ggb2YgdGhlIGluZGV4ZXMgcmFuZ2VzLlxuICogQHJldHVybnMge051bWJlcltdfSBtYXhcbiAqL1xuSW5kZXgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuX3Jhbmdlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2VzW2ldO1xuICAgIHZhbHVlc1tpXSA9IHJhbmdlLm1heCgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtaW5pbXVtIHZhbHVlIGZvciBlYWNoIG9mIHRoZSBpbmRleGVzIHJhbmdlcy5cbiAqIEByZXR1cm5zIHtOdW1iZXJbXX0gbWluXG4gKi9cbkluZGV4LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9yYW5nZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3Jhbmdlc1tpXTtcblxuICAgIHZhbHVlc1tpXSA9IHJhbmdlLm1pbigpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn07XG5cbi8qKlxuICogTG9vcCBvdmVyIGVhY2ggb2YgdGhlIHJhbmdlcyBvZiB0aGUgaW5kZXhcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGVkIGZvciBlYWNoIHJhbmdlIHdpdGggYSBSYW5nZSBhcyBmaXJzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudCwgdGhlIGRpbWVuc2lvbiBhcyBzZWNvbmQsIGFuZCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggb2JqZWN0IGFzIHRoaXJkLlxuICovXG5JbmRleC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9yYW5nZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGNhbGxiYWNrKHRoaXMuX3Jhbmdlc1tpXSwgaSwgdGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHJhbmdlIGZvciBhIGdpdmVuIGRpbWVuc2lvbiBudW1iZXIgZnJvbSB0aGUgaW5kZXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaW0gICAgICAgICAgICAgICAgICBOdW1iZXIgb2YgdGhlIGRpbWVuc2lvblxuICogQHJldHVybnMge1JhbmdlIHwgbnVsbH0gcmFuZ2VcbiAqL1xuSW5kZXgucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24oZGltKSB7XG4gIHJldHVybiB0aGlzLl9yYW5nZXNbZGltXSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhpcyBpbmRleCBjb250YWlucyBvbmx5IGEgc2luZ2xlIHZhbHVlLlxuICpcbiAqIFRoaXMgaXMgdGhlIGNhc2Ugd2hlbiB0aGUgaW5kZXggaXMgY3JlYXRlZCB3aXRoIG9ubHkgc2NhbGFyIHZhbHVlcyBhcyByYW5nZXMsXG4gKiBub3QgZm9yIHJhbmdlcyByZXNvbHZpbmcgaW50byBhIHNpbmdsZSB2YWx1ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlzU2NhbGFyXG4gKi9cbkluZGV4LnByb3RvdHlwZS5pc1NjYWxhciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzU2NhbGFyO1xufTtcblxuLyoqXG4gKiBFeHBhbmQgdGhlIEluZGV4IGludG8gYW4gYXJyYXkuXG4gKiBGb3IgZXhhbXBsZSBuZXcgSW5kZXgoWzAsM10sIFsyLDddKSByZXR1cm5zIFtbMCwxLDJdLCBbMiwzLDQsNSw2XV1cbiAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXlcbiAqL1xuSW5kZXgucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9yYW5nZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3Jhbmdlc1tpXSxcbiAgICAgICAgcm93ID0gW10sXG4gICAgICAgIHggPSByYW5nZS5zdGFydCxcbiAgICAgICAgZW5kID0gcmFuZ2UuZW5kLFxuICAgICAgICBzdGVwID0gcmFuZ2Uuc3RlcDtcblxuICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgd2hpbGUgKHggPCBlbmQpIHtcbiAgICAgICAgcm93LnB1c2goeCk7XG4gICAgICAgIHggKz0gc3RlcDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIHdoaWxlICh4ID4gZW5kKSB7XG4gICAgICAgIHJvdy5wdXNoKHgpO1xuICAgICAgICB4ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXJyYXkucHVzaChyb3cpO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHByaW1pdGl2ZSB2YWx1ZSBvZiB0aGUgSW5kZXgsIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5LlxuICogRXF1aXZhbGVudCB0byBJbmRleC50b0FycmF5KCkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gKi9cbkluZGV4LnByb3RvdHlwZS52YWx1ZU9mID0gSW5kZXgucHJvdG90eXBlLnRvQXJyYXk7XG5cbi8qKlxuICogR2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluZGV4LCBmb3IgZXhhbXBsZSAnWzI6Nl0nIG9yICdbMDoyOjEwLCA0OjddJ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyXG4gKi9cbkluZGV4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0cmluZ3MgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9yYW5nZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3Jhbmdlc1tpXTtcbiAgICB2YXIgc3RyID0gbnVtYmVyLmZvcm1hdChyYW5nZS5zdGFydCk7XG4gICAgaWYgKHJhbmdlLnN0ZXAgIT0gMSkge1xuICAgICAgc3RyICs9ICc6JyArIG51bWJlci5mb3JtYXQocmFuZ2Uuc3RlcCk7XG4gICAgfVxuICAgIHN0ciArPSAnOicgKyBudW1iZXIuZm9ybWF0KHJhbmdlLmVuZCk7XG4gICAgc3RyaW5ncy5wdXNoKHN0cik7XG4gIH1cblxuICByZXR1cm4gJ1snICsgc3RyaW5ncy5qb2luKCcsICcpICsgJ10nO1xufTtcblxuLy8gZXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBJbmRleDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2luZGV4JyksXG4gICAgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9EaW1lbnNpb25FcnJvcicpLFxuXG4gICAgSW5kZXggPSByZXF1aXJlKCcuL0luZGV4JyksXG5cbiAgICBudW1iZXIgPSB1dGlsLm51bWJlcixcbiAgICBzdHJpbmcgPSB1dGlsLnN0cmluZyxcbiAgICBhcnJheSA9IHV0aWwuYXJyYXksXG4gICAgb2JqZWN0ID0gdXRpbC5vYmplY3QsXG5cbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICB2YWxpZGF0ZUluZGV4ID0gYXJyYXkudmFsaWRhdGVJbmRleDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgTWF0cml4XG4gKlxuICogQSBNYXRyaXggaXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBBcnJheS4gQSBtYXRyaXggY2FuIGhvbGQgYSBtdWx0aSBkaW1lbnNpb25hbFxuICogYXJyYXkuIEEgbWF0cml4IGNhbiBiZSBjb25zdHJ1Y3RlZCBhczpcbiAqICAgICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeChkYXRhKVxuICpcbiAqIE1hdHJpeCBjb250YWlucyB0aGUgZnVuY3Rpb25zIHRvIHJlc2l6ZSwgZ2V0IGFuZCBzZXQgdmFsdWVzLCBnZXQgdGhlIHNpemUsXG4gKiBjbG9uZSB0aGUgbWF0cml4IGFuZCB0byBjb252ZXJ0IHRoZSBtYXRyaXggdG8gYSB2ZWN0b3IsIGFycmF5LCBvciBzY2FsYXIuXG4gKiBGdXJ0aGVybW9yZSwgb25lIGNhbiBpdGVyYXRlIG92ZXIgdGhlIG1hdHJpeCB1c2luZyBtYXAgYW5kIGZvckVhY2guXG4gKiBUaGUgaW50ZXJuYWwgQXJyYXkgb2YgdGhlIE1hdHJpeCBjYW4gYmUgYWNjZXNzZWQgdXNpbmcgdGhlIGZ1bmN0aW9uIHZhbHVlT2YuXG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqICAgICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeChbWzEsIDJdLCBbMywgNF0pO1xuICogICAgIG1hdGl4LnNpemUoKTsgICAgICAgICAgICAgIC8vIFsyLCAyXVxuICogICAgIG1hdHJpeC5yZXNpemUoWzMsIDJdLCA1KTtcbiAqICAgICBtYXRyaXgudmFsdWVPZigpOyAgICAgICAgICAvLyBbWzEsIDJdLCBbMywgNF0sIFs1LCA1XV1cbiAqICAgICBtYXRyaXguc3Vic2V0KFsxLDJdKSAgICAgICAvLyAzIChpbmRleGVzIGFyZSB6ZXJvLWJhc2VkKVxuICpcbiAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IFtkYXRhXSAgICBBIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKi9cbmZ1bmN0aW9uIE1hdHJpeChkYXRhKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXRyaXgpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgLy8gY2xvbmUgZGF0YSBmcm9tIGEgTWF0cml4XG4gICAgdGhpcy5fZGF0YSA9IGRhdGEuY2xvbmUoKS5fZGF0YTtcbiAgfVxuICBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgLy8gdXNlIGFycmF5XG4gICAgLy8gcmVwbGFjZSBuZXN0ZWQgTWF0cmljZXMgd2l0aCBBcnJheXNcbiAgICB0aGlzLl9kYXRhID0gcHJlcHJvY2VzcyhkYXRhKTtcbiAgfVxuICBlbHNlIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAvLyB1bnN1cHBvcnRlZCB0eXBlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBvZiBkYXRhICgnICsgdXRpbC50eXBlcy50eXBlKGRhdGEpICsgJyknKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBub3RoaW5nIHByb3ZpZGVkXG4gICAgdGhpcy5fZGF0YSA9IFtdO1xuICB9XG5cbiAgLy8gdmVyaWZ5IHRoZSBzaXplIG9mIHRoZSBhcnJheVxuICB0aGlzLl9zaXplID0gYXJyYXkuc2l6ZSh0aGlzLl9kYXRhKTtcbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIGEgTWF0cml4XG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNNYXRyaXhcbiAqL1xuTWF0cml4LmlzTWF0cml4ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gKG9iamVjdCBpbnN0YW5jZW9mIE1hdHJpeCk7XG59O1xuXG4vKipcbiAqIEdldCBhIHN1YnNldCBvZiB0aGUgbWF0cml4LCBvciByZXBsYWNlIGEgc3Vic2V0IG9mIHRoZSBtYXRyaXguXG4gKlxuICogVXNhZ2U6XG4gKiAgICAgdmFyIHN1YnNldCA9IG1hdHJpeC5zdWJzZXQoaW5kZXgpICAgICAgICAgICAgICAgLy8gcmV0cmlldmUgc3Vic2V0XG4gKiAgICAgdmFyIHZhbHVlID0gbWF0cml4LnN1YnNldChpbmRleCwgcmVwbGFjZW1lbnQpICAgLy8gcmVwbGFjZSBzdWJzZXRcbiAqXG4gKiBAcGFyYW0ge0luZGV4fSBpbmRleFxuICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeCB8ICp9IFtyZXBsYWNlbWVudF1cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZT0wXSAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcyB3aGVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbWF0cml4IGlzIHJlc2l6ZWQuIElmIG5vdCBwcm92aWRlZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBtYXRyaXggZWxlbWVudHMgd2lsbCBiZSBmaWxsZWQgd2l0aCB6ZXJvcy5cbiAqL1xuTWF0cml4LnByb3RvdHlwZS5zdWJzZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50LCBkZWZhdWx0VmFsdWUpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIF9nZXQodGhpcywgaW5kZXgpO1xuXG4gICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXG4gICAgY2FzZSAyOlxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBfc2V0KHRoaXMsIGluZGV4LCByZXBsYWNlbWVudCwgZGVmYXVsdFZhbHVlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBzaW5nbGUgZWxlbWVudCBmcm9tIHRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSBpbmRleCAgIFplcm8tYmFzZWQgaW5kZXhcbiAqIEByZXR1cm4geyp9IHZhbHVlXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIGlmICghaXNBcnJheShpbmRleCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBleHBlY3RlZCcpO1xuICB9XG4gIGlmIChpbmRleC5sZW5ndGggIT0gdGhpcy5fc2l6ZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoaW5kZXgubGVuZ3RoLCB0aGlzLl9zaXplLmxlbmd0aCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGluZGV4Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICB2YXIgaW5kZXhfaSA9IGluZGV4W2ldO1xuICAgIHZhbGlkYXRlSW5kZXgoaW5kZXhfaSwgZGF0YS5sZW5ndGgpO1xuICAgIGRhdGEgPSBkYXRhW2luZGV4X2ldO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdC5jbG9uZShkYXRhKTtcbn07XG5cbi8qKlxuICogUmVwbGFjZSBhIHNpbmdsZSBlbGVtZW50IGluIHRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSBpbmRleCAgIFplcm8tYmFzZWQgaW5kZXhcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gICAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcyB3aGVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbWF0cml4IGlzIHJlc2l6ZWQuIElmIG5vdCBwcm92aWRlZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBtYXRyaXggZWxlbWVudHMgd2lsbCBiZSBsZWZ0IHVuZGVmaW5lZC5cbiAqIEByZXR1cm4ge01hdHJpeH0gc2VsZlxuICovXG5NYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgaSwgaWk7XG5cbiAgLy8gdmFsaWRhdGUgaW5wdXQgdHlwZSBhbmQgZGltZW5zaW9uc1xuICBpZiAoIWlzQXJyYXkoaW5kZXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSBleHBlY3RlZCcpO1xuICB9XG4gIGlmIChpbmRleC5sZW5ndGggPCB0aGlzLl9zaXplLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihpbmRleC5sZW5ndGgsIHRoaXMuX3NpemUubGVuZ3RoLCAnPCcpO1xuICB9XG5cbiAgLy8gZW5sYXJnZSBtYXRyaXggd2hlbiBuZWVkZWRcbiAgdmFyIHNpemUgPSBpbmRleC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gaSArIDE7XG4gIH0pO1xuICBfZml0KHRoaXMsIHNpemUsIGRlZmF1bHRWYWx1ZSk7XG5cbiAgLy8gdHJhdmVyc2Ugb3ZlciB0aGUgZGltZW5zaW9uc1xuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gIGZvciAoaSA9IDAsIGlpID0gaW5kZXgubGVuZ3RoIC0gMTsgaSA8IGlpOyBpKyspIHtcbiAgICB2YXIgaW5kZXhfaSA9IGluZGV4W2ldO1xuICAgIHZhbGlkYXRlSW5kZXgoaW5kZXhfaSwgZGF0YS5sZW5ndGgpO1xuICAgIGRhdGEgPSBkYXRhW2luZGV4X2ldO1xuICB9XG5cbiAgLy8gc2V0IG5ldyB2YWx1ZVxuICBpbmRleF9pID0gaW5kZXhbaW5kZXgubGVuZ3RoIC0gMV07XG4gIHZhbGlkYXRlSW5kZXgoaW5kZXhfaSwgZGF0YS5sZW5ndGgpO1xuICBkYXRhW2luZGV4X2ldID0gdmFsdWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCBhIHN1Ym1hdHJpeCBvZiB0aGlzIG1hdHJpeFxuICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeFxuICogQHBhcmFtIHtJbmRleH0gaW5kZXggICBaZXJvLWJhc2VkIGluZGV4XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0IChtYXRyaXgsIGluZGV4KSB7XG4gIGlmICghKGluZGV4IGluc3RhbmNlb2YgSW5kZXgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBpbmRleCcpO1xuICB9XG5cbiAgdmFyIGlzU2NhbGFyID0gaW5kZXguaXNTY2FsYXIoKTtcbiAgaWYgKGlzU2NhbGFyKSB7XG4gICAgLy8gcmV0dXJuIGEgc2NhbGFyXG4gICAgcmV0dXJuIG1hdHJpeC5nZXQoaW5kZXgubWluKCkpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIHZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICB2YXIgc2l6ZSA9IGluZGV4LnNpemUoKTtcbiAgICBpZiAoc2l6ZS5sZW5ndGggIT0gbWF0cml4Ll9zaXplLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKHNpemUubGVuZ3RoLCBtYXRyaXguX3NpemUubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBpZiBhbnkgb2YgdGhlIHJhbmdlcyBpbiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlXG4gICAgdmFyIG1pbiA9IGluZGV4Lm1pbigpO1xuICAgIHZhciBtYXggPSBpbmRleC5tYXgoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBtYXRyaXguX3NpemUubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFsaWRhdGVJbmRleChtaW5baV0sIG1hdHJpeC5fc2l6ZVtpXSk7XG4gICAgICB2YWxpZGF0ZUluZGV4KG1heFtpXSwgbWF0cml4Ll9zaXplW2ldKTtcbiAgICB9XG5cbiAgICAvLyByZXRyaWV2ZSBzdWJtYXRyaXhcbiAgICAvLyBUT0RPOiBtb3JlIGVmZmljaWVudCB3aGVuIGNyZWF0aW5nIGFuIGVtcHR5IG1hdHJpeCBhbmQgc2V0dGluZyBfZGF0YSBhbmQgX3NpemUgbWFudWFsbHlcbiAgICByZXR1cm4gbmV3IE1hdHJpeChfZ2V0U3VibWF0cml4KG1hdHJpeC5fZGF0YSwgaW5kZXgsIHNpemUubGVuZ3RoLCAwKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBnZXQgYSBzdWJtYXRyaXggb2YgYSBtdWx0aSBkaW1lbnNpb25hbCBtYXRyaXguXG4gKiBJbmRleCBpcyBub3QgY2hlY2tlZCBmb3IgY29ycmVjdCBudW1iZXIgb3IgbGVuZ3RoIG9mIGRpbWVuc2lvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gKiBAcGFyYW0ge0luZGV4fSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGRpbXMgICBUb3RhbCBudW1iZXIgb2YgZGltZW5zaW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpbSAgICBDdXJyZW50IGRpbWVuc2lvblxuICogQHJldHVybiB7QXJyYXl9IHN1Ym1hdHJpeFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFN1Ym1hdHJpeCAoZGF0YSwgaW5kZXgsIGRpbXMsIGRpbSkge1xuICB2YXIgbGFzdCA9IChkaW0gPT0gZGltcyAtIDEpO1xuICB2YXIgcmFuZ2UgPSBpbmRleC5yYW5nZShkaW0pO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgcmV0dXJuIHJhbmdlLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGRhdGFbaV07XG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHJhbmdlLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgdmFyIGNoaWxkID0gZGF0YVtpXTtcbiAgICAgIHJldHVybiBfZ2V0U3VibWF0cml4KGNoaWxkLCBpbmRleCwgZGltcywgZGltICsgMSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXBsYWNlIGEgc3VibWF0cml4IGluIHRoaXMgbWF0cml4XG4gKiBJbmRleGVzIGFyZSB6ZXJvLWJhc2VkLlxuICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeFxuICogQHBhcmFtIHtJbmRleH0gaW5kZXhcbiAqIEBwYXJhbSB7TWF0cml4IHwgQXJyYXkgfCAqfSBzdWJtYXRyaXhcbiAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlICAgICAgICAgIERlZmF1bHQgdmFsdWUsIGZpbGxlZCBpbiBvbiBuZXcgZW50cmllcyB3aGVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbWF0cml4IGlzIHJlc2l6ZWQuXG4gKiBAcmV0dXJuIHtNYXRyaXh9IG1hdHJpeFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3NldCAobWF0cml4LCBpbmRleCwgc3VibWF0cml4LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKCEoaW5kZXggaW5zdGFuY2VvZiBJbmRleCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGluZGV4Jyk7XG4gIH1cblxuICAvLyBnZXQgaW5kZXggc2l6ZSBhbmQgY2hlY2sgd2hldGhlciB0aGUgaW5kZXggY29udGFpbnMgYSBzaW5nbGUgdmFsdWVcbiAgdmFyIGlTaXplID0gaW5kZXguc2l6ZSgpLFxuICAgICAgaXNTY2FsYXIgPSBpbmRleC5pc1NjYWxhcigpO1xuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGUgc3VibWF0cml4LCBhbmQgY29udmVydCBpdCBpbnRvIGFuIEFycmF5IGlmIG5lZWRlZFxuICB2YXIgc1NpemU7XG4gIGlmIChzdWJtYXRyaXggaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICBzU2l6ZSA9IHN1Ym1hdHJpeC5zaXplKCk7XG4gICAgc3VibWF0cml4ID0gc3VibWF0cml4LnZhbHVlT2YoKTtcbiAgfVxuICBlbHNlIHtcbiAgICBzU2l6ZSA9IGFycmF5LnNpemUoc3VibWF0cml4KTtcbiAgfVxuXG4gIGlmIChpc1NjYWxhcikge1xuICAgIC8vIHNldCBhIHNjYWxhclxuXG4gICAgLy8gY2hlY2sgd2hldGhlciBzdWJtYXRyaXggaXMgYSBzY2FsYXJcbiAgICBpZiAoc1NpemUubGVuZ3RoICE9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NjYWxhciBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIG1hdHJpeC5zZXQoaW5kZXgubWluKCksIHN1Ym1hdHJpeCwgZGVmYXVsdFZhbHVlKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBzZXQgYSBzdWJtYXRyaXhcblxuICAgIC8vIHZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICBpZiAoaVNpemUubGVuZ3RoIDwgbWF0cml4Ll9zaXplLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKGlTaXplLmxlbmd0aCwgbWF0cml4Ll9zaXplLmxlbmd0aCwgJzwnKTtcbiAgICB9XG5cbiAgICBpZiAoc1NpemUubGVuZ3RoIDwgaVNpemUubGVuZ3RoKSB7XG4gICAgICAvLyBjYWxjdWxhdGUgbnVtYmVyIG9mIG1pc3Npbmcgb3V0ZXIgZGltZW5zaW9uc1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIG91dGVyID0gMDtcbiAgICAgIHdoaWxlIChpU2l6ZVtpXSA9PT0gMSAmJiBzU2l6ZVtpXSA9PT0gMSkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaVNpemVbaV0gPT09IDEpIHtcbiAgICAgICAgb3V0ZXIrKztcbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICAvLyB1bnNxdWVlemUgYm90aCBvdXRlciBhbmQgaW5uZXIgZGltZW5zaW9uc1xuICAgICAgc3VibWF0cml4ID0gYXJyYXkudW5zcXVlZXplKHN1Ym1hdHJpeCwgaVNpemUubGVuZ3RoLCBvdXRlciwgc1NpemUpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHNpemUgb2YgdGhlIHN1Ym1hdHJpeCBtYXRjaGVzIHRoZSBpbmRleCBzaXplXG4gICAgaWYgKCFvYmplY3QuZGVlcEVxdWFsKGlTaXplLCBzU2l6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihpU2l6ZSwgc1NpemUsICc+Jyk7XG4gICAgfVxuXG4gICAgLy8gZW5sYXJnZSBtYXRyaXggd2hlbiBuZWVkZWRcbiAgICB2YXIgc2l6ZSA9IGluZGV4Lm1heCgpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGkgKyAxO1xuICAgIH0pO1xuICAgIF9maXQobWF0cml4LCBzaXplLCBkZWZhdWx0VmFsdWUpO1xuXG4gICAgLy8gaW5zZXJ0IHRoZSBzdWIgbWF0cml4XG4gICAgdmFyIGRpbXMgPSBpU2l6ZS5sZW5ndGgsXG4gICAgICAgIGRpbSA9IDA7XG4gICAgX3NldFN1Ym1hdHJpeCAobWF0cml4Ll9kYXRhLCBpbmRleCwgc3VibWF0cml4LCBkaW1zLCBkaW0pO1xuICB9XG5cbiAgcmV0dXJuIG1hdHJpeDtcbn1cblxuLyoqXG4gKiBSZXBsYWNlIGEgc3VibWF0cml4IG9mIGEgbXVsdGkgZGltZW5zaW9uYWwgbWF0cml4LlxuICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICogQHBhcmFtIHtJbmRleH0gaW5kZXhcbiAqIEBwYXJhbSB7QXJyYXl9IHN1Ym1hdHJpeFxuICogQHBhcmFtIHtudW1iZXJ9IGRpbXMgICBUb3RhbCBudW1iZXIgb2YgZGltZW5zaW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3NldFN1Ym1hdHJpeCAoZGF0YSwgaW5kZXgsIHN1Ym1hdHJpeCwgZGltcywgZGltKSB7XG4gIHZhciBsYXN0ID0gKGRpbSA9PSBkaW1zIC0gMSksXG4gICAgICByYW5nZSA9IGluZGV4LnJhbmdlKGRpbSk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICByYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhSW5kZXgsIHN1YkluZGV4KSB7XG4gICAgICB2YWxpZGF0ZUluZGV4KGRhdGFJbmRleCk7XG4gICAgICBkYXRhW2RhdGFJbmRleF0gPSBzdWJtYXRyaXhbc3ViSW5kZXhdO1xuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIHJhbmdlLmZvckVhY2goZnVuY3Rpb24gKGRhdGFJbmRleCwgc3ViSW5kZXgpIHtcbiAgICAgIHZhbGlkYXRlSW5kZXgoZGF0YUluZGV4KTtcbiAgICAgIF9zZXRTdWJtYXRyaXgoZGF0YVtkYXRhSW5kZXhdLCBpbmRleCwgc3VibWF0cml4W3N1YkluZGV4XSwgZGltcywgZGltICsgMSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNpemUgdGhlIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJbXX0gc2l6ZVxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlPTBdICAgICAgRGVmYXVsdCB2YWx1ZSwgZmlsbGVkIGluIG9uIG5ldyBlbnRyaWVzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnRzIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGZpbGxlZCB3aXRoIHplcm9zLlxuICogQHJldHVybiB7TWF0cml4fSBzZWxmICAgICAgICAgICAgVGhlIG1hdHJpeCBpdHNlbGYgaXMgcmV0dXJuZWRcbiAqL1xuTWF0cml4LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHRoaXMuX3NpemUgPSBvYmplY3QuY2xvbmUoc2l6ZSk7XG4gIHRoaXMuX2RhdGEgPSBhcnJheS5yZXNpemUodGhpcy5fZGF0YSwgdGhpcy5fc2l6ZSwgZGVmYXVsdFZhbHVlKTtcblxuICAvLyByZXR1cm4gdGhlIG1hdHJpeCBpdHNlbGZcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVubGFyZ2UgdGhlIG1hdHJpeCB3aGVuIGl0IGlzIHNtYWxsZXIgdGhhbiBnaXZlbiBzaXplLlxuICogSWYgdGhlIG1hdHJpeCBpcyBsYXJnZXIgb3IgZXF1YWwgc2l6ZWQsIG5vdGhpbmcgaXMgZG9uZS5cbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXggICAgICAgICAgIFRoZSBtYXRyaXggdG8gYmUgcmVzaXplZFxuICogQHBhcmFtIHtOdW1iZXJbXX0gc2l6ZVxuICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgICAgICAgICAgRGVmYXVsdCB2YWx1ZSwgZmlsbGVkIGluIG9uIG5ldyBlbnRyaWVzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2ZpdChtYXRyaXgsIHNpemUsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgbmV3U2l6ZSA9IG9iamVjdC5jbG9uZShtYXRyaXguX3NpemUpLFxuICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuXG4gIC8vIGFkZCBkaW1lbnNpb25zIHdoZW4gbmVlZGVkXG4gIHdoaWxlIChuZXdTaXplLmxlbmd0aCA8IHNpemUubGVuZ3RoKSB7XG4gICAgbmV3U2l6ZS5wdXNoKDApO1xuICAgIGNoYW5nZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZW5sYXJnZSBzaXplIHdoZW4gbmVlZGVkXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHNpemUubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlmIChzaXplW2ldID4gbmV3U2l6ZVtpXSkge1xuICAgICAgbmV3U2l6ZVtpXSA9IHNpemVbaV07XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoY2hhbmdlZCkge1xuICAgIC8vIHJlc2l6ZSBvbmx5IHdoZW4gc2l6ZSBpcyBjaGFuZ2VkXG4gICAgbWF0cml4LnJlc2l6ZShuZXdTaXplLCBkZWZhdWx0VmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhlIG1hdHJpeFxuICogQHJldHVybiB7TWF0cml4fSBjbG9uZVxuICovXG5NYXRyaXgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICBtYXRyaXguX2RhdGEgPSBvYmplY3QuY2xvbmUodGhpcy5fZGF0YSk7XG4gIG1hdHJpeC5fc2l6ZSA9IG9iamVjdC5jbG9uZSh0aGlzLl9zaXplKTtcbiAgcmV0dXJuIG1hdHJpeDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHNpemUgb2YgdGhlIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtOdW1iZXJbXX0gc2l6ZVxuICovXG5NYXRyaXgucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NpemU7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXRyaXggd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgb25cbiAqIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQsIHRoZSBpbmRleFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgZWxlbWVudCwgYW5kIHRoZSBNYXRyaXggYmVpbmcgdHJhdmVyc2VkLlxuICogQHJldHVybiB7TWF0cml4fSBtYXRyaXhcbiAqL1xuTWF0cml4LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgdmFyIGluZGV4ID0gW107XG4gIHZhciByZWN1cnNlID0gZnVuY3Rpb24gKHZhbHVlLCBkaW0pIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgIGluZGV4W2RpbV0gPSBpO1xuICAgICAgICByZXR1cm4gcmVjdXJzZShjaGlsZCwgZGltICsgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBtZSk7XG4gICAgfVxuICB9O1xuICBtYXRyaXguX2RhdGEgPSByZWN1cnNlKHRoaXMuX2RhdGEsIDApO1xuICBtYXRyaXguX3NpemUgPSBvYmplY3QuY2xvbmUodGhpcy5fc2l6ZSk7XG5cbiAgcmV0dXJuIG1hdHJpeDtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIG9uIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQsIHRoZSBpbmRleFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgZWxlbWVudCwgYW5kIHRoZSBNYXRyaXggYmVpbmcgdHJhdmVyc2VkLlxuICovXG5NYXRyaXgucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIGluZGV4ID0gW107XG4gIHZhciByZWN1cnNlID0gZnVuY3Rpb24gKHZhbHVlLCBkaW0pIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgIGluZGV4W2RpbV0gPSBpO1xuICAgICAgICByZWN1cnNlKGNoaWxkLCBkaW0gKyAxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgbWUpO1xuICAgIH1cbiAgfTtcbiAgcmVjdXJzZSh0aGlzLl9kYXRhLCAwKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIEFycmF5IHdpdGggYSBjb3B5IG9mIHRoZSBkYXRhIG9mIHRoZSBNYXRyaXhcbiAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXlcbiAqL1xuTWF0cml4LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gb2JqZWN0LmNsb25lKHRoaXMuX2RhdGEpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHByaW1pdGl2ZSB2YWx1ZSBvZiB0aGUgTWF0cml4OiBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXlcbiAqL1xuTWF0cml4LnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZGF0YTtcbn07XG5cbi8qKlxuICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXgsIHdpdGggb3B0aW9uYWwgZm9ybWF0dGluZyBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3QgfCBOdW1iZXIgfCBGdW5jdGlvbn0gW29wdGlvbnNdICBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIvdXRpbC9udW1iZXI6Zm9ybWF0IGZvciBhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uIG9mIHRoZSBhdmFpbGFibGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0clxuICovXG5NYXRyaXgucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBzdHJpbmcuZm9ybWF0KHRoaXMuX2RhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICogQHJldHVybnMge1N0cmluZ30gc3RyXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBzdHJpbmcuZm9ybWF0KHRoaXMuX2RhdGEpO1xufTtcblxuLyoqXG4gKiBQcmVwcm9jZXNzIGRhdGEsIHdoaWNoIGNhbiBiZSBhbiBBcnJheSBvciBNYXRyaXggd2l0aCBuZXN0ZWQgQXJyYXlzIGFuZFxuICogTWF0cmljZXMuIFJlcGxhY2VzIGFsbCBuZXN0ZWQgTWF0cmljZXMgd2l0aCBBcnJheXNcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAqIEByZXR1cm4ge0FycmF5fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHByZXByb2Nlc3MoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBkYXRhLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICB2YXIgZWxlbSA9IGRhdGFbaV07XG4gICAgaWYgKGlzQXJyYXkoZWxlbSkpIHtcbiAgICAgIGRhdGFbaV0gPSBwcmVwcm9jZXNzKGVsZW0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICBkYXRhW2ldID0gcHJlcHJvY2VzcyhlbGVtLl9kYXRhKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gZXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBNYXRyaXg7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgbnVtYmVyID0gdXRpbC5udW1iZXIsXG4gICAgc3RyaW5nID0gdXRpbC5zdHJpbmcsXG4gICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBVbml0XG4gKlxuICogQSB1bml0IGNhbiBiZSBjb25zdHJ1Y3RlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAgICAgdmFyIGEgPSBuZXcgVW5pdCh2YWx1ZSwgbmFtZSk7XG4gKiAgICAgdmFyIGIgPSBuZXcgVW5pdChudWxsLCBuYW1lKTtcbiAqICAgICB2YXIgYyA9IFVuaXQucGFyc2Uoc3RyKTtcbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICogICAgIHZhciBhID0gbmV3IFVuaXQoNSwgJ2NtJyk7ICAgICAgICAgICAgICAgLy8gNTAgbW1cbiAqICAgICB2YXIgYiA9IFVuaXQucGFyc2UoJzIzIGtnJyk7ICAgICAgICAgICAgIC8vIDIzIGtnXG4gKiAgICAgdmFyIGMgPSBtYXRoLmluKGEsIG5ldyBVbml0KG51bGwsICdtJyk7ICAvLyAwLjA1IG1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW3ZhbHVlXSAgQSB2YWx1ZSBsaWtlIDUuMlxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAgIEEgdW5pdCBuYW1lIGxpa2UgXCJjbVwiIG9yIFwiaW5jaFwiLiBDYW4gaW5jbHVkZSBhIHByZWZpeFxuICovXG5mdW5jdGlvbiBVbml0KHZhbHVlLCBuYW1lKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVbml0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICBpZiAodmFsdWUgIT0gdW5kZWZpbmVkICYmICFpc051bWJlcih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgaW4gVW5pdCBjb25zdHJ1Y3RvciBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKG5hbWUgIT0gdW5kZWZpbmVkICYmICghaXNTdHJpbmcobmFtZSkgfHwgbmFtZSA9PSAnJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZWNvbmQgcGFyYW1ldGVyIGluIFVuaXQgY29uc3RydWN0b3IgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKG5hbWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gZmluZCB0aGUgdW5pdCBhbmQgcHJlZml4IGZyb20gdGhlIHN0cmluZ1xuICAgIHZhciByZXMgPSBfZmluZFVuaXQobmFtZSk7XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5rbm93biB1bml0IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICB9XG4gICAgdGhpcy51bml0ID0gcmVzLnVuaXQ7XG4gICAgdGhpcy5wcmVmaXggPSByZXMucHJlZml4O1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMudW5pdCA9IFVOSVRfTk9ORTtcbiAgICB0aGlzLnByZWZpeCA9IFBSRUZJWF9OT05FOyAgLy8gbGluayB0byBhIGxpc3Qgd2l0aCBzdXBwb3J0ZWQgcHJlZml4ZXNcbiAgfVxuXG4gIHRoaXMudmFsdWUgPSAodmFsdWUgIT0gdW5kZWZpbmVkKSA/IHRoaXMuX25vcm1hbGl6ZSh2YWx1ZSkgOiBudWxsO1xuICB0aGlzLmZpeFByZWZpeCA9IGZhbHNlOyAvLyBpZiB0cnVlLCBmdW5jdGlvbiBmb3JtYXQgd2lsbCBub3Qgc2VhcmNoIGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVzdCBwcmVmaXggYnV0IGxlYXZlIGl0IGFzIGluaXRpYWxseSBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4UHJlZml4IGlzIHNldCB0cnVlIGJ5IHRoZSBtZXRob2QgVW5pdC50b1xufVxuXG4vLyBwcml2YXRlIHZhcmlhYmxlcyBhbmQgZnVuY3Rpb25zIGZvciB0aGUgVW5pdCBwYXJzZXJcbnZhciB0ZXh0LCBpbmRleCwgYztcblxuZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gIHdoaWxlIChjID09ICcgJyB8fCBjID09ICdcXHQnKSB7XG4gICAgbmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRGlnaXREb3QgKGMpIHtcbiAgcmV0dXJuICgoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHx8IGMgPT0gJy4nKTtcbn1cblxuZnVuY3Rpb24gaXNEaWdpdCAoYykge1xuICByZXR1cm4gKChjID49ICcwJyAmJiBjIDw9ICc5JykpO1xufVxuXG5mdW5jdGlvbiBuZXh0KCkge1xuICBpbmRleCsrO1xuICBjID0gdGV4dC5jaGFyQXQoaW5kZXgpO1xufVxuXG5mdW5jdGlvbiByZXZlcnQob2xkSW5kZXgpIHtcbiAgaW5kZXggPSBvbGRJbmRleDtcbiAgYyA9IHRleHQuY2hhckF0KGluZGV4KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VOdW1iZXIgKCkge1xuICB2YXIgbnVtYmVyID0gJyc7XG4gIHZhciBvbGRJbmRleDtcbiAgb2xkSW5kZXggPSBpbmRleDtcblxuICBpZiAoYyA9PSAnKycpIHtcbiAgICBuZXh0KCk7XG4gIH1cbiAgZWxzZSBpZiAoYyA9PSAnLScpIHtcbiAgICBudW1iZXIgKz0gYztcbiAgICBuZXh0KCk7XG4gIH1cblxuICBpZiAoIWlzRGlnaXREb3QoYykpIHtcbiAgICAvLyBhICsgb3IgLSBtdXN0IGJlIGZvbGxvd2VkIGJ5IGEgZGlnaXRcbiAgICByZXZlcnQob2xkSW5kZXgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gZ2V0IG51bWJlciwgY2FuIGhhdmUgYSBzaW5nbGUgZG90XG4gIGlmIChjID09ICcuJykge1xuICAgIG51bWJlciArPSBjO1xuICAgIG5leHQoKTtcbiAgICBpZiAoIWlzRGlnaXQoYykpIHtcbiAgICAgIC8vIHRoaXMgaXMgbm8gbGVnYWwgbnVtYmVyLCBpdCBpcyBqdXN0IGEgZG90XG4gICAgICByZXZlcnQob2xkSW5kZXgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHdoaWxlIChpc0RpZ2l0KGMpKSB7XG4gICAgICBudW1iZXIgKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgaWYgKGMgPT0gJy4nKSB7XG4gICAgICBudW1iZXIgKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGlnaXQoYykpIHtcbiAgICBudW1iZXIgKz0gYztcbiAgICBuZXh0KCk7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgZXhwb25lbnRpYWwgbm90YXRpb24gbGlrZSBcIjIuM2UtNFwiIG9yIFwiMS4yM2U1MFwiXG4gIGlmIChjID09ICdFJyB8fCBjID09ICdlJykge1xuICAgIG51bWJlciArPSBjO1xuICAgIG5leHQoKTtcblxuICAgIGlmIChjID09ICcrJyB8fCBjID09ICctJykge1xuICAgICAgbnVtYmVyICs9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgLy8gU2NpZW50aWZpYyBub3RhdGlvbiBNVVNUIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cG9uZW50XG4gICAgaWYgKCFpc0RpZ2l0KGMpKSB7XG4gICAgICAvLyB0aGlzIGlzIG5vIGxlZ2FsIG51bWJlciwgZXhwb25lbnQgaXMgbWlzc2luZy5cbiAgICAgIHJldmVydChvbGRJbmRleCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAoaXNEaWdpdChjKSkge1xuICAgICAgbnVtYmVyICs9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bWJlcjtcbn1cblxuZnVuY3Rpb24gcGFyc2VVbml0KCkge1xuICB2YXIgdW5pdE5hbWUgPSAnJztcblxuICBza2lwV2hpdGVzcGFjZSgpO1xuICB3aGlsZSAoYyAmJiBjICE9ICcgJyAmJiBjICE9ICdcXHQnKSB7XG4gICAgdW5pdE5hbWUgKz0gYztcbiAgICBuZXh0KCk7XG4gIH1cblxuICByZXR1cm4gdW5pdE5hbWUgfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBpbnRvIGEgdW5pdC4gUmV0dXJucyBudWxsIGlmIHRoZSBwcm92aWRlZCBzdHJpbmcgZG9lcyBub3RcbiAqIGNvbnRhaW4gYSB2YWxpZCB1bml0LlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAgICAgICAgQSBzdHJpbmcgbGlrZSBcIjUuMiBpbmNoXCIsIFwiNGUyIGtnXCJcbiAqIEByZXR1cm4ge1VuaXQgfCBudWxsfSB1bml0XG4gKi9cblVuaXQucGFyc2UgPSBmdW5jdGlvbihzdHIpIHtcbiAgdGV4dCA9IHN0cjtcbiAgaW5kZXggPSAtMTtcbiAgYyA9ICcnO1xuXG4gIGlmICghaXNTdHJpbmcodGV4dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG5leHQoKTtcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgdmFyIHZhbHVlID0gcGFyc2VOdW1iZXIoKTtcbiAgdmFyIG5hbWU7XG4gIGlmICh2YWx1ZSkge1xuICAgIG5hbWUgPSBwYXJzZVVuaXQoKTtcblxuICAgIG5leHQoKTtcbiAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgIGlmIChjKSB7XG4gICAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQuIG5vdCBnb29kLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmIG5hbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIHdpbGwgdGhyb3cgYW4gZXJyb3Igd2hlbiB1bml0IGlzIG5vdCBmb3VuZFxuICAgICAgICByZXR1cm4gbmV3IFVuaXQoTnVtYmVyKHZhbHVlKSwgbmFtZSk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyKSB7fVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBuYW1lID0gcGFyc2VVbml0KCk7XG5cbiAgICBuZXh0KCk7XG4gICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICBpZiAoYykge1xuICAgICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kLiBub3QgZ29vZC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBjb25zdHJ1Y3RvciB3aWxsIHRocm93IGFuIGVycm9yIHdoZW4gdW5pdCBpcyBub3QgZm91bmRcbiAgICAgICAgcmV0dXJuIG5ldyBVbml0KG51bGwsIG5hbWUpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGVycikge31cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHZhbHVlIGlzIG9mIHR5cGUgVW5pdFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNVbml0XG4gKi9cblVuaXQuaXNVbml0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIFVuaXQpO1xufTtcblxuLyoqXG4gKiBjcmVhdGUgYSBjb3B5IG9mIHRoaXMgdW5pdFxuICogQHJldHVybiB7VW5pdH0gY2xvbmVcbiAqL1xuVW5pdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjbG9uZSA9IG5ldyBVbml0KCk7XG5cbiAgZm9yICh2YXIgcCBpbiB0aGlzKSB7XG4gICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgIGNsb25lW3BdID0gdGhpc1twXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvbmU7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZhbHVlLCBiYXNlZCBvbiBpdHMgY3VycmVudGx5IHNldCB1bml0XG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge051bWJlcn0gbm9ybWFsaXplZCB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuVW5pdC5wcm90b3R5cGUuX25vcm1hbGl6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgKyB0aGlzLnVuaXQub2Zmc2V0KSAqIHRoaXMudW5pdC52YWx1ZSAqIHRoaXMucHJlZml4LnZhbHVlO1xufTtcblxuLyoqXG4gKiBVbm5vcm1hbGl6ZSBhIHZhbHVlLCBiYXNlZCBvbiBpdHMgY3VycmVudGx5IHNldCB1bml0XG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJlZml4VmFsdWVdICAgIE9wdGlvbmFsIHByZWZpeCB2YWx1ZSB0byBiZSB1c2VkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHVubm9ybWFsaXplZCB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuVW5pdC5wcm90b3R5cGUuX3Vubm9ybWFsaXplID0gZnVuY3Rpb24gKHZhbHVlLCBwcmVmaXhWYWx1ZSkge1xuICBpZiAocHJlZml4VmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlIC8gdGhpcy51bml0LnZhbHVlIC8gdGhpcy5wcmVmaXgudmFsdWUgLSB0aGlzLnVuaXQub2Zmc2V0O1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZSAvIHRoaXMudW5pdC52YWx1ZSAvIHByZWZpeFZhbHVlIC0gdGhpcy51bml0Lm9mZnNldDtcbiAgfVxufTtcblxuLyoqXG4gKiBGaW5kIGEgdW5pdCBmcm9tIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICAgICAgICBBIHN0cmluZyBsaWtlICdjbScgb3IgJ2luY2gnXG4gKiBAcmV0dXJucyB7T2JqZWN0IHwgbnVsbH0gcmVzdWx0ICBXaGVuIGZvdW5kLCBhbiBvYmplY3Qgd2l0aCBmaWVsZHMgdW5pdCBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCBpcyByZXR1cm5lZC4gRWxzZSwgbnVsbCBpcyByZXR1cm5lZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9maW5kVW5pdChzdHIpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiBVTklUUykge1xuICAgIGlmIChVTklUUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgaWYgKHN0cmluZy5lbmRzV2l0aChzdHIsIG5hbWUpICkge1xuICAgICAgICB2YXIgdW5pdCA9IFVOSVRTW25hbWVdO1xuICAgICAgICB2YXIgcHJlZml4TGVuID0gKHN0ci5sZW5ndGggLSBuYW1lLmxlbmd0aCk7XG4gICAgICAgIHZhciBwcmVmaXhOYW1lID0gc3RyLnN1YnN0cmluZygwLCBwcmVmaXhMZW4pO1xuICAgICAgICB2YXIgcHJlZml4ID0gdW5pdC5wcmVmaXhlc1twcmVmaXhOYW1lXTtcbiAgICAgICAgaWYgKHByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gc3RvcmUgdW5pdCwgcHJlZml4LCBhbmQgdmFsdWVcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRlc3QgaWYgdGhlIGdpdmVuIGV4cHJlc3Npb24gaXMgYSB1bml0LlxuICogVGhlIHVuaXQgY2FuIGhhdmUgYSBwcmVmaXggYnV0IGNhbm5vdCBoYXZlIGEgdmFsdWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgIEEgc3RyaW5nIHRvIGJlIHRlc3RlZCB3aGV0aGVyIGl0IGlzIGEgdmFsdWUgbGVzcyB1bml0LlxuICogICAgICAgICAgICAgICAgICAgICAgICBUaGUgdW5pdCBjYW4gaGF2ZSBwcmVmaXgsIGxpa2UgXCJjbVwiXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIHRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHVuaXRcbiAqL1xuVW5pdC5pc1ZhbHVlbGVzc1VuaXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gKF9maW5kVW5pdChuYW1lKSAhPSBudWxsKTtcbn07XG5cbi8qKlxuICogY2hlY2sgaWYgdGhpcyB1bml0IGhhcyBnaXZlbiBiYXNlIHVuaXRcbiAqIEBwYXJhbSB7QkFTRV9VTklUUyB8IHVuZGVmaW5lZH0gYmFzZVxuICovXG5Vbml0LnByb3RvdHlwZS5oYXNCYXNlID0gZnVuY3Rpb24oYmFzZSkge1xuICByZXR1cm4gKHRoaXMudW5pdC5iYXNlID09PSBiYXNlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyB1bml0IGhhcyBhIGJhc2UgZXF1YWwgdG8gYW5vdGhlciBiYXNlXG4gKiBAcGFyYW0ge1VuaXR9IG90aGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGVxdWFsIGJhc2VcbiAqL1xuVW5pdC5wcm90b3R5cGUuZXF1YWxCYXNlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgcmV0dXJuICh0aGlzLnVuaXQuYmFzZSA9PT0gb3RoZXIudW5pdC5iYXNlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyB1bml0IGVxdWFscyBhbm90aGVyIHVuaXRcbiAqIEBwYXJhbSB7VW5pdH0gb3RoZXJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYm90aCB1bml0cyBhcmUgZXF1YWxcbiAqL1xuVW5pdC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgcmV0dXJuICh0aGlzLmVxdWFsQmFzZShvdGhlcikgJiYgdGhpcy52YWx1ZSA9PSBvdGhlci52YWx1ZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGNsb25lIG9mIHRoaXMgdW5pdCB3aXRoIGEgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nIHwgVW5pdH0gdmFsdWVsZXNzVW5pdCAgIEEgdW5pdCB3aXRob3V0IHZhbHVlLiBDYW4gaGF2ZSBwcmVmaXgsIGxpa2UgXCJjbVwiXG4gKiBAcmV0dXJucyB7VW5pdH0gdW5pdCBoYXZpbmcgZml4ZWQsIHNwZWNpZmllZCB1bml0XG4gKi9cblVuaXQucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKHZhbHVlbGVzc1VuaXQpIHtcbiAgdmFyIG90aGVyO1xuICBpZiAoaXNTdHJpbmcodmFsdWVsZXNzVW5pdCkpIHtcbiAgICBvdGhlciA9IG5ldyBVbml0KG51bGwsIHZhbHVlbGVzc1VuaXQpO1xuXG4gICAgaWYgKCF0aGlzLmVxdWFsQmFzZShvdGhlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5pdHMgZG8gbm90IG1hdGNoJyk7XG4gICAgfVxuXG4gICAgb3RoZXIudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIG90aGVyLmZpeFByZWZpeCA9IHRydWU7XG4gICAgcmV0dXJuIG90aGVyO1xuICB9XG4gIGVsc2UgaWYgKHZhbHVlbGVzc1VuaXQgaW5zdGFuY2VvZiBVbml0KSB7XG4gICAgaWYgKCF0aGlzLmVxdWFsQmFzZSh2YWx1ZWxlc3NVbml0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbml0cyBkbyBub3QgbWF0Y2gnKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlbGVzc1VuaXQudmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgdG8gYSB1bml0IHdpdGggYSB2YWx1ZScpO1xuICAgIH1cblxuICAgIG90aGVyID0gdmFsdWVsZXNzVW5pdC5jbG9uZSgpO1xuICAgIG90aGVyLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBvdGhlci5maXhQcmVmaXggPSB0cnVlO1xuICAgIHJldHVybiBvdGhlcjtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyBvciBVbml0IGV4cGVjdGVkIGFzIHBhcmFtZXRlcicpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHVuaXQgd2hlbiByZXByZXNlbnRlZCB3aXRoIGdpdmVuIHZhbHVlbGVzcyB1bml0XG4gKiBAcGFyYW0ge1N0cmluZyB8IFVuaXR9IHZhbHVlbGVzc1VuaXQgICAgRm9yIGV4YW1wbGUgJ2NtJyBvciAnaW5jaCdcbiAqIEByZXR1cm4ge051bWJlcn0gdmFsdWVcbiAqL1xuVW5pdC5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsdWVsZXNzVW5pdCkge1xuICB2YXIgb3RoZXIgPSB0aGlzLnRvKHZhbHVlbGVzc1VuaXQpO1xuICByZXR1cm4gb3RoZXIuX3Vubm9ybWFsaXplKG90aGVyLnZhbHVlLCBvdGhlci5wcmVmaXgudmFsdWUpO1xufTtcblxuXG4vKipcbiAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuVW5pdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZm9ybWF0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuVW5pdC5wcm90b3R5cGUudmFsdWVPZiA9IFVuaXQucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVW5pdCwgd2l0aCBvcHRpb25hbCBmb3JtYXR0aW5nIG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdCB8IE51bWJlciB8IEZ1bmN0aW9ufSBbb3B0aW9uc10gIEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYi91dGlsL251bWJlcjpmb3JtYXQgZm9yIGFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gb2YgdGhlIGF2YWlsYWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5Vbml0LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciB2YWx1ZSxcbiAgICAgIHN0cjtcblxuICBpZiAodGhpcy52YWx1ZSAhPT0gbnVsbCAmJiAhdGhpcy5maXhQcmVmaXgpIHtcbiAgICB2YXIgYmVzdFByZWZpeCA9IHRoaXMuX2Jlc3RQcmVmaXgoKTtcbiAgICB2YWx1ZSA9IHRoaXMuX3Vubm9ybWFsaXplKHRoaXMudmFsdWUsIGJlc3RQcmVmaXgudmFsdWUpO1xuICAgIHN0ciA9IG51bWJlci5mb3JtYXQodmFsdWUsIG9wdGlvbnMpICsgJyAnO1xuICAgIHN0ciArPSBiZXN0UHJlZml4Lm5hbWUgKyB0aGlzLnVuaXQubmFtZTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YWx1ZSA9IHRoaXMuX3Vubm9ybWFsaXplKHRoaXMudmFsdWUpO1xuICAgIHN0ciA9ICh0aGlzLnZhbHVlICE9PSBudWxsKSA/IChudW1iZXIuZm9ybWF0KHZhbHVlLCBvcHRpb25zKSArICcgJykgOiAnJztcbiAgICBzdHIgKz0gdGhpcy5wcmVmaXgubmFtZSArIHRoaXMudW5pdC5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBiZXN0IHByZWZpeCB1c2luZyBjdXJyZW50IHZhbHVlLlxuICogQHJldHVybnMge09iamVjdH0gcHJlZml4XG4gKiBAcHJpdmF0ZVxuICovXG5Vbml0LnByb3RvdHlwZS5fYmVzdFByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZmluZCB0aGUgYmVzdCBwcmVmaXggdmFsdWUgKHJlc3VsdGluZyBpbiB0aGUgdmFsdWUgb2Ygd2hpY2hcbiAgLy8gdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBsb2cxMCBpcyBjbG9zZXN0IHRvIHplcm8sXG4gIC8vIHRob3VnaCB3aXRoIGEgbGl0dGxlIG9mZnNldCBvZiAxLjIgZm9yIG5pY2VyIHZhbHVlczogeW91IGdldCBhXG4gIC8vIHNlcXVlbmNlIDFtbSAxMDBtbSA1MDBtbSAwLjZtIDFtIDEwbSAxMDBtIDUwMG0gMC42a20gMWttIC4uLlxuICB2YXIgYWJzVmFsdWUgPSBNYXRoLmFicyh0aGlzLnZhbHVlIC8gdGhpcy51bml0LnZhbHVlKTtcbiAgdmFyIGJlc3RQcmVmaXggPSBQUkVGSVhfTk9ORTtcbiAgdmFyIGJlc3REaWZmID0gTWF0aC5hYnMoXG4gICAgICBNYXRoLmxvZyhhYnNWYWx1ZSAvIGJlc3RQcmVmaXgudmFsdWUpIC8gTWF0aC5MTjEwIC0gMS4yKTtcblxuICB2YXIgcHJlZml4ZXMgPSB0aGlzLnVuaXQucHJlZml4ZXM7XG4gIGZvciAodmFyIHAgaW4gcHJlZml4ZXMpIHtcbiAgICBpZiAocHJlZml4ZXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1twXTtcbiAgICAgIGlmIChwcmVmaXguc2NpZW50aWZpYykge1xuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKFxuICAgICAgICAgICAgTWF0aC5sb2coYWJzVmFsdWUgLyBwcmVmaXgudmFsdWUpIC8gTWF0aC5MTjEwIC0gMS4yKTtcblxuICAgICAgICBpZiAoZGlmZiA8IGJlc3REaWZmKSB7XG4gICAgICAgICAgYmVzdFByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgICBiZXN0RGlmZiA9IGRpZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmVzdFByZWZpeDtcbn07XG5cbnZhciBQUkVGSVhFUyA9IHtcbiAgTk9ORToge1xuICAgICcnOiB7bmFtZTogJycsIHZhbHVlOiAxLCBzY2llbnRpZmljOiB0cnVlfVxuICB9LFxuICBTSE9SVDoge1xuICAgICcnOiB7bmFtZTogJycsIHZhbHVlOiAxLCBzY2llbnRpZmljOiB0cnVlfSxcblxuICAgICdkYSc6IHtuYW1lOiAnZGEnLCB2YWx1ZTogMWUxLCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgJ2gnOiB7bmFtZTogJ2gnLCB2YWx1ZTogMWUyLCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgJ2snOiB7bmFtZTogJ2snLCB2YWx1ZTogMWUzLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnTSc6IHtuYW1lOiAnTScsIHZhbHVlOiAxZTYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdHJzoge25hbWU6ICdHJywgdmFsdWU6IDFlOSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ1QnOiB7bmFtZTogJ1QnLCB2YWx1ZTogMWUxMiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ1AnOiB7bmFtZTogJ1AnLCB2YWx1ZTogMWUxNSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ0UnOiB7bmFtZTogJ0UnLCB2YWx1ZTogMWUxOCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ1onOiB7bmFtZTogJ1onLCB2YWx1ZTogMWUyMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ1knOiB7bmFtZTogJ1knLCB2YWx1ZTogMWUyNCwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAnZCc6IHtuYW1lOiAnZCcsIHZhbHVlOiAxZS0xLCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgJ2MnOiB7bmFtZTogJ2MnLCB2YWx1ZTogMWUtMiwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICdtJzoge25hbWU6ICdtJywgdmFsdWU6IDFlLTMsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICd1Jzoge25hbWU6ICd1JywgdmFsdWU6IDFlLTYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICduJzoge25hbWU6ICduJywgdmFsdWU6IDFlLTksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdwJzoge25hbWU6ICdwJywgdmFsdWU6IDFlLTEyLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnZic6IHtuYW1lOiAnZicsIHZhbHVlOiAxZS0xNSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ2EnOiB7bmFtZTogJ2EnLCB2YWx1ZTogMWUtMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICd6Jzoge25hbWU6ICd6JywgdmFsdWU6IDFlLTIxLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAneSc6IHtuYW1lOiAneScsIHZhbHVlOiAxZS0yNCwgc2NpZW50aWZpYzogdHJ1ZX1cbiAgfSxcbiAgTE9ORzoge1xuICAgICcnOiB7bmFtZTogJycsIHZhbHVlOiAxLCBzY2llbnRpZmljOiB0cnVlfSxcblxuICAgICdkZWNhJzoge25hbWU6ICdkZWNhJywgdmFsdWU6IDFlMSwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICdoZWN0byc6IHtuYW1lOiAnaGVjdG8nLCB2YWx1ZTogMWUyLCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgJ2tpbG8nOiB7bmFtZTogJ2tpbG8nLCB2YWx1ZTogMWUzLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnbWVnYSc6IHtuYW1lOiAnbWVnYScsIHZhbHVlOiAxZTYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdnaWdhJzoge25hbWU6ICdnaWdhJywgdmFsdWU6IDFlOSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ3RlcmEnOiB7bmFtZTogJ3RlcmEnLCB2YWx1ZTogMWUxMiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ3BldGEnOiB7bmFtZTogJ3BldGEnLCB2YWx1ZTogMWUxNSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ2V4YSc6IHtuYW1lOiAnZXhhJywgdmFsdWU6IDFlMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICd6ZXR0YSc6IHtuYW1lOiAnemV0dGEnLCB2YWx1ZTogMWUyMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ3lvdHRhJzoge25hbWU6ICd5b3R0YScsIHZhbHVlOiAxZTI0LCBzY2llbnRpZmljOiB0cnVlfSxcblxuICAgICdkZWNpJzoge25hbWU6ICdkZWNpJywgdmFsdWU6IDFlLTEsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAnY2VudGknOiB7bmFtZTogJ2NlbnRpJywgdmFsdWU6IDFlLTIsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAnbWlsbGknOiB7bmFtZTogJ21pbGxpJywgdmFsdWU6IDFlLTMsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdtaWNybyc6IHtuYW1lOiAnbWljcm8nLCB2YWx1ZTogMWUtNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ25hbm8nOiB7bmFtZTogJ25hbm8nLCB2YWx1ZTogMWUtOSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ3BpY28nOiB7bmFtZTogJ3BpY28nLCB2YWx1ZTogMWUtMTIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdmZW10byc6IHtuYW1lOiAnZmVtdG8nLCB2YWx1ZTogMWUtMTUsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdhdHRvJzoge25hbWU6ICdhdHRvJywgdmFsdWU6IDFlLTE4LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnemVwdG8nOiB7bmFtZTogJ3plcHRvJywgdmFsdWU6IDFlLTIxLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAneW9jdG8nOiB7bmFtZTogJ3lvY3RvJywgdmFsdWU6IDFlLTI0LCBzY2llbnRpZmljOiB0cnVlfVxuICB9LFxuICBTUVVBUkVEOiB7XG4gICAgJyc6IHtuYW1lOiAnJywgdmFsdWU6IDEsIHNjaWVudGlmaWM6IHRydWV9LFxuXG4gICAgJ2RhJzoge25hbWU6ICdkYScsIHZhbHVlOiAxZTIsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAnaCc6IHtuYW1lOiAnaCcsIHZhbHVlOiAxZTQsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAnayc6IHtuYW1lOiAnaycsIHZhbHVlOiAxZTYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdNJzoge25hbWU6ICdNJywgdmFsdWU6IDFlMTIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdHJzoge25hbWU6ICdHJywgdmFsdWU6IDFlMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdUJzoge25hbWU6ICdUJywgdmFsdWU6IDFlMjQsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdQJzoge25hbWU6ICdQJywgdmFsdWU6IDFlMzAsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdFJzoge25hbWU6ICdFJywgdmFsdWU6IDFlMzYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdaJzoge25hbWU6ICdaJywgdmFsdWU6IDFlNDIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdZJzoge25hbWU6ICdZJywgdmFsdWU6IDFlNDgsIHNjaWVudGlmaWM6IHRydWV9LFxuXG4gICAgJ2QnOiB7bmFtZTogJ2QnLCB2YWx1ZTogMWUtMiwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICdjJzoge25hbWU6ICdjJywgdmFsdWU6IDFlLTQsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAnbSc6IHtuYW1lOiAnbScsIHZhbHVlOiAxZS02LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAndSc6IHtuYW1lOiAndScsIHZhbHVlOiAxZS0xMiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ24nOiB7bmFtZTogJ24nLCB2YWx1ZTogMWUtMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdwJzoge25hbWU6ICdwJywgdmFsdWU6IDFlLTI0LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnZic6IHtuYW1lOiAnZicsIHZhbHVlOiAxZS0zMCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ2EnOiB7bmFtZTogJ2EnLCB2YWx1ZTogMWUtMzYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICd6Jzoge25hbWU6ICd6JywgdmFsdWU6IDFlLTQyLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAneSc6IHtuYW1lOiAneScsIHZhbHVlOiAxZS00Miwgc2NpZW50aWZpYzogdHJ1ZX1cbiAgfSxcbiAgQ1VCSUM6IHtcbiAgICAnJzoge25hbWU6ICcnLCB2YWx1ZTogMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAnZGEnOiB7bmFtZTogJ2RhJywgdmFsdWU6IDFlMywgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICdoJzoge25hbWU6ICdoJywgdmFsdWU6IDFlNiwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICdrJzoge25hbWU6ICdrJywgdmFsdWU6IDFlOSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ00nOiB7bmFtZTogJ00nLCB2YWx1ZTogMWUxOCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ0cnOiB7bmFtZTogJ0cnLCB2YWx1ZTogMWUyNywgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ1QnOiB7bmFtZTogJ1QnLCB2YWx1ZTogMWUzNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ1AnOiB7bmFtZTogJ1AnLCB2YWx1ZTogMWU0NSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ0UnOiB7bmFtZTogJ0UnLCB2YWx1ZTogMWU1NCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ1onOiB7bmFtZTogJ1onLCB2YWx1ZTogMWU2Mywgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ1knOiB7bmFtZTogJ1knLCB2YWx1ZTogMWU3Miwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAnZCc6IHtuYW1lOiAnZCcsIHZhbHVlOiAxZS0zLCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgJ2MnOiB7bmFtZTogJ2MnLCB2YWx1ZTogMWUtNiwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICdtJzoge25hbWU6ICdtJywgdmFsdWU6IDFlLTksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICd1Jzoge25hbWU6ICd1JywgdmFsdWU6IDFlLTE4LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnbic6IHtuYW1lOiAnbicsIHZhbHVlOiAxZS0yNywgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ3AnOiB7bmFtZTogJ3AnLCB2YWx1ZTogMWUtMzYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdmJzoge25hbWU6ICdmJywgdmFsdWU6IDFlLTQ1LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnYSc6IHtuYW1lOiAnYScsIHZhbHVlOiAxZS01NCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ3onOiB7bmFtZTogJ3onLCB2YWx1ZTogMWUtNjMsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICd5Jzoge25hbWU6ICd5JywgdmFsdWU6IDFlLTcyLCBzY2llbnRpZmljOiB0cnVlfVxuICB9LFxuICBCSU5BUllfU0hPUlQ6IHtcbiAgICAnJzoge25hbWU6ICcnLCB2YWx1ZTogMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ2snOiB7bmFtZTogJ2snLCB2YWx1ZTogMTAyNCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ00nOiB7bmFtZTogJ00nLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgMiksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdHJzoge25hbWU6ICdHJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDMpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnVCc6IHtuYW1lOiAnVCcsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA0KSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ1AnOiB7bmFtZTogJ1AnLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgNSksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdFJzoge25hbWU6ICdFJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDYpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnWic6IHtuYW1lOiAnWicsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA3KSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ1knOiB7bmFtZTogJ1knLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgOCksIHNjaWVudGlmaWM6IHRydWV9LFxuXG4gICAgJ0tpJzoge25hbWU6ICdLaScsIHZhbHVlOiAxMDI0LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnTWknOiB7bmFtZTogJ01pJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDIpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnR2knOiB7bmFtZTogJ0dpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDMpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnVGknOiB7bmFtZTogJ1RpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDQpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnUGknOiB7bmFtZTogJ1BpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDUpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnRWknOiB7bmFtZTogJ0VpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDYpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnWmknOiB7bmFtZTogJ1ppJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDcpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnWWknOiB7bmFtZTogJ1lpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDgpLCBzY2llbnRpZmljOiB0cnVlfVxuICB9LFxuICBCSU5BUllfTE9ORzoge1xuICAgICcnOiB7bmFtZTogJycsIHZhbHVlOiAxLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAna2lsbyc6IHtuYW1lOiAna2lsbycsIHZhbHVlOiAxMDI0LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnbWVnYSc6IHtuYW1lOiAnbWVnYScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCAyKSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ2dpZ2EnOiB7bmFtZTogJ2dpZ2EnLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgMyksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICd0ZXJhJzoge25hbWU6ICd0ZXJhJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDQpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAncGV0YSc6IHtuYW1lOiAncGV0YScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA1KSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ2V4YSc6IHtuYW1lOiAnZXhhJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDYpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnemV0dGEnOiB7bmFtZTogJ3pldHRhJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDcpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAneW90dGEnOiB7bmFtZTogJ3lvdHRhJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDgpLCBzY2llbnRpZmljOiB0cnVlfSxcblxuICAgICdraWJpJzoge25hbWU6ICdraWJpJywgdmFsdWU6IDEwMjQsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdtZWJpJzoge25hbWU6ICdtZWJpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDIpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnZ2liaSc6IHtuYW1lOiAnZ2liaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCAzKSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgJ3RlYmknOiB7bmFtZTogJ3RlYmknLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgNCksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICdwZWJpJzoge25hbWU6ICdwZWJpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDUpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAnZXhpJzoge25hbWU6ICdleGknLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgNiksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICd6ZWJpJzoge25hbWU6ICd6ZWJpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDcpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAneW9iaSc6IHtuYW1lOiAneW9iaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA4KSwgc2NpZW50aWZpYzogdHJ1ZX1cbiAgfVxufTtcblxudmFyIFBSRUZJWF9OT05FID0ge25hbWU6ICcnLCB2YWx1ZTogMSwgc2NpZW50aWZpYzogdHJ1ZX07XG5cbnZhciBCQVNFX1VOSVRTID0ge1xuICBOT05FOiB7fSxcblxuICBMRU5HVEg6IHt9LCAgICAgICAgICAgICAgIC8vIG1ldGVyXG4gIE1BU1M6IHt9LCAgICAgICAgICAgICAgICAgLy8ga2lsb2dyYW1cbiAgVElNRToge30sICAgICAgICAgICAgICAgICAvLyBzZWNvbmRcbiAgQ1VSUkVOVDoge30sICAgICAgICAgICAgICAvLyBhbXBlcmVcbiAgVEVNUEVSQVRVUkU6IHt9LCAgICAgICAgICAvLyBrZWx2aW5cbiAgTFVNSU5PVVNfSU5URU5TSVRZOiB7fSwgICAvLyBjYW5kZWxhXG4gIEFNT1VOVF9PRl9TVUJTVEFOQ0U6IHt9LCAgLy8gbW9sZVxuXG4gIEZPUkNFOiB7fSwgICAgICAgICAgICAgICAgLy8gTmV3dG9uXG4gIFNVUkZBQ0U6IHt9LCAgICAgICAgICAgICAgLy8gbTJcbiAgVk9MVU1FOiB7fSwgICAgICAgICAgICAgICAvLyBtM1xuICBBTkdMRToge30sICAgICAgICAgICAgICAgIC8vIHJhZFxuICBCSVQ6IHt9ICAgICAgICAgICAgICAgICAgIC8vIGJpdCAoZGlnaXRhbClcbn07XG5cbnZhciBCQVNFX1VOSVRfTk9ORSA9IHt9O1xuXG52YXIgVU5JVF9OT05FID0ge25hbWU6ICcnLCBiYXNlOiBCQVNFX1VOSVRfTk9ORSwgdmFsdWU6IDEsIG9mZnNldDogMH07XG5cbnZhciBVTklUUyA9IHtcbiAgLy8gbGVuZ3RoXG4gIG1ldGVyOiB7bmFtZTogJ21ldGVyJywgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLCB2YWx1ZTogMSwgb2Zmc2V0OiAwfSxcbiAgaW5jaDoge25hbWU6ICdpbmNoJywgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC4wMjU0LCBvZmZzZXQ6IDB9LFxuICBmb290OiB7bmFtZTogJ2Zvb3QnLCBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjMwNDgsIG9mZnNldDogMH0sXG4gIHlhcmQ6IHtuYW1lOiAneWFyZCcsIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuOTE0NCwgb2Zmc2V0OiAwfSxcbiAgbWlsZToge25hbWU6ICdtaWxlJywgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMTYwOS4zNDQsIG9mZnNldDogMH0sXG4gIGxpbms6IHtuYW1lOiAnbGluaycsIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMjAxMTY4LCBvZmZzZXQ6IDB9LFxuICByb2Q6IHtuYW1lOiAncm9kJywgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogNS4wMjkyMTAsIG9mZnNldDogMH0sXG4gIGNoYWluOiB7bmFtZTogJ2NoYWluJywgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMjAuMTE2OCwgb2Zmc2V0OiAwfSxcbiAgYW5nc3Ryb206IHtuYW1lOiAnYW5nc3Ryb20nLCBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAxZS0xMCwgb2Zmc2V0OiAwfSxcblxuICBtOiB7bmFtZTogJ20nLCBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCwgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULCB2YWx1ZTogMSwgb2Zmc2V0OiAwfSxcbiAgJ2luJzoge25hbWU6ICdpbicsIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDI1NCwgb2Zmc2V0OiAwfSxcbiAgZnQ6IHtuYW1lOiAnZnQnLCBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjMwNDgsIG9mZnNldDogMH0sXG4gIHlkOiB7bmFtZTogJ3lkJywgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC45MTQ0LCBvZmZzZXQ6IDB9LFxuICBtaToge25hbWU6ICdtaScsIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDE2MDkuMzQ0LCBvZmZzZXQ6IDB9LFxuICBsaToge25hbWU6ICdsaScsIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMjAxMTY4LCBvZmZzZXQ6IDB9LFxuICByZDoge25hbWU6ICdyZCcsIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDUuMDI5MjEwLCBvZmZzZXQ6IDB9LFxuICBjaDoge25hbWU6ICdjaCcsIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDIwLjExNjgsIG9mZnNldDogMH0sXG4gIG1pbDoge25hbWU6ICdtaWwnLCBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjAwMDAyNTQsIG9mZnNldDogMH0sIC8vIDEvMTAwMCBpbmNoXG5cbiAgLy8gU3VyZmFjZVxuICBtMjoge25hbWU6ICdtMicsIGJhc2U6IEJBU0VfVU5JVFMuU1VSRkFDRSwgcHJlZml4ZXM6IFBSRUZJWEVTLlNRVUFSRUQsIHZhbHVlOiAxLCBvZmZzZXQ6IDB9LFxuICBzcWluOiB7bmFtZTogJ3NxaW4nLCBiYXNlOiBCQVNFX1VOSVRTLlNVUkZBQ0UsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC4wMDA2NDUxNiwgb2Zmc2V0OiAwfSwgLy8gNjQ1LjE2IG1tMlxuICBzcWZ0OiB7bmFtZTogJ3NxZnQnLCBiYXNlOiBCQVNFX1VOSVRTLlNVUkZBQ0UsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC4wOTI5MDMwNCwgb2Zmc2V0OiAwfSwgLy8gMC4wOTI5MDMwNCBtMlxuICBzcXlkOiB7bmFtZTogJ3NxeWQnLCBiYXNlOiBCQVNFX1VOSVRTLlNVUkZBQ0UsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC44MzYxMjczNiwgb2Zmc2V0OiAwfSwgLy8gMC44MzYxMjczNiBtMlxuICBzcW1pOiB7bmFtZTogJ3NxbWknLCBiYXNlOiBCQVNFX1VOSVRTLlNVUkZBQ0UsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMjU4OTk4OC4xMTAzMzYsIG9mZnNldDogMH0sIC8vIDIuNTg5OTg4MTEwMzM2IGttMlxuICBzcXJkOiB7bmFtZTogJ3NxcmQnLCBiYXNlOiBCQVNFX1VOSVRTLlNVUkZBQ0UsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMjUuMjkyOTUsIG9mZnNldDogMH0sIC8vIDI1LjI5Mjk1IG0yXG4gIHNxY2g6IHtuYW1lOiAnc3FjaCcsIGJhc2U6IEJBU0VfVU5JVFMuU1VSRkFDRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiA0MDQuNjg3Mywgb2Zmc2V0OiAwfSwgLy8gNDA0LjY4NzMgbTJcbiAgc3FtaWw6IHtuYW1lOiAnc3FtaWwnLCBiYXNlOiBCQVNFX1VOSVRTLlNVUkZBQ0UsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogNi40NTE2ZS0xMCwgb2Zmc2V0OiAwfSwgLy8gNi40NTE2ICogMTBeLTEwIG0yXG5cbiAgLy8gVm9sdW1lXG4gIG0zOiB7bmFtZTogJ20zJywgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5DVUJJQywgdmFsdWU6IDEsIG9mZnNldDogMH0sXG4gIEw6IHtuYW1lOiAnTCcsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsIHZhbHVlOiAwLjAwMSwgb2Zmc2V0OiAwfSwgLy8gbGl0cmVcbiAgbDoge25hbWU6ICdsJywgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCwgdmFsdWU6IDAuMDAxLCBvZmZzZXQ6IDB9LCAvLyBsaXRyZVxuICBsaXRyZToge25hbWU6ICdsaXRyZScsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTE9ORywgdmFsdWU6IDAuMDAxLCBvZmZzZXQ6IDB9LFxuICBjdWluOiB7bmFtZTogJ2N1aW4nLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAxLjYzODcwNjRlLTUsIG9mZnNldDogMH0sIC8vIDEuNjM4NzA2NGUtNSBtM1xuICBjdWZ0OiB7bmFtZTogJ2N1ZnQnLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjAyODMxNjg0NjU5Miwgb2Zmc2V0OiAwfSwgLy8gMjguMzE2IDg0NiA1OTIgTFxuICBjdXlkOiB7bmFtZTogJ2N1eWQnLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjc2NDU1NDg1Nzk4NCwgb2Zmc2V0OiAwfSwgLy8gNzY0LjU1NCA4NTcgOTg0IExcbiAgdGVhc3Bvb246IHtuYW1lOiAndGVhc3Bvb24nLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjAwMDAwNSwgb2Zmc2V0OiAwfSwgLy8gNSBtTFxuICB0YWJsZXNwb29uOiB7bmFtZTogJ3RhYmxlc3Bvb24nLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjAwMDAxNSwgb2Zmc2V0OiAwfSwgLy8gMTUgbUxcbiAgLy97bmFtZTogJ2N1cCcsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAwMjQwLCBvZmZzZXQ6IDB9LCAvLyAyNDAgbUwgIC8vIG5vdCBwb3NzaWJsZSwgd2UgaGF2ZSBhbHJlYWR5IGFub3RoZXIgY3VwXG4gIGRyb3A6IHtuYW1lOiAnZHJvcCcsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDVlLTgsIG9mZnNldDogMH0sICAvLyAwLjA1IG1MID0gNWUtOCBtM1xuICBndHQ6IHtuYW1lOiAnZ3R0JywgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogNWUtOCwgb2Zmc2V0OiAwfSwgIC8vIDAuMDUgbUwgPSA1ZS04IG0zXG5cbiAgLy8gTGlxdWlkIHZvbHVtZVxuICBtaW5pbToge25hbWU6ICdtaW5pbScsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAwMDAwMDYxNjExNTIsIG9mZnNldDogMH0sIC8vIDAuMDYxNjExNTIgbUxcbiAgZmx1aWRkcmFtOiB7bmFtZTogJ2ZsdWlkZHJhbScsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAwMDAzNjk2NjkxMSwgb2Zmc2V0OiAwfSwgIC8vIDMuNjk2NjkxIG1MXG4gIGZsdWlkb3VuY2U6IHtuYW1lOiAnZmx1aWRvdW5jZScsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAwMDI5NTczNTMsIG9mZnNldDogMH0sIC8vIDI5LjU3MzUzIG1MXG4gIGdpbGw6IHtuYW1lOiAnZ2lsbCcsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAwMTE4Mjk0MSwgb2Zmc2V0OiAwfSwgLy8gMTE4LjI5NDEgbUxcbiAgY2M6IHtuYW1lOiAnY2MnLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAxZS02LCBvZmZzZXQ6IDB9LCAvLyAxZS02IExcbiAgY3VwOiB7bmFtZTogJ2N1cCcsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAwMjM2NTg4Miwgb2Zmc2V0OiAwfSwgLy8gMjM2LjU4ODIgbUxcbiAgcGludDoge25hbWU6ICdwaW50JywgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC4wMDA0NzMxNzY1LCBvZmZzZXQ6IDB9LCAvLyA0NzMuMTc2NSBtTFxuICBxdWFydDoge25hbWU6ICdxdWFydCcsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAwOTQ2MzUyOSwgb2Zmc2V0OiAwfSwgLy8gOTQ2LjM1MjkgbUxcbiAgZ2FsbG9uOiB7bmFtZTogJ2dhbGxvbicsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAzNzg1NDEyLCBvZmZzZXQ6IDB9LCAvLyAzLjc4NTQxMiBMXG4gIGJlZXJiYXJyZWw6IHtuYW1lOiAnYmVlcmJhcnJlbCcsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMTE3MzQ3OCwgb2Zmc2V0OiAwfSwgLy8gMTE3LjM0NzggTFxuICBvaWxiYXJyZWw6IHtuYW1lOiAnb2lsYmFycmVsJywgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC4xNTg5ODczLCBvZmZzZXQ6IDB9LCAvLyAxNTguOTg3MyBMXG4gIGhvZ3NoZWFkOiB7bmFtZTogJ2hvZ3NoZWFkJywgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC4yMzg0ODEwLCBvZmZzZXQ6IDB9LCAvLyAyMzguNDgxMCBMXG5cbiAgLy97bmFtZTogJ21pbicsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAwMDAwMDYxNjExNTIsIG9mZnNldDogMH0sIC8vIDAuMDYxNjExNTIgbUwgLy8gbWluIGlzIGFscmVhZHkgaW4gdXNlIGFzIG1pbnV0ZVxuICBmbGRyOiB7bmFtZTogJ2ZsZHInLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjAwMDAwMzY5NjY5MTEsIG9mZnNldDogMH0sICAvLyAzLjY5NjY5MSBtTFxuICBmbG96OiB7bmFtZTogJ2Zsb3onLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjAwMDAyOTU3MzUzLCBvZmZzZXQ6IDB9LCAvLyAyOS41NzM1MyBtTFxuICBnaToge25hbWU6ICdnaScsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAwMTE4Mjk0MSwgb2Zmc2V0OiAwfSwgLy8gMTE4LjI5NDEgbUxcbiAgY3A6IHtuYW1lOiAnY3AnLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjAwMDIzNjU4ODIsIG9mZnNldDogMH0sIC8vIDIzNi41ODgyIG1MXG4gIHB0OiB7bmFtZTogJ3B0JywgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC4wMDA0NzMxNzY1LCBvZmZzZXQ6IDB9LCAvLyA0NzMuMTc2NSBtTFxuICBxdDoge25hbWU6ICdxdCcsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAwOTQ2MzUyOSwgb2Zmc2V0OiAwfSwgLy8gOTQ2LjM1MjkgbUxcbiAgZ2FsOiB7bmFtZTogJ2dhbCcsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDAzNzg1NDEyLCBvZmZzZXQ6IDB9LCAvLyAzLjc4NTQxMiBMXG4gIGJibDoge25hbWU6ICdiYmwnLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjExNzM0NzgsIG9mZnNldDogMH0sIC8vIDExNy4zNDc4IExcbiAgb2JsOiB7bmFtZTogJ29ibCcsIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMTU4OTg3Mywgb2Zmc2V0OiAwfSwgLy8gMTU4Ljk4NzMgTFxuICAvL3tuYW1lOiAnaG9nc2hlYWQnLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjIzODQ4MTAsIG9mZnNldDogMH0sIC8vIDIzOC40ODEwIEwgLy8gVE9ETzogaGg/XG5cbiAgLy8gTWFzc1xuICBnOiB7bmFtZTogJ2cnLCBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCwgdmFsdWU6IDAuMDAxLCBvZmZzZXQ6IDB9LFxuICBncmFtOiB7bmFtZTogJ2dyYW0nLCBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLCB2YWx1ZTogMC4wMDEsIG9mZnNldDogMH0sXG5cbiAgdG9uOiB7bmFtZTogJ3RvbicsIGJhc2U6IEJBU0VfVU5JVFMuTUFTUywgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULCB2YWx1ZTogOTA3LjE4NDc0LCBvZmZzZXQ6IDB9LFxuICB0b25uZToge25hbWU6ICd0b25uZScsIGJhc2U6IEJBU0VfVU5JVFMuTUFTUywgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULCB2YWx1ZTogMTAwMCwgb2Zmc2V0OiAwfSxcblxuICBncmFpbjoge25hbWU6ICdncmFpbicsIGJhc2U6IEJBU0VfVU5JVFMuTUFTUywgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiA2NC43OTg5MWUtNiwgb2Zmc2V0OiAwfSxcbiAgZHJhbToge25hbWU6ICdkcmFtJywgYmFzZTogQkFTRV9VTklUUy5NQVNTLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDEuNzcxODQ1MTk1MzEyNWUtMywgb2Zmc2V0OiAwfSxcbiAgb3VuY2U6IHtuYW1lOiAnb3VuY2UnLCBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMjguMzQ5NTIzMTI1ZS0zLCBvZmZzZXQ6IDB9LFxuICBwb3VuZG1hc3M6IHtuYW1lOiAncG91bmRtYXNzJywgYmFzZTogQkFTRV9VTklUUy5NQVNTLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDQ1My41OTIzN2UtMywgb2Zmc2V0OiAwfSxcbiAgaHVuZHJlZHdlaWdodDoge25hbWU6ICdodW5kcmVkd2VpZ2h0JywgYmFzZTogQkFTRV9VTklUUy5NQVNTLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDQ1LjM1OTIzNywgb2Zmc2V0OiAwfSxcbiAgc3RpY2s6IHtuYW1lOiAnc3RpY2snLCBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMTE1ZS0zLCBvZmZzZXQ6IDB9LFxuXG4gIGdyOiB7bmFtZTogJ2dyJywgYmFzZTogQkFTRV9VTklUUy5NQVNTLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDY0Ljc5ODkxZS02LCBvZmZzZXQ6IDB9LFxuICBkcjoge25hbWU6ICdkcicsIGJhc2U6IEJBU0VfVU5JVFMuTUFTUywgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAxLjc3MTg0NTE5NTMxMjVlLTMsIG9mZnNldDogMH0sXG4gIG96OiB7bmFtZTogJ296JywgYmFzZTogQkFTRV9VTklUUy5NQVNTLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDI4LjM0OTUyMzEyNWUtMywgb2Zmc2V0OiAwfSxcbiAgbGJtOiB7bmFtZTogJ2xibScsIGJhc2U6IEJBU0VfVU5JVFMuTUFTUywgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiA0NTMuNTkyMzdlLTMsIG9mZnNldDogMH0sXG4gIGN3dDoge25hbWU6ICdjd3QnLCBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogNDUuMzU5MjM3LCBvZmZzZXQ6IDB9LFxuXG4gIC8vIFRpbWVcbiAgczoge25hbWU6ICdzJywgYmFzZTogQkFTRV9VTklUUy5USU1FLCBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsIHZhbHVlOiAxLCBvZmZzZXQ6IDB9LFxuICBtaW46IHtuYW1lOiAnbWluJywgYmFzZTogQkFTRV9VTklUUy5USU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDYwLCBvZmZzZXQ6IDB9LFxuICBoOiB7bmFtZTogJ2gnLCBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMzYwMCwgb2Zmc2V0OiAwfSxcbiAgc2Vjb25kOiB7bmFtZTogJ3NlY29uZCcsIGJhc2U6IEJBU0VfVU5JVFMuVElNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsIHZhbHVlOiAxLCBvZmZzZXQ6IDB9LFxuICBzZWM6IHtuYW1lOiAnc2VjJywgYmFzZTogQkFTRV9VTklUUy5USU1FLCBwcmVmaXhlczogUFJFRklYRVMuTE9ORywgdmFsdWU6IDEsIG9mZnNldDogMH0sXG4gIG1pbnV0ZToge25hbWU6ICdtaW51dGUnLCBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogNjAsIG9mZnNldDogMH0sXG4gIGhvdXI6IHtuYW1lOiAnaG91cicsIGJhc2U6IEJBU0VfVU5JVFMuVElNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAzNjAwLCBvZmZzZXQ6IDB9LFxuICBkYXk6IHtuYW1lOiAnZGF5JywgYmFzZTogQkFTRV9VTklUUy5USU1FLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDg2NDAwLCBvZmZzZXQ6IDB9LFxuXG4gIC8vIEFuZ2xlXG4gIHJhZDoge25hbWU6ICdyYWQnLCBiYXNlOiBCQVNFX1VOSVRTLkFOR0xFLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDEsIG9mZnNldDogMH0sXG4gIC8vIGRlZyA9IHJhZCAvICgyKnBpKSAqIDM2MCA9IHJhZCAvIDAuMDE3NDUzMjkyNTE5OTQzMjk1NzY5MjM2OTA3Njg0ODg4XG4gIGRlZzoge25hbWU6ICdkZWcnLCBiYXNlOiBCQVNFX1VOSVRTLkFOR0xFLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDAuMDE3NDUzMjkyNTE5OTQzMjk1NzY5MjM2OTA3Njg0ODg4LCBvZmZzZXQ6IDB9LFxuICAvLyBncmFkID0gcmFkIC8gKDIqcGkpICogNDAwICA9IHJhZCAvIDAuMDE1NzA3OTYzMjY3OTQ4OTY2MTkyMzEzMjE2OTE2Mzk5XG4gIGdyYWQ6IHtuYW1lOiAnZ3JhZCcsIGJhc2U6IEJBU0VfVU5JVFMuQU5HTEUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC4wMTU3MDc5NjMyNjc5NDg5NjYxOTIzMTMyMTY5MTYzOTksIG9mZnNldDogMH0sXG4gIC8vIGN5Y2xlID0gcmFkIC8gKDIqcGkpID0gcmFkIC8gNi4yODMxODUzMDcxNzk1ODY0NzY5MjUyODY3NjY1NzkzXG4gIGN5Y2xlOiB7bmFtZTogJ2N5Y2xlJywgYmFzZTogQkFTRV9VTklUUy5BTkdMRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiA2LjI4MzE4NTMwNzE3OTU4NjQ3NjkyNTI4Njc2NjU3OTMsIG9mZnNldDogMH0sXG5cbiAgLy8gRWxlY3RyaWMgY3VycmVudFxuICBBOiB7bmFtZTogJ0EnLCBiYXNlOiBCQVNFX1VOSVRTLkNVUlJFTlQsIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCwgdmFsdWU6IDEsIG9mZnNldDogMH0sXG4gIGFtcGVyZToge25hbWU6ICdhbXBlcmUnLCBiYXNlOiBCQVNFX1VOSVRTLkNVUlJFTlQsIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLCB2YWx1ZTogMSwgb2Zmc2V0OiAwfSxcblxuICAvLyBUZW1wZXJhdHVyZVxuICAvLyBLKEMpID0gwrBDICsgMjczLjE1XG4gIC8vIEsoRikgPSAowrBGICsgNDU5LjY3KSAvIDEuOFxuICAvLyBLKFIpID0gwrBSIC8gMS44XG4gIEs6IHtuYW1lOiAnSycsIGJhc2U6IEJBU0VfVU5JVFMuVEVNUEVSQVRVUkUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMSwgb2Zmc2V0OiAwfSxcbiAgZGVnQzoge25hbWU6ICdkZWdDJywgYmFzZTogQkFTRV9VTklUUy5URU1QRVJBVFVSRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAxLCBvZmZzZXQ6IDI3My4xNX0sXG4gIGRlZ0Y6IHtuYW1lOiAnZGVnRicsIGJhc2U6IEJBU0VfVU5JVFMuVEVNUEVSQVRVUkUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMS8xLjgsIG9mZnNldDogNDU5LjY3fSxcbiAgZGVnUjoge25hbWU6ICdkZWdSJywgYmFzZTogQkFTRV9VTklUUy5URU1QRVJBVFVSRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAxLzEuOCwgb2Zmc2V0OiAwfSxcbiAga2VsdmluOiB7bmFtZTogJ2tlbHZpbicsIGJhc2U6IEJBU0VfVU5JVFMuVEVNUEVSQVRVUkUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMSwgb2Zmc2V0OiAwfSxcbiAgY2Vsc2l1czoge25hbWU6ICdjZWxzaXVzJywgYmFzZTogQkFTRV9VTklUUy5URU1QRVJBVFVSRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAxLCBvZmZzZXQ6IDI3My4xNX0sXG4gIGZhaHJlbmhlaXQ6IHtuYW1lOiAnZmFocmVuaGVpdCcsIGJhc2U6IEJBU0VfVU5JVFMuVEVNUEVSQVRVUkUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMS8xLjgsIG9mZnNldDogNDU5LjY3fSxcbiAgcmFua2luZToge25hbWU6ICdyYW5raW5lJywgYmFzZTogQkFTRV9VTklUUy5URU1QRVJBVFVSRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAxLzEuOCwgb2Zmc2V0OiAwfSxcblxuICAvLyBhbW91bnQgb2Ygc3Vic3RhbmNlXG4gIG1vbDoge25hbWU6ICdtb2wnLCBiYXNlOiBCQVNFX1VOSVRTLkFNT1VOVF9PRl9TVUJTVEFOQ0UsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMSwgb2Zmc2V0OiAwfSxcbiAgbW9sZToge25hbWU6ICdtb2xlJywgYmFzZTogQkFTRV9VTklUUy5BTU9VTlRfT0ZfU1VCU1RBTkNFLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDEsIG9mZnNldDogMH0sXG5cbiAgLy8gbHVtaW5vdXMgaW50ZW5zaXR5XG4gIGNkOiB7bmFtZTogJ2NkJywgYmFzZTogQkFTRV9VTklUUy5MVU1JTk9VU19JTlRFTlNJVFksIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMSwgb2Zmc2V0OiAwfSxcbiAgY2FuZGVsYToge25hbWU6ICdjYW5kZWxhJywgYmFzZTogQkFTRV9VTklUUy5MVU1JTk9VU19JTlRFTlNJVFksIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMSwgb2Zmc2V0OiAwfSxcbiAgLy8gVE9ETzogdW5pdHMgU1RFUkFESUFOXG4gIC8ve25hbWU6ICdzcicsIGJhc2U6IEJBU0VfVU5JVFMuU1RFUkFESUFOLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDEsIG9mZnNldDogMH0sXG4gIC8ve25hbWU6ICdzdGVyYWRpYW4nLCBiYXNlOiBCQVNFX1VOSVRTLlNURVJBRElBTiwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAxLCBvZmZzZXQ6IDB9LFxuXG4gIC8vIEZvcmNlXG4gIE46IHtuYW1lOiAnTicsIGJhc2U6IEJBU0VfVU5JVFMuRk9SQ0UsIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCwgdmFsdWU6IDEsIG9mZnNldDogMH0sXG4gIG5ld3Rvbjoge25hbWU6ICduZXd0b24nLCBiYXNlOiBCQVNFX1VOSVRTLkZPUkNFLCBwcmVmaXhlczogUFJFRklYRVMuTE9ORywgdmFsdWU6IDEsIG9mZnNldDogMH0sXG4gIGxiZjoge25hbWU6ICdsYmYnLCBiYXNlOiBCQVNFX1VOSVRTLkZPUkNFLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDQuNDQ4MjIxNjE1MjYwNSwgb2Zmc2V0OiAwfSxcbiAgcG91bmRmb3JjZToge25hbWU6ICdwb3VuZGZvcmNlJywgYmFzZTogQkFTRV9VTklUUy5GT1JDRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiA0LjQ0ODIyMTYxNTI2MDUsIG9mZnNldDogMH0sXG5cbiAgLy8gQmluYXJ5XG4gIGI6IHtuYW1lOiAnYicsIGJhc2U6IEJBU0VfVU5JVFMuQklULCBwcmVmaXhlczogUFJFRklYRVMuQklOQVJZX1NIT1JULCB2YWx1ZTogMSwgb2Zmc2V0OiAwfSxcbiAgYml0czoge25hbWU6ICdiaXRzJywgYmFzZTogQkFTRV9VTklUUy5CSVQsIHByZWZpeGVzOiBQUkVGSVhFUy5CSU5BUllfTE9ORywgdmFsdWU6IDEsIG9mZnNldDogMH0sXG4gIEI6IHtuYW1lOiAnQicsIGJhc2U6IEJBU0VfVU5JVFMuQklULCBwcmVmaXhlczogUFJFRklYRVMuQklOQVJZX1NIT1JULCB2YWx1ZTogOCwgb2Zmc2V0OiAwfSxcbiAgYnl0ZXM6IHtuYW1lOiAnYnl0ZXMnLCBiYXNlOiBCQVNFX1VOSVRTLkJJVCwgcHJlZml4ZXM6IFBSRUZJWEVTLkJJTkFSWV9MT05HLCB2YWx1ZTogOCwgb2Zmc2V0OiAwfVxufTtcblxuLy8gcGx1cmFsc1xudmFyIFBMVVJBTFMgPSB7XG4gIG1ldGVyczogJ21ldGVyJyxcbiAgaW5jaGVzOiAnaW5jaCcsXG4gIGZlZXQ6ICdmb290JyxcbiAgeWFyZHM6ICd5YXJkJyxcbiAgbWlsZXM6ICdtaWxlJyxcbiAgbGlua3M6ICdsaW5rJyxcbiAgcm9kczogJ3JvZCcsXG4gIGNoYWluczogJ2NoYWluJyxcbiAgYW5nc3Ryb21zOiAnYW5nc3Ryb20nLFxuXG4gIGxpdHJlczogJ2xpdHJlJyxcbiAgdGVhc3Bvb25zOiAndGVhc3Bvb24nLFxuICB0YWJsZXNwb29uczogJ3RhYmxlc3Bvb24nLFxuICBtaW5pbXM6ICdtaW5pbScsXG4gIGZsdWlkZHJhbXM6ICdmbHVpZGRyYW0nLFxuICBmbHVpZG91bmNlczogJ2ZsdWlkb3VuY2UnLFxuICBnaWxsczogJ2dpbGwnLFxuICBjdXBzOiAnY3VwJyxcbiAgcGludHM6ICdwaW50JyxcbiAgcXVhcnRzOiAncXVhcnQnLFxuICBnYWxsb25zOiAnZ2FsbG9uJyxcbiAgYmVlcmJhcnJlbHM6ICdiZWVyYmFycmVsJyxcbiAgb2lsYmFycmVsczogJ29pbGJhcnJlbCcsXG4gIGhvZ3NoZWFkczogJ2hvZ3NoZWFkJyxcbiAgZ3R0czogJ2d0dCcsXG5cbiAgZ3JhbXM6ICdncmFtJyxcbiAgdG9uczogJ3RvbicsXG4gIHRvbm5lczogJ3Rvbm5lJyxcbiAgZ3JhaW5zOiAnZ3JhaW4nLFxuICBkcmFtczogJ2RyYW0nLFxuICBvdW5jZXM6ICdvdW5jZScsXG4gIHBvdW5kbWFzc2VzOiAncG91bmRtYXNzJyxcbiAgaHVuZHJlZHdlaWdodHM6ICdodW5kcmVkd2VpZ2h0JyxcbiAgc3RpY2tzOiAnc3RpY2snLFxuXG4gIHNlY29uZHM6ICdzZWNvbmQnLFxuICBtaW51dGVzOiAnbWludXRlJyxcbiAgaG91cnM6ICdob3VyJyxcbiAgZGF5czogJ2RheScsXG5cbiAgcmFkaWFuczogJ3JhZCcsXG4gIGRlZ3JlZXM6ICdkZWcnLFxuICBncmFkaWVudHM6ICdncmFkJyxcbiAgY3ljbGVzOiAnY3ljbGUnLFxuXG4gIGFtcGVyZXM6ICdhbXBlcmUnLFxuICBtb2xlczogJ21vbGUnXG59O1xuXG5mb3IgKHZhciBuYW1lIGluIFBMVVJBTFMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKHdlIGNhbm5vdCByZWFsbHkgdGVzdCBuZXh0IHN0YXRlbWVudCkgKi9cbiAgaWYgKFBMVVJBTFMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB2YXIgdW5pdCA9IFVOSVRTW1BMVVJBTFNbbmFtZV1dO1xuICAgIHZhciBwbHVyYWwgPSBPYmplY3QuY3JlYXRlKHVuaXQpO1xuICAgIHBsdXJhbC5uYW1lID0gbmFtZTtcbiAgICBVTklUU1tuYW1lXSA9IHBsdXJhbDtcbiAgfVxufVxuXG4vLyBhbGlhc2VzXG5VTklUUy5sdCA9IFVOSVRTLmw7XG5VTklUUy5saXRlciA9IFVOSVRTLmxpdHJlO1xuVU5JVFMubGl0ZXJzID0gVU5JVFMubGl0cmVzO1xuVU5JVFMubGIgPSBVTklUUy5sYm07XG5VTklUUy5sYnMgPSBVTklUUy5sYm07XG5cblxuVW5pdC5QUkVGSVhFUyA9IFBSRUZJWEVTO1xuVW5pdC5CQVNFX1VOSVRTID0gQkFTRV9VTklUUztcblVuaXQuVU5JVFMgPSBVTklUUztcblxuLy8gZW5kIG9mIHVuaXQgYWxpYXNlc1xuXG5cbi8vIGV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gVW5pdDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2luZGV4JyksXG4gICAgb2JqZWN0ID0gdXRpbC5vYmplY3QsXG4gICAgc3RyaW5nID0gdXRpbC5zdHJpbmc7XG5cbi8qKlxuICogRG9jdW1lbnRhdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRoIFRoZSBtYXRoLmpzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtPYmplY3R9IGRvYyAgT2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllczpcbiAqICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGNhdGVnb3J5XG4gKiAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nW119IHN5bnRheFxuICogICAgICAgICAgICAgICAgICAgICAge1N0cmluZ1tdfSBleGFtcGxlc1xuICogICAgICAgICAgICAgICAgICAgICAge1N0cmluZ1tdfSBzZWVhbHNvXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGVscCAobWF0aCwgZG9jKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIZWxwKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICAvLyBUT0RPOiB0aHJvdyBhbiBlcnJvciB3aGVuIG1hdGggb3IgZG9jIGlzIG5vdCBwcm92aWRlZFxuXG4gIHRoaXMubWF0aCA9IG1hdGg7XG4gIHRoaXMuZG9jID0gZG9jO1xufVxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIEhlbHBcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzSGVscFxuICovXG5IZWxwLmlzSGVscCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgSGVscCk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHJlYWRhYmxlIGRlc2NyaXB0aW9uIGZyb20gYSBIZWxwIG9iamVjdFxuICogQHJldHVybiB7U3RyaW5nfSByZWFkYWJsZURvY1xuICogQHByaXZhdGVcbiAqL1xuSGVscC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkb2MgPSB0aGlzLmRvYyB8fCB7fTtcbiAgdmFyIGRlc2MgPSAnXFxuJztcblxuICBpZiAoZG9jLm5hbWUpIHtcbiAgICBkZXNjICs9ICdOYW1lOiAnICsgZG9jLm5hbWUgKyAnXFxuXFxuJztcbiAgfVxuICBpZiAoZG9jLmNhdGVnb3J5KSB7XG4gICAgZGVzYyArPSAnQ2F0ZWdvcnk6ICcgKyBkb2MuY2F0ZWdvcnkgKyAnXFxuXFxuJztcbiAgfVxuICBpZiAoZG9jLmRlc2NyaXB0aW9uKSB7XG4gICAgZGVzYyArPSAnRGVzY3JpcHRpb246XFxuICAgICcgKyBkb2MuZGVzY3JpcHRpb24gKyAnXFxuXFxuJztcbiAgfVxuICBpZiAoZG9jLnN5bnRheCkge1xuICAgIGRlc2MgKz0gJ1N5bnRheDpcXG4gICAgJyArIGRvYy5zeW50YXguam9pbignXFxuICAgICcpICsgJ1xcblxcbic7XG4gIH1cbiAgaWYgKGRvYy5leGFtcGxlcykge1xuICAgIHZhciBwYXJzZXIgPSB0aGlzLm1hdGgucGFyc2VyKCk7XG4gICAgZGVzYyArPSAnRXhhbXBsZXM6XFxuJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5leGFtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4cHIgPSBkb2MuZXhhbXBsZXNbaV07XG4gICAgICB2YXIgcmVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzID0gcGFyc2VyLmV2YWwoZXhwcik7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXMgPSBlO1xuICAgICAgfVxuICAgICAgZGVzYyArPSAnICAgICcgKyBleHByICsgJ1xcbic7XG4gICAgICBpZiAocmVzICYmICEocmVzIGluc3RhbmNlb2YgSGVscCkpIHtcbiAgICAgICAgZGVzYyArPSAnICAgICAgICAnICsgc3RyaW5nLmZvcm1hdChyZXMsIHtwcmVjaXNpb246IDE0fSkgKyAnXFxuJztcbiAgICAgIH1cbiAgICB9XG4gICAgZGVzYyArPSAnXFxuJztcbiAgfVxuICBpZiAoZG9jLnNlZWFsc28pIHtcbiAgICBkZXNjICs9ICdTZWUgYWxzbzogJyArIGRvYy5zZWVhbHNvLmpvaW4oJywgJykgKyAnXFxuJztcbiAgfVxuXG4gIHJldHVybiBkZXNjO1xufTtcblxuLy8gVE9ETzogaW1wbGVtZW50IGEgdG9IVE1MIGZ1bmN0aW9uIGluIEhlbHBcblxuLyoqXG4gKiBFeHBvcnQgdGhlIGhlbHAgb2JqZWN0IHRvIEpTT05cbiAqL1xuSGVscC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gb2JqZWN0LmNsb25lKHRoaXMuZG9jKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgSGVscCBvYmplY3RcbiAqL1xuSGVscC5wcm90b3R5cGUudmFsdWVPZiA9IEhlbHAucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vLyBleHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IEhlbHA7XG4iLCIvLyB1dGlsaXR5IG1ldGhvZHMgZm9yIGFycmF5cyBhbmQgbWF0cmljZXNcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2luZGV4JyksXG5cbiAgICBJbmRleEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvSW5kZXhFcnJvcicpLFxuICAgIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvRGltZW5zaW9uRXJyb3InKSxcblxuICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4vTWF0cml4JyksXG5cbiAgICBhcnJheSA9IHV0aWwuYXJyYXksXG4gICAgaXNBcnJheSA9IHV0aWwuYXJyYXkuaXNBcnJheSxcbiAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnQgZnVuY3Rpb24gYXJndW1lbnRzIHRvIGFuIGFycmF5LiBBcmd1bWVudHMgY2FuIGhhdmUgdGhlIGZvbGxvd2luZ1xuICogc2lnbmF0dXJlOlxuICogICAgIGZuKClcbiAqICAgICBmbihuKVxuICogICAgIGZuKG0sIG4sIHAsIC4uLilcbiAqICAgICBmbihbbSwgbiwgcCwgLi4uXSlcbiAqIEBwYXJhbSB7Li4uTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IGFyZ3NcbiAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXlcbiAqL1xuZXhwb3J0cy5hcmdzVG9BcnJheSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09IDApIHtcbiAgICAvLyBmbigpXG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09IDEpIHtcbiAgICAvLyBmbihuKVxuICAgIC8vIGZuKFttLCBuLCBwLCAuLi5dKVxuICAgIHZhciBhcnJheSA9IGFyZ3NbMF07XG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICBhcnJheSA9IGFycmF5LnZhbHVlT2YoKTtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5KGFycmF5KSkge1xuICAgICAgYXJyYXkgPSBbYXJyYXldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZm4obSwgbiwgcCwgLi4uKVxuICAgIHJldHVybiB1dGlsLmFycmF5LmFyZ3NUb0FycmF5KGFyZ3MpO1xuICB9XG59O1xuXG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgYSBjb2xsZWN0aW9uOiBhbiBBcnJheSBvciBNYXRyaXhcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybnMge2Jvb2xlYW59IGlzQ29sbGVjdGlvblxuICovXG5leHBvcnRzLmlzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChpc0FycmF5KHgpIHx8ICh4IGluc3RhbmNlb2YgTWF0cml4KSk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGVsZW1lbnQgd2lzZSBmb3IgZWFjaCBlbGVtZW50IGluIGFycmF5IGFuZCBhbnlcbiAqIG5lc3RlZCBhcnJheVxuICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSByZXN1bHRzXG4gKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4fSBhcnJheVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggdHdvIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMSBhbmQgdmFsdWUyLCB3aGljaCBjb250YWluIHRoZSBjdXJyZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgb2YgYm90aCBhcnJheXMuXG4gKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH0gcmVzXG4gKi9cbmV4cG9ydHMuZGVlcE1hcCA9IGZ1bmN0aW9uIGRlZXBNYXAoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGlmIChhcnJheSAmJiAodHlwZW9mIGFycmF5Lm1hcCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICByZXR1cm4gYXJyYXkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGFycmF5KTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBlbGVtZW50IHdpc2UgZm9yIGVhY2ggZW50cnkgaW4gdHdvIGdpdmVuIGFycmF5cyxcbiAqIGFuZCBmb3IgYW55IG5lc3RlZCBhcnJheS4gT2JqZWN0cyBjYW4gYWxzbyBiZSBzY2FsYXIgb2JqZWN0cy5cbiAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgcmVzdWx0cy5cbiAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXggfCBPYmplY3R9IGFycmF5MVxuICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeCB8IE9iamVjdH0gYXJyYXkyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCB0d28gcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUxIGFuZCB2YWx1ZTIsIHdoaWNoIGNvbnRhaW4gdGhlIGN1cnJlbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCBvZiBib3RoIGFycmF5cy5cbiAqIEByZXR1cm4ge0FycmF5IHwgTWF0cml4fSByZXNcbiAqL1xuZXhwb3J0cy5kZWVwTWFwMiA9IGZ1bmN0aW9uIGRlZXBNYXAyKGFycmF5MSwgYXJyYXkyLCBjYWxsYmFjaykge1xuICB2YXIgcmVzLCBsZW4sIGk7XG5cbiAgaWYgKGlzQXJyYXkoYXJyYXkxKSkge1xuICAgIGlmIChpc0FycmF5KGFycmF5MikpIHtcbiAgICAgIC8vIGNhbGxiYWNrKGFycmF5LCBhcnJheSlcbiAgICAgIGlmIChhcnJheTEubGVuZ3RoICE9IGFycmF5Mi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXMgPSBbXTtcbiAgICAgIGxlbiA9IGFycmF5MS5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gZGVlcE1hcDIoYXJyYXkxW2ldLCBhcnJheTJbaV0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXJyYXkyIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAvLyBjYWxsYmFjayhhcnJheSwgbWF0cml4KVxuICAgICAgcmVzID0gZGVlcE1hcDIoYXJyYXkxLCBhcnJheTIudmFsdWVPZigpLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeChyZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNhbGxiYWNrKGFycmF5LCBvYmplY3QpXG4gICAgICByZXMgPSBbXTtcbiAgICAgIGxlbiA9IGFycmF5MS5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gZGVlcE1hcDIoYXJyYXkxW2ldLCBhcnJheTIsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYXJyYXkxIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgaWYgKGFycmF5MiBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgLy8gY2FsbGJhY2sobWF0cml4LCBtYXRyaXgpXG4gICAgICByZXMgPSBkZWVwTWFwMihhcnJheTEudmFsdWVPZigpLCBhcnJheTIudmFsdWVPZigpLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeChyZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNhbGxiYWNrKG1hdHJpeCwgYXJyYXkpXG4gICAgICAvLyBjYWxsYmFjayhtYXRyaXgsIG9iamVjdClcbiAgICAgIHJlcyA9IGRlZXBNYXAyKGFycmF5MS52YWx1ZU9mKCksIGFycmF5MiwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgocmVzKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKGlzQXJyYXkoYXJyYXkyKSkge1xuICAgICAgLy8gY2FsbGJhY2sob2JqZWN0LCBhcnJheSlcbiAgICAgIHJlcyA9IFtdO1xuICAgICAgbGVuID0gYXJyYXkyLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXNbaV0gPSBkZWVwTWFwMihhcnJheTEsIGFycmF5MltpXSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhcnJheTIgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgIC8vIGNhbGxiYWNrKG9iamVjdCwgbWF0cml4KVxuICAgICAgcmVzID0gZGVlcE1hcDIoYXJyYXkxLCBhcnJheTIudmFsdWVPZigpLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeChyZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNhbGxiYWNrKG9iamVjdCwgb2JqZWN0KVxuICAgICAgcmVzID0gY2FsbGJhY2soYXJyYXkxLCBhcnJheTIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIFJlZHVjZSBhIGdpdmVuIG1hdHJpeCBvciBhcnJheSB0byBhIG5ldyBtYXRyaXggb3JcbiAqIGFycmF5IHdpdGggb25lIGxlc3MgZGltZW5zaW9uLCBhcHBseWluZyB0aGUgZ2l2ZW5cbiAqIGNhbGxiYWNrIGluIHRoZSBzZWxlY3RlZCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4fSBtYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaW1cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH0gcmVzXG4gKi9cbmV4cG9ydHMucmVkdWNlID0gZnVuY3Rpb24obWF0LCBkaW0sIGNhbGxiYWNrKSB7XG4gIHZhciBzaXplID0gaXNBcnJheShtYXQpID8gYXJyYXkuc2l6ZShtYXQpIDogbWF0LnNpemUoKTtcbiAgaWYgKGRpbSA8IDApIHtcbiAgICAvLyBUT0RPOiB3b3VsZCBiZSBtb3JlIGNsZWFyIHdoZW4gdGhyb3dpbmcgYSBEaW1lbnNpb25FcnJvciBoZXJlXG4gICAgdGhyb3cgbmV3IEluZGV4RXJyb3IoZGltKTtcbiAgfVxuICBpZiAoZGltID49IHNpemUubGVuZ3RoKSB7XG4gICAgLy8gVE9ETzogd291bGQgYmUgbW9yZSBjbGVhciB3aGVuIHRocm93aW5nIGEgRGltZW5zaW9uRXJyb3IgaGVyZVxuICAgIHRocm93IG5ldyBJbmRleEVycm9yKGRpbSwgc2l6ZS5sZW5ndGgpO1xuICB9XG5cblx0aWYgKG1hdCBpbnN0YW5jZW9mIE1hdHJpeCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4KF9yZWR1Y2UobWF0LnZhbHVlT2YoKSwgZGltLCBjYWxsYmFjaykpO1xuXHR9ZWxzZSB7XG5cdFx0cmV0dXJuIF9yZWR1Y2UobWF0LCBkaW0sIGNhbGxiYWNrKTtcblx0fVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSByZWR1Y2UgYSBtYXRyaXhcbiAqIEBwYXJhbSB7QXJyYXl9IG1hdFxuICogQHBhcmFtIHtOdW1iZXJ9IGRpbVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtBcnJheX0gcmV0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVkdWNlKG1hdCwgZGltLCBjYWxsYmFjayl7XG4gIHZhciBpLCByZXQsIHZhbCwgdHJhbjtcblxuXHRpZihkaW08PTApe1xuXHRcdGlmKCAhaXNBcnJheShtYXRbMF0pICl7XG5cdFx0XHR2YWwgPSBtYXRbMF07XG5cdFx0XHRmb3IoaT0xOyBpPG1hdC5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdHZhbCA9IGNhbGxiYWNrKHZhbCwgbWF0W2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fWVsc2V7XG5cdFx0XHR0cmFuID0gX3N3aXRjaChtYXQpO1xuXHRcdFx0cmV0ID0gW107XG5cdFx0XHRmb3IoaT0wOyBpPHRyYW4ubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRyZXRbaV0gPSBfcmVkdWNlKHRyYW5baV0sIGRpbS0xLCBjYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0XG5cdFx0fVxuXHR9ZWxzZXtcblx0XHRyZXQgPSBbXTtcblx0XHRmb3IoaT0wOyBpPG1hdC5sZW5ndGg7IGkrKyl7XG5cdFx0XHRyZXRbaV0gPSBfcmVkdWNlKG1hdFtpXSwgZGltLTEsIGNhbGxiYWNrKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fVxufVxuXG4vKipcbiAqIFRyYW5zcG9zZSBhIG1hdHJpeFxuICogQHBhcmFtIHtBcnJheX0gbWF0XG4gKiBAcmV0dXJucyB7QXJyYXl9IHJldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3N3aXRjaChtYXQpe1xuICB2YXIgSSA9IG1hdC5sZW5ndGg7XG4gIHZhciBKID0gbWF0WzBdLmxlbmd0aDtcbiAgdmFyIGksIGo7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yKCBqPTA7IGo8SjsgaisrKSB7XG4gICAgdmFyIHRtcCA9IFtdO1xuICAgIGZvciggaT0wOyBpPEk7IGkrKykge1xuICAgICAgdG1wLnB1c2gobWF0W2ldW2pdKTtcbiAgICB9XG4gICAgcmV0LnB1c2godG1wKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGxvb3Agb3ZlciBhbGwgZWxlbWVudHMgaW4gYSBnaXZlbiBtdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICogYW5kIGludm9rZSB0aGUgY2FsbGJhY2sgb24gZWFjaCBvZiB0aGUgZWxlbWVudHMuXG4gKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4fSBhcnJheVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICAgIFRoZSBjYWxsYmFjayBtZXRob2QgaXMgaW52b2tlZCB3aXRoIG9uZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcjogdGhlIGN1cnJlbnQgZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAqL1xuZXhwb3J0cy5kZWVwRm9yRWFjaCA9IGZ1bmN0aW9uIGRlZXBGb3JFYWNoIChhcnJheSwgY2FsbGJhY2spIHtcbiAgaWYgKGFycmF5IGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgYXJyYXkgPSBhcnJheS52YWx1ZU9mKCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGRlZXBGb3JFYWNoKHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbiIsIihmdW5jdGlvbigpeyd1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2luZGV4JyksXG5cbiAgICBBcmd1bWVudHNFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL0FyZ3VtZW50c0Vycm9yJyksXG5cbiAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nLFxuICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIHR5cGUgPSB1dGlsLnR5cGVzLnR5cGUsXG5cbiAgICAvLyB0eXBlc1xuICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi90eXBlL0NvbXBsZXgnKSxcbiAgICBNYXRyaXggPSByZXF1aXJlKCcuLi90eXBlL01hdHJpeCcpLFxuICAgIFVuaXQgPSByZXF1aXJlKCcuLi90eXBlL1VuaXQnKSxcbiAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAvLyBzY29wZSBhbmQgbm9kZXNcbiAgICBBcnJheU5vZGUgPSByZXF1aXJlKCcuL25vZGUvQXJyYXlOb2RlJyksXG4gICAgQXNzaWdubWVudE5vZGUgPSByZXF1aXJlKCcuL25vZGUvQXNzaWdubWVudE5vZGUnKSxcbiAgICBCbG9ja05vZGUgPSByZXF1aXJlKCcuL25vZGUvQmxvY2tOb2RlJyksXG4gICAgQ29uZGl0aW9uYWxOb2RlID0gcmVxdWlyZSgnLi9ub2RlL0NvbmRpdGlvbmFsTm9kZScpLFxuICAgIENvbnN0YW50Tm9kZSA9IHJlcXVpcmUoJy4vbm9kZS9Db25zdGFudE5vZGUnKSxcbiAgICBGdW5jdGlvbkFzc2lnbm1lbnROb2RlID0gcmVxdWlyZSgnLi9ub2RlL0Z1bmN0aW9uQXNzaWdubWVudE5vZGUnKSxcbiAgICBJbmRleE5vZGUgPSByZXF1aXJlKCcuL25vZGUvSW5kZXhOb2RlJyksXG4gICAgT3BlcmF0b3JOb2RlID0gcmVxdWlyZSgnLi9ub2RlL09wZXJhdG9yTm9kZScpLFxuICAgIEZ1bmN0aW9uTm9kZSA9IHJlcXVpcmUoJy4vbm9kZS9GdW5jdGlvbk5vZGUnKSxcbiAgICBSYW5nZU5vZGUgPSByZXF1aXJlKCcuL25vZGUvUmFuZ2VOb2RlJyksXG4gICAgU3ltYm9sTm9kZSA9IHJlcXVpcmUoJy4vbm9kZS9TeW1ib2xOb2RlJyksXG4gICAgVXBkYXRlTm9kZSA9IHJlcXVpcmUoJy4vbm9kZS9VcGRhdGVOb2RlJyk7XG5cbi8qKlxuICogUGFyc2UgYW4gZXhwcmVzc2lvbi4gUmV0dXJucyBhIG5vZGUgdHJlZSwgd2hpY2ggY2FuIGJlIGV2YWx1YXRlZCBieVxuICogaW52b2tpbmcgbm9kZS5ldmFsKCk7XG4gKlxuICogU3ludGF4OlxuICpcbiAqICAgICBwYXJzZShleHByKVxuICogICAgIHBhcnNlKGV4cHIsIG9wdGlvbnMpXG4gKiAgICAgcGFyc2UoW2V4cHIxLCBleHByMiwgZXhwcjMsIC4uLl0pXG4gKiAgICAgcGFyc2UoW2V4cHIxLCBleHByMiwgZXhwcjMsIC4uLl0sIG9wdGlvbnMpXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIG5vZGUgPSBwYXJzZSgnc3FydCgzXjIgKyA0XjIpJyk7XG4gKiAgICAgbm9kZS5jb21waWxlKG1hdGgpLmV2YWwoKTsgLy8gNVxuICpcbiAqICAgICB2YXIgc2NvcGUgPSB7YTozLCBiOjR9XG4gKiAgICAgdmFyIG5vZGUgPSBwYXJzZSgnYSAqIGInKTsgLy8gMTJcbiAqICAgICB2YXIgY29kZSA9IG5vZGUuY29tcGlsZShtYXRoKTtcbiAqICAgICBjb2RlLmV2YWwoc2NvcGUpOyAvLyAxMlxuICogICAgIHNjb3BlLmEgPSA1O1xuICogICAgIGNvZGUuZXZhbChzY29wZSk7IC8vIDIwXG4gKlxuICogICAgIHZhciBub2RlcyA9IG1hdGgucGFyc2UoWydhID0gMycsICdiID0gNCcsICdhICogYiddKTtcbiAqICAgICBub2Rlc1syXS5jb21waWxlKG1hdGgpLmV2YWwoKTsgLy8gMTJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZyB8IFN0cmluZ1tdIHwgTWF0cml4fSBleHByXG4gKiBAcGFyYW0ge3tub2RlczogT2JqZWN0PFN0cmluZywgTm9kZT59fSBbb3B0aW9uc10gIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGBub2Rlc2AgYSBzZXQgb2YgY3VzdG9tIG5vZGVzXG4gKiBAcmV0dXJuIHtOb2RlIHwgTm9kZVtdfSBub2RlXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKGV4cHIsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSAmJiBhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICB0aHJvdyBuZXcgQXJndW1lbnRzRXJyb3IoJ3BhcnNlJywgYXJndW1lbnRzLmxlbmd0aCwgMSwgMik7XG4gIH1cblxuICAvLyBwYXNzIGV4dHJhIG5vZGVzXG4gIGV4dHJhX25vZGVzID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5ub2RlcykgPyBvcHRpb25zLm5vZGVzIDoge307XG5cbiAgaWYgKGlzU3RyaW5nKGV4cHIpKSB7XG4gICAgLy8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvblxuICAgIGV4cHJlc3Npb24gPSBleHByO1xuICAgIHJldHVybiBwYXJzZVN0YXJ0KCk7XG4gIH1cbiAgZWxzZSBpZiAoaXNBcnJheShleHByKSB8fCBleHByIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgLy8gcGFyc2UgYW4gYXJyYXkgb3IgbWF0cml4IHdpdGggZXhwcmVzc2lvbnNcbiAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKGV4cHIsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICBpZiAoIWlzU3RyaW5nKGVsZW0pKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdHJpbmcgZXhwZWN0ZWQnKTtcblxuICAgICAgZXhwcmVzc2lvbiA9IGVsZW07XG4gICAgICByZXR1cm4gcGFyc2VTdGFydCgpO1xuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIG9vcHNcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdHJpbmcgb3IgbWF0cml4IGV4cGVjdGVkJyk7XG4gIH1cbn1cblxuLy8gdG9rZW4gdHlwZXMgZW51bWVyYXRpb25cbnZhciBUT0tFTlRZUEUgPSB7XG4gIE5VTEwgOiAwLFxuICBERUxJTUlURVIgOiAxLFxuICBOVU1CRVIgOiAyLFxuICBTWU1CT0wgOiAzLFxuICBVTktOT1dOIDogNFxufTtcblxuLy8gbWFwIHdpdGggYWxsIGRlbGltaXRlcnNcbnZhciBERUxJTUlURVJTID0ge1xuICAnLCc6IHRydWUsXG4gICcoJzogdHJ1ZSxcbiAgJyknOiB0cnVlLFxuICAnWyc6IHRydWUsXG4gICddJzogdHJ1ZSxcbiAgJ1xcXCInOiB0cnVlLFxuICAnOyc6IHRydWUsXG5cbiAgJysnOiB0cnVlLFxuICAnLSc6IHRydWUsXG4gICcqJzogdHJ1ZSxcbiAgJy4qJzogdHJ1ZSxcbiAgJy8nOiB0cnVlLFxuICAnLi8nOiB0cnVlLFxuICAnJSc6IHRydWUsXG4gICdeJzogdHJ1ZSxcbiAgJy5eJzogdHJ1ZSxcbiAgJyEnOiB0cnVlLFxuICAnXFwnJzogdHJ1ZSxcbiAgJz0nOiB0cnVlLFxuICAnOic6IHRydWUsXG4gICc/JzogdHJ1ZSxcblxuICAnPT0nOiB0cnVlLFxuICAnIT0nOiB0cnVlLFxuICAnPCc6IHRydWUsXG4gICc+JzogdHJ1ZSxcbiAgJzw9JzogdHJ1ZSxcbiAgJz49JzogdHJ1ZVxufTtcblxuLy8gbWFwIHdpdGggYWxsIG5hbWVkIGRlbGltaXRlcnNcbnZhciBOQU1FRF9ERUxJTUlURVJTID0ge1xuICAnbW9kJzogdHJ1ZSxcbiAgJ3RvJzogdHJ1ZSxcbiAgJ2luJzogdHJ1ZVxufTtcblxudmFyIGV4dHJhX25vZGVzID0ge307ICAgICAgICAgICAgIC8vIGN1cnJlbnQgZXh0cmEgbm9kZXNcbnZhciBleHByZXNzaW9uID0gJyc7ICAgICAgICAgICAgICAvLyBjdXJyZW50IGV4cHJlc3Npb25cbnZhciBpbmRleCA9IDA7ICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGluZGV4IGluIGV4cHJcbnZhciBjID0gJyc7ICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHRva2VuIGNoYXJhY3RlciBpbiBleHByXG52YXIgdG9rZW4gPSAnJzsgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCB0b2tlblxudmFyIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuTlVMTDsgIC8vIHR5cGUgb2YgdGhlIHRva2VuXG52YXIgbmVzdGluZ19sZXZlbCA9IDA7ICAgICAgICAgICAgLy8gbGV2ZWwgb2YgbmVzdGluZyBpbnNpZGUgcGFyYW1ldGVycywgdXNlZCB0byBpZ25vcmUgbmV3bGluZSBjaGFyYWN0ZXJzXG52YXIgY29uZGl0aW9uYWxfbGV2ZWwgPSBudWxsOyAgICAgLy8gd2hlbiBhIGNvbmRpdGlvbmFsIGlzIGJlaW5nIHBhcnNlZCwgdGhlIGxldmVsIG9mIHRoZSBjb25kaXRpb25hbCBpcyBzdG9yZWQgaGVyZVxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgY2hhcmFjdGVyIGZyb20gdGhlIGV4cHJlc3Npb24uXG4gKiBUaGUgY2hhcmFjdGVyIGlzIHN0b3JlZCBpbnRvIHRoZSBjaGFyIGMuIElmIHRoZSBlbmQgb2YgdGhlIGV4cHJlc3Npb24gaXNcbiAqIHJlYWNoZWQsIHRoZSBmdW5jdGlvbiBwdXRzIGFuIGVtcHR5IHN0cmluZyBpbiBjLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZmlyc3QoKSB7XG4gIGluZGV4ID0gMDtcbiAgYyA9IGV4cHJlc3Npb24uY2hhckF0KDApO1xuICBuZXN0aW5nX2xldmVsID0gMDtcbiAgY29uZGl0aW9uYWxfbGV2ZWwgPSBudWxsO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZXhwcmVzc2lvbi5cbiAqIFRoZSBjaGFyYWN0ZXIgaXMgc3RvcmVkIGludG8gdGhlIGNoYXIgYy4gSWYgdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvbiBpc1xuICogcmVhY2hlZCwgdGhlIGZ1bmN0aW9uIHB1dHMgYW4gZW1wdHkgc3RyaW5nIGluIGMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXh0KCkge1xuICBpbmRleCsrO1xuICBjID0gZXhwcmVzc2lvbi5jaGFyQXQoaW5kZXgpO1xufVxuXG4vKipcbiAqIFByZXZpZXcgdGhlIG5leHQgY2hhcmFjdGVyIGZyb20gdGhlIGV4cHJlc3Npb24uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGNOZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXh0UHJldmlldygpIHtcbiAgcmV0dXJuIGV4cHJlc3Npb24uY2hhckF0KGluZGV4ICsgMSk7XG59XG5cbi8qKlxuICogR2V0IG5leHQgdG9rZW4gaW4gdGhlIGN1cnJlbnQgc3RyaW5nIGV4cHIuXG4gKiBUaGUgdG9rZW4gYW5kIHRva2VuIHR5cGUgYXJlIGF2YWlsYWJsZSBhcyB0b2tlbiBhbmQgdG9rZW5fdHlwZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0VG9rZW4oKSB7XG4gIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuTlVMTDtcbiAgdG9rZW4gPSAnJztcblxuICAvLyBza2lwIG92ZXIgd2hpdGVzcGFjZXNcbiAgLy8gc3BhY2UsIHRhYiwgYW5kIG5ld2xpbmUgd2hlbiBpbnNpZGUgcGFyYW1ldGVyc1xuICB3aGlsZSAoYyA9PSAnICcgfHwgYyA9PSAnXFx0JyB8fCAoYyA9PSAnXFxuJyAmJiBuZXN0aW5nX2xldmVsKSkge1xuICAgIC8vIFRPRE86IGFsc28gdGFrZSAnXFxyJyBjYXJyaWFnZSByZXR1cm4gYXMgbmV3bGluZT8gT3IgZG9lcyB0aGF0IGdpdmUgcHJvYmxlbXMgb24gbWFjP1xuICAgIG5leHQoKTtcbiAgfVxuXG4gIC8vIHNraXAgY29tbWVudFxuICBpZiAoYyA9PSAnIycpIHtcbiAgICB3aGlsZSAoYyAhPSAnXFxuJyAmJiBjICE9ICcnKSB7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGVuZCBvZiBleHByZXNzaW9uXG4gIGlmIChjID09ICcnKSB7XG4gICAgLy8gdG9rZW4gaXMgc3RpbGwgZW1wdHlcbiAgICB0b2tlbl90eXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjaGVjayBmb3IgbmV3IGxpbmUgY2hhcmFjdGVyXG4gIGlmIChjID09ICdcXG4nICYmICFuZXN0aW5nX2xldmVsKSB7XG4gICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgdG9rZW4gPSBjO1xuICAgIG5leHQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjaGVjayBmb3IgZGVsaW1pdGVycyBjb25zaXN0aW5nIG9mIDIgY2hhcmFjdGVyc1xuICB2YXIgYzIgPSBjICsgbmV4dFByZXZpZXcoKTtcbiAgaWYgKGMyLmxlbmd0aCA9PSAyICYmIERFTElNSVRFUlNbYzJdKSB7XG4gICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgdG9rZW4gPSBjMjtcbiAgICBuZXh0KCk7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMSBjaGFyYWN0ZXJcbiAgaWYgKERFTElNSVRFUlNbY10pIHtcbiAgICB0b2tlbl90eXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICB0b2tlbiA9IGM7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBhIG51bWJlclxuICBpZiAoaXNEaWdpdERvdChjKSkge1xuICAgIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuTlVNQkVSO1xuXG4gICAgLy8gZ2V0IG51bWJlciwgY2FuIGhhdmUgYSBzaW5nbGUgZG90XG4gICAgaWYgKGMgPT0gJy4nKSB7XG4gICAgICB0b2tlbiArPSBjO1xuICAgICAgbmV4dCgpO1xuXG4gICAgICBpZiAoIWlzRGlnaXQoYykpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBubyBsZWdhbCBudW1iZXIsIGl0IGlzIGp1c3QgYSBkb3RcbiAgICAgICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5VTktOT1dOO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlIChpc0RpZ2l0KGMpKSB7XG4gICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjID09ICcuJykge1xuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChpc0RpZ2l0KGMpKSB7XG4gICAgICB0b2tlbiArPSBjO1xuICAgICAgbmV4dCgpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBleHBvbmVudGlhbCBub3RhdGlvbiBsaWtlIFwiMi4zZS00XCIgb3IgXCIxLjIzZTUwXCJcbiAgICBpZiAoYyA9PSAnRScgfHwgYyA9PSAnZScpIHtcbiAgICAgIHRva2VuICs9IGM7XG4gICAgICBuZXh0KCk7XG5cbiAgICAgIGlmIChjID09ICcrJyB8fCBjID09ICctJykge1xuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNjaWVudGlmaWMgbm90YXRpb24gTVVTVCBiZSBmb2xsb3dlZCBieSBhbiBleHBvbmVudFxuICAgICAgaWYgKCFpc0RpZ2l0KGMpKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm8gbGVnYWwgbnVtYmVyLCBleHBvbmVudCBpcyBtaXNzaW5nLlxuICAgICAgICB0b2tlbl90eXBlID0gVE9LRU5UWVBFLlVOS05PV047XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpc0RpZ2l0KGMpKSB7XG4gICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjaGVjayBmb3IgdmFyaWFibGVzLCBmdW5jdGlvbnMsIG5hbWVkIG9wZXJhdG9yc1xuICBpZiAoaXNBbHBoYShjKSkge1xuICAgIHdoaWxlIChpc0FscGhhKGMpIHx8IGlzRGlnaXQoYykpIHtcbiAgICAgIHRva2VuICs9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKE5BTUVEX0RFTElNSVRFUlNbdG9rZW5dKSB7XG4gICAgICB0b2tlbl90eXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0b2tlbl90eXBlID0gVE9LRU5UWVBFLlNZTUJPTDtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzb21ldGhpbmcgdW5rbm93biBpcyBmb3VuZCwgd3JvbmcgY2hhcmFjdGVycyAtPiBhIHN5bnRheCBlcnJvclxuICB0b2tlbl90eXBlID0gVE9LRU5UWVBFLlVOS05PV047XG4gIHdoaWxlIChjICE9ICcnKSB7XG4gICAgdG9rZW4gKz0gYztcbiAgICBuZXh0KCk7XG4gIH1cbiAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1N5bnRheCBlcnJvciBpbiBwYXJ0IFwiJyArIHRva2VuICsgJ1wiJyk7XG59XG5cbi8qKlxuICogR2V0IG5leHQgdG9rZW4gYW5kIHNraXAgbmV3bGluZSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gZ2V0VG9rZW5Ta2lwTmV3bGluZSAoKSB7XG4gIGRvIHtcbiAgICBnZXRUb2tlbigpO1xuICB9XG4gIHdoaWxlICh0b2tlbiA9PSAnXFxuJyk7XG59XG5cbi8qKlxuICogT3BlbiBwYXJhbWV0ZXJzLlxuICogTmV3IGxpbmUgY2hhcmFjdGVycyB3aWxsIGJlIGlnbm9yZWQgdW50aWwgY2xvc2VQYXJhbXMoKSBpcyBjYWxsZWRcbiAqL1xuZnVuY3Rpb24gb3BlblBhcmFtcygpIHtcbiAgbmVzdGluZ19sZXZlbCsrO1xufVxuXG4vKipcbiAqIENsb3NlIHBhcmFtZXRlcnMuXG4gKiBOZXcgbGluZSBjaGFyYWN0ZXJzIHdpbGwgbm8gbG9uZ2VyIGJlIGlnbm9yZWRcbiAqL1xuZnVuY3Rpb24gY2xvc2VQYXJhbXMoKSB7XG4gIG5lc3RpbmdfbGV2ZWwtLTtcbn1cblxuLyoqXG4gKiBjaGVja3MgaWYgdGhlIGdpdmVuIGNoYXIgYyBpcyBhIGxldHRlciAodXBwZXIgb3IgbG93ZXIgY2FzZSlcbiAqIG9yIHVuZGVyc2NvcmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBjICAgYSBzdHJpbmcgd2l0aCBvbmUgY2hhcmFjdGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNBbHBoYSAoYykge1xuICByZXR1cm4gKChjID49ICdhJyAmJiBjIDw9ICd6JykgfHxcbiAgICAgIChjID49ICdBJyAmJiBjIDw9ICdaJykgfHxcbiAgICAgIGMgPT0gJ18nKTtcbn1cblxuLyoqXG4gKiBjaGVja3MgaWYgdGhlIGdpdmVuIGNoYXIgYyBpcyBhIGRpZ2l0IG9yIGRvdFxuICogQHBhcmFtIHtTdHJpbmd9IGMgICBhIHN0cmluZyB3aXRoIG9uZSBjaGFyYWN0ZXJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0RpZ2l0RG90IChjKSB7XG4gIHJldHVybiAoKGMgPj0gJzAnICYmIGMgPD0gJzknKSB8fFxuICAgICAgYyA9PSAnLicpO1xufVxuXG4vKipcbiAqIGNoZWNrcyBpZiB0aGUgZ2l2ZW4gY2hhciBjIGlzIGEgZGlnaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjICAgYSBzdHJpbmcgd2l0aCBvbmUgY2hhcmFjdGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNEaWdpdCAoYykge1xuICByZXR1cm4gKChjID49ICcwJyAmJiBjIDw9ICc5JykpO1xufVxuXG4vKipcbiAqIFN0YXJ0IG9mIHRoZSBwYXJzZSBsZXZlbHMgYmVsb3csIGluIG9yZGVyIG9mIHByZWNlZGVuY2VcbiAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RhcnQgKCkge1xuICAvLyBnZXQgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBleHByZXNzaW9uXG4gIGZpcnN0KCk7XG5cbiAgZ2V0VG9rZW4oKTtcblxuICB2YXIgbm9kZSA9IHBhcnNlQmxvY2soKTtcblxuICAvLyBjaGVjayBmb3IgZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uXG4gIC8vIGFuIGV4cHJlc3Npb24gZW5kcyB3aXRoIGEgZW1wdHkgY2hhcmFjdGVyICcnIGFuZCB0b2tlbl90eXBlIERFTElNSVRFUlxuICBpZiAodG9rZW4gIT0gJycpIHtcbiAgICBpZiAodG9rZW5fdHlwZSA9PSBUT0tFTlRZUEUuREVMSU1JVEVSKSB7XG4gICAgICAvLyB1c2VyIGVudGVyZWQgYSBub3QgZXhpc3Rpbmcgb3BlcmF0b3IgbGlrZSBcIi8vXCJcblxuICAgICAgLy8gVE9ETzogZ2l2ZSBoaW50cyBmb3IgYWxpYXNlcywgZm9yIGV4YW1wbGUgd2l0aCBcIjw+XCIgZ2l2ZSBhcyBoaW50IFwiIGRpZCB5b3UgbWVhbiAhPSA/XCJcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdVbmV4cGVjdGVkIG9wZXJhdG9yICcgKyB0b2tlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgcGFydCBcIicgKyB0b2tlbiArICdcIicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgYmxvY2sgd2l0aCBleHByZXNzaW9ucy4gRXhwcmVzc2lvbnMgY2FuIGJlIHNlcGFyYXRlZCBieSBhIG5ld2xpbmVcbiAqIGNoYXJhY3RlciAnXFxuJywgb3IgYnkgYSBzZW1pY29sb24gJzsnLiBJbiBjYXNlIG9mIGEgc2VtaWNvbG9uLCBubyBvdXRwdXRcbiAqIG9mIHRoZSBwcmVjZWRpbmcgbGluZSBpcyByZXR1cm5lZC5cbiAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQmxvY2sgKCkge1xuICB2YXIgbm9kZSwgYmxvY2ssIHZpc2libGU7XG5cbiAgaWYgKHRva2VuID09ICcnKSB7XG4gICAgLy8gZW1wdHkgZXhwcmVzc2lvblxuICAgIHJldHVybiBuZXcgQ29uc3RhbnROb2RlKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIH1cblxuICBpZiAodG9rZW4gIT0gJ1xcbicgJiYgdG9rZW4gIT0gJzsnKSB7XG4gICAgbm9kZSA9IHBhcnNlRnVuY3Rpb25Bc3NpZ25tZW50KCk7XG4gIH1cblxuICB3aGlsZSAodG9rZW4gPT0gJ1xcbicgfHwgdG9rZW4gPT0gJzsnKSB7XG4gICAgaWYgKCFibG9jaykge1xuICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgYmxvY2tcbiAgICAgIGJsb2NrID0gbmV3IEJsb2NrTm9kZSgpO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgdmlzaWJsZSA9ICh0b2tlbiAhPSAnOycpO1xuICAgICAgICBibG9jay5hZGQobm9kZSwgdmlzaWJsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VG9rZW4oKTtcbiAgICBpZiAodG9rZW4gIT0gJ1xcbicgJiYgdG9rZW4gIT0gJzsnICYmIHRva2VuICE9ICcnKSB7XG4gICAgICBub2RlID0gcGFyc2VGdW5jdGlvbkFzc2lnbm1lbnQoKTtcblxuICAgICAgdmlzaWJsZSA9ICh0b2tlbiAhPSAnOycpO1xuICAgICAgYmxvY2suYWRkKG5vZGUsIHZpc2libGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChibG9jaykge1xuICAgIHJldHVybiBibG9jaztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgZnVuY3Rpb24gYXNzaWdubWVudCBsaWtlIFwiZnVuY3Rpb24gZihhLGIpID0gYSpiXCJcbiAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25Bc3NpZ25tZW50ICgpIHtcbiAgLy8gVE9ETzogZnVuY3Rpb24gYXNzaWdubWVudCB1c2luZyBrZXl3b3JkICdmdW5jdGlvbicgaXMgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDAuMTguMCwgY2xlYW51cCBzb21lIGRheVxuICBpZiAodG9rZW5fdHlwZSA9PSBUT0tFTlRZUEUuU1lNQk9MICYmIHRva2VuID09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignRGVwcmVjYXRlZCBrZXl3b3JkIFwiZnVuY3Rpb25cIi4gJyArXG4gICAgICAgICdGdW5jdGlvbnMgY2FuIG5vdyBiZSBhc3NpZ25lZCB3aXRob3V0IGl0LCBsaWtlIFwiZih4KSA9IHheMlwiLicpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlQXNzaWdubWVudCgpO1xufVxuXG4vKipcbiAqIEFzc2lnbm1lbnQgb2YgYSB2YXJpYWJsZSwgY2FuIGJlIGEgdmFyaWFibGUgbGlrZSBcImE9Mi4zXCIgb3IgYSB1cGRhdGluZyBhblxuICogZXhpc3RpbmcgdmFyaWFibGUgbGlrZSBcIm1hdHJpeCgyLDM6NSk9WzYsNyw4XVwiXG4gKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFzc2lnbm1lbnQgKCkge1xuICB2YXIgbmFtZSwgYXJncywgZXhwciwgdmFsaWQ7XG5cbiAgdmFyIG5vZGUgPSBwYXJzZUNvbmRpdGlvbmFsKCk7XG5cbiAgaWYgKHRva2VuID09ICc9Jykge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgU3ltYm9sTm9kZSkge1xuICAgICAgLy8gcGFyc2UgYSB2YXJpYWJsZSBhc3NpZ25tZW50IGxpa2UgJ2EgPSAyLzMnXG4gICAgICBuYW1lID0gbm9kZS5uYW1lO1xuICAgICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuICAgICAgZXhwciA9IHBhcnNlQXNzaWdubWVudCgpO1xuICAgICAgcmV0dXJuIG5ldyBBc3NpZ25tZW50Tm9kZShuYW1lLCBleHByKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEluZGV4Tm9kZSkge1xuICAgICAgLy8gcGFyc2UgYSBtYXRyaXggc3Vic2V0IGFzc2lnbm1lbnQgbGlrZSAnQVsxLDJdID0gNCdcbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgIGV4cHIgPSBwYXJzZUFzc2lnbm1lbnQoKTtcbiAgICAgIHJldHVybiBuZXcgVXBkYXRlTm9kZShub2RlLCBleHByKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEZ1bmN0aW9uTm9kZSkge1xuICAgICAgLy8gcGFyc2UgZnVuY3Rpb24gYXNzaWdubWVudCBsaWtlICdmKHgpID0geF4yJ1xuICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgYXJncyA9IFtdO1xuXG4gICAgICBuYW1lID0gbm9kZS5zeW1ib2wubmFtZTtcbiAgICAgIG5vZGUucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtLCBpbmRleCkge1xuICAgICAgICBpZiAocGFyYW0gaW5zdGFuY2VvZiBTeW1ib2xOb2RlKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBwYXJhbS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuICAgICAgICBleHByID0gcGFyc2VBc3NpZ25tZW50KCk7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZShuYW1lLCBhcmdzLCBleHByKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignSW52YWxpZCBsZWZ0IGhhbmQgc2lkZSBvZiBhc3NpZ25tZW50IG9wZXJhdG9yID0nKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIGNvbmRpdGlvbmFsIG9wZXJhdGlvblxuICpcbiAqICAgICBjb25kaXRpb24gPyB0cnVlUGFydCA6IGZhbHNlUGFydFxuICpcbiAqIE5vdGU6IGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHJpZ2h0LWFzc29jaWF0aXZlXG4gKlxuICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VDb25kaXRpb25hbCAoKSB7XG4gIHZhciBub2RlID0gcGFyc2VSZWxhdGlvbmFsKCk7XG5cbiAgd2hpbGUgKHRva2VuID09ICc/Jykge1xuICAgIC8vIHNldCBhIGNvbmRpdGlvbmFsIGxldmVsLCB0aGUgcmFuZ2Ugb3BlcmF0b3Igd2lsbCBiZSBpZ25vcmVkIGFzIGxvbmdcbiAgICAvLyBhcyBjb25kaXRpb25hbF9sZXZlbCA9PSBuZXN0aW5nX2xldmVsLlxuICAgIHZhciBwcmV2ID0gY29uZGl0aW9uYWxfbGV2ZWw7XG4gICAgY29uZGl0aW9uYWxfbGV2ZWwgPSBuZXN0aW5nX2xldmVsO1xuICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcblxuICAgIHZhciBjb25kaXRpb24gPSBub2RlO1xuICAgIHZhciB0cnVlRXhwciA9IHBhcnNlUmVsYXRpb25hbCgpO1xuXG4gICAgaWYgKHRva2VuICE9ICc6JykgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ0ZhbHNlIHBhcnQgb2YgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuXG4gICAgY29uZGl0aW9uYWxfbGV2ZWwgPSBudWxsO1xuICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcblxuICAgIHZhciBmYWxzZUV4cHIgPSBwYXJzZUNvbmRpdGlvbmFsKCk7IC8vIE5vdGU6IHdlIGRvbid0IGRvIHBhcnNlUmVsYXRpb25hbCgpIGhlcmVcblxuICAgIG5vZGUgPSBuZXcgQ29uZGl0aW9uYWxOb2RlKGNvbmRpdGlvbiwgdHJ1ZUV4cHIsIGZhbHNlRXhwcik7XG5cbiAgICAvLyByZXN0b3JlIHRoZSBwcmV2aW91cyBjb25kaXRpb25hbCBsZXZlbFxuICAgIGNvbmRpdGlvbmFsX2xldmVsID0gcHJldjtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIGNvbmRpdGlvbmFsIG9wZXJhdG9ycyBhbmQgYml0c2hpZnRcbiAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbi8qIFRPRE86IGltcGxlbWVudCBiaXR3aXNlIGNvbmRpdGlvbnMuIHB1dCBvbiByaWdodCBwbGFjZSBmb3IgcHJlY2VkZW5jZVxuZnVuY3Rpb24gcGFyc2VCaXR3aXNlQ29uZGl0aW9ucyAoKSB7XG4gIHZhciBub2RlID0gcGFyc2VSYW5nZSgpO1xuXG4gICB2YXIgb3BlcmF0b3JzID0ge1xuICAgJyYnIDogJ2JpdHdpc2VhbmQnLFxuICAgJ3wnIDogJ2JpdHdpc2VvcicsXG4gICAvLyB0b2RvOiBiaXR3aXNlIHhvcj9cbiAgICc8PCc6ICdiaXRzaGlmdGxlZnQnLFxuICAgJz4+JzogJ2JpdHNoaWZ0cmlnaHQnXG4gICB9O1xuICAgd2hpbGUgKHRva2VuIGluIG9wZXJhdG9ycykge1xuICAgdmFyIG5hbWUgPSB0b2tlbjtcblxuICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuICAgdmFyIHBhcmFtcyA9IFtub2RlLCBwYXJzZVJlbGF0aW9uYWwoKV07XG4gICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZShuYW1lLCBmbiwgcGFyYW1zKTtcbiAgIH1cblxuICByZXR1cm4gbm9kZTtcbn1cbiovXG5cbi8qKlxuICogY29uZGl0aW9ucyBsaWtlIGFuZCwgb3IsIGluXG4gKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG4vKiBUT0RPOiBjb25kaXRpb25hbCBhbmQsIG9yLCBpbiwgZXRjLlxuZnVuY3Rpb24gcGFyc2VDb25kaXRpb25zICgpIHtcbiAgdmFyIG5vZGUsIG9wZXJhdG9ycywgbmFtZSwgZm4sIHBhcmFtcztcblxuICBub2RlID0gcGFyc2VSZWxhdGlvbmFsKCk7XG5cbiAgLy8gVE9ETzogcHJlY2VkZW5jZSBvZiBBbmQgYWJvdmUgT3I/XG4gIC8vIFRPRE86IGltcGxlbWVudCBhIG1ldGhvZCBmb3IgdW5pdCB0byBudW1iZXIgY29udmVyc2lvblxuICBvcGVyYXRvcnMgPSB7XG4gICAgICdhbmQnIDogJ2FuZCcsXG4gICAgICcmJicgOiAnYW5kJyxcbiAgICAgJ29yJzogJ29yJyxcbiAgICAgJ3x8JzogJ29yJyxcbiAgICAgJ3hvcic6ICd4b3InXG4gIH07XG5cbiAgd2hpbGUgKHRva2VuIGluIG9wZXJhdG9ycykge1xuICAgIG5hbWUgPSB0b2tlbjtcbiAgICBmbiA9IG9wZXJhdG9yc1tuYW1lXTtcblxuICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICBwYXJhbXMgPSBbbm9kZSwgcGFyc2VSZWxhdGlvbmFsKCldO1xuICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKG5hbWUsIGZuLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG4qL1xuXG4vKipcbiAqIHJlbGF0aW9uYWwgb3BlcmF0b3JzXG4gKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZVJlbGF0aW9uYWwgKCkge1xuICB2YXIgbm9kZSwgb3BlcmF0b3JzLCBuYW1lLCBmbiwgcGFyYW1zO1xuXG4gIG5vZGUgPSBwYXJzZUNvbnZlcnNpb24oKTtcblxuICBvcGVyYXRvcnMgPSB7XG4gICAgJz09JzogJ2VxdWFsJyxcbiAgICAnIT0nOiAndW5lcXVhbCcsXG4gICAgJzwnOiAnc21hbGxlcicsXG4gICAgJz4nOiAnbGFyZ2VyJyxcbiAgICAnPD0nOiAnc21hbGxlckVxJyxcbiAgICAnPj0nOiAnbGFyZ2VyRXEnXG4gIH07XG4gIHdoaWxlICh0b2tlbiBpbiBvcGVyYXRvcnMpIHtcbiAgICBuYW1lID0gdG9rZW47XG4gICAgZm4gPSBvcGVyYXRvcnNbbmFtZV07XG5cbiAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG4gICAgcGFyYW1zID0gW25vZGUsIHBhcnNlQ29udmVyc2lvbigpXTtcbiAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZShuYW1lLCBmbiwgcGFyYW1zKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIGNvbnZlcnNpb24gb3BlcmF0b3JzICd0bycgYW5kICdpbidcbiAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29udmVyc2lvbiAoKSB7XG4gIHZhciBub2RlLCBvcGVyYXRvcnMsIG5hbWUsIGZuLCBwYXJhbXM7XG5cbiAgbm9kZSA9IHBhcnNlUmFuZ2UoKTtcblxuICBvcGVyYXRvcnMgPSB7XG4gICAgJ3RvJyA6ICd0bycsXG4gICAgJ2luJyA6ICd0bycgICAvLyBhbGlhcyBvZiAndG8nXG4gIH07XG5cbiAgd2hpbGUgKHRva2VuIGluIG9wZXJhdG9ycykge1xuICAgIG5hbWUgPSB0b2tlbjtcbiAgICBmbiA9IG9wZXJhdG9yc1tuYW1lXTtcblxuICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICBwYXJhbXMgPSBbbm9kZSwgcGFyc2VSYW5nZSgpXTtcbiAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZShuYW1lLCBmbiwgcGFyYW1zKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIHBhcnNlIHJhbmdlLCBcInN0YXJ0OmVuZFwiLCBcInN0YXJ0OnN0ZXA6ZW5kXCIsIFwiOlwiLCBcInN0YXJ0OlwiLCBcIjplbmRcIiwgZXRjXG4gKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZVJhbmdlICgpIHtcbiAgdmFyIG5vZGUsIHBhcmFtcyA9IFtdO1xuXG4gIGlmICh0b2tlbiA9PSAnOicpIHtcbiAgICAvLyBpbXBsaWNpdCBzdGFydD0xIChvbmUtYmFzZWQpXG4gICAgbm9kZSA9IG5ldyBDb25zdGFudE5vZGUoJzEnLCAnbnVtYmVyJyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZXhwbGljaXQgc3RhcnRcbiAgICBub2RlID0gcGFyc2VBZGRTdWJ0cmFjdCgpO1xuICB9XG5cbiAgaWYgKHRva2VuID09ICc6JyAmJiAoY29uZGl0aW9uYWxfbGV2ZWwgIT09IG5lc3RpbmdfbGV2ZWwpKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSByYW5nZSBvcGVyYXRvciB3aGVuIGEgY29uZGl0aW9uYWwgb3BlcmF0b3IgaXMgYmVpbmcgcHJvY2Vzc2VkIG9uIHRoZSBzYW1lIGxldmVsXG4gICAgcGFyYW1zLnB1c2gobm9kZSk7XG5cbiAgICAvLyBwYXJzZSBzdGVwIGFuZCBlbmRcbiAgICB3aGlsZSAodG9rZW4gPT0gJzonKSB7XG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG5cbiAgICAgIGlmICh0b2tlbiA9PSAnKScgfHwgdG9rZW4gPT0gJ10nIHx8IHRva2VuID09ICcsJyB8fCB0b2tlbiA9PSAnJykge1xuICAgICAgICAvLyBpbXBsaWNpdCBlbmRcbiAgICAgICAgcGFyYW1zLnB1c2gobmV3IFN5bWJvbE5vZGUoJ2VuZCcpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBleHBsaWNpdCBlbmRcbiAgICAgICAgcGFyYW1zLnB1c2gocGFyc2VBZGRTdWJ0cmFjdCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzd2FwIHN0ZXAgYW5kIGVuZFxuICAgIGlmIChwYXJhbXMubGVuZ3RoID09IDMpIHtcbiAgICAgIHZhciBzdGVwID0gcGFyYW1zWzJdO1xuICAgICAgcGFyYW1zWzJdID0gcGFyYW1zWzFdO1xuICAgICAgcGFyYW1zWzFdID0gc3RlcDtcbiAgICB9XG4gICAgbm9kZSA9IG5ldyBSYW5nZU5vZGUocGFyYW1zKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIGFkZCBvciBzdWJ0cmFjdFxuICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VBZGRTdWJ0cmFjdCAoKSAge1xuICB2YXIgbm9kZSwgb3BlcmF0b3JzLCBuYW1lLCBmbiwgcGFyYW1zO1xuXG4gIG5vZGUgPSBwYXJzZU11bHRpcGx5RGl2aWRlKCk7XG5cbiAgb3BlcmF0b3JzID0ge1xuICAgICcrJzogJ2FkZCcsXG4gICAgJy0nOiAnc3VidHJhY3QnXG4gIH07XG4gIHdoaWxlICh0b2tlbiBpbiBvcGVyYXRvcnMpIHtcbiAgICBuYW1lID0gdG9rZW47XG4gICAgZm4gPSBvcGVyYXRvcnNbbmFtZV07XG5cbiAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG4gICAgcGFyYW1zID0gW25vZGUsIHBhcnNlTXVsdGlwbHlEaXZpZGUoKV07XG4gICAgbm9kZSA9IG5ldyBPcGVyYXRvck5vZGUobmFtZSwgZm4sIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBtdWx0aXBseSwgZGl2aWRlLCBtb2R1bHVzXG4gKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU11bHRpcGx5RGl2aWRlICgpIHtcbiAgdmFyIG5vZGUsIG9wZXJhdG9ycywgbmFtZSwgZm4sIHBhcmFtcztcblxuICBub2RlID0gcGFyc2VVbmFyeSgpO1xuXG4gIG9wZXJhdG9ycyA9IHtcbiAgICAnKic6ICdtdWx0aXBseScsXG4gICAgJy4qJzogJ2RvdE11bHRpcGx5JyxcbiAgICAnLyc6ICdkaXZpZGUnLFxuICAgICcuLyc6ICdkb3REaXZpZGUnLFxuICAgICclJzogJ21vZCcsXG4gICAgJ21vZCc6ICdtb2QnXG4gIH07XG5cbiAgaWYgKHRva2VuIGluIG9wZXJhdG9ycykge1xuICAgIHdoaWxlICh0b2tlbiBpbiBvcGVyYXRvcnMpIHtcbiAgICAgIG5hbWUgPSB0b2tlbjtcbiAgICAgIGZuID0gb3BlcmF0b3JzW25hbWVdO1xuXG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG4gICAgICBwYXJhbXMgPSBbbm9kZSwgcGFyc2VVbmFyeSgpXTtcbiAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKG5hbWUsIGZuLCBwYXJhbXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHBhcnNlIGltcGxpY2l0IG11bHRpcGxpY2F0aW9uXG4gIGlmICgodG9rZW5fdHlwZSA9PSBUT0tFTlRZUEUuU1lNQk9MKSB8fFxuICAgICAgKHRva2VuID09ICdpbicgJiYgKG5vZGUgaW5zdGFuY2VvZiBDb25zdGFudE5vZGUpKSB8fFxuICAgICAgKHRva2VuX3R5cGUgPT0gVE9LRU5UWVBFLk5VTUJFUiAmJiAhKG5vZGUgaW5zdGFuY2VvZiBDb25zdGFudE5vZGUpKSB8fFxuICAgICAgKHRva2VuID09ICcoJyB8fCB0b2tlbiA9PSAnWycpKSB7XG4gICAgLy8gc3ltYm9sOiAgICAgIGltcGxpY2l0IG11bHRpcGxpY2F0aW9uIGxpa2UgJzJhJywgJygyKzMpYScsICdhIGInXG4gICAgLy8gbnVtYmVyOiAgICAgIGltcGxpY2l0IG11bHRpcGxpY2F0aW9uIGxpa2UgJygyKzMpMidcbiAgICAvLyAgICAgICAgICAgICAgTm90ZTogd2UgZG9uJ3QgYWxsb3cgaW1wbGljaXQgbXVsdGlwbGljYXRpb24gYmV0d2VlbiBudW1iZXJzLFxuICAgIC8vICAgICAgICAgICAgICBsaWtlICcyIDMnLiBJJ20gbm90IHN1cmUgd2hldGhlciB0aGF0IGlzIGEgZ29vZCBpZGVhLlxuICAgIC8vIHBhcmVudGhlc2lzOiBpbXBsaWNpdCBtdWx0aXBsaWNhdGlvbiBsaWtlICcyKDMrNCknLCAnKDMrNCkoMSsyKScsICcyWzEsMiwzXSdcbiAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZSgnKicsICdtdWx0aXBseScsIFtub2RlLCBwYXJzZU11bHRpcGx5RGl2aWRlKCldKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIFVuYXJ5IHBsdXMgYW5kIG1pbnVzXG4gKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZVVuYXJ5ICgpIHtcbiAgdmFyIG5hbWUsIGZuLCBwYXJhbXM7XG5cbiAgaWYgKHRva2VuID09ICctJyB8fCB0b2tlbiA9PSAnKycpIHtcbiAgICBuYW1lID0gdG9rZW47XG4gICAgZm4gPSBuYW1lID09ICcrJyA/ICd1bmFyeVBsdXMnIDogJ3VuYXJ5TWludXMnO1xuXG4gICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuICAgIHBhcmFtcyA9IFtwYXJzZVVuYXJ5KCldO1xuXG4gICAgcmV0dXJuIG5ldyBPcGVyYXRvck5vZGUobmFtZSwgZm4sIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VQb3coKTtcbn1cblxuLyoqXG4gKiBwb3dlclxuICogTm90ZTogcG93ZXIgb3BlcmF0b3IgaXMgcmlnaHQgYXNzb2NpYXRpdmVcbiAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUG93ICgpIHtcbiAgdmFyIG5vZGUsIG5hbWUsIGZuLCBwYXJhbXM7XG5cbiAgbm9kZSA9IHBhcnNlTGVmdEhhbmRPcGVyYXRvcnMoKTtcblxuICBpZiAodG9rZW4gPT0gJ14nIHx8IHRva2VuID09ICcuXicpIHtcbiAgICBuYW1lID0gdG9rZW47XG4gICAgZm4gPSAobmFtZSA9PSAnXicpID8gJ3BvdycgOiAnZG90UG93JztcblxuICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICBwYXJhbXMgPSBbbm9kZSwgcGFyc2VVbmFyeSgpXTsgLy8gR28gYmFjayB0byB1bmFyeSwgd2UgY2FuIGhhdmUgJzJeLTMnXG4gICAgbm9kZSA9IG5ldyBPcGVyYXRvck5vZGUobmFtZSwgZm4sIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBMZWZ0IGhhbmQgb3BlcmF0b3JzOiBmYWN0b3JpYWwgeCEsIHRyYW5zcG9zZSB4J1xuICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZE9wZXJhdG9ycyAoKSAge1xuICB2YXIgbm9kZSwgb3BlcmF0b3JzLCBuYW1lLCBmbiwgcGFyYW1zO1xuXG4gIG5vZGUgPSBwYXJzZUN1c3RvbU5vZGVzKCk7XG5cbiAgb3BlcmF0b3JzID0ge1xuICAgICchJzogJ2ZhY3RvcmlhbCcsXG4gICAgJ1xcJyc6ICd0cmFuc3Bvc2UnXG4gIH07XG5cbiAgd2hpbGUgKHRva2VuIGluIG9wZXJhdG9ycykge1xuICAgIG5hbWUgPSB0b2tlbjtcbiAgICBmbiA9IG9wZXJhdG9yc1tuYW1lXTtcblxuICAgIGdldFRva2VuKCk7XG4gICAgcGFyYW1zID0gW25vZGVdO1xuXG4gICAgbm9kZSA9IG5ldyBPcGVyYXRvck5vZGUobmFtZSwgZm4sIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIGN1c3RvbSBub2RlIGhhbmRsZXIuIEEgbm9kZSBoYW5kbGVyIGNhbiBiZSB1c2VkIHRvIHByb2Nlc3NcbiAqIG5vZGVzIGluIGEgY3VzdG9tIHdheSwgZm9yIGV4YW1wbGUgZm9yIGhhbmRsaW5nIGEgcGxvdC5cbiAqXG4gKiBBIGhhbmRsZXIgbXVzdCBiZSBwYXNzZWQgYXMgc2Vjb25kIGFyZ3VtZW50IG9mIHRoZSBwYXJzZSBmdW5jdGlvbi5cbiAqIC0gbXVzdCBleHRlbmQgbWF0aC5leHByZXNzaW9uLm5vZGUuTm9kZVxuICogLSBtdXN0IGNvbnRhaW4gYSBmdW5jdGlvbiBfY29tcGlsZShkZWZzOiBPYmplY3QpIDogU3RyaW5nXG4gKiAtIG11c3QgY29udGFpbiBhIGZ1bmN0aW9uIGZpbmQoZmlsdGVyOiBPYmplY3QpIDogTm9kZVtdXG4gKiAtIG11c3QgY29udGFpbiBhIGZ1bmN0aW9uIHRvU3RyaW5nKCkgOiBTdHJpbmdcbiAqIC0gdGhlIGNvbnN0cnVjdG9yIGlzIGNhbGxlZCB3aXRoIGEgc2luZ2xlIGFyZ3VtZW50IGNvbnRhaW5pbmcgYWxsIHBhcmFtZXRlcnNcbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgbm9kZXMgPSB7XG4gKiAgICAgICAncGxvdCc6IFBsb3RIYW5kbGVyXG4gKiAgICAgfTtcbiAqXG4gKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGhhbmRsZXIgaXMgY2FsbGVkIGFzOlxuICpcbiAqICAgICBub2RlID0gbmV3IFBsb3RIYW5kbGVyKHBhcmFtcyk7XG4gKlxuICogVGhlIGhhbmRsZXIgd2lsbCBiZSBpbnZva2VkIHdoZW4gZXZhbHVhdGluZyBhbiBleHByZXNzaW9uIGxpa2U6XG4gKlxuICogICAgIG5vZGUgPSBtYXRoLnBhcnNlKCdwbG90KHNpbih4KSwgeCknLCBub2Rlcyk7XG4gKlxuICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VDdXN0b21Ob2RlcyAoKSB7XG4gIHZhciBwYXJhbXMgPSBbXSwgaGFuZGxlcjtcblxuICBpZiAodG9rZW5fdHlwZSA9PSBUT0tFTlRZUEUuU1lNQk9MICYmIGV4dHJhX25vZGVzW3Rva2VuXSkge1xuICAgIGhhbmRsZXIgPSBleHRyYV9ub2Rlc1t0b2tlbl07XG5cbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gcGFyc2UgcGFyYW1ldGVyc1xuICAgIGlmICh0b2tlbiA9PSAnKCcpIHtcbiAgICAgIHBhcmFtcyA9IFtdO1xuXG4gICAgICBvcGVuUGFyYW1zKCk7XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICBpZiAodG9rZW4gIT0gJyknKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHBhcnNlQ29uZGl0aW9uYWwoKSk7XG5cbiAgICAgICAgLy8gcGFyc2UgYSBsaXN0IHdpdGggcGFyYW1ldGVyc1xuICAgICAgICB3aGlsZSAodG9rZW4gPT0gJywnKSB7XG4gICAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgICAgICBwYXJhbXMucHVzaChwYXJzZUNvbmRpdGlvbmFsKCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbiAhPSAnKScpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1BhcmVudGhlc2lzICkgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGNsb3NlUGFyYW1zKCk7XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIG5ldyBub2RlIGhhbmRsZXJcbiAgICAvL25vaW5zcGVjdGlvbiBKU1ZhbGlkYXRlVHlwZXNcbiAgICByZXR1cm4gbmV3IGhhbmRsZXIocGFyYW1zKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZVN5bWJvbCgpO1xufVxuXG4vKipcbiAqIHBhcnNlIHN5bWJvbHM6IGZ1bmN0aW9ucywgdmFyaWFibGVzLCBjb25zdGFudHMsIHVuaXRzXG4gKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZVN5bWJvbCAoKSB7XG4gIHZhciBub2RlLCBuYW1lO1xuXG4gIGlmICh0b2tlbl90eXBlID09IFRPS0VOVFlQRS5TWU1CT0wgfHxcbiAgICAgICh0b2tlbl90eXBlID09IFRPS0VOVFlQRS5ERUxJTUlURVIgJiYgdG9rZW4gaW4gTkFNRURfREVMSU1JVEVSUykpIHtcbiAgICBuYW1lID0gdG9rZW47XG5cbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gY3JlYXRlIGEgc3ltYm9sXG4gICAgbm9kZSA9IG5ldyBTeW1ib2xOb2RlKG5hbWUpO1xuXG4gICAgLy8gcGFyc2UgZnVuY3Rpb24gcGFyYW1ldGVycyBhbmQgbWF0cml4IGluZGV4XG4gICAgbm9kZSA9IHBhcnNlRnVuY3Rpb25zKG5vZGUpO1xuICAgIG5vZGUgPSBwYXJzZUluZGV4KG5vZGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlU3RyaW5nKCk7XG59XG5cbi8qKlxuICogcGFyc2UgYSBmdW5jdGlvbiBjYWxsIGxpa2UgZm4oYSwgYiwgYylcbiAqIEBwYXJhbSB7U3ltYm9sTm9kZX0gc3ltYm9sICAgU3ltYm9sTm9kZSBvbiB3aGljaCB0byBhcHBseSB0aGUgcGFyYW1ldGVycy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdGhlcmUgYXJlIG5vIHBhcmFtZXRlcnMgaW4gdGhlIGV4cHJlc3Npb24sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBub2RlIGl0c2VsZiBpcyByZXR1cm5lZFxuICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VGdW5jdGlvbnMgKHN5bWJvbCkge1xuICB2YXIgcGFyYW1zO1xuXG4gIGlmICh0b2tlbiA9PSAnKCcpIHtcbiAgICBwYXJhbXMgPSBbXTtcblxuICAgIG9wZW5QYXJhbXMoKTtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgaWYgKHRva2VuICE9ICcpJykge1xuICAgICAgcGFyYW1zLnB1c2gocGFyc2VDb25kaXRpb25hbCgpKTtcblxuICAgICAgLy8gcGFyc2UgYSBsaXN0IHdpdGggcGFyYW1ldGVyc1xuICAgICAgd2hpbGUgKHRva2VuID09ICcsJykge1xuICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgICBwYXJhbXMucHVzaChwYXJzZUNvbmRpdGlvbmFsKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbiAhPSAnKScpIHtcbiAgICAgIHRocm93IGNyZWF0ZVN5bnRheEVycm9yKCdQYXJlbnRoZXNpcyApIGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGNsb3NlUGFyYW1zKCk7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIHJldHVybiBuZXcgRnVuY3Rpb25Ob2RlKHN5bWJvbCwgcGFyYW1zKTtcbiAgfVxuXG4gIHJldHVybiBzeW1ib2w7XG59XG5cbi8qKlxuICogcGFyc2UgaW5kZXggcGFyYW1ldGVycywgZW5jbG9zZWQgaW4gc3F1YXJlIGJyYWNrZXRzIFsuLi5dLCBmb3IgZXhhbXBsZSBBWzIsM11cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgICBOb2RlIG9uIHdoaWNoIHRvIGFwcGx5IHRoZSBwYXJhbWV0ZXJzLiBJZiB0aGVyZVxuICogICAgICAgICAgICAgICAgICAgICAgIGFyZSBubyBwYXJhbWV0ZXJzIGluIHRoZSBleHByZXNzaW9uLCB0aGUgbm9kZVxuICogICAgICAgICAgICAgICAgICAgICAgIGl0c2VsZiBpcyByZXR1cm5lZFxuICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VJbmRleCAobm9kZSkge1xuICB2YXIgcGFyYW1zO1xuXG4gIHdoaWxlICh0b2tlbiA9PSAnWycpIHtcbiAgICBwYXJhbXMgPSBbXTtcblxuICAgIG9wZW5QYXJhbXMoKTtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgaWYgKHRva2VuICE9ICddJykge1xuICAgICAgcGFyYW1zLnB1c2gocGFyc2VDb25kaXRpb25hbCgpKTtcblxuICAgICAgLy8gcGFyc2UgYSBsaXN0IHdpdGggcGFyYW1ldGVyc1xuICAgICAgd2hpbGUgKHRva2VuID09ICcsJykge1xuICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgICBwYXJhbXMucHVzaChwYXJzZUNvbmRpdGlvbmFsKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbiAhPSAnXScpIHtcbiAgICAgIHRocm93IGNyZWF0ZVN5bnRheEVycm9yKCdQYXJlbnRoZXNpcyBdIGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGNsb3NlUGFyYW1zKCk7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIG5vZGUgPSBuZXcgSW5kZXhOb2RlKG5vZGUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBwYXJzZSBhIHN0cmluZy5cbiAqIEEgc3RyaW5nIGlzIGVuY2xvc2VkIGJ5IGRvdWJsZSBxdW90ZXNcbiAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nICgpIHtcbiAgdmFyIG5vZGUsIHN0ciwgdFByZXY7XG5cbiAgaWYgKHRva2VuID09ICdcIicpIHtcbiAgICAvLyBzdHJpbmcgXCIuLi5cIlxuICAgIHN0ciA9ICcnO1xuICAgIHRQcmV2ID0gJyc7XG4gICAgd2hpbGUgKGMgIT0gJycgJiYgKGMgIT0gJ1xcXCInIHx8IHRQcmV2ID09ICdcXFxcJykpIHsgLy8gYWxzbyBoYW5kbGUgZXNjYXBlIGNoYXJhY3RlclxuICAgICAgc3RyICs9IGM7XG4gICAgICB0UHJldiA9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgZ2V0VG9rZW4oKTtcbiAgICBpZiAodG9rZW4gIT0gJ1wiJykge1xuICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ0VuZCBvZiBzdHJpbmcgXCIgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIGNyZWF0ZSBjb25zdGFudFxuICAgIG5vZGUgPSBuZXcgQ29uc3RhbnROb2RlKHN0ciwgJ3N0cmluZycpO1xuXG4gICAgLy8gcGFyc2UgaW5kZXggcGFyYW1ldGVyc1xuICAgIG5vZGUgPSBwYXJzZUluZGV4KG5vZGUpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gcGFyc2VNYXRyaXgoKTtcbn1cblxuLyoqXG4gKiBwYXJzZSB0aGUgbWF0cml4XG4gKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU1hdHJpeCAoKSB7XG4gIHZhciBhcnJheSwgcGFyYW1zLCByb3dzLCBjb2xzO1xuXG4gIGlmICh0b2tlbiA9PSAnWycpIHtcbiAgICAvLyBtYXRyaXggWy4uLl1cbiAgICBvcGVuUGFyYW1zKCk7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIGlmICh0b2tlbiAhPSAnXScpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBub24tZW1wdHkgbWF0cml4XG4gICAgICB2YXIgcm93ID0gcGFyc2VSb3coKTtcblxuICAgICAgaWYgKHRva2VuID09ICc7Jykge1xuICAgICAgICAvLyAyIGRpbWVuc2lvbmFsIGFycmF5XG4gICAgICAgIHJvd3MgPSAxO1xuICAgICAgICBwYXJhbXMgPSBbcm93XTtcblxuICAgICAgICAvLyB0aGUgcm93cyBvZiB0aGUgbWF0cml4IGFyZSBzZXBhcmF0ZWQgYnkgZG90LWNvbW1hJ3NcbiAgICAgICAgd2hpbGUgKHRva2VuID09ICc7Jykge1xuICAgICAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgICAgICBwYXJhbXNbcm93c10gPSBwYXJzZVJvdygpO1xuICAgICAgICAgIHJvd3MrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbiAhPSAnXScpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignRW5kIG9mIG1hdHJpeCBdIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VQYXJhbXMoKTtcbiAgICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgbWF0Y2hlcyBpbiBhbGwgcm93c1xuICAgICAgICBjb2xzID0gcGFyYW1zWzBdLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3dzOyByKyspIHtcbiAgICAgICAgICBpZiAocGFyYW1zW3JdLm5vZGVzLmxlbmd0aCAhPSBjb2xzKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcignQ29sdW1uIGRpbWVuc2lvbnMgbWlzbWF0Y2ggJyArXG4gICAgICAgICAgICAgICAgJygnICsgcGFyYW1zW3JdLm5vZGVzLmxlbmd0aCArICcgIT0gJyArIGNvbHMgKyAnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5ID0gbmV3IEFycmF5Tm9kZShwYXJhbXMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIDEgZGltZW5zaW9uYWwgdmVjdG9yXG4gICAgICAgIGlmICh0b2tlbiAhPSAnXScpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignRW5kIG9mIG1hdHJpeCBdIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VQYXJhbXMoKTtcbiAgICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgICBhcnJheSA9IHJvdztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB0aGlzIGlzIGFuIGVtcHR5IG1hdHJpeCBcIlsgXVwiXG4gICAgICBjbG9zZVBhcmFtcygpO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIGFycmF5ID0gbmV3IEFycmF5Tm9kZShbXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlTnVtYmVyKCk7XG59XG5cbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgY29tbWEtc2VwYXJhdGVkIHJvdyBmcm9tIGEgbWF0cml4LCBsaWtlICdhLCBiLCBjJ1xuICogQHJldHVybiB7QXJyYXlOb2RlfSBub2RlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUm93ICgpIHtcbiAgdmFyIHBhcmFtcyA9IFtwYXJzZUFzc2lnbm1lbnQoKV07XG4gIHZhciBsZW4gPSAxO1xuXG4gIHdoaWxlICh0b2tlbiA9PSAnLCcpIHtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gcGFyc2UgZXhwcmVzc2lvblxuICAgIHBhcmFtc1tsZW5dID0gcGFyc2VBc3NpZ25tZW50KCk7XG4gICAgbGVuKys7XG4gIH1cblxuICByZXR1cm4gbmV3IEFycmF5Tm9kZShwYXJhbXMpO1xufVxuXG4vKipcbiAqIHBhcnNlIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU51bWJlciAoKSB7XG4gIHZhciBudW1iZXI7XG5cbiAgaWYgKHRva2VuX3R5cGUgPT0gVE9LRU5UWVBFLk5VTUJFUikge1xuICAgIC8vIHRoaXMgaXMgYSBudW1iZXJcbiAgICBudW1iZXIgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgcmV0dXJuIG5ldyBDb25zdGFudE5vZGUobnVtYmVyLCAnbnVtYmVyJyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VQYXJlbnRoZXNlcygpO1xufVxuXG4vKipcbiAqIHBhcmVudGhlc2VzXG4gKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZVBhcmVudGhlc2VzICgpIHtcbiAgdmFyIG5vZGU7XG5cbiAgLy8gY2hlY2sgaWYgaXQgaXMgYSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25cbiAgaWYgKHRva2VuID09ICcoJykge1xuICAgIC8vIHBhcmVudGhlc2VzICguLi4pXG4gICAgb3BlblBhcmFtcygpO1xuICAgIGdldFRva2VuKCk7XG5cbiAgICBub2RlID0gcGFyc2VBc3NpZ25tZW50KCk7IC8vIHN0YXJ0IGFnYWluXG5cbiAgICBpZiAodG9rZW4gIT0gJyknKSB7XG4gICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignUGFyZW50aGVzaXMgKSBleHBlY3RlZCcpO1xuICAgIH1cbiAgICBjbG9zZVBhcmFtcygpO1xuICAgIGdldFRva2VuKCk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUVuZCgpO1xufVxuXG4vKipcbiAqIEV2YWx1YXRlZCB3aGVuIHRoZSBleHByZXNzaW9uIGlzIG5vdCB5ZXQgZW5kZWQgYnV0IGV4cGVjdGVkIHRvIGVuZFxuICogQHJldHVybiB7Tm9kZX0gcmVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUVuZCAoKSB7XG4gIGlmICh0b2tlbiA9PSAnJykge1xuICAgIC8vIHN5bnRheCBlcnJvciBvciB1bmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uXG4gICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb24nKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignVmFsdWUgZXhwZWN0ZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0Y3V0IGZvciBnZXR0aW5nIHRoZSBjdXJyZW50IHJvdyB2YWx1ZSAob25lIGJhc2VkKVxuICogUmV0dXJucyB0aGUgbGluZSBvZiB0aGUgY3VycmVudGx5IGhhbmRsZWQgZXhwcmVzc2lvblxuICogQHByaXZhdGVcbiAqL1xuLyogVE9ETzogaW1wbGVtZW50IGtlZXBpbmcgdHJhY2sgb24gdGhlIHJvdyBudW1iZXJcbmZ1bmN0aW9uIHJvdyAoKSB7XG4gIHJldHVybiBudWxsO1xufVxuKi9cblxuLyoqXG4gKiBTaG9ydGN1dCBmb3IgZ2V0dGluZyB0aGUgY3VycmVudCBjb2wgdmFsdWUgKG9uZSBiYXNlZClcbiAqIFJldHVybnMgdGhlIGNvbHVtbiAocG9zaXRpb24pIHdoZXJlIHRoZSBsYXN0IHRva2VuIHN0YXJ0c1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29sICgpIHtcbiAgcmV0dXJuIGluZGV4IC0gdG9rZW4ubGVuZ3RoICsgMTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXJyb3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTeW50YXhFcnJvcn0gaW5zdGFudGlhdGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTeW50YXhFcnJvciAobWVzc2FnZSkge1xuICB2YXIgYyA9IGNvbCgpO1xuICB2YXIgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSArICcgKGNoYXIgJyArIGMgKyAnKScpO1xuICBlcnJvclsnY2hhciddID0gYztcblxuICByZXR1cm4gZXJyb3I7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVycm9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybiB7RXJyb3J9IGluc3RhbnRpYXRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3IgKG1lc3NhZ2UpIHtcbiAgdmFyIGMgPSBjb2woKTtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UgKyAnIChjaGFyICcgKyBjICsgJyknKTtcbiAgZXJyb3JbJ2NoYXInXSA9IGM7XG5cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG59KSgpIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3BhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBQYXJzZXJcbiAqIFBhcnNlciBjb250YWlucyBtZXRob2RzIHRvIGV2YWx1YXRlIG9yIHBhcnNlIGV4cHJlc3Npb25zLCBhbmQgaGFzIGEgbnVtYmVyXG4gKiBvZiBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGdldCwgc2V0LCBhbmQgcmVtb3ZlIHZhcmlhYmxlcyBmcm9tIG1lbW9yeS4gUGFyc2VyXG4gKiBrZWVwcyBhIHNjb3BlIGNvbnRhaW5pbmcgdmFyaWFibGVzIGluIG1lbW9yeSwgd2hpY2ggaXMgdXNlZCBmb3IgYWxsXG4gKiBldmFsdWF0aW9ucy5cbiAqXG4gKiBNZXRob2RzOlxuICogICAgdmFyIHJlc3VsdCA9IHBhcnNlci5ldmFsKGV4cHIpOyAgICAvLyBldmFsdWF0ZSBhbiBleHByZXNzaW9uXG4gKiAgICB2YXIgdmFsdWUgPSBwYXJzZXIuZ2V0KG5hbWUpOyAgICAgIC8vIHJldHJpZXZlIGEgdmFyaWFibGUgZnJvbSB0aGUgcGFyc2VyXG4gKiAgICBwYXJzZXIuc2V0KG5hbWUsIHZhbHVlKTsgICAgICAgICAgIC8vIHNldCBhIHZhcmlhYmxlIGluIHRoZSBwYXJzZXJcbiAqICAgIHBhcnNlci5yZW1vdmUobmFtZSk7ICAgICAgICAgICAgICAgLy8gY2xlYXIgYSB2YXJpYWJsZSBmcm9tIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZXJzIHNjb3BlXG4gKiAgICBwYXJzZXIuY2xlYXIoKTsgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBwYXJzZXJzIHNjb3BlXG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG1hdGgpO1xuICogICAgLy8gTm90ZTogdGhlcmUgaXMgYSBjb252ZW5pZW5jZSBtZXRob2Qgd2hpY2ggY2FuIGJlIHVzZWQgaW5zdGVhZDpcbiAqICAgIC8vIHZhciBwYXJzZXIgPSBuZXcgbWF0aC5wYXJzZXIoKTtcbiAqXG4gKiAgICAvLyBldmFsdWF0ZSBleHByZXNzaW9uc1xuICogICAgcGFyc2VyLmV2YWwoJ3NxcnQoM14yICsgNF4yKScpOyAgICAgICAgIC8vIDVcbiAqICAgIHBhcnNlci5ldmFsKCdzcXJ0KC00KScpOyAgICAgICAgICAgICAgICAvLyAyaVxuICogICAgcGFyc2VyLmV2YWwoJzIgaW5jaCBpbiBjbScpOyAgICAgICAgICAgIC8vIDUuMDggY21cbiAqICAgIHBhcnNlci5ldmFsKCdjb3MoNDUgZGVnKScpOyAgICAgICAgICAgICAvLyAwLjcwNzEwNjc4MTE4NjU0NzZcbiAqXG4gKiAgICAvLyBkZWZpbmUgdmFyaWFibGVzIGFuZCBmdW5jdGlvbnNcbiAqICAgIHBhcnNlci5ldmFsKCd4ID0gNyAvIDInKTsgICAgICAgICAgICAgICAvLyAzLjVcbiAqICAgIHBhcnNlci5ldmFsKCd4ICsgMycpOyAgICAgICAgICAgICAgICAgICAvLyA2LjVcbiAqICAgIHBhcnNlci5ldmFsKCdmdW5jdGlvbiBmKHgsIHkpID0geF55Jyk7ICAvLyBmKHgsIHkpXG4gKiAgICBwYXJzZXIuZXZhbCgnZigyLCAzKScpOyAgICAgICAgICAgICAgICAgLy8gOFxuICpcbiAqICAgIC8vIGdldCBhbmQgc2V0IHZhcmlhYmxlcyBhbmQgZnVuY3Rpb25zXG4gKiAgICB2YXIgeCA9IHBhcnNlci5nZXQoJ3gnKTsgICAgICAgICAgICAgICAgLy8gN1xuICogICAgdmFyIGYgPSBwYXJzZXIuZ2V0KCdmJyk7ICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uXG4gKiAgICB2YXIgZyA9IGYoMywgMik7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gOVxuICogICAgcGFyc2VyLnNldCgnaCcsIDUwMCk7XG4gKiAgICB2YXIgaSA9IHBhcnNlci5ldmFsKCdoIC8gMicpOyAgICAgICAgICAgLy8gMjUwXG4gKiAgICBwYXJzZXIuc2V0KCdoZWxsbycsIGZ1bmN0aW9uIChuYW1lKSB7XG4gKiAgICAgICAgcmV0dXJuICdoZWxsbywgJyArIG5hbWUgKyAnISc7XG4gKiAgICB9KTtcbiAqICAgIHBhcnNlci5ldmFsKCdoZWxsbyhcInVzZXJcIiknKTsgICAgICAgICAgIC8vIFwiaGVsbG8sIHVzZXIhXCJcbiAqXG4gKiAgICAvLyBjbGVhciBkZWZpbmVkIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzXG4gKiAgICBwYXJzZXIuY2xlYXIoKTtcbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1hdGggICAgIExpbmsgdG8gdGhlIG1hdGguanMgbmFtZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIFBhcnNlcihtYXRoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXJzZXIpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAnQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICBpZiAoIShtYXRoIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBleHBlY3RlZCBhcyBwYXJhbWV0ZXIgbWF0aCcpO1xuICB9XG5cbiAgdGhpcy5tYXRoID0gbWF0aDtcbiAgdGhpcy5zY29wZSA9IHt9O1xufVxuXG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYW5kIHJldHVybiB0aGUgcGFyc2VkIGZ1bmN0aW9uIG5vZGUuXG4gKiBUaGUgbm9kZSB0cmVlIGNhbiBiZSBjb21waWxlZCB2aWEgYGNvZGUgPSBub2RlLmNvbXBpbGUobWF0aClgLFxuICogYW5kIHRoZSBjb21waWxlZCBjb2RlIGNhbiBiZSBleGVjdXRlZCBhcyBgY29kZS5ldmFsKFtzY29wZV0pYFxuICogQHBhcmFtIHtTdHJpbmd9IGV4cHJcbiAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIucGFyc2UgaXMgZGVwcmVjYXRlZC4gVXNlIG1hdGgucGFyc2UgaW5zdGVhZC4nKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYW5kIGNvbXBpbGUgYW4gZXhwcmVzc2lvbiwgcmV0dXJuIHRoZSBjb21waWxlZCBqYXZhc2NyaXB0IGNvZGUuXG4gKiBUaGUgbm9kZSBjYW4gYmUgZXZhbHVhdGVkIHZpYSBjb2RlLmV2YWwoW3Njb3BlXSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHByXG4gKiBAcmV0dXJuIHt7ZXZhbDogZnVuY3Rpb259fSBjb2RlXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIuY29tcGlsZSBpcyBkZXByZWNhdGVkLiBVc2UgbWF0aC5jb21waWxlIGluc3RlYWQuJyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGFuZCBldmFsdWF0ZSB0aGUgZ2l2ZW4gZXhwcmVzc2lvblxuICogQHBhcmFtIHtTdHJpbmd9IGV4cHIgICBBIHN0cmluZyBjb250YWluaW5nIGFuIGV4cHJlc3Npb24sIGZvciBleGFtcGxlIFwiMiszXCJcbiAqIEByZXR1cm4geyp9IHJlc3VsdCAgICAgVGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIHdoZW4gdGhlIGV4cHJlc3Npb24gd2FzIGVtcHR5XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgLy8gVE9ETzogdmFsaWRhdGUgYXJndW1lbnRzXG4gIHJldHVybiBfcGFyc2UoZXhwcilcbiAgICAgIC5jb21waWxlKHRoaXMubWF0aClcbiAgICAgIC5ldmFsKHRoaXMuc2NvcGUpO1xufTtcblxuLyoqXG4gKiBHZXQgYSB2YXJpYWJsZSAoYSBmdW5jdGlvbiBvciB2YXJpYWJsZSkgYnkgbmFtZSBmcm9tIHRoZSBwYXJzZXJzIHNjb3BlLlxuICogUmV0dXJucyB1bmRlZmluZWQgd2hlbiBub3QgZm91bmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHsqIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICovXG5QYXJzZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIC8vIFRPRE86IHZhbGlkYXRlIGFyZ3VtZW50c1xuICByZXR1cm4gdGhpcy5zY29wZVtuYW1lXTtcbn07XG5cbi8qKlxuICogU2V0IGEgc3ltYm9sIChhIGZ1bmN0aW9uIG9yIHZhcmlhYmxlKSBieSBuYW1lIGZyb20gdGhlIHBhcnNlcnMgc2NvcGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICovXG5QYXJzZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZSBhcmd1bWVudHNcbiAgcmV0dXJuIHRoaXMuc2NvcGVbbmFtZV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgdmFyaWFibGUgZnJvbSB0aGUgcGFyc2VycyBzY29wZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZSBhcmd1bWVudHNcbiAgZGVsZXRlIHRoaXMuc2NvcGVbbmFtZV07XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBzY29wZSB3aXRoIHZhcmlhYmxlcyBhbmQgZnVuY3Rpb25zXG4gKi9cblBhcnNlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIG5hbWUgaW4gdGhpcy5zY29wZSkge1xuICAgIGlmICh0aGlzLnNjb3BlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBkZWxldGUgdGhpcy5zY29wZVtuYW1lXTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciBzdHJpbmcgPSByZXF1aXJlKCcuLi91dGlsL3N0cmluZycpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgU2VsZWN0b3JcbiAgICogV3JhcCBhbnkgdmFsdWUgaW4gYSBTZWxlY3RvciwgYWxsb3dpbmcgdG8gcGVyZm9ybSBjaGFpbmVkIG9wZXJhdGlvbnMgb25cbiAgICogdGhlIHZhbHVlLlxuICAgKlxuICAgKiBBbGwgbWV0aG9kcyBhdmFpbGFibGUgaW4gdGhlIG1hdGguanMgbGlicmFyeSBjYW4gYmUgY2FsbGVkIHVwb24gdGhlIHNlbGVjdG9yLFxuICAgKiBhbmQgdGhlbiB3aWxsIGJlIGV2YWx1YXRlZCB3aXRoIHRoZSB2YWx1ZSBpdHNlbGYgYXMgZmlyc3QgYXJndW1lbnQuXG4gICAqIFRoZSBzZWxlY3RvciBjYW4gYmUgY2xvc2VkIGJ5IGV4ZWN1dGluZyBzZWxlY3Rvci5kb25lKCksIHdoaWNoIHdpbGwgcmV0dXJuXG4gICAqIHRoZSBmaW5hbCB2YWx1ZS5cbiAgICpcbiAgICogVGhlIFNlbGVjdG9yIGhhcyBhIG51bWJlciBvZiBzcGVjaWFsIGZ1bmN0aW9uczpcbiAgICogLSBkb25lKCkgICAgICAgICAgICAgRmluYWxpemUgdGhlIGNoYWluZWQgb3BlcmF0aW9uIGFuZCByZXR1cm4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycyB2YWx1ZS5cbiAgICogLSB2YWx1ZU9mKCkgICAgICAgICAgVGhlIHNhbWUgYXMgZG9uZSgpXG4gICAqIC0gdG9TdHJpbmcoKSAgICAgICAgIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlbGVjdG9ycyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gICAqL1xuICBmdW5jdGlvbiBTZWxlY3RvciAodmFsdWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VsZWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNlbGVjdG9yKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWUudmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgc2VsZWN0b3IuIFJldHVybnMgdGhlIGZpbmFsIHZhbHVlLlxuICAgKiBEb2VzIHRoZSBzYW1lIGFzIG1ldGhvZCB2YWx1ZU9mKClcbiAgICogQHJldHVybnMgeyp9IHZhbHVlXG4gICAqL1xuICBTZWxlY3Rvci5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2UgdGhlIHNlbGVjdG9yLiBSZXR1cm5zIHRoZSBmaW5hbCB2YWx1ZS5cbiAgICogRG9lcyB0aGUgc2FtZSBhcyBtZXRob2QgZG9uZSgpXG4gICAqIEByZXR1cm5zIHsqfSB2YWx1ZVxuICAgKi9cbiAgU2VsZWN0b3IucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUgaW4gdGhlIHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBTZWxlY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0cmluZy5mb3JtYXQodGhpcy52YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHByb3h5IG1ldGhvZCBmb3IgdGhlIHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgICAgICAgVGhlIHZhbHVlIG9yIGZ1bmN0aW9uIHRvIGJlIHByb3hpZWRcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVByb3h5KG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGEgZnVuY3Rpb25cbiAgICAgIFNlbGVjdG9yLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy52YWx1ZV0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0b3IodmFsdWUuYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGEgY29uc3RhbnRcbiAgICAgIFNlbGVjdG9yLnByb3RvdHlwZVtuYW1lXSA9IG5ldyBTZWxlY3Rvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgU2VsZWN0b3IuY3JlYXRlUHJveHkgPSBjcmVhdGVQcm94eTtcblxuICAvKipcbiAgICogaW5pdGlhbGlzZSB0aGUgQ2hhaW4gcHJvdG90eXBlIHdpdGggYWxsIGZ1bmN0aW9ucyBhbmQgY29uc3RhbnRzIGluIG1hdGhcbiAgICovXG4gIGZvciAodmFyIHByb3AgaW4gbWF0aCkge1xuICAgIGlmIChtYXRoLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBjcmVhdGVQcm94eShwcm9wLCBtYXRoW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gU2VsZWN0b3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkFycmF5Tm9kZSA9IHJlcXVpcmUoJy4vQXJyYXlOb2RlJyk7XG5leHBvcnRzLkFzc2lnbm1lbnROb2RlID0gcmVxdWlyZSgnLi9Bc3NpZ25tZW50Tm9kZScpO1xuZXhwb3J0cy5CbG9ja05vZGUgPSByZXF1aXJlKCcuL0Jsb2NrTm9kZScpO1xuZXhwb3J0cy5Db25kaXRpb25hbE5vZGUgPSByZXF1aXJlKCcuL0NvbmRpdGlvbmFsTm9kZScpO1xuZXhwb3J0cy5Db25zdGFudE5vZGUgPSByZXF1aXJlKCcuL0NvbnN0YW50Tm9kZScpO1xuZXhwb3J0cy5JbmRleE5vZGUgPSByZXF1aXJlKCcuL0luZGV4Tm9kZScpO1xuZXhwb3J0cy5GdW5jdGlvbkFzc2lnbm1lbnROb2RlID0gcmVxdWlyZSgnLi9GdW5jdGlvbkFzc2lnbm1lbnROb2RlJyk7XG5leHBvcnRzLkZ1bmN0aW9uTm9kZSA9IHJlcXVpcmUoJy4vRnVuY3Rpb25Ob2RlJyk7XG5leHBvcnRzLk5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcbmV4cG9ydHMuT3BlcmF0b3JOb2RlID0gcmVxdWlyZSgnLi9PcGVyYXRvck5vZGUnKTtcbmV4cG9ydHMuUmFuZ2VOb2RlID0gcmVxdWlyZSgnLi9SYW5nZU5vZGUnKTtcbmV4cG9ydHMuU3ltYm9sTm9kZSA9IHJlcXVpcmUoJy4vU3ltYm9sTm9kZScpO1xuZXhwb3J0cy5VcGRhdGVOb2RlID0gcmVxdWlyZSgnLi9VcGRhdGVOb2RlJyk7XG4iLCIvLyBjb25zdGFudHNcbmV4cG9ydHMuZSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL2UnKTtcbmV4cG9ydHMuRSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL2UnKTtcbmV4cG9ydHNbJ2ZhbHNlJ10gPSByZXF1aXJlKCcuL2NvbnN0YW50cy9mYWxzZScpO1xuZXhwb3J0cy5pID0gcmVxdWlyZSgnLi9jb25zdGFudHMvaScpO1xuZXhwb3J0c1snSW5maW5pdHknXSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL0luZmluaXR5Jyk7XG5leHBvcnRzLkxOMiA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL0xOMicpO1xuZXhwb3J0cy5MTjEwID0gcmVxdWlyZSgnLi9jb25zdGFudHMvTE4xMCcpO1xuZXhwb3J0cy5MT0cyRSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL0xPRzJFJyk7XG5leHBvcnRzLkxPRzEwRSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL0xPRzEwRScpO1xuZXhwb3J0cy5OYU4gPSByZXF1aXJlKCcuL2NvbnN0YW50cy9OYU4nKTtcbmV4cG9ydHNbJ251bGwnXSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL251bGwnKTtcbmV4cG9ydHMucGkgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9waScpO1xuZXhwb3J0cy5QSSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL3BpJyk7XG5leHBvcnRzLnBoaSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL3BoaScpO1xuZXhwb3J0cy5TUVJUMV8yID0gcmVxdWlyZSgnLi9jb25zdGFudHMvU1FSVDFfMicpO1xuZXhwb3J0cy5TUVJUMiA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL1NRUlQyJyk7XG5leHBvcnRzLnRhdSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL3RhdScpO1xuZXhwb3J0c1sndHJ1ZSddID0gcmVxdWlyZSgnLi9jb25zdGFudHMvdHJ1ZScpO1xuZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi9jb25zdGFudHMvdmVyc2lvbicpO1xuXG4vLyBmdW5jdGlvbnMgLSBhcml0aG1ldGljXG5leHBvcnRzLmFicyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9hYnMnKTtcbmV4cG9ydHMuYWRkID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2FkZCcpO1xuZXhwb3J0cy5jZWlsID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2NlaWwnKTtcbmV4cG9ydHMuY3ViZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9jdWJlJyk7XG5leHBvcnRzLmRpdmlkZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9kaXZpZGUnKTtcbmV4cG9ydHMuZG90RGl2aWRlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2RvdERpdmlkZScpO1xuZXhwb3J0cy5kb3RNdWx0aXBseSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9kb3RNdWx0aXBseScpO1xuZXhwb3J0cy5kb3RQb3cgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvZG90UG93Jyk7XG5leHBvcnRzLmV4cCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9leHAnKTtcbmV4cG9ydHMuZml4ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2ZpeCcpO1xuZXhwb3J0cy5mbG9vciA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9mbG9vcicpO1xuZXhwb3J0cy5nY2QgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvZ2NkJyk7XG5leHBvcnRzLmxjbSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9sY20nKTtcbmV4cG9ydHMubG9nID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2xvZycpO1xuZXhwb3J0cy5sb2cxMCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cxMCcpO1xuZXhwb3J0cy5tb2QgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvbW9kJyk7XG5leHBvcnRzLm11bHRpcGx5ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL211bHRpcGx5Jyk7XG5leHBvcnRzLm5vcm0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvbm9ybScpO1xuZXhwb3J0cy5wb3cgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvcG93Jyk7XG5leHBvcnRzLnJvdW5kID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL3JvdW5kJyk7XG5leHBvcnRzLnNpZ24gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvc2lnbicpO1xuZXhwb3J0cy5zcXJ0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL3NxcnQnKTtcbmV4cG9ydHMuc3F1YXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL3NxdWFyZScpO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9zdWJ0cmFjdCcpO1xuZXhwb3J0cy51bmFyeU1pbnVzID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL3VuYXJ5TWludXMnKTtcbmV4cG9ydHMudW5hcnlQbHVzID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL3VuYXJ5UGx1cycpO1xuZXhwb3J0cy54Z2NkID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL3hnY2QnKTtcblxuLy8gZnVuY3Rpb25zIC0gcmVsYXRpb25hbFxuZXhwb3J0cy5jb21wYXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2NvbXBhcmUnKTtcbmV4cG9ydHMuZGVlcEVxdWFsID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2RlZXBFcXVhbCcpO1xuZXhwb3J0c1snZXF1YWwnXSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9lcXVhbCcpO1xuZXhwb3J0cy5sYXJnZXIgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3JlbGF0aW9uYWwvbGFyZ2VyJyk7XG5leHBvcnRzLmxhcmdlckVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2xhcmdlckVxJyk7XG5leHBvcnRzLnNtYWxsZXIgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3JlbGF0aW9uYWwvc21hbGxlcicpO1xuZXhwb3J0cy5zbWFsbGVyRXEgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3JlbGF0aW9uYWwvc21hbGxlckVxJyk7XG5leHBvcnRzLnVuZXF1YWwgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3JlbGF0aW9uYWwvdW5lcXVhbCcpO1xuXG4vLyBmdW5jdGlvbnMgLSBjb21wbGV4XG5leHBvcnRzLmFyZyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29tcGxleC9hcmcnKTtcbmV4cG9ydHMuY29uaiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29tcGxleC9jb25qJyk7XG5leHBvcnRzLnJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21wbGV4L3JlJyk7XG5leHBvcnRzLmltID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21wbGV4L2ltJyk7XG5cbi8vIGZ1bmN0aW9ucyAtIGNvbnN0cnVjdGlvblxuZXhwb3J0cy5iaWdudW1iZXIgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9iaWdudW1iZXInKTtcbmV4cG9ydHNbJ2Jvb2xlYW4nXSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29uc3RydWN0aW9uL2Jvb2xlYW4nKTtcbmV4cG9ydHMuY29tcGxleCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29uc3RydWN0aW9uL2NvbXBsZXgnKTtcbmV4cG9ydHMuaW5kZXggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9pbmRleCcpO1xuZXhwb3J0cy5tYXRyaXggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbnN0cnVjdGlvbi9tYXRyaXgnKTtcbmV4cG9ydHMubnVtYmVyID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vbnVtYmVyJyk7XG5leHBvcnRzLnN0cmluZyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29uc3RydWN0aW9uL3N0cmluZycpO1xuZXhwb3J0cy51bml0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9jb25zdHJ1Y3Rpb24vdW5pdCcpO1xuXG4vLyBmdW5jdGlvbnMgLSBlcHhyZXNzaW9uXG5leHBvcnRzWydldmFsJ10gPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi9leHByZXNzaW9uL2V2YWwnKTtcbmV4cG9ydHMuaGVscCA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL2V4cHJlc3Npb24vaGVscCcpO1xuXG4vLyBmdW5jdGlvbnMgLSBtYXRyaXhcbmV4cG9ydHNbJ2NvbmNhdCddID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvY29uY2F0Jyk7XG5leHBvcnRzLmRldCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L2RldCcpO1xuZXhwb3J0cy5kaWFnID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvZGlhZycpO1xuZXhwb3J0cy5leWUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9leWUnKTtcbmV4cG9ydHMuZmxhdHRlbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L2ZsYXR0ZW4nKTtcbmV4cG9ydHMuaW52ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvaW52Jyk7XG5leHBvcnRzLm9uZXMgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9vbmVzJyk7XG5leHBvcnRzLnJhbmdlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvcmFuZ2UnKTtcbmV4cG9ydHMucmVzaXplID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvcmVzaXplJyk7XG5leHBvcnRzLnNpemUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9zaXplJyk7XG5leHBvcnRzLnNxdWVlemUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9zcXVlZXplJyk7XG5leHBvcnRzLnN1YnNldCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L3N1YnNldCcpO1xuZXhwb3J0cy50cmFuc3Bvc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC90cmFuc3Bvc2UnKTtcbmV4cG9ydHMuemVyb3MgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC96ZXJvcycpO1xuXG4vLyBmdW5jdGlvbnMgLSBwcm9iYWJpbGl0eVxuZXhwb3J0cy5jb21iaW5hdGlvbnMgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L2NvbWJpbmF0aW9ucycpO1xuLy9leHBvcnRzLmRpc3RyaWJ1dGlvbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvZGlzdHJpYnV0aW9uJyk7XG5leHBvcnRzLmZhY3RvcmlhbCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvZmFjdG9yaWFsJyk7XG5leHBvcnRzLnBlcm11dGF0aW9ucyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvcGVybXV0YXRpb25zJyk7XG5leHBvcnRzLnBpY2tSYW5kb20gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L3BpY2tSYW5kb20nKTtcbmV4cG9ydHMucmFuZG9tID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9yYW5kb20nKTtcbmV4cG9ydHMucmFuZG9tSW50ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9yYW5kb21JbnQnKTtcblxuLy8gZnVuY3Rpb25zIC0gc3RhdGlzdGljc1xuZXhwb3J0cy5tYXggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWF4Jyk7XG5leHBvcnRzLm1lYW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWVhbicpO1xuZXhwb3J0cy5tZWRpYW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWVkaWFuJyk7XG5leHBvcnRzLm1pbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9taW4nKTtcbmV4cG9ydHMucHJvZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9wcm9kJyk7XG5leHBvcnRzLnN0ZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9zdGQnKTtcbmV4cG9ydHMuc3VtID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9zdGF0aXN0aWNzL3N1bScpO1xuZXhwb3J0c1sndmFyJ10gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3MvdmFyJyk7XG5cbi8vIGZ1bmN0aW9ucyAtIHRyaWdvbm9tZXRyeVxuZXhwb3J0cy5hY29zID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNvcycpO1xuZXhwb3J0cy5hc2luID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXNpbicpO1xuZXhwb3J0cy5hdGFuID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbicpO1xuZXhwb3J0cy5hdGFuMiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2F0YW4yJyk7XG5leHBvcnRzLmNvcyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NvcycpO1xuZXhwb3J0cy5jb3NoID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY29zaCcpO1xuZXhwb3J0cy5jb3QgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3QnKTtcbmV4cG9ydHMuY290aCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NvdGgnKTtcbmV4cG9ydHMuY3NjID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY3NjJyk7XG5leHBvcnRzLmNzY2ggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jc2NoJyk7XG5leHBvcnRzLnNlYyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3NlYycpO1xuZXhwb3J0cy5zZWNoID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2VjaCcpO1xuZXhwb3J0cy5zaW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zaW4nKTtcbmV4cG9ydHMuc2luaCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3NpbmgnKTtcbmV4cG9ydHMudGFuID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvdGFuJyk7XG5leHBvcnRzLnRhbmggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS90YW5oJyk7XG5cbi8vIGZ1bmN0aW9ucyAtIHVuaXRzXG5leHBvcnRzLnRvID0gcmVxdWlyZSgnLi9mdW5jdGlvbi91bml0cy90bycpO1xuXG4vLyBmdW5jdGlvbnMgLSB1dGlsc1xuZXhwb3J0cy5jbG9uZSA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2Nsb25lJyk7XG5leHBvcnRzLm1hcCA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL21hcCcpO1xuZXhwb3J0cy5maWx0ZXIgPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi91dGlscy9maWx0ZXInKTtcbmV4cG9ydHMuZm9yRWFjaCA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2ZvckVhY2gnKTtcbmV4cG9ydHMuZm9ybWF0ID0gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdXRpbHMvZm9ybWF0Jyk7XG4vLyBleHBvcnRzLnByaW50ID0gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdXRpbHMvcHJpbnQnKTsgLy8gVE9ETzogYWRkIGRvY3VtZW50YXRpb24gZm9yIHByaW50IGFzIHNvb24gYXMgdGhlIHBhcnNlciBzdXBwb3J0cyBvYmplY3RzLlxuZXhwb3J0c1snaW1wb3J0J10gPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi91dGlscy9pbXBvcnQnKTtcbmV4cG9ydHMuc29ydCA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL3NvcnQnKTtcbmV4cG9ydHNbJ3R5cGVvZiddID0gIHJlcXVpcmUoJy4vZnVuY3Rpb24vdXRpbHMvdHlwZW9mJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgsIGNvbmZpZykge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcbiAgICAgIF9wYXJzZSA9IHJlcXVpcmUoJy4uLy4uL2V4cHJlc3Npb24vcGFyc2UnKSxcblxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nLFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuZCBjb21waWxlIGFuIGV4cHJlc3Npb24uXG4gICAqIFJldHVybnMgYSBhbiBvYmplY3Qgd2l0aCBhIGZ1bmN0aW9uIGBldmFsKFtzY29wZV0pYCB0byBldmFsdWF0ZSB0aGVcbiAgICogY29tcGlsZWQgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5jb21waWxlKGV4cHIpICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIG9uZSBub2RlXG4gICAqICAgICBtYXRoLmNvbXBpbGUoW2V4cHIxLCBleHByMiwgZXhwcjMsIC4uLl0pIC8vIHJldHVybnMgYW4gYXJyYXkgd2l0aCBub2Rlc1xuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIHZhciBjb2RlID0gbWF0aC5jb21waWxlKCdzcXJ0KDNeMiArIDReMiknKTtcbiAgICogICAgIGNvZGUuZXZhbCgpOyAvLyA1XG4gICAqXG4gICAqICAgICB2YXIgc2NvcGUgPSB7YTogMywgYjogNH1cbiAgICogICAgIHZhciBjb2RlID0gbWF0aC5jb21waWxlKCdhICogYicpOyAvLyAxMlxuICAgKiAgICAgY29kZS5ldmFsKHNjb3BlKTsgLy8gMTJcbiAgICogICAgIHNjb3BlLmEgPSA1O1xuICAgKiAgICAgY29kZS5ldmFsKHNjb3BlKTsgLy8gMjBcbiAgICpcbiAgICogICAgIHZhciBub2RlcyA9IG1hdGguY29tcGlsZShbJ2EgPSAzJywgJ2IgPSA0JywgJ2EgKiBiJ10pO1xuICAgKiAgICAgbm9kZXNbMl0uZXZhbCgpOyAvLyAxMlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgcGFyc2UsIGV2YWxcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBTdHJpbmdbXSB8IE1hdHJpeH0gZXhwclxuICAgKiAgICAgICAgICAgIFRoZSBleHByZXNzaW9uIHRvIGJlIGNvbXBpbGVkXG4gICAqIEByZXR1cm4ge3tldmFsOiBGdW5jdGlvbn0gfCBBcnJheS48e2V2YWw6IEZ1bmN0aW9ufT59IGNvZGVcbiAgICogICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCB0aGUgY29tcGlsZWQgZXhwcmVzc2lvblxuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICovXG4gIG1hdGguY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUgKGV4cHIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignY29tcGlsZScsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyhleHByKSkge1xuICAgICAgLy8gZXZhbHVhdGUgYSBzaW5nbGUgZXhwcmVzc2lvblxuICAgICAgcmV0dXJuIF9wYXJzZShleHByKS5jb21waWxlKG1hdGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0NvbGxlY3Rpb24oZXhwcikpIHtcbiAgICAgIC8vIGV2YWx1YXRlIGFuIGFycmF5IG9yIG1hdHJpeCB3aXRoIGV4cHJlc3Npb25zXG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKGV4cHIsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBfcGFyc2UoZWxlbSkuY29tcGlsZShtYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIG9vcHNcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZywgYXJyYXksIG9yIG1hdHJpeCBleHBlY3RlZCcpO1xuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcbiAgICAgIF9wYXJzZSA9IHJlcXVpcmUoJy4uLy4uL2V4cHJlc3Npb24vcGFyc2UnKSxcblxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nLFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIGFuIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGguZXZhbChleHByKVxuICAgKiAgICAgbWF0aC5ldmFsKGV4cHIsIHNjb3BlKVxuICAgKiAgICAgbWF0aC5ldmFsKFtleHByMSwgZXhwcjIsIGV4cHIzLCAuLi5dKVxuICAgKiAgICAgbWF0aC5ldmFsKFtleHByMSwgZXhwcjIsIGV4cHIzLCAuLi5dLCBzY29wZSlcbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICAgIG1hdGguZXZhbCgnKDIrMykvNCcpOyAgICAgICAgICAgICAgICAvLyAxLjI1XG4gICAqICAgICBtYXRoLmV2YWwoJ3NxcnQoM14yICsgNF4yKScpOyAgICAgICAgLy8gNVxuICAgKiAgICAgbWF0aC5ldmFsKCdzcXJ0KC00KScpOyAgICAgICAgICAgICAgIC8vIDJpXG4gICAqICAgICBtYXRoLmV2YWwoWydhPTMnLCAnYj00JywgJ2EqYiddKTssICAgLy8gWzMsIDQsIDEyXVxuICAgKlxuICAgKiAgICAgdmFyIHNjb3BlID0ge2E6MywgYjo0fTtcbiAgICogICAgIG1hdGguZXZhbCgnYSAqIGInLCBzY29wZSk7ICAgICAgICAgICAvLyAxMlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgcGFyc2UsIGNvbXBpbGVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBTdHJpbmdbXSB8IE1hdHJpeH0gZXhwciAgIFRoZSBleHByZXNzaW9uIHRvIGJlIGV2YWx1YXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAgICAgICAgICAgICAgICAgICAgU2NvcGUgdG8gcmVhZC93cml0ZSB2YXJpYWJsZXNcbiAgICogQHJldHVybiB7Kn0gVGhlIHJlc3VsdCBvZiB0aGUgZXhwcmVzc2lvblxuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICovXG4gIG1hdGguZXZhbCA9IGZ1bmN0aW9uIF9ldmFsIChleHByLCBzY29wZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEgJiYgYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignZXZhbCcsIGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpO1xuICAgIH1cblxuICAgIC8vIGluc3RhbnRpYXRlIGEgc2NvcGVcbiAgICBzY29wZSA9IHNjb3BlIHx8IHt9O1xuXG4gICAgaWYgKGlzU3RyaW5nKGV4cHIpKSB7XG4gICAgICAvLyBldmFsdWF0ZSBhIHNpbmdsZSBleHByZXNzaW9uXG4gICAgICByZXR1cm4gX3BhcnNlKGV4cHIpXG4gICAgICAgICAgLmNvbXBpbGUobWF0aClcbiAgICAgICAgICAuZXZhbChzY29wZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ29sbGVjdGlvbihleHByKSkge1xuICAgICAgLy8gZXZhbHVhdGUgYW4gYXJyYXkgb3IgbWF0cml4IHdpdGggZXhwcmVzc2lvbnNcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAoZXhwciwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIF9wYXJzZShlbGVtKVxuICAgICAgICAgICAgLmNvbXBpbGUobWF0aCkuZXZhbChzY29wZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBvb3BzXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdHJpbmcsIGFycmF5LCBvciBtYXRyaXggZXhwZWN0ZWQnKTtcbiAgICB9XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciBIZWxwID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9IZWxwJyk7XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGhlbHAgb24gYSBmdW5jdGlvbiBvciBkYXRhIHR5cGUuXG4gICAqIEhlbHAgZmlsZXMgYXJlIHJldHJpZXZlZCBmcm9tIHRoZSBkb2N1bWVudGF0aW9uIGluIG1hdGguZXhwcmVzc2lvbi5kb2NzLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguaGVscChzZWFyY2gpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBjb25zb2xlLmxvZyhtYXRoLmhlbHAoJ3NpbicpLnRvU3RyaW5nKCkpO1xuICAgKiAgICBjb25zb2xlLmxvZyhtYXRoLmhlbHAobWF0aC5hZGQpLnRvU3RyaW5nKCkpO1xuICAgKiAgICBjb25zb2xlLmxvZyhtYXRoLmhlbHAobWF0aC5hZGQpLnRvSlNPTigpKTtcbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbiB8IHN0cmluZyB8IE9iamVjdH0gc2VhcmNoICAgQSBmdW5jdGlvbiBvciBmdW5jdGlvbiBuYW1lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB3aGljaCB0byBnZXQgaGVscFxuICAgKiBAcmV0dXJuIHtIZWxwfSBBIGhlbHAgb2JqZWN0XG4gICAqL1xuICBtYXRoLmhlbHAgPSBmdW5jdGlvbiBoZWxwKHNlYXJjaCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiBmdW5jdGlvbiBoZWxwICcgK1xuICAgICAgICAgICcoJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByb3ZpZGVkLCAxIGV4cGVjdGVkKScpO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gbnVsbDtcbiAgICBpZiAoKHNlYXJjaCBpbnN0YW5jZW9mIFN0cmluZykgfHwgKHR5cGVvZihzZWFyY2gpID09PSAnc3RyaW5nJykpIHtcbiAgICAgIHRleHQgPSBzZWFyY2g7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHByb3A7XG4gICAgICBmb3IgKHByb3AgaW4gbWF0aCkge1xuICAgICAgICAvLyBzZWFyY2ggaW4gZnVuY3Rpb25zIGFuZCBjb25zdGFudHNcbiAgICAgICAgaWYgKG1hdGguaGFzT3duUHJvcGVydHkocHJvcCkgJiYgKHNlYXJjaCA9PT0gbWF0aFtwcm9wXSkpIHtcbiAgICAgICAgICB0ZXh0ID0gcHJvcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBUT0RPOiBpbXBsZW1lbnQgaGVscCBmb3IgZGF0YSB0eXBlc1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIC8vIHNlYXJjaCBkYXRhIHR5cGVcbiAgICAgICAgZm9yIChwcm9wIGluIG1hdGgudHlwZSkge1xuICAgICAgICAgIGlmIChtYXRoLnR5cGUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2ggPT09IG1hdGgudHlwZVtwcm9wXSkge1xuICAgICAgICAgICAgICB0ZXh0ID0gcHJvcDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAqL1xuICAgIH1cblxuICAgIHZhciBkb2MgPSBtYXRoLmV4cHJlc3Npb24uZG9jc1t0ZXh0XTtcbiAgICBpZiAoIXRleHQgfHwgIWRvYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkb2N1bWVudGF0aW9uIGZvdW5kIG9uIFwiJyArIHRleHQgKyAnXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIZWxwKG1hdGgsIGRvYyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoLCBjb25maWcpIHtcbiAgdmFyIF9wYXJzZSA9IHJlcXVpcmUoJy4uLy4uL2V4cHJlc3Npb24vcGFyc2UnKTtcblxuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbi4gUmV0dXJucyBhIG5vZGUgdHJlZSwgd2hpY2ggY2FuIGJlIGV2YWx1YXRlZCBieVxuICAgKiBpbnZva2luZyBub2RlLmV2YWwoKTtcbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgcGFyc2UoZXhwcilcbiAgICogICAgIHBhcnNlKGV4cHIsIG9wdGlvbnMpXG4gICAqICAgICBwYXJzZShbZXhwcjEsIGV4cHIyLCBleHByMywgLi4uXSlcbiAgICogICAgIHBhcnNlKFtleHByMSwgZXhwcjIsIGV4cHIzLCAuLi5dLCBvcHRpb25zKVxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgdmFyIG5vZGUgPSBwYXJzZSgnc3FydCgzXjIgKyA0XjIpJyk7XG4gICAqICAgICBub2RlLmNvbXBpbGUobWF0aCkuZXZhbCgpOyAvLyA1XG4gICAqXG4gICAqICAgICB2YXIgc2NvcGUgPSB7YTozLCBiOjR9XG4gICAqICAgICB2YXIgbm9kZSA9IHBhcnNlKCdhICogYicpOyAvLyAxMlxuICAgKiAgICAgdmFyIGNvZGUgPSBub2RlLmNvbXBpbGUobWF0aCk7XG4gICAqICAgICBjb2RlLmV2YWwoc2NvcGUpOyAvLyAxMlxuICAgKiAgICAgc2NvcGUuYSA9IDU7XG4gICAqICAgICBjb2RlLmV2YWwoc2NvcGUpOyAvLyAyMFxuICAgKlxuICAgKiAgICAgdmFyIG5vZGVzID0gbWF0aC5wYXJzZShbJ2EgPSAzJywgJ2IgPSA0JywgJ2EgKiBiJ10pO1xuICAgKiAgICAgbm9kZXNbMl0uY29tcGlsZShtYXRoKS5ldmFsKCk7IC8vIDEyXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgU3RyaW5nW10gfCBNYXRyaXh9IGV4cHIgICAgICAgICAgRXhwcmVzc2lvbiB0byBiZSBwYXJzZWRcbiAgICogQHBhcmFtIHt7bm9kZXM6IE9iamVjdDxTdHJpbmcsIE5vZGU+fX0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGBub2Rlc2AgYSBzZXQgb2YgY3VzdG9tIG5vZGVzXG4gICAqIEByZXR1cm4ge05vZGUgfCBOb2RlW119IG5vZGVcbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqL1xuICBtYXRoLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGV4cHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX3BhcnNlLmFwcGx5KF9wYXJzZSwgYXJndW1lbnRzKTtcbiAgfVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxuICAgICAgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGFic29sdXRlIHZhbHVlIG9mIGEgbnVtYmVyLiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpc1xuICAgKiBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYWJzKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFicygzLjUpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAzLjVcbiAgICogICAgbWF0aC5hYnMoLTQuMik7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgNC4yXG4gICAqXG4gICAqICAgIG1hdGguYWJzKFszLCAtNSwgLTEsIDAsIDJdKTsgIC8vIHJldHVybnMgQXJyYXkgWzMsIDUsIDEsIDAsIDJdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBzaWduXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4XG4gICAqICAgICAgICAgICAgQSBudW1iZXIgb3IgbWF0cml4IGZvciB3aGljaCB0byBnZXQgdGhlIGFic29sdXRlIHZhbHVlXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH1cbiAgICogICAgICAgICAgICBBYnNvbHV0ZSB2YWx1ZSBvZiBgeGBcbiAgICovXG4gIG1hdGguYWJzID0gZnVuY3Rpb24gYWJzKHgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignYWJzJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoeCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydCh4LnJlICogeC5yZSArIHguaW0gKiB4LmltKTtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuIHguYWJzKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCBhYnMpO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHgpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdhYnMnLCBtYXRoWyd0eXBlb2YnXSh4KSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxuICAgICAgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKSxcbiAgICAgIFVuaXQgPSByZXF1aXJlKCcuLi8uLi90eXBlL1VuaXQnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc1VuaXQgPSBVbml0LmlzVW5pdCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBBZGQgdHdvIHZhbHVlcywgYHggKyB5YC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmFkZCh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hZGQoMiwgMyk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgNVxuICAgKlxuICAgKiAgICB2YXIgYSA9IG1hdGguY29tcGxleCgyLCAzKTtcbiAgICogICAgdmFyIGIgPSBtYXRoLmNvbXBsZXgoLTQsIDEpO1xuICAgKiAgICBtYXRoLmFkZChhLCBiKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggLTIgKyA0aVxuICAgKlxuICAgKiAgICBtYXRoLmFkZChbMSwgMiwgM10sIDQpOyAgICAgICAvLyByZXR1cm5zIEFycmF5IFs1LCA2LCA3XVxuICAgKlxuICAgKiAgICB2YXIgYyA9IG1hdGgudW5pdCgnNSBjbScpO1xuICAgKiAgICB2YXIgZCA9IG1hdGgudW5pdCgnMi4xIG1tJyk7XG4gICAqICAgIG1hdGguYWRkKGMsIGQpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgVW5pdCA1Mi4xIG1tXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBzdWJ0cmFjdFxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBTdHJpbmcgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggRmlyc3QgdmFsdWUgdG8gYWRkXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IFN0cmluZyB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geSBTZWNvbmQgdmFsdWUgdG8gYWRkXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgU3RyaW5nIHwgQXJyYXkgfCBNYXRyaXh9IFN1bSBvZiBgeGAgYW5kIGB5YFxuICAgKi9cbiAgbWF0aC5hZGQgPSBmdW5jdGlvbiBhZGQoeCwgeSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdhZGQnLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICAvLyBudW1iZXIgKyBudW1iZXJcbiAgICAgICAgcmV0dXJuIHggKyB5O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNDb21wbGV4KHkpKSB7XG4gICAgICAgIC8vIG51bWJlciArIGNvbXBsZXhcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgeCArIHkucmUsXG4gICAgICAgICAgICB5LmltXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNDb21wbGV4KHgpKSB7XG4gICAgICBpZiAoaXNDb21wbGV4KHkpKSB7XG4gICAgICAgIC8vIGNvbXBsZXggKyBjb21wbGV4XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgIHgucmUgKyB5LnJlLFxuICAgICAgICAgICAgeC5pbSArIHkuaW1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIC8vIGNvbXBsZXggKyBudW1iZXJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgeC5yZSArIHksXG4gICAgICAgICAgICB4LmltXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNVbml0KHgpKSB7XG4gICAgICBpZiAoaXNVbml0KHkpKSB7XG4gICAgICAgIGlmICh4LnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciB4IGNvbnRhaW5zIGEgdW5pdCB3aXRoIHVuZGVmaW5lZCB2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyIHkgY29udGFpbnMgYSB1bml0IHdpdGggdW5kZWZpbmVkIHZhbHVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXguZXF1YWxCYXNlKHkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbml0cyBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXMgPSB4LmNsb25lKCk7XG4gICAgICAgIHJlcy52YWx1ZSArPSB5LnZhbHVlO1xuICAgICAgICByZXMuZml4UHJlZml4ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHRvIGJpZyBudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICB5ID0gQmlnTnVtYmVyLmNvbnZlcnQoeSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeSkgfHwgeSA9PT0gbnVsbCkge1xuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcih5ID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoeSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xuICAgICAgfVxuXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gYWRkKHgudG9OdW1iZXIoKSwgeSk7XG4gICAgfVxuICAgIGlmICh5IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyB0cnkgdG8gY29udmVydCB0byBiaWcgbnVtYmVyXG4gICAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgeCA9IEJpZ051bWJlci5jb252ZXJ0KHgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHgpIHx8IHggPT09IG51bGwpIHtcbiAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIoeCA/IDEgOiAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KVxuICAgICAgfVxuXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gYWRkKHgsIHkudG9OdW1iZXIoKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSB8fCBpc0NvbGxlY3Rpb24oeSkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAyKHgsIHksIGFkZCk7XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKHgpIHx8IGlzU3RyaW5nKHkpKSB7XG4gICAgICByZXR1cm4geCArIHk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYWRkKCt4LCB5KTtcbiAgICB9XG4gICAgaWYgKGlzQm9vbGVhbih5KSB8fCB5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYWRkKHgsICt5KTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignYWRkJywgbWF0aFsndHlwZW9mJ10oeCksIG1hdGhbJ3R5cGVvZiddKHkpKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb2xsZWN0aW9uID1jb2xsZWN0aW9uLmlzQ29sbGVjdGlvbixcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4O1xuXG4gIC8qKlxuICAgKiBSb3VuZCBhIHZhbHVlIHRvd2FyZHMgcGx1cyBpbmZpbml0eVxuICAgKiBJZiBgeGAgaXMgY29tcGxleCwgYm90aCByZWFsIGFuZCBpbWFnaW5hcnkgcGFydCBhcmUgcm91bmRlZCB0b3dhcmRzIHBsdXMgaW5maW5pdHkuXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5jZWlsKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNlaWwoMy4yKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciA0XG4gICAqICAgIG1hdGguY2VpbCgzLjgpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDRcbiAgICogICAgbWF0aC5jZWlsKC00LjIpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgLTRcbiAgICogICAgbWF0aC5jZWlsKC00LjcpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgLTRcbiAgICpcbiAgICogICAgdmFyIGMgPSBtYXRoLmNvbXBsZXgoMy4yLCAtMi43KTtcbiAgICogICAgbWF0aC5jZWlsKGMpOyAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBDb21wbGV4IDQgLSAyaVxuICAgKlxuICAgKiAgICBtYXRoLmNlaWwoWzMuMiwgMy44LCAtNC43XSk7ICAvLyByZXR1cm5zIEFycmF5IFs0LCA0LCAtNF1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGZsb29yLCBmaXgsIHJvdW5kXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4ICBOdW1iZXIgdG8gYmUgcm91bmRlZFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFJvdW5kZWQgdmFsdWVcbiAgICovXG4gIG1hdGguY2VpbCA9IGZ1bmN0aW9uIGNlaWwoeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdjZWlsJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHgpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleCAoXG4gICAgICAgICAgTWF0aC5jZWlsKHgucmUpLFxuICAgICAgICAgIE1hdGguY2VpbCh4LmltKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuIHguY2VpbCgpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAoeCwgY2VpbCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHgpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdjZWlsJywgbWF0aFsndHlwZW9mJ10oeCkpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBjdWJlIG9mIGEgdmFsdWUsIGB4ICogeCAqIHhgLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguY3ViZSh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5jdWJlKDIpOyAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDhcbiAgICogICAgbWF0aC5wb3coMiwgMyk7ICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDhcbiAgICogICAgbWF0aC5jdWJlKDQpOyAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDY0XG4gICAqICAgIDQgKiA0ICogNDsgICAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciA2NFxuICAgKlxuICAgKiAgICBtYXRoLmN1YmUoWzEsIDIsIDMsIDRdKTsgLy8gcmV0dXJucyBBcnJheSBbMSwgOCwgMjcsIDY0XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbXVsdGlwbHksIHNxdWFyZSwgcG93XG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4ICBOdW1iZXIgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY3ViZVxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEN1YmUgb2YgeFxuICAgKi9cbiAgbWF0aC5jdWJlID0gZnVuY3Rpb24gY3ViZSh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2N1YmUnLCBhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgIHJldHVybiB4ICogeCAqIHg7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgcmV0dXJuIG1hdGgubXVsdGlwbHkobWF0aC5tdWx0aXBseSh4LCB4KSwgeCk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIHJldHVybiB4LnRpbWVzKHgpLnRpbWVzKHgpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAoeCwgY3ViZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gY3ViZSgreCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2N1YmUnLCBtYXRoWyd0eXBlb2YnXSh4KSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpLFxuICAgICAgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxuICAgICAgaXNVbml0ID0gVW5pdC5pc1VuaXQsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogRGl2aWRlIHR3byB2YWx1ZXMsIGB4IC8geWAuXG4gICAqIFRvIGRpdmlkZSBtYXRyaWNlcywgYHhgIGlzIG11bHRpcGxpZWQgd2l0aCB0aGUgaW52ZXJzZSBvZiBgeWA6IGB4ICogaW52KHkpYC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmRpdmlkZSh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5kaXZpZGUoMiwgMyk7ICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgMC42NjY2NjY2NjY2NjY2NjY2XG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC5jb21wbGV4KDUsIDE0KTtcbiAgICogICAgdmFyIGIgPSBtYXRoLmNvbXBsZXgoNCwgMSk7XG4gICAqICAgIG1hdGguZGl2aWRlKGEsIGIpOyAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAyICsgM2lcbiAgICpcbiAgICogICAgdmFyIGMgPSBbWzcsIC02XSwgWzEzLCAtNF1dO1xuICAgKiAgICB2YXIgZCA9IFtbMSwgMl0sIFs0LCAzXV07XG4gICAqICAgIG1hdGguZGl2aWRlKGMsIGQpOyAgICAgICAgICAgIC8vIHJldHVybnMgQXJyYXkgW1stOSwgNF0sIFstMTEsIDZdXVxuICAgKlxuICAgKiAgICB2YXIgZSA9IG1hdGgudW5pdCgnMTgga20nKTtcbiAgICogICAgbWF0aC5kaXZpZGUoZSwgNC41KTsgICAgICAgICAgLy8gcmV0dXJucyBVbml0IDQga21cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIG11bHRpcGx5XG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCAgIE51bWVyYXRvclxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geSAgICAgICAgICBEZW5vbWluYXRvclxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSAgICAgICAgICAgICAgICAgICAgICBRdW90aWVudCwgYHggLyB5YFxuICAgKi9cbiAgbWF0aC5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoeCwgeSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdkaXZpZGUnLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICAvLyBudW1iZXIgLyBudW1iZXJcbiAgICAgICAgcmV0dXJuIHggLyB5O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNDb21wbGV4KHkpKSB7XG4gICAgICAgIC8vIG51bWJlciAvIGNvbXBsZXhcbiAgICAgICAgcmV0dXJuIF9kaXZpZGVDb21wbGV4KG5ldyBDb21wbGV4KHgsIDApLCB5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNDb21wbGV4KHgpKSB7XG4gICAgICBpZiAoaXNDb21wbGV4KHkpKSB7XG4gICAgICAgIC8vIGNvbXBsZXggLyBjb21wbGV4XG4gICAgICAgIHJldHVybiBfZGl2aWRlQ29tcGxleCh4LCB5KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIC8vIGNvbXBsZXggLyBudW1iZXJcbiAgICAgICAgcmV0dXJuIF9kaXZpZGVDb21wbGV4KHgsIG5ldyBDb21wbGV4KHksIDApKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdG8gYmlnIG51bWJlclxuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIHkgPSBCaWdOdW1iZXIuY29udmVydCh5KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbih5KSB8fCB5ID09PSBudWxsKSB7XG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHkgPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB4LmRpdih5KTtcbiAgICAgIH1cblxuICAgICAgLy8gZG93bmdyYWRlIHRvIE51bWJlclxuICAgICAgcmV0dXJuIGRpdmlkZSh4LnRvTnVtYmVyKCksIHkpO1xuICAgIH1cbiAgICBpZiAoeSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdG8gYmlnIG51bWJlclxuICAgICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICAgIHggPSBCaWdOdW1iZXIuY29udmVydCh4KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHggPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB4LmRpdih5KVxuICAgICAgfVxuXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gZGl2aWRlKHgsIHkudG9OdW1iZXIoKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5pdCh4KSkge1xuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIHZhciByZXMgPSB4LmNsb25lKCk7XG4gICAgICAgIHJlcy52YWx1ZSAvPSB5O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkpIHtcbiAgICAgIGlmIChpc0NvbGxlY3Rpb24oeSkpIHtcbiAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IG1hdHJpeCByaWdodCBkaXZpc2lvbiB1c2luZyBwc2V1ZG8gaW52ZXJzZVxuICAgICAgICAvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5ubC9oZWxwL21hdGxhYi9yZWYvbXJkaXZpZGUuaHRtbFxuICAgICAgICAvLyBodHRwOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvb2N0YXZlL2RvYy9pbnRlcnByZXRlci9Bcml0aG1ldGljLU9wcy5odG1sXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTIyNjM5MzIvaG93LWRvZXMtZ251LW9jdGF2ZS1tYXRyaXgtZGl2aXNpb24td29yay1nZXR0aW5nLXVuZXhwZWN0ZWQtYmVoYXZpb3VyXG4gICAgICAgIHJldHVybiBtYXRoLm11bHRpcGx5KHgsIG1hdGguaW52KHkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBtYXRyaXggLyBzY2FsYXJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcDIoeCwgeSwgZGl2aWRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHkpKSB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgbWF0cml4IHJpZ2h0IGRpdmlzaW9uIHVzaW5nIHBzZXVkbyBpbnZlcnNlXG4gICAgICByZXR1cm4gbWF0aC5tdWx0aXBseSh4LCBtYXRoLmludih5KSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGl2aWRlKCt4LCB5KTtcbiAgICB9XG4gICAgaWYgKGlzQm9vbGVhbih5KSB8fCB5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGl2aWRlKHgsICt5KTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignZGl2aWRlJywgbWF0aFsndHlwZW9mJ10oeCksIG1hdGhbJ3R5cGVvZiddKHkpKTtcbiAgfTtcblxuICAvKipcbiAgICogRGl2aWRlIHR3byBjb21wbGV4IG51bWJlcnMuIHggLyB5IG9yIGRpdmlkZSh4LCB5KVxuICAgKiBAcGFyYW0ge0NvbXBsZXh9IHhcbiAgICogQHBhcmFtIHtDb21wbGV4fSB5XG4gICAqIEByZXR1cm4ge0NvbXBsZXh9IHJlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2RpdmlkZUNvbXBsZXggKHgsIHkpIHtcbiAgICB2YXIgZGVuID0geS5yZSAqIHkucmUgKyB5LmltICogeS5pbTtcbiAgICBpZiAoZGVuICE9IDApIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAoeC5yZSAqIHkucmUgKyB4LmltICogeS5pbSkgLyBkZW4sXG4gICAgICAgICAgKHguaW0gKiB5LnJlIC0geC5yZSAqIHkuaW0pIC8gZGVuXG4gICAgICApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGJvdGggeS5yZSBhbmQgeS5pbSBhcmUgemVyb1xuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICh4LnJlICE9IDApID8gKHgucmUgLyAwKSA6IDAsXG4gICAgICAgICAgKHguaW0gIT0gMCkgPyAoeC5pbSAvIDApIDogMFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKTtcblxuICAvKipcbiAgICogRGl2aWRlIHR3byBtYXRyaWNlcyBlbGVtZW50IHdpc2UuIFRoZSBmdW5jdGlvbiBhY2NlcHRzIGJvdGggbWF0cmljZXMgYW5kXG4gICAqIHNjYWxhciB2YWx1ZXMuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5kb3REaXZpZGUoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZG90RGl2aWRlKDIsIDQpOyAgIC8vIHJldHVybnMgMC41XG4gICAqXG4gICAqICAgIGEgPSBbWzksIDVdLCBbNiwgMV1dO1xuICAgKiAgICBiID0gW1szLCAyXSwgWzUsIDJdXTtcbiAgICpcbiAgICogICAgbWF0aC5kb3REaXZpZGUoYSwgYik7ICAgLy8gcmV0dXJucyBbWzMsIDIuNV0sIFsxLjIsIDAuNV1dXG4gICAqICAgIG1hdGguZGl2aWRlKGEsIGIpOyAgICAgIC8vIHJldHVybnMgW1sxLjc1LCAwLjc1XSwgWy0xLjc1LCAyLjI1XV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGRpdmlkZSwgbXVsdGlwbHksIGRvdE11bHRpcGx5XG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCBOdW1lcmF0b3JcbiAgICogQHBhcmFtICB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB5IERlbm9taW5hdG9yXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBRdW90aWVudCwgYHggLi8geWBcbiAgICovXG4gIG1hdGguZG90RGl2aWRlID0gZnVuY3Rpb24gZG90RGl2aWRlKHgsIHkpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignZG90RGl2aWRlJywgYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcDIoeCwgeSwgbWF0aC5kaXZpZGUpO1xuICB9O1xuXG4gIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAwLjIzLjAsIGNsZWFuIHVwIHNvbWUgZGF5XG4gIG1hdGguZWRpdmlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGVkaXZpZGUgaXMgcmVuYW1lZCB0byBkb3REaXZpZGUnKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKTtcblxuICAvKipcbiAgICogTXVsdGlwbHkgdHdvIG1hdHJpY2VzIGVsZW1lbnQgd2lzZS4gVGhlIGZ1bmN0aW9uIGFjY2VwdHMgYm90aCBtYXRyaWNlcyBhbmRcbiAgICogc2NhbGFyIHZhbHVlcy5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmRvdE11bHRpcGx5KHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmRvdE11bHRpcGx5KDIsIDQpOyAvLyByZXR1cm5zIDhcbiAgICpcbiAgICogICAgYSA9IFtbOSwgNV0sIFs2LCAxXV07XG4gICAqICAgIGIgPSBbWzMsIDJdLCBbNSwgMl1dO1xuICAgKlxuICAgKiAgICBtYXRoLmRvdE11bHRpcGx5KGEsIGIpOyAvLyByZXR1cm5zIFtbMjcsIDEwXSwgWzMwLCAyXV1cbiAgICogICAgbWF0aC5tdWx0aXBseShhLCBiKTsgICAgLy8gcmV0dXJucyBbWzUyLCAyOF0sIFsyMywgMTRdXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbXVsdGlwbHksIGRpdmlkZSwgZG90RGl2aWRlXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCBMZWZ0IGhhbmQgdmFsdWVcbiAgICogQHBhcmFtICB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB5IFJpZ2h0IGhhbmQgdmFsdWVcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0gICAgICAgICAgICAgICAgICAgIE11bHRpcGxpY2F0aW9uIG9mIGB4YCBhbmQgYHlgXG4gICAqL1xuICBtYXRoLmRvdE11bHRpcGx5ID0gZnVuY3Rpb24gZG90TXVsdGlwbHkoeCwgeSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdkb3RNdWx0aXBseScsIGFyZ3VtZW50cy5sZW5ndGgsIDIpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAyKHgsIHksIG1hdGgubXVsdGlwbHkpO1xuICB9O1xuXG4gIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAwLjIzLjAsIGNsZWFuIHVwIHNvbWUgZGF5XG4gIG1hdGguZW11bHRpcGx5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gZW11bHRpcGx5IGlzIHJlbmFtZWQgdG8gZG90TXVsdGlwbHknKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcG93ZXIgb2YgeCB0byB5IGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmRvdFBvdyh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5kb3RQb3coMiwgMyk7ICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgOFxuICAgKlxuICAgKiAgICB2YXIgYSA9IFtbMSwgMl0sIFs0LCAzXV07XG4gICAqICAgIG1hdGguZG90UG93KGEsIDIpOyAgICAgICAgICAgIC8vIHJldHVybnMgQXJyYXkgW1sxLCA0XSwgWzE2LCA5XV1cbiAgICogICAgbWF0aC5wb3coYSwgMik7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBBcnJheSBbWzksIDhdLCBbMTYsIDE3XV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHBvdywgc3FydCwgbXVsdGlwbHlcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4ICBUaGUgYmFzZVxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHkgIFRoZSBleHBvbmVudFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSAgICAgICAgICAgICAgICAgICAgIFRoZSB2YWx1ZSBvZiBgeGAgdG8gdGhlIHBvd2VyIGB5YFxuICAgKi9cbiAgbWF0aC5kb3RQb3cgPSBmdW5jdGlvbiBkb3RQb3coeCwgeSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdkb3RQb3cnLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwMih4LCB5LCBtYXRoLnBvdyk7XG4gIH07XG5cbiAgLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDAuMjMuMCwgY2xlYW4gdXAgc29tZSBkYXlcbiAgbWF0aC5lcG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gZXBvdyBpcyByZW5hbWVkIHRvIGRvdFBvdycpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxuICAgICAgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cG9uZW50IG9mIGEgdmFsdWUuXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5leHAoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZXhwKDIpOyAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDcuMzg5MDU2MDk4OTMwNjQ5NVxuICAgKiAgICBtYXRoLnBvdyhtYXRoLmUsIDIpOyAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciA3LjM4OTA1NjA5ODkzMDY0OTVcbiAgICogICAgbWF0aC5sb2cobWF0aC5leHAoMikpOyAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgMlxuICAgKlxuICAgKiAgICBtYXRoLmV4cChbMSwgMiwgM10pO1xuICAgKiAgICAvLyByZXR1cm5zIEFycmF5IFtcbiAgICogICAgLy8gICAyLjcxODI4MTgyODQ1OTA0NSxcbiAgICogICAgLy8gICA3LjM4OTA1NjA5ODkzMDY0OTUsXG4gICAqICAgIC8vICAgMjAuMDg1NTM2OTIzMTg3NjY4XG4gICAqICAgIC8vIF1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGxvZywgcG93XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggIEEgbnVtYmVyIG9yIG1hdHJpeCB0byBleHBvbmVudGlhdGVcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBFeHBvbmVudCBvZiBgeGBcbiAgICovXG4gIG1hdGguZXhwID0gZnVuY3Rpb24gZXhwICh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2V4cCcsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgcmV0dXJuIE1hdGguZXhwKHgpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIHZhciByID0gTWF0aC5leHAoeC5yZSk7XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgciAqIE1hdGguY29zKHguaW0pLFxuICAgICAgICAgIHIgKiBNYXRoLnNpbih4LmltKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuIHguZXhwKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCBleHApO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE1hdGguZXhwKHgpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdleHAnLCBtYXRoWyd0eXBlb2YnXSh4KSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIFJvdW5kIGEgdmFsdWUgdG93YXJkcyB6ZXJvLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZml4KHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmZpeCgzLjIpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAzXG4gICAqICAgIG1hdGguZml4KDMuOCk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDNcbiAgICogICAgbWF0aC5maXgoLTQuMik7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgLTRcbiAgICogICAgbWF0aC5maXgoLTQuNyk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgLTRcbiAgICpcbiAgICogICAgdmFyIGMgPSBtYXRoLmNvbXBsZXgoMy4yLCAtMi43KTtcbiAgICogICAgbWF0aC5maXgoYyk7ICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBDb21wbGV4IDMgLSAyaVxuICAgKlxuICAgKiAgICBtYXRoLmZpeChbMy4yLCAzLjgsIC00LjddKTsgICAvLyByZXR1cm5zIEFycmF5IFszLCAzLCAtNF1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGNlaWwsIGZsb29yLCByb3VuZFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4IE51bWJlciB0byBiZSByb3VuZGVkXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gICAgICAgICAgICBSb3VuZGVkIHZhbHVlXG4gICAqL1xuICBtYXRoLmZpeCA9IGZ1bmN0aW9uIGZpeCh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2ZpeCcsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgcmV0dXJuICh4ID4gMCkgPyBNYXRoLmZsb29yKHgpIDogTWF0aC5jZWlsKHgpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAoeC5yZSA+IDApID8gTWF0aC5mbG9vcih4LnJlKSA6IE1hdGguY2VpbCh4LnJlKSxcbiAgICAgICAgICAoeC5pbSA+IDApID8gTWF0aC5mbG9vcih4LmltKSA6IE1hdGguY2VpbCh4LmltKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuIHguaXNOZWdhdGl2ZSgpID8geC5jZWlsKCkgOiB4LmZsb29yKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCBmaXgpO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZpeCgreCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2ZpeCcsIG1hdGhbJ3R5cGVvZiddKHgpKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogUm91bmQgYSB2YWx1ZSB0b3dhcmRzIG1pbnVzIGluZmluaXR5LlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZmxvb3IoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZmxvb3IoMy4yKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDNcbiAgICogICAgbWF0aC5mbG9vcigzLjgpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgM1xuICAgKiAgICBtYXRoLmZsb29yKC00LjIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAtNVxuICAgKiAgICBtYXRoLmZsb29yKC00LjcpOyAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAtNVxuICAgKlxuICAgKiAgICB2YXIgYyA9IG1hdGguY29tcGxleCgzLjIsIC0yLjcpO1xuICAgKiAgICBtYXRoLmZsb29yKGMpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMyAtIDNpXG4gICAqXG4gICAqICAgIG1hdGguZmxvb3IoWzMuMiwgMy44LCAtNC43XSk7IC8vIHJldHVybnMgQXJyYXkgWzMsIDMsIC01XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY2VpbCwgZml4LCByb3VuZFxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCAgTnVtYmVyIHRvIGJlIHJvdW5kZWRcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBSb3VuZGVkIHZhbHVlXG4gICAqL1xuICBtYXRoLmZsb29yID0gZnVuY3Rpb24gZmxvb3IoeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdmbG9vcicsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoeCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4IChcbiAgICAgICAgICBNYXRoLmZsb29yKHgucmUpLFxuICAgICAgICAgIE1hdGguZmxvb3IoeC5pbSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIHJldHVybiB4LmZsb29yKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCBmbG9vcik7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmxvb3IoK3gpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdmbG9vcicsIG1hdGhbJ3R5cGVvZiddKHgpKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNJbnRlZ2VyID0gdXRpbC5udW1iZXIuaXNJbnRlZ2VyLFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3IgZm9yIHR3byBvciBtb3JlIHZhbHVlcyBvciBhcnJheXMuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5nY2QoYSwgYilcbiAgICogICAgbWF0aC5nY2QoYSwgYiwgYywgLi4uKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5nY2QoOCwgMTIpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyA0XG4gICAqICAgIG1hdGguZ2NkKC00LCA2KTsgICAgICAgICAgICAgIC8vIHJldHVybnMgMlxuICAgKiAgICBtYXRoLmdjZCgyNSwgMTUsIC0xMCk7ICAgICAgICAvLyByZXR1cm5zIDVcbiAgICpcbiAgICogICAgbWF0aC5nY2QoWzgsIC00XSwgWzEyLCA2XSk7ICAgLy8gcmV0dXJucyBbNCwgMl1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGxjbSwgeGdjZFxuICAgKlxuICAgKiBAcGFyYW0gey4uLiBOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSBhcmdzICBUd28gb3IgbW9yZSBpbnRlZ2VyIG51bWJlcnNcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yXG4gICAqL1xuICBtYXRoLmdjZCA9IGZ1bmN0aW9uIGdjZChhcmdzKSB7XG4gICAgdmFyIGEgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgIGIgPSBhcmd1bWVudHNbMV0sXG4gICAgICAgIHI7IC8vIHJlbWFpbmRlclxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgLy8gdHdvIGFyZ3VtZW50c1xuICAgICAgaWYgKGlzTnVtYmVyKGEpICYmIGlzTnVtYmVyKGIpKSB7XG4gICAgICAgIGlmICghaXNJbnRlZ2VyKGEpIHx8ICFpc0ludGVnZXIoYikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlcnMgaW4gZnVuY3Rpb24gZ2NkIG11c3QgYmUgaW50ZWdlciBudW1iZXJzJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9hbGdvcml0aG1cbiAgICAgICAgd2hpbGUgKGIgIT0gMCkge1xuICAgICAgICAgIHIgPSBhICUgYjtcbiAgICAgICAgICBhID0gYjtcbiAgICAgICAgICBiID0gcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGEgPCAwKSA/IC1hIDogYTtcbiAgICAgIH1cblxuICAgICAgLy8gZXZhbHVhdGUgZ2NkIGVsZW1lbnQgd2lzZVxuICAgICAgaWYgKGlzQ29sbGVjdGlvbihhKSB8fCBpc0NvbGxlY3Rpb24oYikpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcDIoYSwgYiwgZ2NkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdG8gYmlnIG51bWJlclxuICAgICAgICBpZiAoaXNOdW1iZXIoYikpIHtcbiAgICAgICAgICBiID0gQmlnTnVtYmVyLmNvbnZlcnQoYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKGIpIHx8IGIgPT09IG51bGwpIHtcbiAgICAgICAgICBiID0gbmV3IEJpZ051bWJlcihiID8gMSA6IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gX2JpZ0djZChhLCBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgICAgcmV0dXJuIGdjZChhLnRvTnVtYmVyKCksIGIpO1xuICAgICAgfVxuICAgICAgaWYgKGIgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdG8gYmlnIG51bWJlclxuICAgICAgICBpZiAoaXNOdW1iZXIoYSkpIHtcbiAgICAgICAgICBhID0gQmlnTnVtYmVyLmNvbnZlcnQoYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKGEpIHx8IGEgPT09IG51bGwpIHtcbiAgICAgICAgICBhID0gbmV3IEJpZ051bWJlcihhID8gMSA6IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gX2JpZ0djZChhLCBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgICAgcmV0dXJuIGdjZChhLnRvTnVtYmVyKCksIGIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNCb29sZWFuKGEpIHx8IGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdjZCgrYSwgYik7XG4gICAgICB9XG4gICAgICBpZiAoaXNCb29sZWFuKGIpIHx8IGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdjZChhLCArYik7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdnY2QnLCBtYXRoWyd0eXBlb2YnXShhKSwgbWF0aFsndHlwZW9mJ10oYikpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgLy8gbXVsdGlwbGUgYXJndW1lbnRzLiBFdmFsdWF0ZSB0aGVtIGl0ZXJhdGl2ZWx5XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhID0gZ2NkKGEsIGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICAvLyB6ZXJvIG9yIG9uZSBhcmd1bWVudFxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRnVuY3Rpb24gZ2NkIGV4cGVjdHMgdHdvIG9yIG1vcmUgYXJndW1lbnRzJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBnY2QgZm9yIEJpZ051bWJlcnNcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IGFcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IGJcbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gZ3JlYXRlc3QgY29tbW9uIGRlbm9taW5hdG9yIG9mIGEgYW5kIGJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9iaWdHY2QoYSwgYikge1xuICAgIGlmICghYS5pc0ludCgpIHx8ICFiLmlzSW50KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVycyBpbiBmdW5jdGlvbiBnY2QgbXVzdCBiZSBpbnRlZ2VyIG51bWJlcnMnKTtcbiAgICB9XG5cbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9hbGdvcml0aG1cbiAgICB2YXIgemVybyA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgd2hpbGUgKCFiLmlzWmVybygpKSB7XG4gICAgICB2YXIgciA9IGEubW9kKGIpO1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gcjtcbiAgICB9XG4gICAgcmV0dXJuIGEubHQoemVybykgPyBhLm5lZygpIDogYTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0ludGVnZXIgPSB1dGlsLm51bWJlci5pc0ludGVnZXIsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBsZWFzdCBjb21tb24gbXVsdGlwbGUgZm9yIHR3byBvciBtb3JlIHZhbHVlcyBvciBhcnJheXMuXG4gICAqXG4gICAqIGxjbSBpcyBkZWZpbmVkIGFzOlxuICAgKlxuICAgKiAgICAgbGNtKGEsIGIpID0gYWJzKGEgKiBiKSAvIGdjZChhLCBiKVxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubGNtKGEsIGIpXG4gICAqICAgIG1hdGgubGNtKGEsIGIsIGMsIC4uLilcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubGNtKDQsIDYpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgMTJcbiAgICogICAgbWF0aC5sY20oNiwgMjEpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyA0MlxuICAgKiAgICBtYXRoLmxjbSg2LCAyMSwgNSk7ICAgICAgICAgICAvLyByZXR1cm5zIDIxMFxuICAgKlxuICAgKiAgICBtYXRoLmxjbShbNCwgNl0sIFs2LCAyMV0pOyAgICAvLyByZXR1cm5zIFsxMiwgNDJdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBnY2QsIHhnY2RcbiAgICpcbiAgICogQHBhcmFtIHsuLi4gTnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0gYXJncyAgVHdvIG9yIG1vcmUgaW50ZWdlciBudW1iZXJzXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IEFycmF5IHwgTWF0cml4fSAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBsZWFzdCBjb21tb24gbXVsdGlwbGVcbiAgICovXG4gIG1hdGgubGNtID0gZnVuY3Rpb24gbGNtKGFyZ3MpIHtcbiAgICB2YXIgYSA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgYiA9IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgdDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgIC8vIHR3byBhcmd1bWVudHNcbiAgICAgIGlmIChpc051bWJlcihhKSAmJiBpc051bWJlcihiKSkge1xuICAgICAgICBpZiAoIWlzSW50ZWdlcihhKSB8fCAhaXNJbnRlZ2VyKGIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIGxjbSBtdXN0IGJlIGludGVnZXIgbnVtYmVycycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPT0gMCB8fCBiID09IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2FsZ29yaXRobVxuICAgICAgICAvLyBldmFsdWF0ZSBsY20gaGVyZSBpbmxpbmUgdG8gcmVkdWNlIG92ZXJoZWFkXG4gICAgICAgIHZhciBwcm9kID0gYSAqIGI7XG4gICAgICAgIHdoaWxlIChiICE9IDApIHtcbiAgICAgICAgICB0ID0gYjtcbiAgICAgICAgICBiID0gYSAlIHQ7XG4gICAgICAgICAgYSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHByb2QgLyBhKTtcbiAgICAgIH1cblxuICAgICAgLy8gZXZhbHVhdGUgbGNtIGVsZW1lbnQgd2lzZVxuICAgICAgaWYgKGlzQ29sbGVjdGlvbihhKSB8fCBpc0NvbGxlY3Rpb24oYikpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcDIoYSwgYiwgbGNtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdG8gYmlnIG51bWJlclxuICAgICAgICBpZiAoaXNOdW1iZXIoYikpIHtcbiAgICAgICAgICBiID0gQmlnTnVtYmVyLmNvbnZlcnQoYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKGIpIHx8IGIgPT09IG51bGwpIHtcbiAgICAgICAgICBiID0gbmV3IEJpZ051bWJlcihiID8gMSA6IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gX2JpZ0xjbShhLCBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgICAgcmV0dXJuIGxjbShhLnRvTnVtYmVyKCksIGIpO1xuICAgICAgfVxuICAgICAgaWYgKGIgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdG8gYmlnIG51bWJlclxuICAgICAgICBpZiAoaXNOdW1iZXIoYSkpIHtcbiAgICAgICAgICBhID0gQmlnTnVtYmVyLmNvbnZlcnQoYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKGEpIHx8IGEgPT09IG51bGwpIHtcbiAgICAgICAgICBhID0gbmV3IEJpZ051bWJlcihhID8gMSA6IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gX2JpZ0xjbShhLCBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgICAgcmV0dXJuIGxjbShhLnRvTnVtYmVyKCksIGIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNCb29sZWFuKGEpIHx8IGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxjbSgrYSwgYik7XG4gICAgICB9XG4gICAgICBpZiAoaXNCb29sZWFuKGIpIHx8IGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxjbShhLCArYik7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdsY20nLCBtYXRoWyd0eXBlb2YnXShhKSwgbWF0aFsndHlwZW9mJ10oYikpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgLy8gbXVsdGlwbGUgYXJndW1lbnRzLiBFdmFsdWF0ZSB0aGVtIGl0ZXJhdGl2ZWx5XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhID0gbGNtKGEsIGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICAvLyB6ZXJvIG9yIG9uZSBhcmd1bWVudFxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRnVuY3Rpb24gbGNtIGV4cGVjdHMgdHdvIG9yIG1vcmUgYXJndW1lbnRzJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBsY20gZm9yIEJpZ051bWJlcnNcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IGFcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IGJcbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gdGhlIGxlYXN0IGNvbW1vbiBtdWx0aXBsZSBvZiBhIGFuZCBiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfYmlnTGNtKGEsIGIpIHtcbiAgICBpZiAoIWEuaXNJbnQoKSB8fCAhYi5pc0ludCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlcnMgaW4gZnVuY3Rpb24gbGNtIG11c3QgYmUgaW50ZWdlciBudW1iZXJzJyk7XG4gICAgfVxuXG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgfVxuXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fYWxnb3JpdGhtXG4gICAgLy8gZXZhbHVhdGUgbGNtIGhlcmUgaW5saW5lIHRvIHJlZHVjZSBvdmVyaGVhZFxuICAgIHZhciBwcm9kID0gYS50aW1lcyhiKTtcbiAgICB3aGlsZSAoIWIuaXNaZXJvKCkpIHtcbiAgICAgIHZhciB0ID0gYjtcbiAgICAgIGIgPSBhLm1vZCh0KTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICByZXR1cm4gcHJvZC5kaXYoYSkuYWJzKCk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBsb2dhcml0aG0gb2YgYSB2YWx1ZS5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmxvZyh4KVxuICAgKiAgICBtYXRoLmxvZyh4LCBiYXNlKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5sb2coMy41KTsgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDEuMjUyNzYyOTY4NDk1MzY4XG4gICAqICAgIG1hdGguZXhwKG1hdGgubG9nKDIuNCkpOyAgICAgICAgLy8gcmV0dXJucyAyLjRcbiAgICpcbiAgICogICAgbWF0aC5wb3coMTAsIDQpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDEwMDAwXG4gICAqICAgIG1hdGgubG9nKDEwMDAwLCAxMCk7ICAgICAgICAgICAgLy8gcmV0dXJucyA0XG4gICAqICAgIG1hdGgubG9nKDEwMDAwKSAvIG1hdGgubG9nKDEwKTsgLy8gcmV0dXJucyA0XG4gICAqXG4gICAqICAgIG1hdGgubG9nKDEwMjQsIDIpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyAxMFxuICAgKiAgICBtYXRoLnBvdygyLCAxMCk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMTAyNFxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZXhwLCBsb2cxMFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4XG4gICAqICAgICAgICAgICAgVmFsdWUgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgbG9nYXJpdGhtLlxuICAgKiBAcGFyYW0ge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgbnVsbH0gW2Jhc2U9ZV1cbiAgICogICAgICAgICAgICBPcHRpb25hbCBiYXNlIGZvciB0aGUgbG9nYXJpdGhtLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBuYXR1cmFsXG4gICAqICAgICAgICAgICAgbG9nYXJpdGhtIG9mIGB4YCBpcyBjYWxjdWxhdGVkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9XG4gICAqICAgICAgICAgICAgUmV0dXJucyB0aGUgbG9nYXJpdGhtIG9mIGB4YFxuICAgKi9cbiAgbWF0aC5sb2cgPSBmdW5jdGlvbiBsb2coeCwgYmFzZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBuYXR1cmFsIGxvZ2FyaXRobSwgbG9nKHgpXG4gICAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgaWYgKHggPj0gMCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmxvZyh4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBuZWdhdGl2ZSB2YWx1ZSAtPiBjb21wbGV4IHZhbHVlIGNvbXB1dGF0aW9uXG4gICAgICAgICAgcmV0dXJuIGxvZyhuZXcgQ29tcGxleCh4LCAwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXggKFxuICAgICAgICAgICAgTWF0aC5sb2coTWF0aC5zcXJ0KHgucmUgKiB4LnJlICsgeC5pbSAqIHguaW0pKSxcbiAgICAgICAgICAgIE1hdGguYXRhbjIoeC5pbSwgeC5yZSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgaWYgKHguaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgLy8gbmVnYXRpdmUgdmFsdWUgLT4gZG93bmdyYWRlIHRvIG51bWJlciB0byBkbyBjb21wbGV4IHZhbHVlIGNvbXB1dGF0aW9uXG4gICAgICAgICAgcmV0dXJuIGxvZyh4LnRvTnVtYmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB4LmxuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHgsIGxvZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbG9nKCt4KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2xvZycsIG1hdGhbJ3R5cGVvZiddKHgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAvLyBjYWxjdWxhdGUgbG9nYXJpdGhtIGZvciBhIHNwZWNpZmllZCBiYXNlLCBsb2coeCwgYmFzZSlcbiAgICAgIHJldHVybiBtYXRoLmRpdmlkZShsb2coeCksIGxvZyhiYXNlKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2xvZycsIGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpO1xuICAgIH1cbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSAxMC1iYXNlIG9mIGEgdmFsdWUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgY2FsY3VsYXRpbmcgYGxvZyh4LCAxMClgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubG9nMTAoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubG9nMTAoMC4wMDAwMSk7ICAgICAgICAgICAgLy8gcmV0dXJucyAtNVxuICAgKiAgICBtYXRoLmxvZzEwKDEwMDAwKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgNFxuICAgKiAgICBtYXRoLmxvZygxMDAwMCkgLyBtYXRoLmxvZygxMCk7IC8vIHJldHVybnMgNFxuICAgKiAgICBtYXRoLnBvdygxMCwgNCk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMTAwMDBcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGV4cCwgbG9nXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHhcbiAgICogICAgICAgICAgICBWYWx1ZSBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBsb2dhcml0aG0uXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH1cbiAgICogICAgICAgICAgICBSZXR1cm5zIHRoZSAxMC1iYXNlIGxvZ2FyaXRobSBvZiBgeGBcbiAgICovXG4gIG1hdGgubG9nMTAgPSBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2xvZzEwJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICBpZiAoeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBuZWdhdGl2ZSB2YWx1ZSAtPiBjb21wbGV4IHZhbHVlIGNvbXB1dGF0aW9uXG4gICAgICAgIHJldHVybiBsb2cxMChuZXcgQ29tcGxleCh4LCAwKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIGlmICh4LmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAvLyBuZWdhdGl2ZSB2YWx1ZSAtPiBkb3duZ3JhZGUgdG8gbnVtYmVyIHRvIGRvIGNvbXBsZXggdmFsdWUgY29tcHV0YXRpb25cbiAgICAgICAgcmV0dXJuIGxvZzEwKHgudG9OdW1iZXIoKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHgubG9nKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4IChcbiAgICAgICAgICBNYXRoLmxvZyhNYXRoLnNxcnQoeC5yZSAqIHgucmUgKyB4LmltICogeC5pbSkpIC8gTWF0aC5MTjEwLFxuICAgICAgICAgIE1hdGguYXRhbjIoeC5pbSwgeC5yZSkgLyBNYXRoLkxOMTBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCBsb2cxMCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbG9nMTAoK3gpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdsb2cxMCcsIG1hdGhbJ3R5cGVvZiddKHgpKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG1vZHVsdXMsIHRoZSByZW1haW5kZXIgb2YgYW4gaW50ZWdlciBkaXZpc2lvbi5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogVGhlIG1vZHVsdXMgaXMgZGVmaW5lZCBhczpcbiAgICpcbiAgICogICAgIHggLSB5ICogZmxvb3IoeCAvIHkpXG4gICAqXG4gICAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsb19vcGVyYXRpb24uXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5tb2QoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubW9kKDgsIDMpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDJcbiAgICogICAgbWF0aC5tb2QoMTEsIDIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgMVxuICAgKlxuICAgKiAgICBmdW5jdGlvbiBpc09kZCh4KSB7XG4gICAqICAgICAgcmV0dXJuIG1hdGgubW9kKHgsIDIpICE9IDA7XG4gICAqICAgIH1cbiAgICpcbiAgICogICAgaXNPZGQoMik7ICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgaXNPZGQoMyk7ICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZGl2aWRlXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggRGl2aWRlbmRcbiAgICogQHBhcmFtICB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geSBEaXZpc29yXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IEFycmF5IHwgTWF0cml4fSBSZXR1cm5zIHRoZSByZW1haW5kZXIgb2YgYHhgIGRpdmlkZWQgYnkgYHlgLlxuICAgKi9cbiAgbWF0aC5tb2QgPSBmdW5jdGlvbiBtb2QoeCwgeSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdtb2QnLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICAvLyBzZWUgaHR0cDovL2Z1bmN0aW9ucy53b2xmcmFtLmNvbS9JbnRlZ2VyRnVuY3Rpb25zL01vZC9cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIC8vIG51bWJlciAlIG51bWJlclxuICAgICAgICByZXR1cm4gX21vZCh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdG8gYmlnIG51bWJlclxuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIHkgPSBCaWdOdW1iZXIuY29udmVydCh5KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbih5KSB8fCB5ID09PSBudWxsKSB7XG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHkgPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB5LmlzWmVybygpID8geCA6IHgubW9kKHkpO1xuICAgICAgfVxuXG4gICAgICAvLyBkb3duZ3JhZGUgeCB0byBOdW1iZXJcbiAgICAgIHJldHVybiBtb2QoeC50b051bWJlcigpLCB5KTtcbiAgICB9XG4gICAgaWYgKHkgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHRvIGJpZyBudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgICB4ID0gQmlnTnVtYmVyLmNvbnZlcnQoeCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih4ID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICByZXR1cm4geS5pc1plcm8oKSA/IHggOiB4Lm1vZCh5KTtcbiAgICAgIH1cblxuICAgICAgLy8gZG93bmdyYWRlIHkgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gbW9kKHgsIHkudG9OdW1iZXIoKSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IG1vZCBmb3IgY29tcGxleCB2YWx1ZXNcblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkgfHwgaXNDb2xsZWN0aW9uKHkpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwMih4LCB5LCBtb2QpO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG1vZCgreCwgeSk7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW4oeSkgfHwgeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG1vZCh4LCAreSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ21vZCcsIG1hdGhbJ3R5cGVvZiddKHgpLCBtYXRoWyd0eXBlb2YnXSh5KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbW9kdWx1cyBvZiB0d28gbnVtYmVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSByZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9tb2QoeCwgeSkge1xuICAgIGlmICh5ID4gMCkge1xuICAgICAgLy8gV2UgZG9uJ3QgdXNlIEphdmFTY3JpcHQncyAlIG9wZXJhdG9yIGhlcmUgYXMgdGhpcyBkb2Vzbid0IHdvcmtcbiAgICAgIC8vIGNvcnJlY3RseSBmb3IgeCA8IDAgYW5kIHggPT0gMFxuICAgICAgLy8gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuICAgICAgcmV0dXJuIHggLSB5ICogTWF0aC5mbG9vcih4IC8geSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHkgPT0gMCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGVsc2UgeyAvLyB5IDwgMFxuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IG1vZCBmb3IgYSBuZWdhdGl2ZSBkaXZpc29yXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxjdWxhdGUgbW9kIGZvciBhIG5lZ2F0aXZlIGRpdmlzb3InKTtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4JyksXG4gICAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGFycmF5ID0gdXRpbC5hcnJheSxcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGlzVW5pdCA9IFVuaXQuaXNVbml0O1xuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0d28gdmFsdWVzLCBgeCAqIHlgLiBUaGUgcmVzdWx0IGlzIHNxdWVlemVkLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBtYXRyaXggcHJvZHVjdCBpcyBjYWxjdWxhdGVkLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubXVsdGlwbHkoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubXVsdGlwbHkoNCwgNS4yKTsgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDIwLjhcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLmNvbXBsZXgoMiwgMyk7XG4gICAqICAgIHZhciBiID0gbWF0aC5jb21wbGV4KDQsIDEpO1xuICAgKiAgICBtYXRoLm11bHRpcGx5KGEsIGIpOyAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggNSArIDE0aVxuICAgKlxuICAgKiAgICB2YXIgYyA9IFtbMSwgMl0sIFs0LCAzXV07XG4gICAqICAgIHZhciBkID0gW1sxLCAyLCAzXSwgWzMsIC00LCA3XV07XG4gICAqICAgIG1hdGgubXVsdGlwbHkoYywgZCk7ICAgICAgICAgIC8vIHJldHVybnMgQXJyYXkgW1s3LCAtNiwgMTddLCBbMTMsIC00LCAzM11dXG4gICAqXG4gICAqICAgIHZhciBlID0gbWF0aC51bml0KCcyLjEga20nKTtcbiAgICogICAgbWF0aC5tdWx0aXBseSgzLCBlKTsgICAgICAgICAgLy8gcmV0dXJucyBVbml0IDYuMyBrbVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZGl2aWRlXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCBGaXJzdCB2YWx1ZSB0byBtdWx0aXBseVxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHkgU2Vjb25kIHZhbHVlIHRvIG11bHRpcGx5XG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IE11bHRpcGxpY2F0aW9uIG9mIGB4YCBhbmQgYHlgXG4gICAqL1xuICBtYXRoLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkoeCwgeSkge1xuICAgIHZhciByZXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignbXVsdGlwbHknLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICAvLyBudW1iZXIgKiBudW1iZXJcbiAgICAgICAgcmV0dXJuIHggKiB5O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNDb21wbGV4KHkpKSB7XG4gICAgICAgIC8vIG51bWJlciAqIGNvbXBsZXhcbiAgICAgICAgcmV0dXJuIF9tdWx0aXBseUNvbXBsZXggKG5ldyBDb21wbGV4KHgsIDApLCB5KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVW5pdCh5KSkge1xuICAgICAgICByZXMgPSB5LmNsb25lKCk7XG4gICAgICAgIHJlcy52YWx1ZSA9IChyZXMudmFsdWUgPT09IG51bGwpID8gcmVzLl9ub3JtYWxpemUoeCkgOiAocmVzLnZhbHVlICogeCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIC8vIGNvbXBsZXggKiBudW1iZXJcbiAgICAgICAgcmV0dXJuIF9tdWx0aXBseUNvbXBsZXggKHgsIG5ldyBDb21wbGV4KHksIDApKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQ29tcGxleCh5KSkge1xuICAgICAgICAvLyBjb21wbGV4ICogY29tcGxleFxuICAgICAgICByZXR1cm4gX211bHRpcGx5Q29tcGxleCAoeCwgeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHRvIGJpZyBudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICB5ID0gQmlnTnVtYmVyLmNvbnZlcnQoeSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeSkgfHwgeSA9PT0gbnVsbCkge1xuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcih5ID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoeSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICByZXR1cm4geC50aW1lcyh5KTtcbiAgICAgIH1cblxuICAgICAgLy8gZG93bmdyYWRlIHRvIE51bWJlclxuICAgICAgcmV0dXJuIG11bHRpcGx5KHgudG9OdW1iZXIoKSwgeSk7XG4gICAgfVxuICAgIGlmICh5IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyB0cnkgdG8gY29udmVydCB0byBiaWcgbnVtYmVyXG4gICAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgeCA9IEJpZ051bWJlci5jb252ZXJ0KHgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHgpIHx8IHggPT09IG51bGwpIHtcbiAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIoeCA/IDEgOiAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHgudGltZXMoeSlcbiAgICAgIH1cblxuICAgICAgLy8gZG93bmdyYWRlIHRvIE51bWJlclxuICAgICAgcmV0dXJuIG11bHRpcGx5KHgsIHkudG9OdW1iZXIoKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5pdCh4KSkge1xuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIHJlcyA9IHguY2xvbmUoKTtcbiAgICAgICAgcmVzLnZhbHVlID0gKHJlcy52YWx1ZSA9PT0gbnVsbCkgPyByZXMuX25vcm1hbGl6ZSh5KSA6IChyZXMudmFsdWUgKiB5KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSh4KSkge1xuICAgICAgaWYgKGlzQXJyYXkoeSkpIHtcbiAgICAgICAgLy8gYXJyYXkgKiBhcnJheVxuICAgICAgICB2YXIgc2l6ZVggPSBhcnJheS5zaXplKHgpO1xuICAgICAgICB2YXIgc2l6ZVkgPSBhcnJheS5zaXplKHkpO1xuXG4gICAgICAgIGlmIChzaXplWC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIGlmIChzaXplWS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgLy8gdmVjdG9yICogdmVjdG9yXG4gICAgICAgICAgICBpZiAoc2l6ZVhbMF0gIT0gc2l6ZVlbMF0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaCBpbiBtdWx0aXBsaWNhdGlvbi4gJyArXG4gICAgICAgICAgICAgICAgICAnTGVuZ3RoIG9mIEEgbXVzdCBtYXRjaCBsZW5ndGggb2YgQiAnICtcbiAgICAgICAgICAgICAgICAgICcoQSBpcyAnICsgc2l6ZVhbMF0gK1xuICAgICAgICAgICAgICAgICAgJywgQiBpcyAnICsgc2l6ZVlbMF0gK1xuICAgICAgICAgICAgICAgICAgc2l6ZVhbMF0gKyAnICE9ICcgKyBzaXplWVswXSArICcpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfbXVsdGlwbHlWZWN0b3JWZWN0b3IoeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHNpemVZLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAvLyB2ZWN0b3IgKiBtYXRyaXhcbiAgICAgICAgICAgIGlmIChzaXplWFswXSAhPSBzaXplWVswXSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGltZW5zaW9uIG1pc21hdGNoIGluIG11bHRpcGxpY2F0aW9uLiAnICtcbiAgICAgICAgICAgICAgICAgICdMZW5ndGggb2YgQSBtdXN0IG1hdGNoIHJvd3Mgb2YgQiAnICtcbiAgICAgICAgICAgICAgICAgICcoQSBpcyAnICsgc2l6ZVhbMF0gK1xuICAgICAgICAgICAgICAgICAgJywgQiBpcyAnICsgc2l6ZVlbMF0gKyAneCcgKyBzaXplWVsxXSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgc2l6ZVhbMF0gKyAnICE9ICcgKyBzaXplWVswXSArICcpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfbXVsdGlwbHlWZWN0b3JNYXRyaXgoeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBtdWx0aXBseSBhIDEgb3IgMiBkaW1lbnNpb25hbCBtYXRyaXggJyArXG4gICAgICAgICAgICAgICAgJyhCIGhhcyAnICsgc2l6ZVkubGVuZ3RoICsgJyBkaW1lbnNpb25zKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplWC5sZW5ndGggPT0gMikge1xuICAgICAgICAgIGlmIChzaXplWS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgLy8gbWF0cml4ICogdmVjdG9yXG4gICAgICAgICAgICBpZiAoc2l6ZVhbMV0gIT0gc2l6ZVlbMF0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaCBpbiBtdWx0aXBsaWNhdGlvbi4gJyArXG4gICAgICAgICAgICAgICAgICAnQ29sdW1ucyBvZiBBIG11c3QgbWF0Y2ggbGVuZ3RoIG9mIEIgJyArXG4gICAgICAgICAgICAgICAgICAnKEEgaXMgJyArIHNpemVYWzBdICsgJ3gnICsgc2l6ZVhbMF0gK1xuICAgICAgICAgICAgICAgICAgJywgQiBpcyAnICsgc2l6ZVlbMF0gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgIHNpemVYWzFdICsgJyAhPSAnICsgc2l6ZVlbMF0gKyAnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX211bHRpcGx5TWF0cml4VmVjdG9yKHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChzaXplWS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgLy8gbWF0cml4ICogbWF0cml4XG4gICAgICAgICAgICBpZiAoc2l6ZVhbMV0gIT0gc2l6ZVlbMF0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaCBpbiBtdWx0aXBsaWNhdGlvbi4gJyArXG4gICAgICAgICAgICAgICAgICAnQ29sdW1ucyBvZiBBIG11c3QgbWF0Y2ggcm93cyBvZiBCICcgK1xuICAgICAgICAgICAgICAgICAgJyhBIGlzICcgKyBzaXplWFswXSArICd4JyArIHNpemVYWzFdICtcbiAgICAgICAgICAgICAgICAgICcsIEIgaXMgJyArIHNpemVZWzBdICsgJ3gnICsgc2l6ZVlbMV0gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgIHNpemVYWzFdICsgJyAhPSAnICsgc2l6ZVlbMF0gKyAnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX211bHRpcGx5TWF0cml4TWF0cml4KHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgbXVsdGlwbHkgYSAxIG9yIDIgZGltZW5zaW9uYWwgbWF0cml4ICcgK1xuICAgICAgICAgICAgICAgICcoQiBoYXMgJyArIHNpemVZLmxlbmd0aCArICcgZGltZW5zaW9ucyknKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBtdWx0aXBseSBhIDEgb3IgMiBkaW1lbnNpb25hbCBtYXRyaXggJyArXG4gICAgICAgICAgICAgICcoQSBoYXMgJyArIHNpemVYLmxlbmd0aCArICcgZGltZW5zaW9ucyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoeSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAvLyBhcnJheSAqIG1hdHJpeFxuICAgICAgICByZXMgPSBtdWx0aXBseSh4LCB5LnZhbHVlT2YoKSk7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHJlcykgPyBuZXcgTWF0cml4KHJlcykgOiByZXM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gYXJyYXkgKiBzY2FsYXJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcDIoeCwgeSwgbXVsdGlwbHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICBpZiAoeSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAvLyBtYXRyaXggKiBtYXRyaXhcbiAgICAgICAgcmVzID0gbXVsdGlwbHkoeC52YWx1ZU9mKCksIHkudmFsdWVPZigpKTtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkocmVzKSA/IG5ldyBNYXRyaXgocmVzKSA6IHJlcztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBtYXRyaXggKiBhcnJheVxuICAgICAgICAvLyBtYXRyaXggKiBzY2FsYXJcbiAgICAgICAgcmVzID0gbXVsdGlwbHkoeC52YWx1ZU9mKCksIHkpO1xuICAgICAgICByZXR1cm4gaXNBcnJheShyZXMpID8gbmV3IE1hdHJpeChyZXMpIDogcmVzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0FycmF5KHkpKSB7XG4gICAgICAvLyBzY2FsYXIgKiBhcnJheVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcDIoeCwgeSwgbXVsdGlwbHkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh5IGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAvLyBzY2FsYXIgKiBtYXRyaXhcbiAgICAgIHJldHVybiBuZXcgTWF0cml4KGNvbGxlY3Rpb24uZGVlcE1hcDIoeCwgeS52YWx1ZU9mKCksIG11bHRpcGx5KSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbXVsdGlwbHkoK3gsIHkpO1xuICAgIH1cbiAgICBpZiAoaXNCb29sZWFuKHkpIHx8IHkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBtdWx0aXBseSh4LCAreSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ211bHRpcGx5JywgbWF0aFsndHlwZW9mJ10oeCksIG1hdGhbJ3R5cGVvZiddKHkpKTtcbiAgfTtcblxuICAvKipcbiAgICogTXVsdGlwbHkgdHdvIDItZGltZW5zaW9uYWwgbWF0cmljZXMuXG4gICAqIFRoZSBzaXplIG9mIHRoZSBtYXRyaWNlcyBpcyBub3QgdmFsaWRhdGVkLlxuICAgKiBAcGFyYW0ge0FycmF5fSB4ICAgQSAyZCBtYXRyaXhcbiAgICogQHBhcmFtIHtBcnJheX0geSAgIEEgMmQgbWF0cml4XG4gICAqIEByZXR1cm4ge0FycmF5IHwgTnVtYmVyfSByZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9tdWx0aXBseU1hdHJpeE1hdHJpeCh4LCB5KSB7XG4gICAgLy8gVE9ETzogcGVyZm9ybWFuY2Ugb2YgbWF0cml4IG11bHRpcGxpY2F0aW9uIGNhbiBiZSBpbXByb3ZlZFxuICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgcm93cyA9IHgubGVuZ3RoLFxuICAgICAgICBjb2xzID0geVswXS5sZW5ndGgsXG4gICAgICAgIG51bSA9IHhbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dzOyByKyspIHtcbiAgICAgIHJlc1tyXSA9IFtdO1xuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb2xzOyBjKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbnVtOyBuKyspIHtcbiAgICAgICAgICB2YXIgcCA9IG1hdGgubXVsdGlwbHkoeFtyXVtuXSwgeVtuXVtjXSk7XG4gICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA9PT0gbnVsbCkgPyBwIDogbWF0aC5hZGQocmVzdWx0LCBwKTtcbiAgICAgICAgfVxuICAgICAgICByZXNbcl1bY10gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzU2NhbGFyID0gcm93cyA9PT0gMSAmJiBjb2xzID09PSAxO1xuICAgIHJldHVybiBpc1NjYWxhciA/IHJlc1swXVswXSA6IHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSBhIHZlY3RvciB3aXRoIGEgMi1kaW1lbnNpb25hbCBtYXRyaXhcbiAgICogVGhlIHNpemUgb2YgdGhlIG1hdHJpY2VzIGlzIG5vdCB2YWxpZGF0ZWQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHggICBBIHZlY3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSB5ICAgQSAyZCBtYXRyaXhcbiAgICogQHJldHVybiB7QXJyYXkgfCBOdW1iZXJ9IHJlc3VsdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX211bHRpcGx5VmVjdG9yTWF0cml4KHgsIHkpIHtcbiAgICAvLyBUT0RPOiBwZXJmb3JtYW5jZSBvZiBtYXRyaXggbXVsdGlwbGljYXRpb24gY2FuIGJlIGltcHJvdmVkXG4gICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICByb3dzID0geS5sZW5ndGgsXG4gICAgICAgIGNvbHMgPSB5WzBdLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sczsgYysrKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93czsgcisrKSB7XG4gICAgICAgIHZhciBwID0gbWF0aC5tdWx0aXBseSh4W3JdLCB5W3JdW2NdKTtcbiAgICAgICAgcmVzdWx0ID0gKHIgPT09IDApID8gcCA6IG1hdGguYWRkKHJlc3VsdCwgcCk7XG4gICAgICB9XG4gICAgICByZXNbY10gPSByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5sZW5ndGggPT09IDEgPyByZXNbMF0gOiByZXM7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgYSAyLWRpbWVuc2lvbmFsIG1hdHJpeCB3aXRoIGEgdmVjdG9yXG4gICAqIFRoZSBzaXplIG9mIHRoZSBtYXRyaWNlcyBpcyBub3QgdmFsaWRhdGVkLlxuICAgKiBAcGFyYW0ge0FycmF5fSB4ICAgQSAyZCBtYXRyaXhcbiAgICogQHBhcmFtIHtBcnJheX0geSAgIEEgdmVjdG9yXG4gICAqIEByZXR1cm4ge0FycmF5IHwgTnVtYmVyfSByZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9tdWx0aXBseU1hdHJpeFZlY3Rvcih4LCB5KSB7XG4gICAgLy8gVE9ETzogcGVyZm9ybWFuY2Ugb2YgbWF0cml4IG11bHRpcGxpY2F0aW9uIGNhbiBiZSBpbXByb3ZlZFxuICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgcm93cyA9IHgubGVuZ3RoLFxuICAgICAgICBjb2xzID0geFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbHM7IGMrKykge1xuICAgICAgICB2YXIgcCA9IG1hdGgubXVsdGlwbHkoeFtyXVtjXSwgeVtjXSk7XG4gICAgICAgIHJlc3VsdCA9IChjID09PSAwKSA/IHAgOiBtYXRoLmFkZChyZXN1bHQsIHApO1xuICAgICAgfVxuICAgICAgcmVzW3JdID0gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiByZXMubGVuZ3RoID09PSAxID8gcmVzWzBdIDogcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHR3byB2ZWN0b3JzLCBjYWxjdWxhdGUgdGhlIGRvdCBwcm9kdWN0XG4gICAqIFRoZSBzaXplIG9mIHRoZSBtYXRyaWNlcyBpcyBub3QgdmFsaWRhdGVkLlxuICAgKiBAcGFyYW0ge0FycmF5fSB4ICAgQSB2ZWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0geSAgIEEgdmVjdG9yXG4gICAqIEByZXR1cm4ge051bWJlcn0gZG90UHJvZHVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX211bHRpcGx5VmVjdG9yVmVjdG9yKHgsIHkpIHtcbiAgICAvLyBUT0RPOiBwZXJmb3JtYW5jZSBvZiBtYXRyaXggbXVsdGlwbGljYXRpb24gY2FuIGJlIGltcHJvdmVkXG4gICAgdmFyIGxlbiA9IHgubGVuZ3RoO1xuXG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG11bHRpcGx5IHR3byBlbXB0eSB2ZWN0b3JzJyk7XG4gICAgfVxuXG4gICAgdmFyIGRvdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZG90ID0gbWF0aC5hZGQoZG90LCBtYXRoLm11bHRpcGx5KHhbaV0sIHlbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0d28gY29tcGxleCBudW1iZXJzLiB4ICogeSBvciBtdWx0aXBseSh4LCB5KVxuICAgKiBAcGFyYW0ge0NvbXBsZXh9IHhcbiAgICogQHBhcmFtIHtDb21wbGV4fSB5XG4gICAqIEByZXR1cm4ge0NvbXBsZXggfCBOdW1iZXJ9IHJlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX211bHRpcGx5Q29tcGxleCAoeCwgeSkge1xuICAgIC8vIE5vdGU6IHdlIHRlc3Qgd2hldGhlciB4IG9yIHkgYXJlIHB1cmUgcmVhbCBvciBwdXJlIGNvbXBsZXgsXG4gICAgLy8gdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBOYU4gdmFsdWVzLiBGb3IgZXhhbXBsZSwgSW5maW5pdHkqaSBzaG91bGRcbiAgICAvLyByZXN1bHQgaW4gSW5maW5pdHkqaSwgYW5kIG5vdCBpbiBOYU4rSW5maW5pdHkqaVxuXG4gICAgaWYgKHguaW0gPT0gMCkge1xuICAgICAgLy8geCBpcyBwdXJlIHJlYWxcbiAgICAgIGlmICh5LmltID09IDApIHtcbiAgICAgICAgLy8geSBpcyBwdXJlIHJlYWxcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHgucmUgKiB5LnJlLCAwKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHkucmUgPT0gMCkge1xuICAgICAgICAvLyB5IGlzIHB1cmUgY29tcGxleFxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgeC5yZSAqIHkuaW1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB5IGhhcyBhIHJlYWwgYW5kIGNvbXBsZXggcGFydFxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICB4LnJlICogeS5yZSxcbiAgICAgICAgICAgIHgucmUgKiB5LmltXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHgucmUgPT0gMCkge1xuICAgICAgLy8geCBpcyBwdXJlIGNvbXBsZXhcbiAgICAgIGlmICh5LmltID09IDApIHtcbiAgICAgICAgLy8geSBpcyBwdXJlIHJlYWxcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHguaW0gKiB5LnJlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh5LnJlID09IDApIHtcbiAgICAgICAgLy8geSBpcyBwdXJlIGNvbXBsZXhcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KC14LmltICogeS5pbSwgMCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8geSBoYXMgYSByZWFsIGFuZCBjb21wbGV4IHBhcnRcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgLXguaW0gKiB5LmltLFxuICAgICAgICAgICAgeC5pbSAqIHkucmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB4IGhhcyBhIHJlYWwgYW5kIGNvbXBsZXggcGFydFxuICAgICAgaWYgKHkuaW0gPT0gMCkge1xuICAgICAgICAvLyB5IGlzIHB1cmUgcmVhbFxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICB4LnJlICogeS5yZSxcbiAgICAgICAgICAgIHguaW0gKiB5LnJlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh5LnJlID09IDApIHtcbiAgICAgICAgLy8geSBpcyBwdXJlIGNvbXBsZXhcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgLXguaW0gKiB5LmltLFxuICAgICAgICAgICAgeC5yZSAqIHkuaW1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB5IGhhcyBhIHJlYWwgYW5kIGNvbXBsZXggcGFydFxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICB4LnJlICogeS5yZSAtIHguaW0gKiB5LmltLFxuICAgICAgICAgICAgeC5yZSAqIHkuaW0gKyB4LmltICogeS5yZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgIGFycmF5ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3V0aWwvYXJyYXknKSxcbiAgICAgICAgICBcbiAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpLFxuICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBub3JtIG9mIGEgbnVtYmVyLCB2ZWN0b3Igb3IgbWF0cml4LlxuICAgKlxuICAgKiBUaGUgc2Vjb25kIHBhcmFtZXRlciBwIGlzIG9wdGlvbmFsLiBJZiBub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvIDIuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5ub3JtKHgpXG4gICAqICAgIG1hdGgubm9ybSh4LCBwKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hYnMoLTMuNSk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMy41XG4gICAqICAgIG1hdGgubm9ybSgtMy41KTsgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDMuNVxuICAgKlxuICAgKiAgICBtYXRoLm5vcm0obWF0aC5jb21wbGV4KDMsIC00KSk7ICAgICAgICAgLy8gcmV0dXJucyA1XG4gICAqXG4gICAqICAgIG1hdGgubm9ybShbMSwgMiwgLTNdLCBJbmZpbml0eSk7ICAgICAgICAvLyByZXR1cm5zIDNcbiAgICogICAgbWF0aC5ub3JtKFsxLCAyLCAtM10sIC1JbmZpbml0eSk7ICAgICAgIC8vIHJldHVybnMgMVxuICAgKlxuICAgKiAgICBtYXRoLm5vcm0oWzMsIDRdLCAyKTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyA1XG4gICAqXG4gICAqICAgIG1hdGgubm9ybShbWzEsIDJdLCBbMywgNF1dLCAxKSAgICAgICAgICAvLyByZXR1cm5zIDZcbiAgICogICAgbWF0aC5ub3JtKFtbMSwgMl0sIFszLCA0XV0sICdpbmYnKTsgICAgIC8vIHJldHVybnMgN1xuICAgKiAgICBtYXRoLm5vcm0oW1sxLCAyXSwgWzMsIDRdXSwgJ2ZybycpOyAgICAgLy8gcmV0dXJucyA1LjQ3NzIyNTU3NTA1MTY2MVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYWJzXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBCb29sZWFuIHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4XG4gICAqICAgICAgICAgICAgVmFsdWUgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgbm9ybVxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBTdHJpbmd9IFtwPTJdXG4gICAqICAgICAgICAgICAgVmVjdG9yIHNwYWNlLlxuICAgKiAgICAgICAgICAgIFN1cHBvcnRlZCBudW1iZXJzIGluY2x1ZGUgSW5maW5pdHkgYW5kIC1JbmZpbml0eS5cbiAgICogICAgICAgICAgICBTdXBwb3J0ZWQgc3RyaW5ncyBhcmU6ICdpbmYnLCAnLWluZicsIGFuZCAnZnJvJyAoVGhlIEZyb2Jlbml1cyBub3JtKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBwLW5vcm1cbiAgICovXG4gIG1hdGgubm9ybSA9IGZ1bmN0aW9uIG5vcm0oeCwgcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCBhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2FicycsIGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgLy8gbm9ybSh4KSA9IGFicyh4KVxuICAgICAgcmV0dXJuIE1hdGguYWJzKHgpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIC8vIGlnbm9yZSBwLCBjb21wbGV4IG51bWJlcnNcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoeC5yZSAqIHgucmUgKyB4LmltICogeC5pbSk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIG5vcm0oeCkgPSBhYnMoeClcbiAgICAgIHJldHVybiB4LmFicygpO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgLy8gbm9ybSh4KSA9IGFicyh4KVxuICAgICAgcmV0dXJuIE1hdGguYWJzKHgpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KHgpKSB7XG4gICAgICAvLyBzaXplXG4gICAgICB2YXIgc2l6ZVggPSBhcnJheS5zaXplKHgpO1xuICAgICAgLy8gbWlzc2luZyBwXG4gICAgICBpZiAocCA9PSBudWxsKVxuICAgICAgICBwID0gMjtcbiAgICAgIC8vIGNoZWNrIGl0IGlzIGEgVmVjdG9yXG4gICAgICBpZiAoc2l6ZVgubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gY2hlY2sgcFxuICAgICAgICBpZiAocCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IHAgPT09ICdpbmYnKSB7XG4gICAgICAgICAgLy8gbm9ybSh4LCBJbmZpbml0eSkgPSBtYXgoYWJzKHgpKVxuICAgICAgICAgIHZhciBuO1xuICAgICAgICAgIG1hdGguZm9yRWFjaCh4LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2ID0gbWF0aC5hYnModmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFuIHx8IG1hdGgubGFyZ2VyKHYsIG4pKVxuICAgICAgICAgICAgICBuID0gdjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIHx8IHAgPT09ICctaW5mJykge1xuICAgICAgICAgIC8vIG5vcm0oeCwgLUluZmluaXR5KSA9IG1pbihhYnMoeCkpXG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgbWF0aC5mb3JFYWNoKHgsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHYgPSBtYXRoLmFicyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIW4gfHwgbWF0aC5zbWFsbGVyKHYsIG4pKVxuICAgICAgICAgICAgICBuID0gdjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA9PT0gJ2ZybycpXG4gICAgICAgICAgICByZXR1cm4gbm9ybSh4KTtcbiAgICAgICAgaWYgKGlzTnVtYmVyKHApICYmICFpc05hTihwKSkge1xuICAgICAgICAgIC8vIGNoZWNrIHAgIT0gMFxuICAgICAgICAgIGlmICghbWF0aC5lcXVhbChwLCAwKSkge1xuICAgICAgICAgICAgLy8gbm9ybSh4LCBwKSA9IHN1bShhYnMoeGkpIF4gcCkgXiAxL3BcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIG1hdGguZm9yRWFjaCh4LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgbiA9IG1hdGguYWRkKG1hdGgucG93KG1hdGguYWJzKHZhbHVlKSwgcCksIG4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5wb3cobiwgMSAvIHApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludmFsaWQgcGFyYW1ldGVyIHZhbHVlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcGFyYW1ldGVyIHZhbHVlJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzaXplWC5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBjaGVjayBwXG4gICAgICAgIGlmIChwID09IDEpIHtcbiAgICAgICAgICAvLyBub3JtKHgpID0gdGhlIGxhcmdlc3QgY29sdW1uIHN1bVxuICAgICAgICAgIHZhciBjID0gW107XG4gICAgICAgICAgLy8gbG9vcCByb3dzXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgciA9IHhbaV07XG4gICAgICAgICAgICAvLyBsb29wIGNvbHVtbnNcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBjW2pdID0gbWF0aC5hZGQoY1tqXSB8fCAwLCBtYXRoLmFicyhyW2pdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXRoLm1heChjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgcCA9PT0gJ2luZicpIHtcbiAgICAgICAgICAvLyBub3JtKHgpID0gdGhlIGxhcmdlc3Qgcm93IHN1bVxuICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAvLyBsb29wIHJvd3NcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBycyA9IDA7XG4gICAgICAgICAgICB2YXIgciA9IHhbaV07XG4gICAgICAgICAgICAvLyBsb29wIGNvbHVtbnNcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBycyA9IG1hdGguYWRkKHJzLCBtYXRoLmFicyhyW2pdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0aC5sYXJnZXIocnMsIG4pKVxuICAgICAgICAgICAgICBuID0gcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSAnZnJvJykge1xuICAgICAgICAgIC8vIG5vcm0oeCkgPSBzcXJ0KHN1bShkaWFnKHgneCkpKVxuICAgICAgICAgIHZhciBkID0gbWF0aC5kaWFnKG1hdGgubXVsdGlwbHkobWF0aC50cmFuc3Bvc2UoeCksIHgpKTtcbiAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgbWF0aC5mb3JFYWNoKGQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcyA9IG1hdGguYWRkKHZhbHVlLCBzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbWF0aC5zcXJ0KHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09IDIpIHtcbiAgICAgICAgICAvLyBub3QgaW1wbGVtZW50ZWRcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHBhcmFtZXRlciB2YWx1ZSwgbWlzc2luZyBpbXBsZW1lbnRhdGlvbiBvZiBtYXRyaXggc2luZ3VsYXIgdmFsdWUgZGVjb21wb3NpdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludmFsaWQgcGFyYW1ldGVyIHZhbHVlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcGFyYW1ldGVyIHZhbHVlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgIHJldHVybiBub3JtKHgudmFsdWVPZigpLCBwKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignbm9ybScsIHgpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGFycmF5ID0gdXRpbC5hcnJheSxcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgICBpc0ludGVnZXIgPSB1dGlsLm51bWJlci5pc0ludGVnZXIsXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleDtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcG93ZXIgb2YgeCB0byB5LCBgeCBeIHlgLlxuICAgKiBNYXRyaXggZXhwb25lbnRpYXRpb24gaXMgc3VwcG9ydGVkIGZvciBzcXVhcmUgbWF0cmljZXMgYHhgLCBhbmQgcG9zaXRpdmVcbiAgICogaW50ZWdlciBleHBvbmVudHMgYHlgLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgucG93KHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnBvdygyLCAzKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciA4XG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC5jb21wbGV4KDIsIDMpO1xuICAgKiAgICBtYXRoLnBvdyhhLCAyKSAgICAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggLTUgKyAxMmlcbiAgICpcbiAgICogICAgdmFyIGIgPSBbWzEsIDJdLCBbNCwgM11dO1xuICAgKiAgICBtYXRoLnBvdyhiLCAyKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIEFycmF5IFtbOSwgOF0sIFsxNiwgMTddXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbXVsdGlwbHksIHNxcnRcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggIFRoZSBiYXNlXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgbnVsbH0geSAgICAgICAgICAgICAgICAgICBUaGUgZXhwb25lbnRcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBUaGUgdmFsdWUgb2YgYHhgIHRvIHRoZSBwb3dlciBgeWBcbiAgICovXG4gIG1hdGgucG93ID0gZnVuY3Rpb24gcG93KHgsIHkpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcigncG93JywgYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICBpZiAoaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgaWYgKGlzSW50ZWdlcih5KSB8fCB4ID49IDApIHtcbiAgICAgICAgICAvLyByZWFsIHZhbHVlIGNvbXB1dGF0aW9uXG4gICAgICAgICAgcmV0dXJuIE1hdGgucG93KHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwb3dDb21wbGV4KG5ldyBDb21wbGV4KHgsIDApLCBuZXcgQ29tcGxleCh5LCAwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQ29tcGxleCh5KSkge1xuICAgICAgICByZXR1cm4gcG93Q29tcGxleChuZXcgQ29tcGxleCh4LCAwKSwgeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIHJldHVybiBwb3dDb21wbGV4KHgsIG5ldyBDb21wbGV4KHksIDApKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQ29tcGxleCh5KSkge1xuICAgICAgICByZXR1cm4gcG93Q29tcGxleCh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgLy8gdHJ5IHRvIHVwZ3JhZGUgeSB0byB0byBiaWdudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICB5ID0gQmlnTnVtYmVyLmNvbnZlcnQoeSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeSkgfHwgeSA9PT0gbnVsbCkge1xuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcih5ID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoeSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICBpZiAoeS5pc0ludGVnZXIoKSAmJiAheC5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICByZXR1cm4geC5wb3coeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gZG93bmdyYWRlIHRvIG51bWJlciB0byBkbyBjb21wbGV4IHZhbHVlZCBjb21wdXRhdGlvblxuICAgICAgICAgIHJldHVybiBwb3coeC50b051bWJlcigpLCB5LnRvTnVtYmVyKCkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBmYWlsZWQgdG8gdXBncmFkZSB5IHRvIGJpZ251bWJlciwgbGV0cyBkb3duZ3JhZGUgeCB0byBudW1iZXJcbiAgICAgICAgcmV0dXJuIHBvdyh4LnRvTnVtYmVyKCksIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh5IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyB0cnkgdG8gY29udmVydCB4IHRvIGJpZ251bWJlclxuICAgICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICAgIHggPSBCaWdOdW1iZXIuY29udmVydCh4KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHggPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIGlmICh5LmlzSW50ZWdlcigpICYmICF4LmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgIHJldHVybiB4LnBvdyh5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBkb3duZ3JhZGUgdG8gbnVtYmVyIHRvIGRvIGNvbXBsZXggdmFsdWVkIGNvbXB1dGF0aW9uXG4gICAgICAgICAgcmV0dXJuIHBvdyh4LnRvTnVtYmVyKCksIHkudG9OdW1iZXIoKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGZhaWxlZCB0byB1cGdyYWRlIHggdG8gYmlnbnVtYmVyLCBsZXRzIGRvd25ncmFkZSB5IHRvIG51bWJlclxuICAgICAgICByZXR1cm4gcG93KHgsIHkudG9OdW1iZXIoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoeCkpIHtcbiAgICAgIGlmICghaXNOdW1iZXIoeSkgfHwgIWlzSW50ZWdlcih5KSB8fCB5IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGb3IgQV5iLCBiIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyICcgK1xuICAgICAgICAgICAgJyh2YWx1ZSBpcyAnICsgeSArICcpJyk7XG4gICAgICB9XG4gICAgICAvLyB2ZXJpZnkgdGhhdCBBIGlzIGEgMiBkaW1lbnNpb25hbCBzcXVhcmUgbWF0cml4XG4gICAgICB2YXIgcyA9IGFycmF5LnNpemUoeCk7XG4gICAgICBpZiAocy5sZW5ndGggIT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvciBBXmIsIEEgbXVzdCBiZSAyIGRpbWVuc2lvbmFsICcgK1xuICAgICAgICAgICAgJyhBIGhhcyAnICsgcy5sZW5ndGggKyAnIGRpbWVuc2lvbnMpJyk7XG4gICAgICB9XG4gICAgICBpZiAoc1swXSAhPSBzWzFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm9yIEFeYiwgQSBtdXN0IGJlIHNxdWFyZSAnICtcbiAgICAgICAgICAgICcoc2l6ZSBpcyAnICsgc1swXSArICd4JyArIHNbMV0gKyAnKScpO1xuICAgICAgfVxuXG4gICAgICAvLyBjb21wdXRlIHBvd2VyIG9mIG1hdHJpeFxuICAgICAgdmFyIHJlcyA9IG1hdGguZXllKHNbMF0pLnZhbHVlT2YoKTtcbiAgICAgIHZhciBweCA9IHg7XG4gICAgICB3aGlsZSAoeSA+PSAxKSB7XG4gICAgICAgIGlmICgoeSAmIDEpID09IDEpIHtcbiAgICAgICAgICByZXMgPSBtYXRoLm11bHRpcGx5KHB4LCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIHkgPj49IDE7XG4gICAgICAgIHB4ID0gbWF0aC5tdWx0aXBseShweCwgcHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZWxzZSBpZiAoeCBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgocG93KHgudmFsdWVPZigpLCB5KSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gcG93KCt4LCB5KTtcbiAgICB9XG4gICAgaWYgKGlzQm9vbGVhbih5KSB8fCB5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gcG93KHgsICt5KTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcigncG93JywgbWF0aFsndHlwZW9mJ10oeCksIG1hdGhbJ3R5cGVvZiddKHkpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcG93ZXIgb2YgeCB0byB5LCB4XnksIGZvciB0d28gY29tcGxleCBudW1iZXJzLlxuICAgKiBAcGFyYW0ge0NvbXBsZXh9IHhcbiAgICogQHBhcmFtIHtDb21wbGV4fSB5XG4gICAqIEByZXR1cm4ge0NvbXBsZXh9IHJlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcG93Q29tcGxleCAoeCwgeSkge1xuICAgIC8vIGNvbXBsZXggY29tcHV0YXRpb25cbiAgICAvLyB4XnkgPSBleHAobG9nKHgpKnkpID0gZXhwKChhYnMoeCkraSphcmcoeCkpKnkpXG4gICAgdmFyIHRlbXAxID0gbWF0aC5sb2coeCk7XG4gICAgdmFyIHRlbXAyID0gbWF0aC5tdWx0aXBseSh0ZW1wMSwgeSk7XG4gICAgcmV0dXJuIG1hdGguZXhwKHRlbXAyKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzSW50ZWdlciA9IHV0aWwubnVtYmVyLmlzSW50ZWdlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBSb3VuZCBhIHZhbHVlIHRvd2FyZHMgdGhlIG5lYXJlc3QgaW50ZWdlci5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnJvdW5kKHgpXG4gICAqICAgIG1hdGgucm91bmQoeCwgbilcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgucm91bmQoMy4yKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDNcbiAgICogICAgbWF0aC5yb3VuZCgzLjgpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgNFxuICAgKiAgICBtYXRoLnJvdW5kKC00LjIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAtNFxuICAgKiAgICBtYXRoLnJvdW5kKC00LjcpOyAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAtNVxuICAgKiAgICBtYXRoLnJvdW5kKG1hdGgucGksIDMpOyAgICAgICAvLyByZXR1cm5zIE51bWJlciAzLjE0XG4gICAqICAgIG1hdGgucm91bmQoMTIzLjQ1Njc4LCAyKTsgICAgIC8vIHJldHVybnMgTnVtYmVyIDEyMy40NlxuICAgKlxuICAgKiAgICB2YXIgYyA9IG1hdGguY29tcGxleCgzLjIsIC0yLjcpO1xuICAgKiAgICBtYXRoLnJvdW5kKGMpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMyAtIDNpXG4gICAqXG4gICAqICAgIG1hdGgucm91bmQoWzMuMiwgMy44LCAtNC43XSk7IC8vIHJldHVybnMgQXJyYXkgWzMsIDQsIC01XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY2VpbCwgZml4LCBmbG9vclxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCAgIE51bWJlciB0byBiZSByb3VuZGVkXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBBcnJheSB8IG51bGx9IFtuPTBdICAgICAgICAgICAgICAgICBOdW1iZXIgb2YgZGVjaW1hbHNcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBSb3VuZGVkIHZhbHVlXG4gICAqL1xuICBtYXRoLnJvdW5kID0gZnVuY3Rpb24gcm91bmQoeCwgbikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEgJiYgYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcigncm91bmQnLCBhcmd1bWVudHMubGVuZ3RoLCAxLCAyKTtcbiAgICB9XG5cbiAgICBpZiAobiA9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJvdW5kICh4KVxuICAgICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNDb21wbGV4KHgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleCAoXG4gICAgICAgICAgICBNYXRoLnJvdW5kKHgucmUpLFxuICAgICAgICAgICAgTWF0aC5yb3VuZCh4LmltKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICByZXR1cm4geC50b0RlY2ltYWxQbGFjZXMoMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0NvbGxlY3Rpb24oeCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCByb3VuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh4KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ3JvdW5kJywgbWF0aFsndHlwZW9mJ10oeCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHJvdW5kICh4LCBuKVxuICAgICAgaWYgKCFpc051bWJlcihuKSB8fCAhaXNJbnRlZ2VyKG4pKSB7XG4gICAgICAgIGlmIChuIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgICAgbiA9IHBhcnNlRmxvYXQobi52YWx1ZU9mKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbihuKSB8fCB4ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsICtuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOdW1iZXIgb2YgZGVjaW1hbHMgaW4gZnVuY3Rpb24gcm91bmQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMCB8fCBuID4gMTUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yICgnTnVtYmVyIG9mIGRlY2ltYWxzIGluIGZ1bmN0aW9uIHJvdW5kIG11c3QgYmUgaW4gdGUgcmFuZ2Ugb2YgMC0xNScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kTnVtYmVyKHgsIG4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNDb21wbGV4KHgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleCAoXG4gICAgICAgICAgICByb3VuZE51bWJlcih4LnJlLCBuKSxcbiAgICAgICAgICAgIHJvdW5kTnVtYmVyKHguaW0sIG4pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB4LnRvRGVjaW1hbFBsYWNlcyhuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQ29sbGVjdGlvbih4KSB8fCBpc0NvbGxlY3Rpb24obikpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcDIoeCwgbiwgcm91bmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNCb29sZWFuKHgpIHx8IHggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKCt4LCBuKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ3JvdW5kJywgbWF0aFsndHlwZW9mJ10oeCksIG1hdGhbJ3R5cGVvZiddKG4pKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHJvdW5kIGEgbnVtYmVyIHRvIHRoZSBnaXZlbiBudW1iZXIgb2YgZGVjaW1hbHMsIG9yIHRvIHplcm8gaWYgZGVjaW1hbHMgaXNcbiAgICogbm90IHByb3ZpZGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVjaW1hbHMgICAgICAgbnVtYmVyIG9mIGRlY2ltYWxzLCBiZXR3ZWVuIDAgYW5kIDE1ICgwIGJ5IGRlZmF1bHQpXG4gICAqIEByZXR1cm4ge051bWJlcn0gcm91bmRlZFZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiByb3VuZE51bWJlciAodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgdmFyIHAgPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogcCkgLyBwO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBudW1iZXIgPSB1dGlsLm51bWJlcixcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgc2lnbiBvZiBhIHZhbHVlLiBUaGUgc2lnbiBvZiBhIHZhbHVlIHggaXM6XG4gICAqXG4gICAqIC0gIDEgd2hlbiB4ID4gMVxuICAgKiAtIC0xIHdoZW4geCA8IDBcbiAgICogLSAgMCB3aGVuIHggPT0gMFxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc2lnbih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5zaWduKDMuNSk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyAxXG4gICAqICAgIG1hdGguc2lnbigtNC4yKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgLTFcbiAgICogICAgbWF0aC5zaWduKDApOyAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAwXG4gICAqXG4gICAqICAgIG1hdGguc2lnbihbMywgNSwgLTIsIDAsIDJdKTsgIC8vIHJldHVybnMgWzEsIDEsIC0xLCAwLCAxXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYWJzXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4XG4gICAqICAgICAgICAgICAgVGhlIG51bWJlciBmb3Igd2hpY2ggdG8gZGV0ZXJtaW5lIHRoZSBzaWduXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH1lXG4gICAqICAgICAgICAgICAgVGhlIHNpZ24gb2YgYHhgXG4gICAqL1xuICBtYXRoLnNpZ24gPSBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignc2lnbicsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgcmV0dXJuIG51bWJlci5zaWduKHgpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIHZhciBhYnMgPSBNYXRoLnNxcnQoeC5yZSAqIHgucmUgKyB4LmltICogeC5pbSk7XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoeC5yZSAvIGFicywgeC5pbSAvIGFicyk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHguY21wKDApKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHgsIHNpZ24pO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bWJlci5zaWduKHgpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdzaWduJywgbWF0aFsndHlwZW9mJ10oeCkpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNxdWFyZSByb290IG9mIGEgdmFsdWUuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5zcXJ0KHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnNxcnQoMjUpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDVcbiAgICogICAgbWF0aC5zcXVhcmUoNSk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyAyNVxuICAgKiAgICBtYXRoLnNxcnQoLTQpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggLTJpXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBzcXVhcmUsIG11bHRpcGx5XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHhcbiAgICogICAgICAgICAgICBWYWx1ZSBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBzcXVhcmUgcm9vdC5cbiAgICogQHJldHVybiB7TnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fVxuICAgKiAgICAgICAgICAgIFJldHVybnMgdGhlIHNxdWFyZSByb290IG9mIGB4YFxuICAgKi9cbiAgbWF0aC5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdzcXJ0JywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICBpZiAoeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoeCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNxcnQobmV3IENvbXBsZXgoeCwgMCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHgucmUgKiB4LnJlICsgeC5pbSAqIHguaW0pO1xuXG4gICAgICB2YXIgcmUsIGltO1xuXG4gICAgICBpZiAoeC5yZSA+PSAwKSB7XG4gICAgICAgIHJlID0gMC41ICogTWF0aC5zcXJ0KDIuMCAqIChyICsgeC5yZSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlID0gTWF0aC5hYnMoeC5pbSkgLyBNYXRoLnNxcnQoMiAqIChyIC0geC5yZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeC5yZSA8PSAwKSB7XG4gICAgICAgIGltID0gMC41ICogTWF0aC5zcXJ0KDIuMCAqIChyIC0geC5yZSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGltID0gTWF0aC5hYnMoeC5pbSkgLyBNYXRoLnNxcnQoMiAqIChyICsgeC5yZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeC5pbSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChyZSwgaW0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChyZSwgLWltKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgaWYgKHguaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIC8vIG5lZ2F0aXZlIHZhbHVlIC0+IGRvd25ncmFkZSB0byBudW1iZXIgdG8gZG8gY29tcGxleCB2YWx1ZSBjb21wdXRhdGlvblxuICAgICAgICByZXR1cm4gc3FydCh4LnRvTnVtYmVyKCkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB4LnNxcnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHgsIHNxcnQpO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNxcnQoK3gpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdzcXJ0JywgbWF0aFsndHlwZW9mJ10oeCkpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBzcXVhcmUgb2YgYSB2YWx1ZSwgYHggKiB4YC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnNxdWFyZSh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5zcXVhcmUoMik7ICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciA0XG4gICAqICAgIG1hdGguc3F1YXJlKDMpOyAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgOVxuICAgKiAgICBtYXRoLnBvdygzLCAyKTsgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDlcbiAgICogICAgbWF0aC5tdWx0aXBseSgzLCAzKTsgICAgICAvLyByZXR1cm5zIE51bWJlciA5XG4gICAqXG4gICAqICAgIG1hdGguc3F1YXJlKFsxLCAyLCAzLCA0XSk7ICAvLyByZXR1cm5zIEFycmF5IFsxLCA0LCA5LCAxNl1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIG11bHRpcGx5LCBjdWJlLCBzcXJ0LCBwb3dcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHhcbiAgICogICAgICAgICAgICBOdW1iZXIgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgc3F1YXJlXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH1cbiAgICogICAgICAgICAgICBTcXVhcmVkIHZhbHVlXG4gICAqL1xuICBtYXRoLnNxdWFyZSA9IGZ1bmN0aW9uIHNxdWFyZSh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3NxdWFyZScsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgcmV0dXJuIHggKiB4O1xuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIHJldHVybiBtYXRoLm11bHRpcGx5KHgsIHgpO1xuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICByZXR1cm4geC50aW1lcyh4KTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHgsIHNxdWFyZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4geCAqIHg7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ3NxdWFyZScsIG1hdGhbJ3R5cGVvZiddKHgpKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpLFxuICAgICAgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxuICAgICAgaXNVbml0ID0gVW5pdC5pc1VuaXQsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogU3VidHJhY3QgdHdvIHZhbHVlcywgYHggLSB5YC5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnN1YnRyYWN0KHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnN1YnRyYWN0KDUuMywgMik7ICAgICAgICAvLyByZXR1cm5zIE51bWJlciAzLjNcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLmNvbXBsZXgoMiwgMyk7XG4gICAqICAgIHZhciBiID0gbWF0aC5jb21wbGV4KDQsIDEpO1xuICAgKiAgICBtYXRoLnN1YnRyYWN0KGEsIGIpOyAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggLTIgKyAyaVxuICAgKlxuICAgKiAgICBtYXRoLnN1YnRyYWN0KFs1LCA3LCA0XSwgNCk7ICAvLyByZXR1cm5zIEFycmF5IFsxLCAzLCAwXVxuICAgKlxuICAgKiAgICB2YXIgYyA9IG1hdGgudW5pdCgnMi4xIGttJyk7XG4gICAqICAgIHZhciBkID0gbWF0aC51bml0KCc1MDBtJyk7XG4gICAqICAgIG1hdGguc3VidHJhY3QoYywgZCk7ICAgICAgICAgIC8vIHJldHVybnMgVW5pdCAxLjYga21cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGFkZFxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHhcbiAgICogICAgICAgICAgICBJbml0aWFsIHZhbHVlXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geVxuICAgKiAgICAgICAgICAgIFZhbHVlIHRvIHN1YnRyYWN0IGZyb20gYHhgXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9XG4gICAqICAgICAgICAgICAgU3VidHJhY3Rpb24gb2YgYHhgIGFuZCBgeWBcbiAgICovXG4gIG1hdGguc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdCh4LCB5KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3N1YnRyYWN0JywgYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICBpZiAoaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgLy8gbnVtYmVyIC0gbnVtYmVyXG4gICAgICAgIHJldHVybiB4IC0geTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQ29tcGxleCh5KSkge1xuICAgICAgICAvLyBudW1iZXIgLSBjb21wbGV4XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleCAoXG4gICAgICAgICAgICB4IC0geS5yZSxcbiAgICAgICAgICAgIC0geS5pbVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICAvLyBjb21wbGV4IC0gbnVtYmVyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleCAoXG4gICAgICAgICAgICB4LnJlIC0geSxcbiAgICAgICAgICAgIHguaW1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNDb21wbGV4KHkpKSB7XG4gICAgICAgIC8vIGNvbXBsZXggLSBjb21wbGV4XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleCAoXG4gICAgICAgICAgICB4LnJlIC0geS5yZSxcbiAgICAgICAgICAgIHguaW0gLSB5LmltXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdG8gYmlnIG51bWJlclxuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIHkgPSBCaWdOdW1iZXIuY29udmVydCh5KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbih5KSB8fCB5ID09PSBudWxsKSB7XG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHkgPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xuICAgICAgfVxuXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gc3VidHJhY3QoeC50b051bWJlcigpLCB5KTtcbiAgICB9XG4gICAgaWYgKHkgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHRvIGJpZyBudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgICB4ID0gQmlnTnVtYmVyLmNvbnZlcnQoeCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih4ID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICByZXR1cm4geC5taW51cyh5KVxuICAgICAgfVxuXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gc3VidHJhY3QoeCwgeS50b051bWJlcigpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNVbml0KHgpKSB7XG4gICAgICBpZiAoaXNVbml0KHkpKSB7XG4gICAgICAgIGlmICh4LnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciB4IGNvbnRhaW5zIGEgdW5pdCB3aXRoIHVuZGVmaW5lZCB2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyIHkgY29udGFpbnMgYSB1bml0IHdpdGggdW5kZWZpbmVkIHZhbHVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXguZXF1YWxCYXNlKHkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbml0cyBkbyBub3QgbWF0Y2gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXMgPSB4LmNsb25lKCk7XG4gICAgICAgIHJlcy52YWx1ZSAtPSB5LnZhbHVlO1xuICAgICAgICByZXMuZml4UHJlZml4ID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpIHx8IGlzQ29sbGVjdGlvbih5KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcDIoeCwgeSwgc3VidHJhY3QpO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN1YnRyYWN0KCt4LCB5KTtcbiAgICB9XG4gICAgaWYgKGlzQm9vbGVhbih5KSB8fCB5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3VidHJhY3QoeCwgK3kpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdzdWJ0cmFjdCcsIG1hdGhbJ3R5cGVvZiddKHgpLCBtYXRoWyd0eXBlb2YnXSh5KSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoLCBjb25maWcpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNTdHJpbmcgPSB1dGlsLnN0cmluZy5pc1N0cmluZyxcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxuICAgICAgaXNVbml0ID0gVW5pdC5pc1VuaXQsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogSW52ZXJzZSB0aGUgc2lnbiBvZiBhIHZhbHVlLCBhcHBseSBhIHVuYXJ5IG1pbnVzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS4gQm9vbGVhbiB2YWx1ZXMgYW5kXG4gICAqIHN0cmluZ3Mgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBudW1iZXIuIEZvciBjb21wbGV4IG51bWJlcnMsIGJvdGggcmVhbCBhbmRcbiAgICogY29tcGxleCB2YWx1ZSBhcmUgaW52ZXJ0ZWQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC51bmFyeU1pbnVzKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnVuYXJ5TWludXMoMy41KTsgICAgICAvLyByZXR1cm5zIC0zLjVcbiAgICogICAgbWF0aC51bmFyeU1pbnVzKC00LjIpOyAgICAgLy8gcmV0dXJucyA0LjJcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGFkZCwgc3VidHJhY3QsIHVuYXJ5UGx1c1xuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgU3RyaW5nIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggTnVtYmVyIHRvIGJlIGludmVydGVkLlxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSBSZXR1cm5zIHRoZSB2YWx1ZSB3aXRoIGludmVydGVkIHNpZ24uXG4gICAqL1xuICBtYXRoLnVuYXJ5TWludXMgPSBmdW5jdGlvbiB1bmFyeU1pbnVzKHgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcigndW5hcnlNaW51cycsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgcmV0dXJuIC14O1xuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAteC5yZSxcbiAgICAgICAgICAteC5pbVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuIHgubmVnKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5pdCh4KSkge1xuICAgICAgdmFyIHJlcyA9IHguY2xvbmUoKTtcbiAgICAgIHJlcy52YWx1ZSA9IC14LnZhbHVlO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHgsIHVuYXJ5TWludXMpO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgaXNTdHJpbmcoeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgLy8gY29udmVydCB0byBhIG51bWJlciBvciBiaWdudW1iZXJcbiAgICAgIHJldHVybiAoY29uZmlnLm51bWJlciA9PSAnYmlnbnVtYmVyJykgPyBuZXcgQmlnTnVtYmVyKC14KTogLXg7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ3VuYXJ5TWludXMnLCBtYXRoWyd0eXBlb2YnXSh4KSk7XG4gIH07XG5cbiAgLy8gVE9ETzogZnVuY3Rpb24gdW5hcnkgaXMgcmVuYW1lZCB0byB1bmFyeU1pbnVzIHNpbmNlIHZlcnNpb24gMC4yMy4wLiBDbGVhbnVwIHNvbWUgZGF5XG4gIG1hdGgudW5hcnkgPSBmdW5jdGlvbiB1bmFyeSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIHVuYXJ5IGlzIGRlcHJlY2F0ZWQuIFVzZSB1bmFyeU1pbnVzIGluc3RlYWQuJyk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgsIGNvbmZpZykge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIFVuaXQgPSByZXF1aXJlKCcuLi8uLi90eXBlL1VuaXQnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc1VuaXQgPSBVbml0LmlzVW5pdCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBVbmFyeSBwbHVzIG9wZXJhdGlvbi5cbiAgICogQm9vbGVhbiB2YWx1ZXMgYW5kIHN0cmluZ3Mgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBudW1iZXIsIG51bWVyaWMgdmFsdWVzIHdpbGwgYmUgcmV0dXJuZWQgYXMgaXMuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC51bmFyeVBsdXMoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgudW5hcnlQbHVzKDMuNSk7ICAgICAgLy8gcmV0dXJucyAzLjVcbiAgICogICAgbWF0aC51bmFyeVBsdXMoMSk7ICAgICAvLyByZXR1cm5zIDFcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHVuYXJ5TWludXMsIGFkZCwgc3VidHJhY3RcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IFN0cmluZyB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4XG4gICAqICAgICAgICAgICAgSW5wdXQgdmFsdWVcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH1cbiAgICogICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnB1dCB2YWx1ZSB3aGVuIG51bWVyaWMsIGNvbnZlcnRzIHRvIGEgbnVtYmVyIHdoZW4gaW5wdXQgaXMgbm9uLW51bWVyaWMuXG4gICAqL1xuICBtYXRoLnVuYXJ5UGx1cyA9IGZ1bmN0aW9uIHVuYXJ5UGx1cyh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3VuYXJ5UGx1cycsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgcmV0dXJuIHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5pdCh4KSkge1xuICAgICAgcmV0dXJuIHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHgsIHVuYXJ5UGx1cyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCBpc1N0cmluZyh4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICAvLyBjb252ZXJ0IHRvIGEgbnVtYmVyIG9yIGJpZ251bWJlclxuICAgICAgcmV0dXJuIChjb25maWcubnVtYmVyID09ICdiaWdudW1iZXInKSA/IG5ldyBCaWdOdW1iZXIoK3gpOiAreDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcigndW5hcnlQbHVzJywgbWF0aFsndHlwZW9mJ10oeCkpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCwgY29uZmlnKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpLFxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0ludGVnZXIgPSB1dGlsLm51bWJlci5pc0ludGVnZXI7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXh0ZW5kZWQgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3IgZm9yIHR3byB2YWx1ZXMuXG4gICAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4dGVuZGVkX0V1Y2xpZGVhbl9hbGdvcml0aG0uXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC54Z2NkKGEsIGIpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnhnY2QoOCwgMTIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIFs0LCAtMSwgMV1cbiAgICogICAgbWF0aC5nY2QoOCwgMTIpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyA0XG4gICAqICAgIG1hdGgueGdjZCgzNjE2MywgMjExOTkpOyAgICAgIC8vIHJldHVybnMgWzEyNDcsIC03LCAxMl1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGdjZCwgbGNtXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbn0gYSAgQW4gaW50ZWdlciBudW1iZXJcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFufSBiICBBbiBpbnRlZ2VyIG51bWJlclxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyAzIGludGVnZXJzIGBbZGl2LCBtLCBuXWBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSBgZGl2ID0gZ2NkKGEsIGIpYCBhbmQgYGEqbSArIGIqbiA9IGRpdmBcbiAgICovXG4gIG1hdGgueGdjZCA9IGZ1bmN0aW9uIHhnY2QoYSwgYikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgIC8vIHR3byBhcmd1bWVudHNcbiAgICAgIGlmIChpc051bWJlcihhKSAmJiBpc051bWJlcihiKSkge1xuICAgICAgICBpZiAoIWlzSW50ZWdlcihhKSB8fCAhaXNJbnRlZ2VyKGIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIHhnY2QgbXVzdCBiZSBpbnRlZ2VyIG51bWJlcnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfeGdjZChhLCBiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdG8gYmlnIG51bWJlclxuICAgICAgICBpZiAoaXNOdW1iZXIoYikpIHtcbiAgICAgICAgICBiID0gQmlnTnVtYmVyLmNvbnZlcnQoYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKGIpIHx8IGIgPT09IG51bGwpIHtcbiAgICAgICAgICBiID0gbmV3IEJpZ051bWJlcihiID8gMSA6IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gX2JpZ1hnY2QoYSwgYik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICAgIHJldHVybiB4Z2NkKGEudG9OdW1iZXIoKSwgYik7XG4gICAgICB9XG4gICAgICBpZiAoYiBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICAvLyB0cnkgdG8gY29udmVydCB0byBiaWcgbnVtYmVyXG4gICAgICAgIGlmIChpc051bWJlcihhKSkge1xuICAgICAgICAgIGEgPSBCaWdOdW1iZXIuY29udmVydChhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oYSkgfHwgYSA9PT0gbnVsbCkge1xuICAgICAgICAgIGEgPSBuZXcgQmlnTnVtYmVyKGEgPyAxIDogMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICAgIHJldHVybiBfYmlnWGdjZChhLCBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgICAgcmV0dXJuIHhnY2QoYS50b051bWJlcigpLCBiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQm9vbGVhbihhKSB8fCBhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB4Z2NkKCthLCBiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Jvb2xlYW4oYikgfHwgYiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geGdjZChhLCArYik7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCd4Z2NkJywgbWF0aFsndHlwZW9mJ10oYSksIG1hdGhbJ3R5cGVvZiddKGIpKTtcbiAgICB9XG5cbiAgICAvLyB6ZXJvIG9yIG9uZSBhcmd1bWVudFxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRnVuY3Rpb24geGdjZCBleHBlY3RzIHR3byBhcmd1bWVudHMnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHhnY2QgZm9yIHR3byBudW1iZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAqIEByZXR1cm4ge051bWJlcn0gcmVzdWx0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfeGdjZChhLCBiKSB7XG4gICAgLy8gc291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4dGVuZGVkX0V1Y2xpZGVhbl9hbGdvcml0aG1cbiAgICB2YXIgdCwgLy8gdXNlZCB0byBzd2FwIHR3byB2YXJpYWJsZXNcbiAgICAgICAgcSwgLy8gcXVvdGllbnRcbiAgICAgICAgciwgLy8gcmVtYWluZGVyXG4gICAgICAgIHggPSAwLCBsYXN0eCA9IDEsXG4gICAgICAgIHkgPSAxLCBsYXN0eSA9IDA7XG5cbiAgICB3aGlsZSAoYikge1xuICAgICAgcSA9IE1hdGguZmxvb3IoYSAvIGIpO1xuICAgICAgciA9IGEgJSBiO1xuXG4gICAgICB0ID0geDtcbiAgICAgIHggPSBsYXN0eCAtIHEgKiB4O1xuICAgICAgbGFzdHggPSB0O1xuXG4gICAgICB0ID0geTtcbiAgICAgIHkgPSBsYXN0eSAtIHEgKiB5O1xuICAgICAgbGFzdHkgPSB0O1xuXG4gICAgICBhID0gYjtcbiAgICAgIGIgPSByO1xuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEgPCAwKSB7XG4gICAgICByZXMgPSBbLWEsIC1sYXN0eCwgLWxhc3R5XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXMgPSBbYSwgYSA/IGxhc3R4IDogMCwgbGFzdHldO1xuICAgIH1cbiAgICByZXR1cm4gKGNvbmZpZy5tYXRyaXggPT09ICdhcnJheScpID8gcmVzIDogbmV3IE1hdHJpeChyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB4Z2NkIGZvciB0d28gQmlnTnVtYmVyc1xuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gYVxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gYlxuICAgKiBAcmV0dXJuIHtCaWdOdW1iZXJbXX0gcmVzdWx0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfYmlnWGdjZChhLCBiKSB7XG4gICAgLy8gc291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4dGVuZGVkX0V1Y2xpZGVhbl9hbGdvcml0aG1cbiAgICB2YXIgdCwgLy8gdXNlZCB0byBzd2FwIHR3byB2YXJpYWJsZXNcbiAgICAgICAgcSwgLy8gcXVvdGllbnRcbiAgICAgICAgciwgLy8gcmVtYWluZGVyXG4gICAgICAgIHplcm8gPSBuZXcgQmlnTnVtYmVyKDApLFxuICAgICAgICB4ID0gbmV3IEJpZ051bWJlcigwKSwgbGFzdHggPSBuZXcgQmlnTnVtYmVyKDEpLFxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcigxKSwgbGFzdHkgPSBuZXcgQmlnTnVtYmVyKDApO1xuXG4gICAgd2hpbGUgKCFiLmlzWmVybygpKSB7XG4gICAgICBxID0gYS5kaXYoYikuZmxvb3IoKTtcbiAgICAgIHIgPSBhLm1vZChiKTtcblxuICAgICAgdCA9IHg7XG4gICAgICB4ID0gbGFzdHgubWludXMocS50aW1lcyh4KSk7XG4gICAgICBsYXN0eCA9IHQ7XG5cbiAgICAgIHQgPSB5O1xuICAgICAgeSA9IGxhc3R5Lm1pbnVzKHEudGltZXMoeSkpO1xuICAgICAgbGFzdHkgPSB0O1xuXG4gICAgICBhID0gYjtcbiAgICAgIGIgPSByO1xuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEubHQoemVybykpIHtcbiAgICAgIHJlcyA9IFthLm5lZygpLCBsYXN0eC5uZWcoKSwgbGFzdHkubmVnKCldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlcyA9IFthLCAhYS5pc1plcm8oKSA/IGxhc3R4IDogMCwgbGFzdHldO1xuICAgIH1cbiAgICByZXR1cm4gKGNvbmZpZy5tYXRyaXggPT09ICdhcnJheScpID8gcmVzIDogbmV3IE1hdHJpeChyZXMpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoLCBjb25maWcpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBuZWFybHlFcXVhbCA9IHV0aWwubnVtYmVyLm5lYXJseUVxdWFsLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzU3RyaW5nID0gdXRpbC5zdHJpbmcuaXNTdHJpbmcsXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzVW5pdCA9IFVuaXQuaXNVbml0LFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIENvbXBhcmUgdHdvIHZhbHVlcy4gUmV0dXJucyAxIHdoZW4geCA+IHksIC0xIHdoZW4geCA8IHksIGFuZCAwIHdoZW4geCA9PSB5LlxuICAgKlxuICAgKiB4IGFuZCB5IGFyZSBjb25zaWRlcmVkIGVxdWFsIHdoZW4gdGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB4IGFuZCB5XG4gICAqIGlzIHNtYWxsZXIgdGhhbiB0aGUgY29uZmlndXJlZCBlcHNpbG9uLiBUaGUgZnVuY3Rpb24gY2Fubm90IGJlIHVzZWQgdG9cbiAgICogY29tcGFyZSB2YWx1ZXMgc21hbGxlciB0aGFuIGFwcHJveGltYXRlbHkgMi4yMmUtMTYuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5jb21wYXJlKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNvbXBhcmUoNiwgMSk7ICAgICAgICAgICAvLyByZXR1cm5zIDFcbiAgICogICAgbWF0aC5jb21wYXJlKDIsIDMpOyAgICAgICAgICAgLy8gcmV0dXJucyAtMVxuICAgKiAgICBtYXRoLmNvbXBhcmUoNywgNyk7ICAgICAgICAgICAvLyByZXR1cm5zIDBcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLnVuaXQoJzUgY20nKTtcbiAgICogICAgdmFyIGIgPSBtYXRoLnVuaXQoJzQwIG1tJyk7XG4gICAqICAgIG1hdGguY29tcGFyZShhLCBiKTsgICAgICAgICAgIC8vIHJldHVybnMgMVxuICAgKlxuICAgKiAgICBtYXRoLmNvbXBhcmUoMiwgWzEsIDIsIDNdKTsgICAvLyByZXR1cm5zIFsxLCAwLCAtMV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGVxdWFsLCB1bmVxdWFsLCBzbWFsbGVyLCBzbWFsbGVyRXEsIGxhcmdlciwgbGFyZ2VyRXFcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IFVuaXQgfCBTdHJpbmcgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgVW5pdCB8IFN0cmluZyB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geSBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBjb21wYXJpc29uOiAxLCAwIG9yIC0xLlxuICAgKi9cbiAgbWF0aC5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2NvbXBhcmUnLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoeCkgJiYgaXNOdW1iZXIoeSkpIHtcbiAgICAgIHJldHVybiBuZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbikgPyAwIDogKHggPiB5ID8gMSA6IC0xKTtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdG8gYmlnIG51bWJlclxuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIHkgPSBCaWdOdW1iZXIuY29udmVydCh5KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbih5KSB8fCB5ID09PSBudWxsKSB7XG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHkgPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHguY21wKHkpKTtcbiAgICAgIH1cblxuICAgICAgLy8gZG93bmdyYWRlIHRvIE51bWJlclxuICAgICAgcmV0dXJuIGNvbXBhcmUoeC50b051bWJlcigpLCB5KTtcbiAgICB9XG4gICAgaWYgKHkgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHRvIGJpZyBudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgICB4ID0gQmlnTnVtYmVyLmNvbnZlcnQoeCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih4ID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4LmNtcCh5KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgIHJldHVybiBjb21wYXJlKHgsIHkudG9OdW1iZXIoKSk7XG4gICAgfVxuXG4gICAgaWYgKChpc1VuaXQoeCkpICYmIChpc1VuaXQoeSkpKSB7XG4gICAgICBpZiAoIXguZXF1YWxCYXNlKHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBhcmUgdW5pdHMgd2l0aCBkaWZmZXJlbnQgYmFzZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4LnZhbHVlID4geS52YWx1ZSkgPyAxIDogKCh4LnZhbHVlIDwgeS52YWx1ZSkgPyAtMSA6IDApO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkgfHwgaXNDb2xsZWN0aW9uKHkpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwMih4LCB5LCBjb21wYXJlKTtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiB0ZXN0IHN0cmluZ3MgYWZ0ZXIgdGVzdGluZyBjb2xsZWN0aW9ucyxcbiAgICAvLyBlbHNlIHdlIGNhbid0IGNvbXBhcmUgYSBzdHJpbmcgd2l0aCBhIG1hdHJpeFxuICAgIGlmIChpc1N0cmluZyh4KSB8fCBpc1N0cmluZyh5KSkge1xuICAgICAgcmV0dXJuICh4ID4geSkgPyAxIDogKCh4IDwgeSkgPyAtMSA6IDApO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmUoK3gsIHkpO1xuICAgIH1cbiAgICBpZiAoaXNCb29sZWFuKHkpIHx8IHkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb21wYXJlKHgsICt5KTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb21wbGV4KHgpIHx8IGlzQ29tcGxleCh5KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gb3JkZXJpbmcgcmVsYXRpb24gaXMgZGVmaW5lZCBmb3IgY29tcGxleCBudW1iZXJzJyk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2NvbXBhcmUnLCBtYXRoWyd0eXBlb2YnXSh4KSwgbWF0aFsndHlwZW9mJ10oeSkpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbixcbiAgICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gIC8qKlxuICAgKiBUZXN0IGVsZW1lbnQgd2lzZSB3aGV0aGVyIHR3byBtYXRyaWNlcyBhcmUgZXF1YWwuXG4gICAqIFRoZSBmdW5jdGlvbiBhY2NlcHRzIGJvdGggbWF0cmljZXMgYW5kIHNjYWxhciB2YWx1ZXMuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5kZWVwRXF1YWwoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZGVlcEVxdWFsKDIsIDQpOyAgIC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogICAgYSA9IFsyLCA1LCAxXTtcbiAgICogICAgYiA9IFsyLCA3LCAxXTtcbiAgICpcbiAgICogICAgbWF0aC5kZWVwRXF1YWwoYSwgYik7ICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmVxdWFsKGEsIGIpOyAgICAgICAvLyByZXR1cm5zIFt0cnVlLCBmYWxzZSwgdHJ1ZV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGVxdWFsLCB1bmVxdWFsXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCBGaXJzdCBtYXRyaXggdG8gY29tcGFyZVxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHkgU2Vjb25kIG1hdHJpeCB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9XG4gICAqICAgICAgICAgICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGlucHV0IG1hdHJpY2VzIGhhdmUgdGhlIHNhbWUgc2l6ZSBhbmQgZWFjaCBvZiB0aGVpciBlbGVtZW50cyBpcyBlcXVhbC5cbiAgICovXG4gIG1hdGguZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKHgsIHkpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignZGVlcEVxdWFsJywgYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSB8fCBpc0NvbGxlY3Rpb24oeSkpIHtcbiAgICAgIHJldHVybiBfZGVlcEVxdWFsKHgudmFsdWVPZigpLCB5LnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGguZXF1YWwoeCwgeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgc2l6ZSBhbmQgYWxsIGVsZW1lbnRzIGFyZSBlcXVhbFxuICAgKiBAcGFyYW0ge0FycmF5IHwgKn0geFxuICAgKiBAcGFyYW0ge0FycmF5IHwgKn0geVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYm90aCBhcnJheXMgYXJlIGRlZXAgZXF1YWxcbiAgICovXG4gIGZ1bmN0aW9uIF9kZWVwRXF1YWwoeCwgeSkge1xuICAgIGlmIChpc0FycmF5KHgpKSB7XG4gICAgICBpZiAoaXNBcnJheSh5KSkge1xuICAgICAgICB2YXIgbGVuID0geC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IHkubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICghX2RlZXBFcXVhbCh4W2ldLCB5W2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KHkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbWF0aC5lcXVhbCh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgsIGNvbmZpZykge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIFVuaXQgPSByZXF1aXJlKCcuLi8uLi90eXBlL1VuaXQnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIG5lYXJseUVxdWFsID0gdXRpbC5udW1iZXIubmVhcmx5RXF1YWwsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNTdHJpbmcgPSB1dGlsLnN0cmluZy5pc1N0cmluZyxcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxuICAgICAgaXNVbml0ID0gVW5pdC5pc1VuaXQsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHR3byB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gdGVzdHMgd2hldGhlciB0aGUgcmVsYXRpdmUgZGlmZmVyZW5jZSBiZXR3ZWVuIHggYW5kIHkgaXNcbiAgICogc21hbGxlciB0aGFuIHRoZSBjb25maWd1cmVkIGVwc2lsb24uIFRoZSBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB0b1xuICAgKiBjb21wYXJlIHZhbHVlcyBzbWFsbGVyIHRoYW4gYXBwcm94aW1hdGVseSAyLjIyZS0xNi5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICogSW4gY2FzZSBvZiBjb21wbGV4IG51bWJlcnMsIHgucmUgbXVzdCBlcXVhbCB5LnJlLCBhbmQgeC5pbSBtdXN0IGVxdWFsIHkuaW0uXG4gICAqXG4gICAqIFZhbHVlcyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBjb21wYXJlZCBzdHJpY3RseSwgdGh1cyBgbnVsbGAgaXMgb25seVxuICAgKiBlcXVhbCB0byBgbnVsbGAgYW5kIG5vdGhpbmcgZWxzZSwgYW5kIGB1bmRlZmluZWRgIGlzIG9ubHkgZXF1YWwgdG9cbiAgICogYHVuZGVmaW5lZGAgYW5kIG5vdGhpbmcgZWxzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmVxdWFsKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmVxdWFsKDIgKyAyLCAzKTsgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqICAgIG1hdGguZXF1YWwoMiArIDIsIDQpOyAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKlxuICAgKiAgICB2YXIgYSA9IG1hdGgudW5pdCgnNTAgY20nKTtcbiAgICogICAgdmFyIGIgPSBtYXRoLnVuaXQoJzUgbScpO1xuICAgKiAgICBtYXRoLmVxdWFsKGEsIGIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICpcbiAgICogICAgdmFyIGMgPSBbMiwgNSwgMV07XG4gICAqICAgIHZhciBkID0gWzIsIDcsIDFdO1xuICAgKlxuICAgKiAgICBtYXRoLmVxdWFsKGMsIGQpOyAgICAgICAgICAgICAvLyByZXR1cm5zIFt0cnVlLCBmYWxzZSwgdHJ1ZV1cbiAgICogICAgbWF0aC5kZWVwRXF1YWwoYywgZCk7ICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKlxuICAgKiAgICBtYXRoLmVxdWFsKDAsIG51bGwpOyAgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICB1bmVxdWFsLCBzbWFsbGVyLCBzbWFsbGVyRXEsIGxhcmdlciwgbGFyZ2VyRXEsIGNvbXBhcmUsIGRlZXBFcXVhbFxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBTdHJpbmcgfCBBcnJheSB8IE1hdHJpeCB8IG51bGwgfCB1bmRlZmluZWR9IHggRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBTdHJpbmcgfCBBcnJheSB8IE1hdHJpeCB8IG51bGwgfCB1bmRlZmluZWR9IHkgU2Vjb25kIHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Qm9vbGVhbiB8IEFycmF5IHwgTWF0cml4fSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgY29tcGFyZWQgdmFsdWVzIGFyZSBlcXVhbCwgZWxzZSByZXR1cm5zIGZhbHNlXG4gICAqL1xuICBtYXRoLmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoeCwgeSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdlcXVhbCcsIGFyZ3VtZW50cy5sZW5ndGgsIDIpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIHJldHVybiBuZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0NvbXBsZXgoeSkpIHtcbiAgICAgICAgcmV0dXJuIG5lYXJseUVxdWFsKHgsIHkucmUsIGNvbmZpZy5lcHNpbG9uKSAmJiBuZWFybHlFcXVhbCh5LmltLCAwLCBjb25maWcuZXBzaWxvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICAgIHJldHVybiBuZWFybHlFcXVhbCh4LnJlLCB5LCBjb25maWcuZXBzaWxvbikgJiYgbmVhcmx5RXF1YWwoeC5pbSwgMCwgY29uZmlnLmVwc2lsb24pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNDb21wbGV4KHkpKSB7XG4gICAgICAgIHJldHVybiBuZWFybHlFcXVhbCh4LnJlLCB5LnJlLCBjb25maWcuZXBzaWxvbikgJiYgbmVhcmx5RXF1YWwoeC5pbSwgeS5pbSwgY29uZmlnLmVwc2lsb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyB0cnkgdG8gY29udmVydCB0byBiaWcgbnVtYmVyXG4gICAgICBpZiAoaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgeSA9IEJpZ051bWJlci5jb252ZXJ0KHkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHkpKSB7XG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHkgPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB4LmVxKHkpO1xuICAgICAgfVxuXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gZXF1YWwoeC50b051bWJlcigpLCB5KTtcbiAgICB9XG4gICAgaWYgKHkgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHRvIGJpZyBudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgICB4ID0gQmlnTnVtYmVyLmNvbnZlcnQoeCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeCkpIHtcbiAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIoeCA/IDEgOiAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHguZXEoeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgIHJldHVybiBlcXVhbCh4LCB5LnRvTnVtYmVyKCkpO1xuICAgIH1cblxuICAgIGlmICgoaXNVbml0KHgpKSAmJiAoaXNVbml0KHkpKSkge1xuICAgICAgaWYgKCF4LmVxdWFsQmFzZSh5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wYXJlIHVuaXRzIHdpdGggZGlmZmVyZW50IGJhc2UnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4LnZhbHVlID09IHkudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSB8fCBpc0NvbGxlY3Rpb24oeSkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAyKHgsIHksIGVxdWFsKTtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiB0ZXN0IHN0cmluZ3MgYWZ0ZXIgdGVzdGluZyBjb2xsZWN0aW9ucyxcbiAgICAvLyBlbHNlIHdlIGNhbiBhY2NpZGVudGFsbHkgY29tcGFyZSBhIHN0cmluZ2lmaWVkIGFycmF5IHdpdGggYSBzdHJpbmdcbiAgICBpZiAoaXNTdHJpbmcoeCkgfHwgaXNTdHJpbmcoeSkpIHtcbiAgICAgIHJldHVybiB4ID09IHk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSkge1xuICAgICAgcmV0dXJuIGVxdWFsKCt4LCB5KTtcbiAgICB9XG4gICAgaWYgKGlzQm9vbGVhbih5KSkge1xuICAgICAgcmV0dXJuIGVxdWFsKHgsICt5KTtcbiAgICB9XG5cbiAgICBpZiAoeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHkgPT09IG51bGw7XG4gICAgfVxuICAgIGlmICh5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4geCA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4geSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdlcXVhbCcsIG1hdGhbJ3R5cGVvZiddKHgpLCBtYXRoWyd0eXBlb2YnXSh5KSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoLCBjb25maWcpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBuZWFybHlFcXVhbCA9IHV0aWwubnVtYmVyLm5lYXJseUVxdWFsLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzU3RyaW5nID0gdXRpbC5zdHJpbmcuaXNTdHJpbmcsXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzVW5pdCA9IFVuaXQuaXNVbml0LFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB2YWx1ZSB4IGlzIGxhcmdlciB0aGFuIHkuXG4gICAqXG4gICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgd2hlbiB4IGlzIGxhcmdlciB0aGFuIHkgYW5kIHRoZSByZWxhdGl2ZVxuICAgKiBkaWZmZXJlbmNlIGJldHdlZW4geCBhbmQgeSBpcyBsYXJnZXIgdGhhbiB0aGUgY29uZmlndXJlZCBlcHNpbG9uLiBUaGVcbiAgICogZnVuY3Rpb24gY2Fubm90IGJlIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMgc21hbGxlciB0aGFuIGFwcHJveGltYXRlbHkgMi4yMmUtMTYuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5sYXJnZXIoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubGFyZ2VyKDIsIDMpOyAgICAgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqICAgIG1hdGgubGFyZ2VyKDUsIDIgKyAyKTsgICAgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLnVuaXQoJzUgY20nKTtcbiAgICogICAgdmFyIGIgPSBtYXRoLnVuaXQoJzIgaW5jaCcpO1xuICAgKiAgICBtYXRoLmxhcmdlcihhLCBiKTsgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZXF1YWwsIHVuZXF1YWwsIHNtYWxsZXIsIHNtYWxsZXJFcSwgbGFyZ2VyRXEsIGNvbXBhcmVcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IFVuaXQgfCBTdHJpbmcgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgVW5pdCB8IFN0cmluZyB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geSBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtCb29sZWFuIHwgQXJyYXkgfCBNYXRyaXh9IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB4IGlzIGxhcmdlciB0aGFuIHksIGVsc2UgcmV0dXJucyBmYWxzZVxuICAgKi9cbiAgbWF0aC5sYXJnZXIgPSBmdW5jdGlvbiBsYXJnZXIoeCwgeSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdsYXJnZXInLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoeCkgJiYgaXNOdW1iZXIoeSkpIHtcbiAgICAgIHJldHVybiAhbmVhcmx5RXF1YWwoeCwgeSwgY29uZmlnLmVwc2lsb24pICYmIHggPiB5O1xuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyB0cnkgdG8gY29udmVydCB0byBiaWcgbnVtYmVyXG4gICAgICBpZiAoaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgeSA9IEJpZ051bWJlci5jb252ZXJ0KHkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHkpIHx8IHkgPT09IG51bGwpIHtcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSA/IDEgOiAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHkgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHguZ3QoeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgIHJldHVybiBsYXJnZXIoeC50b051bWJlcigpLCB5KTtcbiAgICB9XG4gICAgaWYgKHkgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHRvIGJpZyBudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgICB4ID0gQmlnTnVtYmVyLmNvbnZlcnQoeCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih4ID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICByZXR1cm4geC5ndCh5KVxuICAgICAgfVxuXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gbGFyZ2VyKHgsIHkudG9OdW1iZXIoKSk7XG4gICAgfVxuXG4gICAgaWYgKChpc1VuaXQoeCkpICYmIChpc1VuaXQoeSkpKSB7XG4gICAgICBpZiAoIXguZXF1YWxCYXNlKHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBhcmUgdW5pdHMgd2l0aCBkaWZmZXJlbnQgYmFzZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHgudmFsdWUgPiB5LnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkgfHwgaXNDb2xsZWN0aW9uKHkpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwMih4LCB5LCBsYXJnZXIpO1xuICAgIH1cblxuICAgIC8vIE5vdGU6IHRlc3Qgc3RyaW5ncyBhZnRlciB0ZXN0aW5nIGNvbGxlY3Rpb25zLFxuICAgIC8vIGVsc2Ugd2UgY2FuJ3QgY29tcGFyZSBhIHN0cmluZyB3aXRoIGEgbWF0cml4XG4gICAgaWYgKGlzU3RyaW5nKHgpIHx8IGlzU3RyaW5nKHkpKSB7XG4gICAgICByZXR1cm4geCA+IHk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbGFyZ2VyKCt4LCB5KTtcbiAgICB9XG4gICAgaWYgKGlzQm9vbGVhbih5KSB8fCB5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbGFyZ2VyKHgsICt5KTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb21wbGV4KHgpIHx8IGlzQ29tcGxleCh5KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gb3JkZXJpbmcgcmVsYXRpb24gaXMgZGVmaW5lZCBmb3IgY29tcGxleCBudW1iZXJzJyk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2xhcmdlcicsIG1hdGhbJ3R5cGVvZiddKHgpLCBtYXRoWyd0eXBlb2YnXSh5KSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoLCBjb25maWcpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBuZWFybHlFcXVhbCA9IHV0aWwubnVtYmVyLm5lYXJseUVxdWFsLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzU3RyaW5nID0gdXRpbC5zdHJpbmcuaXNTdHJpbmcsXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzVW5pdCA9IFVuaXQuaXNVbml0LFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB2YWx1ZSB4IGlzIGxhcmdlciBvciBlcXVhbCB0byB5LlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4geCBpcyBsYXJnZXIgdGhhbiB5IG9yIHRoZSByZWxhdGl2ZVxuICAgKiBkaWZmZXJlbmNlIGJldHdlZW4geCBhbmQgeSBpcyBzbWFsbGVyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgZXBzaWxvbi4gVGhlXG4gICAqIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzIHNtYWxsZXIgdGhhbiBhcHByb3hpbWF0ZWx5IDIuMjJlLTE2LlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubGFyZ2VyRXEoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubGFyZ2VyKDIsIDEgKyAxKTsgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqICAgIG1hdGgubGFyZ2VyRXEoMiwgMSArIDEpOyAgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGVxdWFsLCB1bmVxdWFsLCBzbWFsbGVyLCBzbWFsbGVyRXEsIGxhcmdlciwgY29tcGFyZVxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgVW5pdCB8IFN0cmluZyB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCBGaXJzdCB2YWx1ZSB0byBjb21wYXJlXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBVbml0IHwgU3RyaW5nIHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB5IFNlY29uZCB2YWx1ZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW4gfCBBcnJheSB8IE1hdHJpeH0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHggaXMgbGFyZ2VyIG9yIGVxdWFsIHRvIHksIGVsc2UgcmV0dXJucyBmYWxzZVxuICAgKi9cbiAgbWF0aC5sYXJnZXJFcSA9IGZ1bmN0aW9uIGxhcmdlckVxKHgsIHkpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignbGFyZ2VyRXEnLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoeCkgJiYgaXNOdW1iZXIoeSkpIHtcbiAgICAgIHJldHVybiBuZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbikgfHwgeCA+IHk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHRvIGJpZyBudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICB5ID0gQmlnTnVtYmVyLmNvbnZlcnQoeSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeSkgfHwgeSA9PT0gbnVsbCkge1xuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcih5ID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoeSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICByZXR1cm4geC5ndGUoeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgIHJldHVybiBsYXJnZXJFcSh4LnRvTnVtYmVyKCksIHkpO1xuICAgIH1cbiAgICBpZiAoeSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdG8gYmlnIG51bWJlclxuICAgICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICAgIHggPSBCaWdOdW1iZXIuY29udmVydCh4KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHggPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB4Lmd0ZSh5KVxuICAgICAgfVxuXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gbGFyZ2VyRXEoeCwgeS50b051bWJlcigpKTtcbiAgICB9XG5cbiAgICBpZiAoKGlzVW5pdCh4KSkgJiYgKGlzVW5pdCh5KSkpIHtcbiAgICAgIGlmICgheC5lcXVhbEJhc2UoeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcGFyZSB1bml0cyB3aXRoIGRpZmZlcmVudCBiYXNlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4geC52YWx1ZSA+PSB5LnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkgfHwgaXNDb2xsZWN0aW9uKHkpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwMih4LCB5LCBsYXJnZXJFcSk7XG4gICAgfVxuXG4gICAgLy8gTm90ZTogdGVzdCBzdHJpbmdzIGFmdGVyIHRlc3RpbmcgY29sbGVjdGlvbnMsXG4gICAgLy8gZWxzZSB3ZSBjYW4ndCBjb21wYXJlIGEgc3RyaW5nIHdpdGggYSBtYXRyaXhcbiAgICBpZiAoaXNTdHJpbmcoeCkgfHwgaXNTdHJpbmcoeSkpIHtcbiAgICAgIHJldHVybiB4ID49IHk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbGFyZ2VyRXEoK3gsIHkpO1xuICAgIH1cbiAgICBpZiAoaXNCb29sZWFuKHkpIHx8IHkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBsYXJnZXJFcSh4LCAreSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSB8fCBpc0NvbXBsZXgoeSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIG9yZGVyaW5nIHJlbGF0aW9uIGlzIGRlZmluZWQgZm9yIGNvbXBsZXggbnVtYmVycycpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdsYXJnZXJFcScsIG1hdGhbJ3R5cGVvZiddKHgpLCBtYXRoWyd0eXBlb2YnXSh5KSk7XG4gIH07XG5cbiAgLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDAuMjMuMCwgY2xlYW51cCBzb21lIGRheVxuICBtYXRoLmxhcmdlcmVxID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gbGFyZ2VyZXEgaXMgcmVuYW1lZCB0byBsYXJnZXJFcScpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoLCBjb25maWcpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBuZWFybHlFcXVhbCA9IHV0aWwubnVtYmVyLm5lYXJseUVxdWFsLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzU3RyaW5nID0gdXRpbC5zdHJpbmcuaXNTdHJpbmcsXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzVW5pdCA9IFVuaXQuaXNVbml0LFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB2YWx1ZSB4IGlzIHNtYWxsZXIgdGhhbiB5LlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4geCBpcyBzbWFsbGVyIHRoYW4geSBhbmQgdGhlIHJlbGF0aXZlXG4gICAqIGRpZmZlcmVuY2UgYmV0d2VlbiB4IGFuZCB5IGlzIGxhcmdlciB0aGFuIHRoZSBjb25maWd1cmVkIGVwc2lsb24uIFRoZVxuICAgKiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB0byBjb21wYXJlIHZhbHVlcyBzbWFsbGVyIHRoYW4gYXBwcm94aW1hdGVseSAyLjIyZS0xNi5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnNtYWxsZXIoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguc21hbGxlcigyLCAzKTsgICAgICAgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5zbWFsbGVyKDUsIDIgKiAyKTsgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLnVuaXQoJzUgY20nKTtcbiAgICogICAgdmFyIGIgPSBtYXRoLnVuaXQoJzIgaW5jaCcpO1xuICAgKiAgICBtYXRoLnNtYWxsZXIoYSwgYik7ICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBlcXVhbCwgdW5lcXVhbCwgc21hbGxlckVxLCBsYXJnZXIsIGxhcmdlckVxLCBjb21wYXJlXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlciB8IEJpZ051bWJlciB8IEJvb2xlYW4gfCBVbml0IHwgU3RyaW5nIHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4IEZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHBhcmFtICB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IFVuaXQgfCBTdHJpbmcgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHkgU2Vjb25kIHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Qm9vbGVhbiB8IEFycmF5IHwgTWF0cml4fSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgeCBpcyBzbWFsbGVyIHRoYW4geSwgZWxzZSByZXR1cm5zIGZhbHNlXG4gICAqL1xuICBtYXRoLnNtYWxsZXIgPSBmdW5jdGlvbiBzbWFsbGVyKHgsIHkpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignc21hbGxlcicsIGFyZ3VtZW50cy5sZW5ndGgsIDIpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSAmJiBpc051bWJlcih5KSkge1xuICAgICAgcmV0dXJuICFuZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbikgJiYgeCA8IHk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHRvIGJpZyBudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICB5ID0gQmlnTnVtYmVyLmNvbnZlcnQoeSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeSkgfHwgeSA9PT0gbnVsbCkge1xuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcih5ID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoeSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICByZXR1cm4geC5sdCh5KTtcbiAgICAgIH1cblxuICAgICAgLy8gZG93bmdyYWRlIHRvIE51bWJlclxuICAgICAgcmV0dXJuIHNtYWxsZXIoeC50b051bWJlcigpLCB5KTtcbiAgICB9XG4gICAgaWYgKHkgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHRvIGJpZyBudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgICB4ID0gQmlnTnVtYmVyLmNvbnZlcnQoeCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih4ID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICByZXR1cm4geC5sdCh5KVxuICAgICAgfVxuXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gc21hbGxlcih4LCB5LnRvTnVtYmVyKCkpO1xuICAgIH1cblxuICAgIGlmICgoaXNVbml0KHgpKSAmJiAoaXNVbml0KHkpKSkge1xuICAgICAgaWYgKCF4LmVxdWFsQmFzZSh5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wYXJlIHVuaXRzIHdpdGggZGlmZmVyZW50IGJhc2UnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4LnZhbHVlIDwgeS52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpIHx8IGlzQ29sbGVjdGlvbih5KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcDIoeCwgeSwgc21hbGxlcik7XG4gICAgfVxuXG4gICAgLy8gTm90ZTogdGVzdCBzdHJpbmdzIGFmdGVyIHRlc3RpbmcgY29sbGVjdGlvbnMsXG4gICAgLy8gZWxzZSB3ZSBjYW4ndCBjb21wYXJlIGEgc3RyaW5nIHdpdGggYSBtYXRyaXhcbiAgICBpZiAoaXNTdHJpbmcoeCkgfHwgaXNTdHJpbmcoeSkpIHtcbiAgICAgIHJldHVybiB4IDwgeTtcbiAgICB9XG5cbiAgICBpZiAoaXNCb29sZWFuKHgpIHx8IHggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzbWFsbGVyKCt4LCB5KTtcbiAgICB9XG4gICAgaWYgKGlzQm9vbGVhbih5KSB8fCB5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc21hbGxlcih4LCAreSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSB8fCBpc0NvbXBsZXgoeSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIG9yZGVyaW5nIHJlbGF0aW9uIGlzIGRlZmluZWQgZm9yIGNvbXBsZXggbnVtYmVycycpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdzbWFsbGVyJywgbWF0aFsndHlwZW9mJ10oeCksIG1hdGhbJ3R5cGVvZiddKHkpKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgsIGNvbmZpZykge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIFVuaXQgPSByZXF1aXJlKCcuLi8uLi90eXBlL1VuaXQnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIG5lYXJseUVxdWFsID0gdXRpbC5udW1iZXIubmVhcmx5RXF1YWwsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNTdHJpbmcgPSB1dGlsLnN0cmluZy5pc1N0cmluZyxcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxuICAgICAgaXNVbml0ID0gVW5pdC5pc1VuaXQsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHZhbHVlIHggaXMgc21hbGxlciBvciBlcXVhbCB0byB5LlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4geCBpcyBzbWFsbGVyIHRoYW4geSBvciB0aGUgcmVsYXRpdmVcbiAgICogZGlmZmVyZW5jZSBiZXR3ZWVuIHggYW5kIHkgaXMgc21hbGxlciB0aGFuIHRoZSBjb25maWd1cmVkIGVwc2lsb24uIFRoZVxuICAgKiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB0byBjb21wYXJlIHZhbHVlcyBzbWFsbGVyIHRoYW4gYXBwcm94aW1hdGVseSAyLjIyZS0xNi5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnNtYWxsZXJFcSh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5zbWFsbGVyKDEgKyAyLCAzKTsgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5zbWFsbGVyRXEoMSArIDIsIDMpOyAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZXF1YWwsIHVuZXF1YWwsIHNtYWxsZXIsIGxhcmdlciwgbGFyZ2VyRXEsIGNvbXBhcmVcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQm9vbGVhbiB8IFVuaXQgfCBTdHJpbmcgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgVW5pdCB8IFN0cmluZyB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geSBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtCb29sZWFuIHwgQXJyYXkgfCBNYXRyaXh9IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB4IGlzIHNtYWxsZXIgdGhhbiB5LCBlbHNlIHJldHVybnMgZmFsc2VcbiAgICovXG4gIG1hdGguc21hbGxlckVxID0gZnVuY3Rpb24gc21hbGxlckVxKHgsIHkpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignc21hbGxlckVxJywgYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpICYmIGlzTnVtYmVyKHkpKSB7XG4gICAgICByZXR1cm4gbmVhcmx5RXF1YWwoeCwgeSwgY29uZmlnLmVwc2lsb24pIHx8IHggPCB5O1xuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyB0cnkgdG8gY29udmVydCB0byBiaWcgbnVtYmVyXG4gICAgICBpZiAoaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgeSA9IEJpZ051bWJlci5jb252ZXJ0KHkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHkpIHx8IHkgPT09IG51bGwpIHtcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSA/IDEgOiAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHkgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHgubHRlKHkpO1xuICAgICAgfVxuXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gc21hbGxlckVxKHgudG9OdW1iZXIoKSwgeSk7XG4gICAgfVxuICAgIGlmICh5IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyB0cnkgdG8gY29udmVydCB0byBiaWcgbnVtYmVyXG4gICAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgeCA9IEJpZ051bWJlci5jb252ZXJ0KHgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHgpIHx8IHggPT09IG51bGwpIHtcbiAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIoeCA/IDEgOiAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHgubHRlKHkpXG4gICAgICB9XG5cbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgIHJldHVybiBzbWFsbGVyRXEoeCwgeS50b051bWJlcigpKTtcbiAgICB9XG5cbiAgICBpZiAoKGlzVW5pdCh4KSkgJiYgKGlzVW5pdCh5KSkpIHtcbiAgICAgIGlmICgheC5lcXVhbEJhc2UoeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcGFyZSB1bml0cyB3aXRoIGRpZmZlcmVudCBiYXNlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4geC52YWx1ZSA8PSB5LnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkgfHwgaXNDb2xsZWN0aW9uKHkpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwMih4LCB5LCBzbWFsbGVyRXEpO1xuICAgIH1cblxuICAgIC8vIE5vdGU6IHRlc3Qgc3RyaW5ncyBhZnRlciB0ZXN0aW5nIGNvbGxlY3Rpb25zLFxuICAgIC8vIGVsc2Ugd2UgY2FuJ3QgY29tcGFyZSBhIHN0cmluZyB3aXRoIGEgbWF0cml4XG4gICAgaWYgKGlzU3RyaW5nKHgpIHx8IGlzU3RyaW5nKHkpKSB7XG4gICAgICByZXR1cm4geCA8PSB5O1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNtYWxsZXJFcSgreCwgeSk7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW4oeSkgfHwgeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNtYWxsZXJFcSh4LCAreSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSB8fCBpc0NvbXBsZXgoeSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIG9yZGVyaW5nIHJlbGF0aW9uIGlzIGRlZmluZWQgZm9yIGNvbXBsZXggbnVtYmVycycpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdzbWFsbGVyRXEnLCBtYXRoWyd0eXBlb2YnXSh4KSwgbWF0aFsndHlwZW9mJ10oeSkpO1xuICB9O1xuXG4gIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAwLjIzLjAsIGNsZWFudXAgc29tZSBkYXlcbiAgbWF0aC5zbWFsbGVyZXEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBzbWFsbGVyZXEgaXMgcmVuYW1lZCB0byBzbWFsbGVyRXEnKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCwgY29uZmlnKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxuICAgICAgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxuICAgICAgbmVhcmx5RXF1YWwgPSB1dGlsLm51bWJlci5uZWFybHlFcXVhbCxcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc1VuaXQgPSBVbml0LmlzVW5pdCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdHdvIHZhbHVlcyBhcmUgdW5lcXVhbC5cbiAgICpcbiAgICogVGhlIGZ1bmN0aW9uIHRlc3RzIHdoZXRoZXIgdGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB4IGFuZCB5IGlzXG4gICAqIGxhcmdlciB0aGFuIHRoZSBjb25maWd1cmVkIGVwc2lsb24uIFRoZSBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB0byBjb21wYXJlXG4gICAqIHZhbHVlcyBzbWFsbGVyIHRoYW4gYXBwcm94aW1hdGVseSAyLjIyZS0xNi5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICogSW4gY2FzZSBvZiBjb21wbGV4IG51bWJlcnMsIHgucmUgbXVzdCB1bmVxdWFsIHkucmUsIG9yIHguaW0gbXVzdCB1bmVxdWFsIHkuaW0uXG4gICAqXG4gICAqIFZhbHVlcyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBjb21wYXJlZCBzdHJpY3RseSwgdGh1cyBgbnVsbGAgaXMgdW5lcXVhbFxuICAgKiB3aXRoIGV2ZXJ5dGhpbmcgZXhjZXB0IGBudWxsYCwgYW5kIGB1bmRlZmluZWRgIGlzIHVuZXF1YWwgd2l0aCBldmVyeWluZ1xuICAgKiBleGNlcHQuIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgudW5lcXVhbCh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC51bmVxdWFsKDIgKyAyLCAzKTsgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGgudW5lcXVhbCgyICsgMiwgNCk7ICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLnVuaXQoJzUwIGNtJyk7XG4gICAqICAgIHZhciBiID0gbWF0aC51bml0KCc1IG0nKTtcbiAgICogICAgbWF0aC51bmVxdWFsKGEsIGIpOyAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKlxuICAgKiAgICB2YXIgYyA9IFsyLCA1LCAxXTtcbiAgICogICAgdmFyIGQgPSBbMiwgNywgMV07XG4gICAqXG4gICAqICAgIG1hdGgudW5lcXVhbChjLCBkKTsgICAgICAgICAgIC8vIHJldHVybnMgW2ZhbHNlLCB0cnVlLCBmYWxzZV1cbiAgICogICAgbWF0aC5kZWVwRXF1YWwoYywgZCk7ICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKlxuICAgKiAgICBtYXRoLnVuZXF1YWwoMCwgbnVsbCk7ICAgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGVxdWFsLCBkZWVwRXF1YWwsIHNtYWxsZXIsIHNtYWxsZXJFcSwgbGFyZ2VyLCBsYXJnZXJFcSwgY29tcGFyZVxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBTdHJpbmcgfCBBcnJheSB8IE1hdHJpeCB8IG51bGwgfCB1bmRlZmluZWR9IHggRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0gIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBTdHJpbmcgfCBBcnJheSB8IE1hdHJpeCB8IG51bGwgfCB1bmRlZmluZWR9IHkgU2Vjb25kIHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Qm9vbGVhbiB8IEFycmF5IHwgTWF0cml4fSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgY29tcGFyZWQgdmFsdWVzIGFyZSB1bmVxdWFsLCBlbHNlIHJldHVybnMgZmFsc2VcbiAgICovXG4gIG1hdGgudW5lcXVhbCA9IGZ1bmN0aW9uIHVuZXF1YWwoeCwgeSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCd1bmVxdWFsJywgYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICBpZiAoaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgcmV0dXJuICFuZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0NvbXBsZXgoeSkpIHtcbiAgICAgICAgcmV0dXJuICFuZWFybHlFcXVhbCh4LCB5LnJlLCBjb25maWcuZXBzaWxvbikgfHwgIW5lYXJseUVxdWFsKHkuaW0sIDAsIGNvbmZpZy5lcHNpbG9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNDb21wbGV4KHgpKSB7XG4gICAgICBpZiAoaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgcmV0dXJuICFuZWFybHlFcXVhbCh4LnJlLCB5LCBjb25maWcuZXBzaWxvbikgfHwgIW5lYXJseUVxdWFsKHguaW0sIDAsIGNvbmZpZy5lcHNpbG9uKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQ29tcGxleCh5KSkge1xuICAgICAgICByZXR1cm4gIW5lYXJseUVxdWFsKHgucmUsIHkucmUsIGNvbmZpZy5lcHNpbG9uKSB8fCAhbmVhcmx5RXF1YWwoeC5pbSwgeS5pbSwgY29uZmlnLmVwc2lsb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyB0cnkgdG8gY29udmVydCB0byBiaWcgbnVtYmVyXG4gICAgICBpZiAoaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgeSA9IEJpZ051bWJlci5jb252ZXJ0KHkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHkpKSB7XG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHkgPyAxIDogMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAheC5lcSh5KTtcbiAgICAgIH1cblxuICAgICAgLy8gZG93bmdyYWRlIHRvIE51bWJlclxuICAgICAgcmV0dXJuIHVuZXF1YWwoeC50b051bWJlcigpLCB5KTtcbiAgICB9XG4gICAgaWYgKHkgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIHRyeSB0byBjb252ZXJ0IHRvIGJpZyBudW1iZXJcbiAgICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgICB4ID0gQmlnTnVtYmVyLmNvbnZlcnQoeCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oeCkpIHtcbiAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIoeCA/IDEgOiAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuICF4LmVxKHkpXG4gICAgICB9XG5cbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgIHJldHVybiB1bmVxdWFsKHgsIHkudG9OdW1iZXIoKSk7XG4gICAgfVxuXG4gICAgaWYgKChpc1VuaXQoeCkpICYmIChpc1VuaXQoeSkpKSB7XG4gICAgICBpZiAoIXguZXF1YWxCYXNlKHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBhcmUgdW5pdHMgd2l0aCBkaWZmZXJlbnQgYmFzZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHgudmFsdWUgIT0geS52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpIHx8IGlzQ29sbGVjdGlvbih5KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcDIoeCwgeSwgdW5lcXVhbCk7XG4gICAgfVxuXG4gICAgLy8gTm90ZTogdGVzdCBzdHJpbmdzIGFmdGVyIHRlc3RpbmcgY29sbGVjdGlvbnMsXG4gICAgLy8gZWxzZSB3ZSBjYW4gYWNjaWRlbnRhbGx5IGNvbXBhcmUgYSBzdHJpbmdpZmllZCBhcnJheSB3aXRoIGEgc3RyaW5nXG4gICAgaWYgKGlzU3RyaW5nKHgpIHx8IGlzU3RyaW5nKHkpKSB7XG4gICAgICByZXR1cm4geCAhPSB5O1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkpIHtcbiAgICAgIHJldHVybiB1bmVxdWFsKCt4LCB5KTtcbiAgICB9XG4gICAgaWYgKGlzQm9vbGVhbih5KSkge1xuICAgICAgcmV0dXJuIHVuZXF1YWwoeCwgK3kpO1xuICAgIH1cblxuICAgIGlmICh4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4geSAhPT0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB4ICE9PSBudWxsO1xuICAgIH1cblxuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB5ICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB4ICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ3VuZXF1YWwnLCBtYXRoWyd0eXBlb2YnXSh4KSwgbWF0aFsndHlwZW9mJ10oeSkpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbixcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4O1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBhcmd1bWVudCBvZiBhIGNvbXBsZXggdmFsdWUuXG4gICAqIEZvciBhIGNvbXBsZXggbnVtYmVyIGBhICsgYmlgLCB0aGUgYXJndW1lbnQgaXMgY29tcHV0ZWQgYXMgYGF0YW4yKGIsIGEpYC5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmFyZyh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLmNvbXBsZXgoMiwgMik7XG4gICAqICAgIG1hdGguYXJnKGEpIC8gbWF0aC5waTsgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgMC4yNVxuICAgKlxuICAgKiAgICB2YXIgYiA9IG1hdGguY29tcGxleCgnMiArIDNpJyk7XG4gICAqICAgIG1hdGguYXJnKGIpOyAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgMC45ODI3OTM3MjMyNDczMjlcbiAgICogICAgbWF0aC5hdGFuMigzLCAyKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAwLjk4Mjc5MzcyMzI0NzMyOVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgcmUsIGltLCBjb25qLCBhYnNcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBCb29sZWFuIHwgbnVsbH0geFxuICAgKiAgICAgICAgICAgIEEgY29tcGxleCBudW1iZXIgb3IgYXJyYXkgd2l0aCBjb21wbGV4IG51bWJlcnNcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IFRoZSBhcmd1bWVudCBvZiB4XG4gICAqL1xuICBtYXRoLmFyZyA9IGZ1bmN0aW9uIGFyZyh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2FyZycsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIoMCwgeCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIoeC5pbSwgeC5yZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCBhcmcpO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFyZygreCk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBCaWdOdW1iZXIgc3VwcG9ydFxuICAgICAgcmV0dXJuIGFyZyh4LnRvTnVtYmVyKCkpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdhcmcnLCBtYXRoWyd0eXBlb2YnXSh4KSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBvYmplY3QgPSB1dGlsLm9iamVjdCxcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb2xsZWN0aW9uID1jb2xsZWN0aW9uLmlzQ29sbGVjdGlvbixcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4O1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBjb21wbGV4IGNvbmp1Z2F0ZSBvZiBhIGNvbXBsZXggdmFsdWUuXG4gICAqIElmIGB4ID0gYStiaWAsIHRoZSBjb21wbGV4IGNvbmp1Z2F0ZSBvZiBgeGAgaXMgYGEgLSBiaWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5jb25qKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNvbmoobWF0aC5jb21wbGV4KCcyICsgM2knKSk7ICAvLyByZXR1cm5zIENvbXBsZXggMiAtIDNpXG4gICAqICAgIG1hdGguY29uaihtYXRoLmNvbXBsZXgoJzIgLSAzaScpKTsgIC8vIHJldHVybnMgQ29tcGxleCAyICsgM2lcbiAgICogICAgbWF0aC5jb25qKG1hdGguY29tcGxleCgnLTUuMmknKSk7ICAvLyByZXR1cm5zIENvbXBsZXggNS4yaVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgcmUsIGltLCBhcmcsIGFic1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IEJvb2xlYW4gfCBudWxsfSB4XG4gICAqICAgICAgICAgICAgQSBjb21wbGV4IG51bWJlciBvciBhcnJheSB3aXRoIGNvbXBsZXggbnVtYmVyc1xuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9XG4gICAqICAgICAgICAgICAgVGhlIGNvbXBsZXggY29uanVnYXRlIG9mIHhcbiAgICovXG4gIG1hdGguY29uaiA9IGZ1bmN0aW9uIGNvbmooeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdjb25qJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHgucmUsIC14LmltKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHgsIGNvbmopO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICt4O1xuICAgIH1cblxuICAgIC8vIHJldHVybiBhIGNsb25lIG9mIHRoZSB2YWx1ZSBmb3Igbm9uLWNvbXBsZXggdmFsdWVzXG4gICAgcmV0dXJuIG9iamVjdC5jbG9uZSh4KTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIG9iamVjdCA9IHV0aWwub2JqZWN0LFxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbixcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlYWwgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyLlxuICAgKiBGb3IgYSBjb21wbGV4IG51bWJlciBgYSArIGJpYCwgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGFgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgucmUoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC5jb21wbGV4KDIsIDMpO1xuICAgKiAgICBtYXRoLnJlKGEpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDJcbiAgICogICAgbWF0aC5pbShhKTsgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAzXG4gICAqXG4gICAqICAgIG1hdGgucmUobWF0aC5jb21wbGV4KCctNS4yaScpKTsgLy8gcmV0dXJucyBOdW1iZXIgMFxuICAgKiAgICBtYXRoLnJlKG1hdGguY29tcGxleCgyLjQpKTsgICAgIC8vIHJldHVybnMgTnVtYmVyIDIuNFxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgaW0sIGNvbmosIGFicywgYXJnXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgQm9vbGVhbiB8IG51bGx9IHhcbiAgICogICAgICAgICAgICBBIGNvbXBsZXggbnVtYmVyIG9yIGFycmF5IHdpdGggY29tcGxleCBudW1iZXJzXG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlciB8IEFycmF5IHwgTWF0cml4fSBUaGUgcmVhbCBwYXJ0IG9mIHhcbiAgICovXG4gIG1hdGgucmUgPSBmdW5jdGlvbiByZSh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3JlJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgcmV0dXJuIHgucmU7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCByZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gK3g7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGEgY2xvbmUgb2YgdGhlIHZhbHVlIGl0c2VsZiBmb3IgYWxsIG5vbi1jb21wbGV4IHZhbHVlc1xuICAgIHJldHVybiBvYmplY3QuY2xvbmUoeCk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzQ29sbGVjdGlvbiA9Y29sbGVjdGlvbi5pc0NvbGxlY3Rpb24sXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleDtcblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnaW5hcnkgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyLlxuICAgKiBGb3IgYSBjb21wbGV4IG51bWJlciBgYSArIGJpYCwgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGJgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguaW0oeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC5jb21wbGV4KDIsIDMpO1xuICAgKiAgICBtYXRoLnJlKGEpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDJcbiAgICogICAgbWF0aC5pbShhKTsgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAzXG4gICAqXG4gICAqICAgIG1hdGgucmUobWF0aC5jb21wbGV4KCctNS4yaScpKTsgLy8gcmV0dXJucyBOdW1iZXIgLTUuMlxuICAgKiAgICBtYXRoLnJlKG1hdGguY29tcGxleCgyLjQpKTsgICAgIC8vIHJldHVybnMgTnVtYmVyIDBcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHJlLCBjb25qLCBhYnMsIGFyZ1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IEJvb2xlYW4gfCBudWxsfSB4XG4gICAqICAgICAgICAgICAgQSBjb21wbGV4IG51bWJlciBvciBhcnJheSB3aXRoIGNvbXBsZXggbnVtYmVyc1xuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0gVGhlIGltYWdpbmFyeSBwYXJ0IG9mIHhcbiAgICovXG4gIG1hdGguaW0gPSBmdW5jdGlvbiBpbSh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2ltJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgcmV0dXJuIHguaW07XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCBpbSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gMCBmb3IgYWxsIG5vbi1jb21wbGV4IHZhbHVlc1xuICAgIHJldHVybiAwO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgLy8gdGFrZSB0aGUgQmlnTnVtYmVyIGluc3RhbmNlIHRoZSBwcm92aWRlZCBtYXRoLmpzIGluc3RhbmNlXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbixcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgQmlnTnVtYmVyLCB3aGljaCBjYW4gc3RvcmUgbnVtYmVycyB3aXRoIGFyYml0cmFyeSBwcmVjaXNpb24uXG4gICAqIFdoZW4gYSBtYXRyaXggaXMgcHJvdmlkZWQsIGFsbCBlbGVtZW50cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBCaWdOdW1iZXIuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5iaWdudW1iZXIoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIDAuMSArIDAuMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgMC4zMDAwMDAwMDAwMDAwMDAwNFxuICAgKiAgICBtYXRoLmJpZ251bWJlcigwLjEpICsgbWF0aC5iaWdudW1iZXIoMC4yKTsgIC8vIHJldHVybnMgQmlnTnVtYmVyIDAuM1xuICAgKlxuICAgKlxuICAgKiAgICA3LjJlNTAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIEluZmluaXR5XG4gICAqICAgIG1hdGguYmlnbnVtYmVyKCc3LjJlNTAwJyk7ICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBCaWdOdW1iZXIgNy4yZTUwMFxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYm9vbGVhbiwgY29tcGxleCwgaW5kZXgsIG1hdHJpeCwgc3RyaW5nLCB1bml0XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nIHwgQXJyYXkgfCBNYXRyaXggfCBCb29sZWFuIHwgbnVsbH0gW3ZhbHVlXSAgVmFsdWUgZm9yIHRoZSBiaWcgbnVtYmVyLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIGJ5IGRlZmF1bHQuXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IFRoZSBjcmVhdGVkIGJpZ251bWJlclxuICAgKi9cbiAgbWF0aC5iaWdudW1iZXIgPSBmdW5jdGlvbiBiaWdudW1iZXIodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdiaWdudW1iZXInLCBhcmd1bWVudHMubGVuZ3RoLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAoKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB8fCBpc051bWJlcih2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCt2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAodmFsdWUsIGJpZ251bWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2JpZ251bWJlcicsIG1hdGhbJ3R5cGVvZiddKHZhbHVlKSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbixcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBib29sZWFuIG9yIGNvbnZlcnQgYSBzdHJpbmcgb3IgbnVtYmVyIHRvIGEgYm9vbGVhbi5cbiAgICogSW4gY2FzZSBvZiBhIG51bWJlciwgYHRydWVgIGlzIHJldHVybmVkIGZvciBub24temVybyBudW1iZXJzLCBhbmQgYGZhbHNlYCBpblxuICAgKiBjYXNlIG9mIHplcm8uXG4gICAqIFN0cmluZ3MgY2FuIGJlIGAndHJ1ZSdgIG9yIGAnZmFsc2UnYCwgb3IgY2FuIGNvbnRhaW4gYSBudW1iZXIuXG4gICAqIFdoZW4gdmFsdWUgaXMgYSBtYXRyaXgsIGFsbCBlbGVtZW50cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBib29sZWFuLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYm9vbGVhbih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5ib29sZWFuKDApOyAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmJvb2xlYW4oMSk7ICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5ib29sZWFuKC0zKTsgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgICBtYXRoLmJvb2xlYW4oJ3RydWUnKTsgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgICBtYXRoLmJvb2xlYW4oJ2ZhbHNlJyk7ICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqICAgIG1hdGguYm9vbGVhbihbMSwgMCwgMSwgMV0pOyAgICAgLy8gcmV0dXJucyBbdHJ1ZSwgZmFsc2UsIHRydWUsIHRydWVdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBiaWdudW1iZXIsIGNvbXBsZXgsIGluZGV4LCBtYXRyaXgsIHN0cmluZywgdW5pdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlciB8IEJvb2xlYW4gfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHZhbHVlICBBIHZhbHVlIG9mIGFueSB0eXBlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW4gfCBBcnJheSB8IE1hdHJpeH0gVGhlIGJvb2xlYW4gdmFsdWVcbiAgICovXG4gIG1hdGhbJ2Jvb2xlYW4nXSA9IGZ1bmN0aW9uIGJvb2wgKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2Jvb2xlYW4nLCBhcmd1bWVudHMubGVuZ3RoLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAodmFsdWUgIT09IDApO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuICF2YWx1ZS5pc1plcm8oKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAvLyB0cnkgY2FzZSBpbnNlbnNpdGl2ZVxuICAgICAgdmFyIGxjYXNlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsY2FzZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGNhc2UgPT09ICdmYWxzZScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZXN0IHdoZXRoZXIgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXJcbiAgICAgIHZhciBudW0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHZhbHVlICE9ICcnICYmICFpc05hTihudW0pKSB7XG4gICAgICAgIHJldHVybiAobnVtICE9PSAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh2YWx1ZSwgYm9vbCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKHZhbHVlLnRvU3RyaW5nKCkgKyAnIGlzIG5vIHZhbGlkIGJvb2xlYW4nKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uLFxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzU3RyaW5nID0gdXRpbC5zdHJpbmcuaXNTdHJpbmcsXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleDtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29tcGxleCB2YWx1ZSBvciBjb252ZXJ0IGEgdmFsdWUgdG8gYSBjb21wbGV4IHZhbHVlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmNvbXBsZXgoKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZXMgYSBjb21wbGV4IHZhbHVlIHdpdGggemVyb1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcyByZWFsIGFuZCBpbWFnaW5hcnkgcGFydC5cbiAgICogICAgIG1hdGguY29tcGxleChyZSA6IG51bWJlciwgaW0gOiBzdHJpbmcpICAgLy8gY3JlYXRlcyBhIGNvbXBsZXggdmFsdWUgd2l0aCBwcm92aWRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgZm9yIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0LlxuICAgKiAgICAgbWF0aC5jb21wbGV4KHJlIDogbnVtYmVyKSAgICAgICAgICAgICAgICAvLyBjcmVhdGVzIGEgY29tcGxleCB2YWx1ZSB3aXRoIHByb3ZpZGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWwgdmFsdWUgYW5kIHplcm8gaW1hZ2luYXJ5IHBhcnQuXG4gICAqICAgICBtYXRoLmNvbXBsZXgoY29tcGxleCA6IENvbXBsZXgpICAgICAgICAgIC8vIGNsb25lcyB0aGUgcHJvdmlkZWQgY29tcGxleCB2YWx1ZS5cbiAgICogICAgIG1hdGguY29tcGxleChhcmcgOiBzdHJpbmcpICAgICAgICAgICAgICAgLy8gcGFyc2VzIGEgc3RyaW5nIGludG8gYSBjb21wbGV4IHZhbHVlLlxuICAgKiAgICAgbWF0aC5jb21wbGV4KGFycmF5IDogQXJyYXkpICAgICAgICAgICAgICAvLyBjb252ZXJ0cyB0aGUgZWxlbWVudHMgb2YgdGhlIGFycmF5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIG1hdHJpeCBlbGVtZW50IHdpc2UgaW50byBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXggdmFsdWUuXG4gICAqICAgICBtYXRoLmNvbXBsZXgoe3JlOiBudW1iZXIsIGltOiBudW1iZXJ9KSAgIC8vIGNyZWF0ZXMgYSBjb21wbGV4IHZhbHVlIHdpdGggcHJvdmlkZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGZvciByZWFsIGFuIGltYWdpbmFyeSBwYXJ0LlxuICAgKiAgICAgbWF0aC5jb21wbGV4KHtyOiBudW1iZXIsIHBoaTogbnVtYmVyfSkgICAvLyBjcmVhdGVzIGEgY29tcGxleCB2YWx1ZSB3aXRoIHByb3ZpZGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvbGFyIGNvb3JkaW5hdGVzXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICB2YXIgYSA9IG1hdGguY29tcGxleCgzLCAtNCk7ICAgICAvLyBhID0gQ29tcGxleCAzIC0gNGlcbiAgICogICAgYS5yZSA9IDU7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSA9IENvbXBsZXggNSAtIDRpXG4gICAqICAgIHZhciBpID0gYS5pbTsgICAgICAgICAgICAgICAgICAgIC8vIE51bWJlciAtNDtcbiAgICogICAgdmFyIGIgPSBtYXRoLmNvbXBsZXgoJzIgKyA2aScpOyAgLy8gQ29tcGxleCAyICsgNmlcbiAgICogICAgdmFyIGMgPSBtYXRoLmNvbXBsZXgoKTsgICAgICAgICAgLy8gQ29tcGxleCAwICsgMGlcbiAgICogICAgdmFyIGQgPSBtYXRoLmFkZChhLCBiKTsgICAgICAgICAgLy8gQ29tcGxleCA1ICsgMmlcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGJpZ251bWJlciwgYm9vbGVhbiwgaW5kZXgsIG1hdHJpeCwgbnVtYmVyLCBzdHJpbmcsIHVuaXRcbiAgICpcbiAgICogQHBhcmFtIHsqIHwgQXJyYXkgfCBNYXRyaXh9IFthcmdzXVxuICAgKiAgICAgICAgICAgIEFyZ3VtZW50cyBzcGVjaWZ5aW5nIHRoZSByZWFsIGFuZCBpbWFnaW5hcnkgcGFydCBvZiB0aGUgY29tcGxleCBudW1iZXJcbiAgICogQHJldHVybiB7Q29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBSZXR1cm5zIGEgY29tcGxleCB2YWx1ZVxuICAgKi9cbiAgbWF0aC5jb21wbGV4ID0gZnVuY3Rpb24gY29tcGxleChhcmdzKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8vIG5vIHBhcmFtZXRlcnMuIFNldCByZSBhbmQgaW0gemVyb1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoMCwgMCk7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLy8gcGFyc2Ugc3RyaW5nIGludG8gYSBjb21wbGV4IG51bWJlclxuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIGlmIChpc051bWJlcihhcmcpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGFyZywgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgICAgLy8gY29udmVydCB0byBOdW1iZXJcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoYXJnLnRvTnVtYmVyKCksIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ29tcGxleChhcmcpKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIGEgY2xvbmVcbiAgICAgICAgICByZXR1cm4gYXJnLmNsb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTdHJpbmcoYXJnKSkge1xuICAgICAgICAgIHZhciBjID0gQ29tcGxleC5wYXJzZShhcmcpO1xuICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1N0cmluZyBcIicgKyBhcmcgKyAnXCIgaXMgbm8gdmFsaWQgY29tcGxleCBudW1iZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKGFyZykpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKGFyZywgY29tcGxleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZigncmUnIGluIGFyZyAmJiAnaW0nIGluIGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGFyZy5yZSwgYXJnLmltKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCdyJyBpbiBhcmcgJiYgJ3BoaScgaW4gYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29tcGxleC5mcm9tUG9sYXIoYXJnLnIsIGFyZy5waGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBcblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUd28gbnVtYmVycywgc2luZ2xlIHN0cmluZyBvciBhbiBmaXR0aW5nIG9iamVjdCBleHBlY3RlZCBpbiBmdW5jdGlvbiBjb21wbGV4Jyk7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gcmUgYW5kIGltIHByb3ZpZGVkXG4gICAgICAgIHZhciByZSA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGltID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgcmUgdG8gbnVtYmVyXG4gICAgICAgIGlmIChyZSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICAgIHJlID0gcmUudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgaW0gdG8gbnVtYmVyXG4gICAgICAgIGlmIChpbSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICAgIGltID0gaW0udG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihyZSkgJiYgaXNOdW1iZXIoaW0pKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHJlLCBpbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHdvIG51bWJlcnMgb3IgYSBzaW5nbGUgc3RyaW5nIGV4cGVjdGVkIGluIGZ1bmN0aW9uIGNvbXBsZXgnKTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignY29tcGxleCcsIGFyZ3VtZW50cy5sZW5ndGgsIDAsIDIpO1xuICAgIH1cbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBJbmRleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvSW5kZXgnKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluZGV4LiBBbiBJbmRleCBjYW4gc3RvcmUgcmFuZ2VzIGhhdmluZyBzdGFydCwgc3RlcCwgYW5kIGVuZFxuICAgKiBmb3IgbXVsdGlwbGUgZGltZW5zaW9ucy5cbiAgICogTWF0cml4LmdldCwgTWF0cml4LnNldCwgYW5kIG1hdGguc3Vic2V0IGFjY2VwdCBhbiBJbmRleCBhcyBpbnB1dC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5pbmRleChyYW5nZTEsIHJhbmdlMiwgLi4uKVxuICAgKlxuICAgKiBXaGVyZTpcbiAgICpcbiAgICogRWFjaCByYW5nZSBjYW4gYmUgYW55IG9mOlxuICAgKlxuICAgKiAtIEFuIGFycmF5IFtzdGFydCwgZW5kXVxuICAgKiAtIEFuIGFycmF5IFtzdGFydCwgZW5kLCBzdGVwXVxuICAgKiAtIEEgbnVtYmVyXG4gICAqIC0gQW4gaW5zdGFuY2Ugb2YgYFJhbmdlYFxuICAgKlxuICAgKiBUaGUgcGFyYW1ldGVycyBzdGFydCwgZW5kLCBhbmQgc3RlcCBtdXN0IGJlIGludGVnZXIgbnVtYmVycy4gU3RhcnQgYW5kIGVuZFxuICAgKiBhcmUgemVybyBiYXNlZC4gVGhlIHN0YXJ0IG9mIGEgcmFuZ2UgaXMgaW5jbHVkZWQsIHRoZSBlbmQgaXMgZXhjbHVkZWQuXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICB2YXIgbWF0aCA9IG1hdGguanNcbiAgICpcbiAgICogICAgdmFyIGIgPSBbMSwgMiwgMywgNCwgNV07XG4gICAqICAgIG1hdGguc3Vic2V0KGIsIG1hdGguaW5kZXgoWzEsIDNdKSk7ICAgICAvLyByZXR1cm5zIFsyLCAzXVxuICAgKlxuICAgKiAgICB2YXIgYSA9IG1hdGgubWF0cml4KFtbMSwgMl0sIFszLCA0XV0pO1xuICAgKiAgICBhLnN1YnNldChtYXRoLmluZGV4KDAsIDEpKTsgICAgICAgICAgICAgLy8gcmV0dXJucyAyXG4gICAqICAgIGEuc3Vic2V0KG1hdGguaW5kZXgoMSwgbnVsbCkpOyAgICAgICAgICAvLyByZXR1cm5zIFszLCA0XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYmlnbnVtYmVyLCBib29sZWFuLCBjb21wbGV4LCBtYXRyaXgsIG51bWJlciwgc3RyaW5nLCB1bml0XG4gICAqXG4gICAqIEBwYXJhbSB7Li4uKn0gcmFuZ2VzICAgWmVybyBvciBtb3JlIHJhbmdlcyBvciBudW1iZXJzLlxuICAgKiBAcmV0dXJuIHtJbmRleH0gICAgICAgIFJldHVybnMgdGhlIGNyZWF0ZWQgaW5kZXhcbiAgICovXG4gIG1hdGguaW5kZXggPSBmdW5jdGlvbihyYW5nZXMpIHtcbiAgICAvLyBkb3duZ3JhZGUgQmlnTnVtYmVyIHRvIE51bWJlclxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGFyZy50b051bWJlcigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIHJldHVybiBhcmcubWFwKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgcmV0dXJuIChlbGVtIGluc3RhbmNlb2YgQmlnTnVtYmVyKSA/IGVsZW0udG9OdW1iZXIoKSA6IGVsZW07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gbmV3IEluZGV4KCk7XG4gICAgSW5kZXguYXBwbHkocmVzLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4Jyk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIE1hdHJpeC4gVGhlIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgYG1hdGgudHlwZS5NYXRyaXhgIG9iamVjdCBmcm9tXG4gICAqIGFuIGBBcnJheWAuIEEgTWF0cml4IGhhcyB1dGlsaXR5IGZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIHRoZSBkYXRhIGluIHRoZVxuICAgKiBtYXRyaXgsIGxpa2UgZ2V0dGluZyB0aGUgc2l6ZSBhbmQgZ2V0dGluZyBvciBzZXR0aW5nIHZhbHVlcyBpbiB0aGUgbWF0cml4LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubWF0cml4KCkgICAgICAvLyBjcmVhdGVzIGFuIGVtcHR5IG1hdHJpeFxuICAgKiAgICBtYXRoLm1hdHJpeChkYXRhKSAgLy8gY3JlYXRlcyBhIG1hdHJpeCB3aXRoIGluaXRpYWwgZGF0YS5cbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIHZhciBtID0gbWF0aC5tYXRyaXgoW1sxLCAyXSwgWzMsIDRdKTtcbiAgICogICAgbS5zaXplKCk7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXkgWzIsIDJdXG4gICAqICAgIG0ucmVzaXplKFszLCAyXSwgNSk7XG4gICAqICAgIG0udmFsdWVPZigpOyAgICAgICAgICAgICAgICAgICAgIC8vIEFycmF5IFtbMSwgMl0sIFszLCA0XSwgWzUsIDVdXVxuICAgKiAgICBtLmdldChbMSwgMF0pICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgM1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYmlnbnVtYmVyLCBib29sZWFuLCBjb21wbGV4LCBpbmRleCwgbnVtYmVyLCBzdHJpbmcsIHVuaXRcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeH0gW2RhdGFdICAgIEEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHJldHVybiB7TWF0cml4fSBUaGUgY3JlYXRlZCBtYXRyaXhcbiAgICovXG4gIG1hdGgubWF0cml4ID0gZnVuY3Rpb24gbWF0cml4KGRhdGEpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdtYXRyaXgnLCBhcmd1bWVudHMubGVuZ3RoLCAwLCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1hdHJpeChkYXRhKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4Jyk7XG5cbiAgdmFyIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXI7XG4gIHZhciBVbml0ID0gbWF0aC50eXBlLlVuaXQ7XG4gIHZhciBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyk7XG5cbiAgdmFyIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuICB2YXIgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcjtcbiAgdmFyIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW47XG4gIHZhciBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBudW1iZXIgb3IgY29udmVydCBhIHN0cmluZywgYm9vbGVhbiwgb3IgdW5pdCB0byBhIG51bWJlci5cbiAgICogV2hlbiB2YWx1ZSBpcyBhIG1hdHJpeCwgYWxsIGVsZW1lbnRzIHdpbGwgYmUgY29udmVydGVkIHRvIG51bWJlci5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLm51bWJlcih2YWx1ZSlcbiAgICogICAgbWF0aC5udW1iZXIodW5pdCwgdmFsdWVsZXNzVW5pdClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubnVtYmVyKDIpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAyXG4gICAqICAgIG1hdGgubnVtYmVyKCc3LjInKTsgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA3LjJcbiAgICogICAgbWF0aC5udW1iZXIodHJ1ZSk7ICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDFcbiAgICogICAgbWF0aC5udW1iZXIoW3RydWUsIGZhbHNlLCB0cnVlLCB0cnVlXSk7IC8vIHJldHVybnMgWzEsIDAsIDEsIDFdXG4gICAqICAgIG1hdGgubnVtYmVyKG1hdGgudW5pdCgnNTJjbScpLCAnbScpOyAgICAvLyByZXR1cm5zIDAuNTJcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGJpZ251bWJlciwgYm9vbGVhbiwgY29tcGxleCwgaW5kZXgsIG1hdHJpeCwgc3RyaW5nLCB1bml0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyIHwgQm9vbGVhbiB8IEFycmF5IHwgTWF0cml4IHwgVW5pdCB8IG51bGx9IFt2YWx1ZV0gIFZhbHVlIHRvIGJlIGNvbnZlcnRlZFxuICAgKiBAcGFyYW0ge1VuaXQgfCBzdHJpbmd9IFt2YWx1ZWxlc3NVbml0XSBBIHZhbHVlbGVzcyB1bml0LCB1c2VkIHRvIGNvbnZlcnQgYSB1bml0IHRvIGEgbnVtYmVyXG4gICAqIEByZXR1cm4ge051bWJlciB8IEFycmF5IHwgTWF0cml4fSBUaGUgY3JlYXRlZCBudW1iZXJcbiAgICovXG4gIG1hdGgubnVtYmVyID0gZnVuY3Rpb24gbnVtYmVyICh2YWx1ZSwgdmFsdWVsZXNzVW5pdCkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAodmFsdWUsIG51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgbnVtID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBpZiAoaXNOYU4obnVtKSkge1xuICAgICAgICAgICAgbnVtID0gTnVtYmVyKHZhbHVlLnZhbHVlT2YoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IodmFsdWUudG9TdHJpbmcoKSArICcgaXMgbm8gdmFsaWQgbnVtYmVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCb29sZWFuKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiArdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVW5pdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2Vjb25kIGFyZ3VtZW50IHdpdGggdmFsdWVsZXNzIHVuaXQgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdudW1iZXInLCBtYXRoWyd0eXBlb2YnXSh2YWx1ZSkpO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVuaXQgJiYgaXNTdHJpbmcodmFsdWVsZXNzVW5pdCkgfHwgdmFsdWVsZXNzVW5pdCBpbnN0YW5jZW9mIFVuaXQpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUudG9OdW1iZXIodmFsdWVsZXNzVW5pdCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignbnVtYmVyJywgbWF0aFsndHlwZW9mJ10odmFsdWUpLCBtYXRoWyd0eXBlb2YnXSh2YWx1ZWxlc3NVbml0KSk7XG5cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ251bWJlcicsIGFyZ3VtZW50cy5sZW5ndGgsIDAsIDEpO1xuICAgIH1cbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIFBhcnNlciA9IHJlcXVpcmUoJy4uLy4uL2V4cHJlc3Npb24vUGFyc2VyJyk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBhcnNlci4gVGhlIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgYG1hdGguZXhwcmVzc2lvbi5QYXJzZXJgIG9iamVjdC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnBhcnNlcigpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgdmFyIHBhcnNlciA9IG5ldyBtYXRoLnBhcnNlcigpO1xuICAgKlxuICAgKiAgICAgLy8gZXZhbHVhdGUgZXhwcmVzc2lvbnNcbiAgICogICAgIHZhciBhID0gcGFyc2VyLmV2YWwoJ3NxcnQoM14yICsgNF4yKScpOyAvLyA1XG4gICAqICAgICB2YXIgYiA9IHBhcnNlci5ldmFsKCdzcXJ0KC00KScpOyAgICAgICAgLy8gMmlcbiAgICogICAgIHZhciBjID0gcGFyc2VyLmV2YWwoJzIgaW5jaCBpbiBjbScpOyAgICAvLyA1LjA4IGNtXG4gICAqICAgICB2YXIgZCA9IHBhcnNlci5ldmFsKCdjb3MoNDUgZGVnKScpOyAgICAgLy8gMC43MDcxMDY3ODExODY1NDc2XG4gICAqXG4gICAqICAgICAvLyBkZWZpbmUgdmFyaWFibGVzIGFuZCBmdW5jdGlvbnNcbiAgICogICAgIHBhcnNlci5ldmFsKCd4ID0gNyAvIDInKTsgICAgICAgICAgICAgICAvLyAzLjVcbiAgICogICAgIHBhcnNlci5ldmFsKCd4ICsgMycpOyAgICAgICAgICAgICAgICAgICAvLyA2LjVcbiAgICogICAgIHBhcnNlci5ldmFsKCdmdW5jdGlvbiBmKHgsIHkpID0geF55Jyk7ICAvLyBmKHgsIHkpXG4gICAqICAgICBwYXJzZXIuZXZhbCgnZigyLCAzKScpOyAgICAgICAgICAgICAgICAgLy8gOFxuICAgKlxuICAgKiAgICAgLy8gZ2V0IGFuZCBzZXQgdmFyaWFibGVzIGFuZCBmdW5jdGlvbnNcbiAgICogICAgIHZhciB4ID0gcGFyc2VyLmdldCgneCcpOyAgICAgICAgICAgICAgICAvLyA3XG4gICAqICAgICB2YXIgZiA9IHBhcnNlci5nZXQoJ2YnKTsgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb25cbiAgICogICAgIHZhciBnID0gZigzLCAyKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyA5XG4gICAqICAgICBwYXJzZXIuc2V0KCdoJywgNTAwKTtcbiAgICogICAgIHZhciBpID0gcGFyc2VyLmV2YWwoJ2ggLyAyJyk7ICAgICAgICAgICAvLyAyNTBcbiAgICogICAgIHBhcnNlci5zZXQoJ2hlbGxvJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICogICAgICAgcmV0dXJuICdoZWxsbywgJyArIG5hbWUgKyAnISc7XG4gICAqICAgICB9KTtcbiAgICogICAgIHBhcnNlci5ldmFsKCdoZWxsbyhcInVzZXJcIiknKTsgICAgICAgICAgIC8vIFwiaGVsbG8sIHVzZXIhXCJcbiAgICpcbiAgICogICAgIC8vIGNsZWFyIGRlZmluZWQgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXNcbiAgICogICAgIHBhcnNlci5jbGVhcigpO1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZXZhbCwgY29tcGlsZSwgcGFyc2VcbiAgICpcbiAgICogQHJldHVybiB7UGFyc2VyfSBQYXJzZXJcbiAgICovXG4gIG1hdGgucGFyc2VyID0gZnVuY3Rpb24gcGFyc2VyKCkge1xuICAgIHJldHVybiBuZXcgUGFyc2VyKG1hdGgpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBudW1iZXIgPSB1dGlsLm51bWJlcixcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgc3RyaW5nIG9yIGNvbnZlcnQgYW55IG9iamVjdCBpbnRvIGEgc3RyaW5nLlxuICAgKiBFbGVtZW50cyBvZiBBcnJheXMgYW5kIE1hdHJpY2VzIGFyZSBwcm9jZXNzZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc3RyaW5nKHZhbHVlKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5zdHJpbmcoNC4yKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIHN0cmluZyAnNC4yJ1xuICAgKiAgICBtYXRoLnN0cmluZyhtYXRoLmNvbXBsZXgoMywgMik7IC8vIHJldHVybnMgc3RyaW5nICczICsgMmknXG4gICAqXG4gICAqICAgIHZhciB1ID0gbWF0aC51bml0KDUsICdrbScpO1xuICAgKiAgICBtYXRoLnN0cmluZyh1LnRvKCdtJykpOyAgICAgICAgIC8vIHJldHVybnMgc3RyaW5nICc1MDAwIG0nXG4gICAqXG4gICAqICAgIG1hdGguc3RyaW5nKFt0cnVlLCBmYWxzZV0pOyAgICAgLy8gcmV0dXJucyBbJ3RydWUnLCAnZmFsc2UnXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYmlnbnVtYmVyLCBib29sZWFuLCBjb21wbGV4LCBpbmRleCwgbWF0cml4LCBudW1iZXIsIHVuaXRcbiAgICpcbiAgICogQHBhcmFtIHsqIHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSBbdmFsdWVdICBBIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmdcbiAgICogQHJldHVybiB7U3RyaW5nIHwgQXJyYXkgfCBNYXRyaXh9IFRoZSBjcmVhdGVkIHN0cmluZ1xuICAgKi9cbiAgbWF0aC5zdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcgKHZhbHVlKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiAnJztcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bWJlci5mb3JtYXQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHZhbHVlLCBzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignc3RyaW5nJywgYXJndW1lbnRzLmxlbmd0aCwgMCwgMSk7XG4gICAgfVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIFVuaXQgPSByZXF1aXJlKCcuLi8uLi90eXBlL1VuaXQnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb24sXG4gICAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB1bml0LiBEZXBlbmRpbmcgb24gdGhlIHBhc3NlZCBhcmd1bWVudHMsIHRoZSBmdW5jdGlvblxuICAgKiB3aWxsIGNyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IG1hdGgudHlwZS5Vbml0IG9iamVjdC5cbiAgICogV2hlbiBhIG1hdHJpeCBpcyBwcm92aWRlZCwgYWxsIGVsZW1lbnRzIHdpbGwgYmUgY29udmVydGVkIHRvIHVuaXRzLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLnVuaXQodW5pdCA6IHN0cmluZylcbiAgICogICAgIG1hdGgudW5pdCh2YWx1ZSA6IG51bWJlciwgdW5pdCA6IHN0cmluZylcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC51bml0KDUsICdjbScpOyAgICAvLyByZXR1cm5zIFVuaXQgNTAgbW1cbiAgICogICAgdmFyIGIgPSBtYXRoLnVuaXQoJzIzIGtnJyk7ICAgIC8vIHJldHVybnMgVW5pdCAyMyBrZ1xuICAgKiAgICBhLnRvKCdtJyk7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBVbml0IDAuMDUgbVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYmlnbnVtYmVyLCBib29sZWFuLCBjb21wbGV4LCBpbmRleCwgbWF0cml4LCBudW1iZXIsIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0geyogfCBBcnJheSB8IE1hdHJpeH0gYXJncyAgIEEgbnVtYmVyIGFuZCB1bml0LlxuICAgKiBAcmV0dXJuIHtVbml0IHwgQXJyYXkgfCBNYXRyaXh9ICAgIFRoZSBjcmVhdGVkIHVuaXRcbiAgICovXG4gIG1hdGgudW5pdCA9IGZ1bmN0aW9uIHVuaXQoYXJncykge1xuICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIHBhcnNlIGEgc3RyaW5nXG4gICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIFVuaXQpIHtcbiAgICAgICAgICAvLyBjcmVhdGUgYSBjbG9uZSBvZiB0aGUgdW5pdFxuICAgICAgICAgIHJldHVybiBhcmcuY2xvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1N0cmluZyhhcmcpKSB7XG4gICAgICAgICAgaWYgKFVuaXQuaXNWYWx1ZWxlc3NVbml0KGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5pdChudWxsLCBhcmcpOyAvLyBhIHB1cmUgdW5pdFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB1ID0gVW5pdC5wYXJzZShhcmcpOyAgICAgICAgLy8gYSB1bml0IHdpdGggdmFsdWUsIGxpa2UgJzVjbSdcbiAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdTdHJpbmcgXCInICsgYXJnICsgJ1wiIGlzIG5vIHZhbGlkIHVuaXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24oYXJncykpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKGFyZ3MsIHVuaXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBzdHJpbmcgb3IgYSBudW1iZXIgYW5kIHN0cmluZyBleHBlY3RlZCBpbiBmdW5jdGlvbiB1bml0Jyk7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gYSBudW1iZXIgYW5kIGEgdW5pdFxuXG4gICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgICAvLyBjb252ZXJ0IHZhbHVlIHRvIG51bWJlclxuICAgICAgICAgIHJldHVybiBuZXcgVW5pdChhcmd1bWVudHNbMF0udG9OdW1iZXIoKSwgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVuaXQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCd1bml0JywgYXJndW1lbnRzLmxlbmd0aCwgMSwgMik7XG4gICAgfVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKSxcblxuICAgICAgb2JqZWN0ID0gdXRpbC5vYmplY3QsXG4gICAgICBzdHJpbmcgPSB1dGlsLnN0cmluZztcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmRldCh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5kZXQoW1sxLCAyXSwgWzMsIDRdXSk7IC8vIHJldHVybnMgLTJcbiAgICpcbiAgICogICAgdmFyIEEgPSBbXG4gICAqICAgICAgWy0yLCAyLCAzXSxcbiAgICogICAgICBbLTEsIDEsIDNdLFxuICAgKiAgICAgIFsyLCAwLCAtMV1cbiAgICogICAgXVxuICAgKiAgICBtYXRoLmRldChBKTsgLy8gcmV0dXJucyA2XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBpbnZcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeH0geCAgQSBtYXRyaXhcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZGV0ZXJtaW5hbnQgb2YgYHhgXG4gICAqL1xuICBtYXRoLmRldCA9IGZ1bmN0aW9uIGRldCAoeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdkZXQnLCBhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB9XG5cbiAgICB2YXIgc2l6ZTtcbiAgICBpZiAoeCBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgc2l6ZSA9IHguc2l6ZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh4IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHggPSBuZXcgTWF0cml4KHgpO1xuICAgICAgc2l6ZSA9IHguc2l6ZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGEgc2NhbGFyXG4gICAgICBzaXplID0gW107XG4gICAgfVxuXG4gICAgc3dpdGNoIChzaXplLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAvLyBzY2FsYXJcbiAgICAgICAgcmV0dXJuIG9iamVjdC5jbG9uZSh4KTtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICAvLyB2ZWN0b3JcbiAgICAgICAgaWYgKHNpemVbMF0gPT0gMSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QuY2xvbmUoeC52YWx1ZU9mKClbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSBzcXVhcmUgJyArXG4gICAgICAgICAgICAgICcoc2l6ZTogJyArIHN0cmluZy5mb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gdHdvIGRpbWVuc2lvbmFsIGFycmF5XG4gICAgICAgIHZhciByb3dzID0gc2l6ZVswXTtcbiAgICAgICAgdmFyIGNvbHMgPSBzaXplWzFdO1xuICAgICAgICBpZiAocm93cyA9PSBjb2xzKSB7XG4gICAgICAgICAgcmV0dXJuIF9kZXQoeC5jbG9uZSgpLnZhbHVlT2YoKSwgcm93cywgY29scyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHNxdWFyZSAnICtcbiAgICAgICAgICAgICAgJyhzaXplOiAnICsgc3RyaW5nLmZvcm1hdChzaXplKSArICcpJyk7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHR3byBkaW1lbnNpb25hbCAnICtcbiAgICAgICAgICAgICcoc2l6ZTogJyArIHN0cmluZy5mb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxuICAgKiBAcGFyYW0ge0FycmF5W119IG1hdHJpeCAgQSBzcXVhcmUsIHR3byBkaW1lbnNpb25hbCBtYXRyaXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd3MgICAgIE51bWJlciBvZiByb3dzIG9mIHRoZSBtYXRyaXggKHplcm8tYmFzZWQpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xzICAgICBOdW1iZXIgb2YgY29sdW1ucyBvZiB0aGUgbWF0cml4ICh6ZXJvLWJhc2VkKVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9kZXQgKG1hdHJpeCwgcm93cywgY29scykge1xuICAgIGlmIChyb3dzID09IDEpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSAxIHggMSBtYXRyaXhcbiAgICAgIHJldHVybiBvYmplY3QuY2xvbmUobWF0cml4WzBdWzBdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocm93cyA9PSAyKSB7XG4gICAgICAvLyB0aGlzIGlzIGEgMiB4IDIgbWF0cml4XG4gICAgICAvLyB0aGUgZGV0ZXJtaW5hbnQgb2YgW2ExMSxhMTI7YTIxLGEyMl0gaXMgZGV0ID0gYTExKmEyMi1hMjEqYTEyXG4gICAgICByZXR1cm4gbWF0aC5zdWJ0cmFjdChcbiAgICAgICAgICBtYXRoLm11bHRpcGx5KG1hdHJpeFswXVswXSwgbWF0cml4WzFdWzFdKSxcbiAgICAgICAgICBtYXRoLm11bHRpcGx5KG1hdHJpeFsxXVswXSwgbWF0cml4WzBdWzFdKVxuICAgICAgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB0aGlzIGlzIGFuIG4geCBuIG1hdHJpeFxuICAgICAgdmFyIGNvbXB1dGVfbXUgPSBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIHZhciBpLCBqO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG1hdHJpeCB3aXRoIHplcm8gbG93ZXIgdHJpYW5nbGUsIHNhbWUgdXBwZXIgdHJpYW5nbGUsXG4gICAgICAgIC8vIGFuZCBkaWFnb25hbHMgZ2l2ZW4gYnkgdGhlIG5lZ2F0ZWQgc3VtIG9mIHRoZSBiZWxvdyBkaWFnb25hbFxuICAgICAgICAvLyBlbGVtZW50cy5cbiAgICAgICAgdmFyIG11ID0gbmV3IEFycmF5KG1hdHJpeC5sZW5ndGgpO1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1hdHJpeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1bSA9IG1hdGguYWRkKHN1bSwgbWF0cml4W2ldW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXRyaXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtdVtpXSA9IG5ldyBBcnJheShtYXRyaXgubGVuZ3RoKTtcbiAgICAgICAgICBtdVtpXVtpXSA9IG1hdGgudW5hcnlNaW51cyhzdW0pO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgbXVbaV1bal0gPSAwOyAvLyBUT0RPOiBtYWtlIGJpZ251bWJlciAwIGluIGNhc2Ugb2YgYmlnbnVtYmVyIGNvbXB1dGF0aW9uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBtYXRyaXgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG11W2ldW2pdID0gbWF0cml4W2ldW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpKzEgPCBtYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdW0gPSBtYXRoLnN1YnRyYWN0KHN1bSwgbWF0cml4W2kgKyAxXVtpICsgMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtdTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBmYSA9IG1hdHJpeDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93cyAtIDE7IGkrKykge1xuICAgICAgICBmYSA9IG1hdGgubXVsdGlwbHkoY29tcHV0ZV9tdShmYSksIG1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyb3dzICUgMiA9PSAwKSB7XG4gICAgICAgIHJldHVybiBtYXRoLnVuYXJ5TWludXMoZmFbMF1bMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhWzBdWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4JyksXG5cbiAgICAgIG9iamVjdCA9IHV0aWwub2JqZWN0LFxuICAgICAgaXNBcnJheSA9IHV0aWwuYXJyYXkuaXNBcnJheSxcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0ludGVnZXIgPSB1dGlsLm51bWJlci5pc0ludGVnZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRpYWdvbmFsIG1hdHJpeCBvciByZXRyaWV2ZSB0aGUgZGlhZ29uYWwgb2YgYSBtYXRyaXhcbiAgICpcbiAgICogV2hlbiBgeGAgaXMgYSB2ZWN0b3IsIGEgbWF0cml4IHdpdGggdmVjdG9yIGB4YCBvbiB0aGUgZGlhZ29uYWwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogV2hlbiBgeGAgaXMgYSB0d28gZGltZW5zaW9uYWwgbWF0cml4LCB0aGUgbWF0cml4ZXMgYGtgdGggZGlhZ29uYWwgd2lsbCBiZSByZXR1cm5lZCBhcyB2ZWN0b3IuXG4gICAqIFdoZW4gayBpcyBwb3NpdGl2ZSwgdGhlIHZhbHVlcyBhcmUgcGxhY2VkIG9uIHRoZSBzdXBlciBkaWFnb25hbC5cbiAgICogV2hlbiBrIGlzIG5lZ2F0aXZlLCB0aGUgdmFsdWVzIGFyZSBwbGFjZWQgb24gdGhlIHN1YiBkaWFnb25hbC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5kaWFnKFgpXG4gICAqICAgICBtYXRoLmRpYWcoWCwgaylcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICAvLyBjcmVhdGUgYSBkaWFnb25hbCBtYXRyaXhcbiAgICogICAgIG1hdGguZGlhZyhbMSwgMiwgM10pOyAgICAgIC8vIHJldHVybnMgW1sxLCAwLCAwXSwgWzAsIDIsIDBdLCBbMCwgMCwgM11dXG4gICAqICAgICBtYXRoLmRpYWcoWzEsIDIsIDNdLCAxKTsgICAvLyByZXR1cm5zIFtbMCwgMSwgMCwgMF0sIFswLCAwLCAyLCAwXSwgWzAsIDAsIDAsIDNdXVxuICAgKiAgICAgbWF0aC5kaWFnKFsxLCAyLCAzXSwgLTEpOyAgLy8gcmV0dXJucyBbWzAsIDAsIDBdLCBbMSwgMCwgMF0sIFswLCAyLCAwXSwgWzAsIDAsIDNdXVxuICAgKlxuICAgKiAgICAvLyByZXRyaWV2ZSB0aGUgZGlhZ29uYWwgZnJvbSBhIG1hdHJpeFxuICAgKiAgICB2YXIgYSA9IFtbMSwgMiwgM10sIFs0LCA1LCA2XSwgWzcsIDgsIDldXTtcbiAgICogICAgbWF0aC5kaWFnKGEpOyAgIC8vIHJldHVybnMgWzEsIDUsIDldXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgb25lcywgemVyb3MsIGV5ZVxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeCB8IEFycmF5fSB4ICAgICAgICAgIEEgdHdvIGRpbWVuc2lvbmFsIG1hdHJpeCBvciBhIHZlY3RvclxuICAgKiBAcGFyYW0ge051bWJlciB8IEJpZ051bWJlcn0gW2s9MF0gIFRoZSBkaWFnb25hbCB3aGVyZSB0aGUgdmVjdG9yIHdpbGwgYmUgZmlsbGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gb3IgcmV0cmlldmVkLlxuICAgKiBAcmV0dXJucyB7TWF0cml4IHwgQXJyYXl9IERpYWdvbmFsIG1hdHJpeCBmcm9tIGlucHV0IHZlY3Rvciwgb3IgZGlhZ29uYWwgZnJvbSBpbnB1dCBtYXRyaXguXG4gICAqL1xuICBtYXRoLmRpYWcgPSBmdW5jdGlvbiBkaWFnICh4LCBrKSB7XG4gICAgdmFyIGRhdGEsIHZlY3RvciwgaSwgaU1heDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEgJiYgYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignZGlhZycsIGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpO1xuICAgIH1cblxuICAgIGlmIChrKSB7XG4gICAgICAvLyBjb252ZXJ0IEJpZ051bWJlciB0byBhIG51bWJlclxuICAgICAgaWYgKGsgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIGsgPSBrLnRvTnVtYmVyKCk7XG5cbiAgICAgIGlmICghaXNOdW1iZXIoaykgfHwgIWlzSW50ZWdlcihrKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnU2Vjb25kIHBhcmFtZXRlciBpbiBmdW5jdGlvbiBkaWFnIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGsgPSAwO1xuICAgIH1cbiAgICB2YXIga1N1cGVyID0gayA+IDAgPyBrIDogMDtcbiAgICB2YXIga1N1YiA9IGsgPCAwID8gLWsgOiAwO1xuXG4gICAgLy8gY2hlY2sgdHlwZSBvZiBpbnB1dFxuICAgIHZhciBhc0FycmF5O1xuICAgIGlmICh4IGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICBhc0FycmF5ID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkoeCkpIHtcbiAgICAgIC8vIGNvbnZlcnQgdG8gbWF0cml4XG4gICAgICB4ID0gbmV3IE1hdHJpeCh4KTtcbiAgICAgIGFzQXJyYXkgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdGaXJzdCBwYXJhbWV0ZXIgaW4gZnVuY3Rpb24gZGlhZyBtdXN0IGJlIGEgTWF0cml4IG9yIEFycmF5Jyk7XG4gICAgfVxuXG4gICAgdmFyIHMgPSB4LnNpemUoKTtcbiAgICBzd2l0Y2ggKHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIHggaXMgYSB2ZWN0b3IuIGNyZWF0ZSBkaWFnb25hbCBtYXRyaXhcbiAgICAgICAgdmVjdG9yID0geC52YWx1ZU9mKCk7XG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSAodmVjdG9yWzBdIGluc3RhbmNlb2YgQmlnTnVtYmVyKSA/IG5ldyBCaWdOdW1iZXIoMCkgOiAwO1xuICAgICAgICBtYXRyaXgucmVzaXplKFt2ZWN0b3IubGVuZ3RoICsga1N1YiwgdmVjdG9yLmxlbmd0aCArIGtTdXBlcl0sIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIGRhdGEgPSBtYXRyaXgudmFsdWVPZigpO1xuICAgICAgICBpTWF4ID0gdmVjdG9yLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICAgIGRhdGFbaSArIGtTdWJdW2kgKyBrU3VwZXJdID0gb2JqZWN0LmNsb25lKHZlY3RvcltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzQXJyYXkgPyBtYXRyaXgudmFsdWVPZigpIDogbWF0cml4O1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIHggaXMgYSBtYXRyaXggZ2V0IGRpYWdvbmFsIGZyb20gbWF0cml4XG4gICAgICAgIHZlY3RvciA9IFtdO1xuICAgICAgICBkYXRhID0geC52YWx1ZU9mKCk7XG4gICAgICAgIGlNYXggPSBNYXRoLm1pbihzWzBdIC0ga1N1Yiwgc1sxXSAtIGtTdXBlcik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgICB2ZWN0b3JbaV0gPSBvYmplY3QuY2xvbmUoZGF0YVtpICsga1N1Yl1baSArIGtTdXBlcl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc0FycmF5ID8gdmVjdG9yIDogbmV3IE1hdHJpeCh2ZWN0b3IpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cml4IGZvciBmdW5jdGlvbiBkaWFnIG11c3QgYmUgMiBkaW1lbnNpb25hbCcpO1xuICAgIH1cbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgsIGNvbmZpZykge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0ludGVnZXIgPSB1dGlsLm51bWJlci5pc0ludGVnZXIsXG4gICAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgMi1kaW1lbnNpb25hbCBpZGVudGl0eSBtYXRyaXggd2l0aCBzaXplIG0geCBuIG9yIG4geCBuLlxuICAgKiBUaGUgbWF0cml4IGhhcyBvbmVzIG9uIHRoZSBkaWFnb25hbCBhbmQgemVyb3MgZWxzZXdoZXJlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZXllKG4pXG4gICAqICAgIG1hdGguZXllKG0sIG4pXG4gICAqICAgIG1hdGguZXllKFttLCBuXSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZXllKDMpOyAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbWzEsIDAsIDBdLCBbMCwgMSwgMF0sIFswLCAwLCAxXV1cbiAgICogICAgbWF0aC5leWUoMywgMik7ICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFtbMSwgMF0sIFswLCAxXSwgWzAsIDBdXVxuICAgKlxuICAgKiAgICB2YXIgQSA9IFtbMSwgMiwgM10sIFs0LCA1LCA2XV07XG4gICAqICAgIG1hdGguZXllKG1hdGguc2l6ZShiKSk7ICAgICAgICAgLy8gcmV0dXJucyBbWzEsIDAsIDBdLCBbMCwgMSwgMF1dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBkaWFnLCBvbmVzLCB6ZXJvcywgc2l6ZSwgcmFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHsuLi5OdW1iZXIgfCBNYXRyaXggfCBBcnJheX0gc2l6ZSAgIFRoZSBzaXplIGZvciB0aGUgbWF0cml4XG4gICAqIEByZXR1cm4ge01hdHJpeCB8IEFycmF5IHwgTnVtYmVyfSBBIG1hdHJpeCB3aXRoIG9uZXMgb24gdGhlIGRpYWdvbmFsLlxuICAgKi9cbiAgbWF0aC5leWUgPSBmdW5jdGlvbiBleWUgKHNpemUpIHtcbiAgICB2YXIgYXJncyA9IGNvbGxlY3Rpb24uYXJnc1RvQXJyYXkoYXJndW1lbnRzKSxcbiAgICAgICAgYXNNYXRyaXggPSAoc2l6ZSBpbnN0YW5jZW9mIE1hdHJpeCkgPyB0cnVlIDpcbiAgICAgICAgKGlzQXJyYXkoc2l6ZSkgPyBmYWxzZSA6IChjb25maWcubWF0cml4ID09PSAnbWF0cml4JykpO1xuXG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMCkge1xuICAgICAgLy8gcmV0dXJuIGFuIGVtcHR5IGFycmF5XG4gICAgICByZXR1cm4gYXNNYXRyaXggPyBuZXcgTWF0cml4KCkgOiBbXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xuICAgICAgLy8gY2hhbmdlIHRvIGEgMi1kaW1lbnNpb25hbCBzcXVhcmVcbiAgICAgIGFyZ3NbMV0gPSBhcmdzWzBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA+IDIpIHtcbiAgICAgIC8vIGVycm9yIGluIGNhc2Ugb2YgYW4gbi1kaW1lbnNpb25hbCBzaXplXG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignZXllJywgYXJncy5sZW5ndGgsIDAsIDIpO1xuICAgIH1cblxuICAgIHZhciByb3dzID0gYXJnc1swXSxcbiAgICAgICAgY29scyA9IGFyZ3NbMV07XG5cbiAgICBpZiAocm93cyBpbnN0YW5jZW9mIEJpZ051bWJlcikgcm93cyA9IHJvd3MudG9OdW1iZXIoKTtcbiAgICBpZiAoY29scyBpbnN0YW5jZW9mIEJpZ051bWJlcikgY29scyA9IGNvbHMudG9OdW1iZXIoKTtcblxuICAgIGlmICghaXNOdW1iZXIocm93cykgfHwgIWlzSW50ZWdlcihyb3dzKSB8fCByb3dzIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIGV5ZSBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXJzJyk7XG4gICAgfVxuICAgIGlmICghaXNOdW1iZXIoY29scykgfHwgIWlzSW50ZWdlcihjb2xzKSB8fCBjb2xzIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIGV5ZSBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXJzJyk7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhcmd1bWVudHMgZnJvbSBiaWdudW1iZXIgdG8gbnVtYmVycyBpZiBuZWVkZWRcbiAgICB2YXIgYXNCaWdOdW1iZXIgPSBmYWxzZTtcbiAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgYXNCaWdOdW1iZXIgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWUudG9OdW1iZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgbWF0cml4XG4gICAgdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB2YXIgb25lID0gYXNCaWdOdW1iZXIgPyBuZXcgQmlnTnVtYmVyKDEpIDogMTtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXNCaWdOdW1iZXIgPyBuZXcgQmlnTnVtYmVyKDApIDogMDtcbiAgICBtYXRyaXgucmVzaXplKGFyZ3MsIGRlZmF1bHRWYWx1ZSk7XG5cbiAgICAvLyBmaWxsIGluIG9uZXMgb24gdGhlIGRpYWdvbmFsXG4gICAgdmFyIG1pbmltdW0gPSBtYXRoLm1pbihhcmdzKTtcbiAgICB2YXIgZGF0YSA9IG1hdHJpeC52YWx1ZU9mKCk7XG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBtaW5pbXVtOyBkKyspIHtcbiAgICAgIGRhdGFbZF1bZF0gPSBvbmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzTWF0cml4ID8gbWF0cml4IDogbWF0cml4LnZhbHVlT2YoKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgsIGNvbmZpZykge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKTtcblxuICB2YXIgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKTtcblxuICB2YXIgb2JqZWN0ID0gdXRpbC5vYmplY3Q7XG4gIHZhciBhcnJheSA9IHV0aWwuYXJyYXk7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAvKipcbiAgICogRmxhdHRlbiBhIG11bHRpIGRpbWVuc2lvbmFsIG1hdHJpeCBpbnRvIGEgc2luZ2xlIGRpbWVuc2lvbmFsIG1hdHJpeC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmZsYXR0ZW4oeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZmxhdHRlbihbWzEsMl0sIFszLDRdXSk7ICAgLy8gcmV0dXJucyBbMSwgMiwgMywgNF1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGNvbmNhdCwgcmVzaXplLCBzaXplLCBzcXVlZXplXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4IHwgQXJyYXl9IHggICBNYXRyaXggdG8gYmUgZmxhdHRlbmVkXG4gICAqIEByZXR1cm4ge01hdHJpeCB8IEFycmF5fSBSZXR1cm5zIHRoZSBmbGF0dGVuZWQgbWF0cml4XG4gICAqL1xuICBtYXRoLmZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuICh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdmbGF0dGVuJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgIHZhciBjbG9uZSA9IG9iamVjdC5jbG9uZSh4LnRvQXJyYXkoKSk7XG4gICAgICB2YXIgZmxhdCA9IGFycmF5LmZsYXR0ZW4oY2xvbmUpO1xuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoZmxhdCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoeCkpIHtcbiAgICAgIHJldHVybiBhcnJheS5mbGF0dGVuKG9iamVjdC5jbG9uZSh4KSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2ZsYXR0ZW4nLCBtYXRoWyd0eXBlb2YnXSh4KSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuICAgICAgc3RyaW5nID0gdXRpbC5zdHJpbmcsXG5cbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4Jyk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSBvZiBhIHNxdWFyZSBtYXRyaXguXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGguaW52KHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5pbnYoW1sxLCAyXSwgWzMsIDRdXSk7ICAvLyByZXR1cm5zIFtbLTIsIDFdLCBbMS41LCAtMC41XV1cbiAgICogICAgIG1hdGguaW52KDQpOyAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAwLjI1XG4gICAqICAgICAxIC8gNDsgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMC4yNVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgIGRldCwgdHJhbnNwb3NlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICAgICBNYXRyaXggdG8gYmUgaW52ZXJzZWRcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBUaGUgaW52ZXJzZSBvZiBgeGAuXG4gICAqL1xuICBtYXRoLmludiA9IGZ1bmN0aW9uIGludiAoeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdpbnYnLCBhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB9XG4gICAgdmFyIHNpemUgPSBtYXRoLnNpemUoeCkudmFsdWVPZigpO1xuICAgIHN3aXRjaCAoc2l6ZS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLy8gc2NhbGFyXG4gICAgICAgIHJldHVybiBtYXRoLmRpdmlkZSgxLCB4KTtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICAvLyB2ZWN0b3JcbiAgICAgICAgaWYgKHNpemVbMF0gPT0gMSkge1xuICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChbXG4gICAgICAgICAgICAgIG1hdGguZGl2aWRlKDEsIHgudmFsdWVPZigpWzBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgbWF0aC5kaXZpZGUoMSwgeFswXSlcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSBzcXVhcmUgJyArXG4gICAgICAgICAgICAgICcoc2l6ZTogJyArIHN0cmluZy5mb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gdHdvIGRpbWVuc2lvbmFsIGFycmF5XG4gICAgICAgIHZhciByb3dzID0gc2l6ZVswXTtcbiAgICAgICAgdmFyIGNvbHMgPSBzaXplWzFdO1xuICAgICAgICBpZiAocm93cyA9PSBjb2xzKSB7XG4gICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4KFxuICAgICAgICAgICAgICAgIF9pbnYoeC52YWx1ZU9mKCksIHJvd3MsIGNvbHMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBhbiBBcnJheVxuICAgICAgICAgICAgcmV0dXJuIF9pbnYoeCwgcm93cywgY29scyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSBzcXVhcmUgJyArXG4gICAgICAgICAgICAgICcoc2l6ZTogJyArIHN0cmluZy5mb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSB0d28gZGltZW5zaW9uYWwgJyArXG4gICAgICAgICAgICAnKHNpemU6ICcgKyBzdHJpbmcuZm9ybWF0KHNpemUpICsgJyknKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSBvZiBhIHNxdWFyZSBtYXRyaXhcbiAgICogQHBhcmFtIHtBcnJheVtdfSBtYXRyaXggIEEgc3F1YXJlIG1hdHJpeFxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93cyAgICAgTnVtYmVyIG9mIHJvd3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbHMgICAgIE51bWJlciBvZiBjb2x1bW5zLCBtdXN0IGVxdWFsIHJvd3NcbiAgICogQHJldHVybiB7QXJyYXlbXX0gaW52ICAgIEludmVyc2UgbWF0cml4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfaW52IChtYXRyaXgsIHJvd3MsIGNvbHMpe1xuICAgIHZhciByLCBzLCBmLCB2YWx1ZSwgdGVtcDtcblxuICAgIGlmIChyb3dzID09IDEpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSAxIHggMSBtYXRyaXhcbiAgICAgIHZhbHVlID0gbWF0cml4WzBdWzBdO1xuICAgICAgaWYgKHZhbHVlID09IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjYWxjdWxhdGUgaW52ZXJzZSwgZGV0ZXJtaW5hbnQgaXMgemVybycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtbXG4gICAgICAgIG1hdGguZGl2aWRlKDEsIHZhbHVlKVxuICAgICAgXV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHJvd3MgPT0gMikge1xuICAgICAgLy8gdGhpcyBpcyBhIDIgeCAyIG1hdHJpeFxuICAgICAgdmFyIGQgPSBtYXRoLmRldChtYXRyaXgpO1xuICAgICAgaWYgKGQgPT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBpbnZlcnNlLCBkZXRlcm1pbmFudCBpcyB6ZXJvJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbXG4gICAgICAgICAgbWF0aC5kaXZpZGUobWF0cml4WzFdWzFdLCBkKSxcbiAgICAgICAgICBtYXRoLmRpdmlkZShtYXRoLnVuYXJ5TWludXMobWF0cml4WzBdWzFdKSwgZClcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIG1hdGguZGl2aWRlKG1hdGgudW5hcnlNaW51cyhtYXRyaXhbMV1bMF0pLCBkKSxcbiAgICAgICAgICBtYXRoLmRpdmlkZShtYXRyaXhbMF1bMF0sIGQpXG4gICAgICAgIF1cbiAgICAgIF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdGhpcyBpcyBhIG1hdHJpeCBvZiAzIHggMyBvciBsYXJnZXJcbiAgICAgIC8vIGNhbGN1bGF0ZSBpbnZlcnNlIHVzaW5nIGdhdXNzLWpvcmRhbiBlbGltaW5hdGlvblxuICAgICAgLy8gICAgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dhdXNzaWFuX2VsaW1pbmF0aW9uXG4gICAgICAvLyAgICAgIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vTWF0cml4SW52ZXJzZS5odG1sXG4gICAgICAvLyAgICAgIGh0dHA6Ly9tYXRoLnV3dy5lZHUvfm1jZmFybGF0L2ludmVyc2UuaHRtXG5cbiAgICAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBtYXRyaXggKG9ubHkgdGhlIGFycmF5cywgbm90IG9mIHRoZSBlbGVtZW50cylcbiAgICAgIHZhciBBID0gbWF0cml4LmNvbmNhdCgpO1xuICAgICAgZm9yIChyID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgICBBW3JdID0gQVtyXS5jb25jYXQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIGFuIGlkZW50aXR5IG1hdHJpeCB3aGljaCBpbiB0aGUgZW5kIHdpbGwgY29udGFpbiB0aGVcbiAgICAgIC8vIG1hdHJpeCBpbnZlcnNlXG4gICAgICB2YXIgQiA9IG1hdGguZXllKHJvd3MpLnZhbHVlT2YoKTtcblxuICAgICAgLy8gbG9vcCBvdmVyIGFsbCBjb2x1bW5zLCBhbmQgcGVyZm9ybSByb3cgcmVkdWN0aW9uc1xuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb2xzOyBjKyspIHtcbiAgICAgICAgLy8gZWxlbWVudCBBY2Mgc2hvdWxkIGJlIG5vbiB6ZXJvLiBpZiBub3QsIHN3YXAgY29udGVudFxuICAgICAgICAvLyB3aXRoIG9uZSBvZiB0aGUgbG93ZXIgcm93c1xuICAgICAgICByID0gYztcbiAgICAgICAgd2hpbGUgKHIgPCByb3dzICYmIEFbcl1bY10gPT0gMCkge1xuICAgICAgICAgIHIrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAociA9PSByb3dzIHx8IEFbcl1bY10gPT0gMCkge1xuICAgICAgICAgIC8vIFRPRE86IGluIGNhc2Ugb2YgemVybyBkZXQsIGp1c3QgcmV0dXJuIGEgbWF0cml4IHdpaCBJbmZpbml0eSB2YWx1ZXM/IChsaWtlIG9jdGF2ZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBpbnZlcnNlLCBkZXRlcm1pbmFudCBpcyB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgIT0gYykge1xuICAgICAgICAgIHRlbXAgPSBBW2NdOyBBW2NdID0gQVtyXTsgQVtyXSA9IHRlbXA7XG4gICAgICAgICAgdGVtcCA9IEJbY107IEJbY10gPSBCW3JdOyBCW3JdID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsaW1pbmF0ZSBub24temVybyB2YWx1ZXMgb24gdGhlIG90aGVyIHJvd3MgYXQgY29sdW1uIGNcbiAgICAgICAgdmFyIEFjID0gQVtjXSxcbiAgICAgICAgICAgIEJjID0gQltjXTtcbiAgICAgICAgZm9yIChyID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgICAgIHZhciBBciA9IEFbcl0sXG4gICAgICAgICAgICAgIEJyID0gQltyXTtcbiAgICAgICAgICBpZihyICE9IGMpIHtcbiAgICAgICAgICAgIC8vIGVsaW1pbmF0ZSB2YWx1ZSBhdCBjb2x1bW4gYyBhbmQgcm93IHJcbiAgICAgICAgICAgIGlmIChBcltjXSAhPSAwKSB7XG4gICAgICAgICAgICAgIGYgPSBtYXRoLmRpdmlkZShtYXRoLnVuYXJ5TWludXMoQXJbY10pLCBBY1tjXSk7XG5cbiAgICAgICAgICAgICAgLy8gYWRkIChmICogcm93IGMpIHRvIHJvdyByIHRvIGVsaW1pbmF0ZSB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgLy8gYXQgY29sdW1uIGNcbiAgICAgICAgICAgICAgZm9yIChzID0gYzsgcyA8IGNvbHM7IHMrKykge1xuICAgICAgICAgICAgICAgIEFyW3NdID0gbWF0aC5hZGQoQXJbc10sIG1hdGgubXVsdGlwbHkoZiwgQWNbc10pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHMgPSAwOyBzIDwgY29sczsgcysrKSB7XG4gICAgICAgICAgICAgICAgQnJbc10gPSBtYXRoLmFkZChCcltzXSwgIG1hdGgubXVsdGlwbHkoZiwgQmNbc10pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB2YWx1ZSBhdCBBY2MgdG8gMSxcbiAgICAgICAgICAgIC8vIGRpdmlkZSBlYWNoIHZhbHVlIG9uIHJvdyByIHdpdGggdGhlIHZhbHVlIGF0IEFjY1xuICAgICAgICAgICAgZiA9IEFjW2NdO1xuICAgICAgICAgICAgZm9yIChzID0gYzsgcyA8IGNvbHM7IHMrKykge1xuICAgICAgICAgICAgICBBcltzXSA9IG1hdGguZGl2aWRlKEFyW3NdLCBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAocyA9IDA7IHMgPCBjb2xzOyBzKyspIHtcbiAgICAgICAgICAgICAgQnJbc10gPSBtYXRoLmRpdmlkZShCcltzXSwgZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gQjtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgsIGNvbmZpZykge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGFycmF5ID0gdXRpbC5hcnJheSxcblxuICAgICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1hdHJpeCBmaWxsZWQgd2l0aCBvbmVzLiBUaGUgY3JlYXRlZCBtYXRyaXggY2FuIGhhdmUgb25lIG9yXG4gICAqIG11bHRpcGxlIGRpbWVuc2lvbnMuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5vbmVzKG0pXG4gICAqICAgIG1hdGgub25lcyhtLCBuKVxuICAgKiAgICBtYXRoLm9uZXMoW20sIG5dKVxuICAgKiAgICBtYXRoLm9uZXMoW20sIG4sIHAsIC4uLl0pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLm9uZXMoMyk7ICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgWzEsIDEsIDFdXG4gICAqICAgIG1hdGgub25lcygzLCAyKTsgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbWzEsIDFdLCBbMSwgMV0sIFsxLCAxXV1cbiAgICpcbiAgICogICAgdmFyIEEgPSBbWzEsIDIsIDNdLCBbNCwgNSwgNl1dO1xuICAgKiAgICBtYXRoLnplcm9zKG1hdGguc2l6ZShBKSk7ICAgICAgIC8vIHJldHVybnMgW1sxLCAxLCAxXSwgWzEsIDEsIDFdXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgemVyb3MsIGV5ZSwgc2l6ZSwgcmFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHsuLi5OdW1iZXIgfCBBcnJheX0gc2l6ZSAgICBUaGUgc2l6ZSBvZiBlYWNoIGRpbWVuc2lvbiBvZiB0aGUgbWF0cml4XG4gICAqIEByZXR1cm4ge0FycmF5IHwgTWF0cml4IHwgTnVtYmVyfSAgQSBtYXRyaXggZmlsbGVkIHdpdGggb25lc1xuICAgKi9cbiAgbWF0aC5vbmVzID0gZnVuY3Rpb24gb25lcyAoc2l6ZSkge1xuICAgIHZhciBhcmdzID0gY29sbGVjdGlvbi5hcmdzVG9BcnJheShhcmd1bWVudHMpO1xuICAgIHZhciBhc01hdHJpeCA9IChzaXplIGluc3RhbmNlb2YgTWF0cml4KSA/IHRydWUgOlxuICAgICAgICAoaXNBcnJheShzaXplKSA/IGZhbHNlIDogKGNvbmZpZy5tYXRyaXggPT09ICdtYXRyaXgnKSk7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMCkge1xuICAgICAgLy8gb3V0cHV0IGFuIGVtcHR5IG1hdHJpeFxuICAgICAgcmV0dXJuIGFzTWF0cml4ID8gbmV3IE1hdHJpeCgpIDogW107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gb3V0cHV0IGFuIGFycmF5IG9yIG1hdHJpeFxuXG4gICAgICAvLyBjb252ZXJ0IGFyZ3VtZW50cyBmcm9tIGJpZ251bWJlciB0byBudW1iZXJzIGlmIG5lZWRlZFxuICAgICAgdmFyIGFzQmlnTnVtYmVyID0gZmFsc2U7XG4gICAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICAgIGFzQmlnTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUudG9OdW1iZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyByZXNpemUgdGhlIG1hdHJpeFxuICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFzQmlnTnVtYmVyID8gbmV3IEJpZ051bWJlcigxKSA6IDE7XG4gICAgICByZXMgPSBhcnJheS5yZXNpemUocmVzLCBhcmdzLCBkZWZhdWx0VmFsdWUpO1xuXG4gICAgICByZXR1cm4gYXNNYXRyaXggPyBuZXcgTWF0cml4KHJlcykgOiByZXM7XG4gICAgfVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCwgY29uZmlnKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzU3RyaW5nID0gdXRpbC5zdHJpbmcuaXNTdHJpbmcsXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYXJyYXkgZnJvbSBhIHJhbmdlLlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgcmFuZ2UgZW5kIGlzIGV4Y2x1ZGVkLiBUaGlzIGNhbiBiZSBjdXN0b21pemVkIGJ5IHByb3ZpZGluZ1xuICAgKiBhbiBleHRyYSBwYXJhbWV0ZXIgYGluY2x1ZGVFbmRgLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLnJhbmdlKHN0ciBbLCBpbmNsdWRlRW5kXSkgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSByYW5nZSBmcm9tIGEgc3RyaW5nLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlcmUgdGhlIHN0cmluZyBjb250YWlucyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0LCBvcHRpb25hbCBzdGVwLCBhbmQgZW5kLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VwYXJhdGVkIGJ5IGEgY29sb24uXG4gICAqICAgICBtYXRoLnJhbmdlKHN0YXJ0LCBlbmQgWywgaW5jbHVkZUVuZF0pICAgICAgICAvLyBDcmVhdGUgYSByYW5nZSB3aXRoIHN0YXJ0IGFuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kIGFuZCBhIHN0ZXAgc2l6ZSBvZiAxLlxuICAgKiAgICAgbWF0aC5yYW5nZShzdGFydCwgZW5kLCBzdGVwIFssIGluY2x1ZGVFbmRdKSAgLy8gQ3JlYXRlIGEgcmFuZ2Ugd2l0aCBzdGFydCwgc3RlcCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBlbmQuXG4gICAqXG4gICAqIFdoZXJlOlxuICAgKlxuICAgKiAtIGBzdHI6IFN0cmluZ2BcbiAgICogICBBIHN0cmluZyAnc3RhcnQ6ZW5kJyBvciAnc3RhcnQ6c3RlcDplbmQnXG4gICAqIC0gYHN0YXJ0OiB7TnVtYmVyIHwgQmlnTnVtYmVyfWBcbiAgICogICBTdGFydCBvZiB0aGUgcmFuZ2VcbiAgICogLSBgZW5kOiBOdW1iZXIgfCBCaWdOdW1iZXJgXG4gICAqICAgRW5kIG9mIHRoZSByYW5nZSwgZXhjbHVkZWQgYnkgZGVmYXVsdCwgaW5jbHVkZWQgd2hlbiBwYXJhbWV0ZXIgaW5jbHVkZUVuZD10cnVlXG4gICAqIC0gYHN0ZXA6IE51bWJlciB8IEJpZ051bWJlcmBcbiAgICogICBTdGVwIHNpemUuIERlZmF1bHQgdmFsdWUgaXMgMS5cbiAgICogLSBgaW5jbHVkZUVuZDogYm9vbGVhbmBcbiAgICogICBPcHRpb24gdG8gc3BlY2lmeSB3aGV0aGVyIHRvIGluY2x1ZGUgdGhlIGVuZCBvciBub3QuIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5yYW5nZSgyLCA2KTsgICAgICAgIC8vIFsyLCAzLCA0LCA1XVxuICAgKiAgICAgbWF0aC5yYW5nZSgyLCAtMywgLTEpOyAgIC8vIFsyLCAxLCAwLCAtMSwgLTJdXG4gICAqICAgICBtYXRoLnJhbmdlKCcyOjE6NicpOyAgICAgLy8gWzIsIDMsIDQsIDVdXG4gICAqICAgICBtYXRoLnJhbmdlKDIsIDYsIHRydWUpOyAgLy8gWzIsIDMsIDQsIDUsIDZdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgb25lcywgemVyb3MsIHNpemUsIHN1YnNldFxuICAgKlxuICAgKiBAcGFyYW0geyp9IGFyZ3MgICBQYXJhbWV0ZXJzIGRlc2NyaWJpbmcgdGhlIHJhbmdlcyBgc3RhcnRgLCBgZW5kYCwgYW5kIG9wdGlvbmFsIGBzdGVwYC5cbiAgICogQHJldHVybiB7QXJyYXkgfCBNYXRyaXh9IHJhbmdlXG4gICAqL1xuICBtYXRoLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoYXJncykge1xuICAgIHZhciBwYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kLFxuICAgICAgICBzdGVwLFxuICAgICAgICBpbmNsdWRlRW5kID0gZmFsc2U7XG5cbiAgICAvLyByZWFkIHRoZSBpbmNsdWRlRW5kIHBhcmFtZXRlclxuICAgIGlmIChpc0Jvb2xlYW4ocGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXSkpIHtcbiAgICAgIGluY2x1ZGVFbmQgPSBwYXJhbXMucG9wKCkgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIHJhbmdlKHN0cilcbiAgICAgICAgLy8gcGFyc2Ugc3RyaW5nIGludG8gYSByYW5nZVxuICAgICAgICBpZiAoaXNTdHJpbmcocGFyYW1zWzBdKSkge1xuICAgICAgICAgIHZhciByID0gX3BhcnNlKHBhcmFtc1swXSk7XG4gICAgICAgICAgaWYgKCFyKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignU3RyaW5nIFwiJyArIHBhcmFtc1swXSArICdcIiBpcyBubyB2YWxpZCByYW5nZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXJ0ID0gci5zdGFydDtcbiAgICAgICAgICBlbmQgPSByLmVuZDtcbiAgICAgICAgICBzdGVwID0gci5zdGVwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1R3byBvciB0aHJlZSBudW1iZXJzIG9yIGEgc2luZ2xlIHN0cmluZyBleHBlY3RlZCBpbiBmdW5jdGlvbiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIHJhbmdlKHN0ciwgZW5kKVxuICAgICAgICAvLyByYW5nZShzdGFydCwgZW5kKVxuICAgICAgICBzdGFydCA9IHBhcmFtc1swXTtcbiAgICAgICAgZW5kID0gcGFyYW1zWzFdO1xuICAgICAgICBzdGVwID0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcClcbiAgICAgICAgc3RhcnQgPSBwYXJhbXNbMF07XG4gICAgICAgIGVuZCA9IHBhcmFtc1sxXTtcbiAgICAgICAgc3RlcCA9IHBhcmFtc1syXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVyIGluY2x1ZGVFbmQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3JhbmdlJywgYXJndW1lbnRzLmxlbmd0aCwgMiwgNCk7XG4gICAgfVxuXG4gICAgLy8gdmVyaWZ5IHR5cGUgb2YgcGFyYW1ldGVyc1xuICAgIGlmICghaXNOdW1iZXIoc3RhcnQpICYmICEoc3RhcnQgaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXJhbWV0ZXIgc3RhcnQgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAoIWlzTnVtYmVyKGVuZCkgJiYgIShlbmQgaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXJhbWV0ZXIgZW5kIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKCFpc051bWJlcihzdGVwKSAmJiAhKHN0ZXAgaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXJhbWV0ZXIgc3RlcCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgLy8gZ28gYmlnXG4gICAgaWYgKHN0YXJ0IGluc3RhbmNlb2YgQmlnTnVtYmVyIHx8IGVuZCBpbnN0YW5jZW9mIEJpZ051bWJlciB8fCBzdGVwIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyBjcmVhdGUgYSByYW5nZSB3aXRoIGJpZyBudW1iZXJzXG4gICAgICB2YXIgYXNCaWdOdW1iZXIgPSB0cnVlO1xuXG4gICAgICAvLyBjb252ZXJ0IHN0YXJ0LCBlbmQsIHN0ZXAgdG8gQmlnTnVtYmVyXG4gICAgICBpZiAoIShzdGFydCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHN0YXJ0ID0gQmlnTnVtYmVyLmNvbnZlcnQoc3RhcnQpO1xuICAgICAgaWYgKCEoZW5kIGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgICBlbmQgICA9IEJpZ051bWJlci5jb252ZXJ0KGVuZCk7XG4gICAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgIHN0ZXAgID0gQmlnTnVtYmVyLmNvbnZlcnQoc3RlcCk7XG5cbiAgICAgIGlmICghKHN0YXJ0IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB8fCAhKGVuZCBpbnN0YW5jZW9mIEJpZ051bWJlcikgfHwgIShzdGVwIGluc3RhbmNlb2YgQmlnTnVtYmVyKSkge1xuICAgICAgICAvLyBub3QgYWxsIHZhbHVlcyBjYW4gYmUgY29udmVydGVkIHRvIGJpZyBudW1iZXIgOihcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIG51bWJlcnNcbiAgICAgICAgYXNCaWdOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXJ0IGluc3RhbmNlb2YgQmlnTnVtYmVyKSBzdGFydCA9IHN0YXJ0LnRvTnVtYmVyKCk7XG4gICAgICAgIGlmIChlbmQgaW5zdGFuY2VvZiBCaWdOdW1iZXIpICAgZW5kICAgPSBlbmQudG9OdW1iZXIoKTtcbiAgICAgICAgaWYgKHN0ZXAgaW5zdGFuY2VvZiBCaWdOdW1iZXIpICBzdGVwICA9IHN0ZXAudG9OdW1iZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBnZW5lcmF0ZSB0aGUgcmFuZ2VcbiAgICB2YXIgZm4gPSBhc0JpZ051bWJlciA/XG4gICAgICAgIChpbmNsdWRlRW5kID8gX2JpZ1JhbmdlSW5jIDogX2JpZ1JhbmdlKSA6XG4gICAgICAgIChpbmNsdWRlRW5kID8gX3JhbmdlSW5jICAgIDogX3JhbmdlKTtcbiAgICB2YXIgYXJyYXkgPSBmbihzdGFydCwgZW5kLCBzdGVwKTtcblxuICAgIC8vIHJldHVybiBhcyBhcnJheSBvciBtYXRyaXhcbiAgICByZXR1cm4gKGNvbmZpZy5tYXRyaXggPT09ICdhcnJheScpID8gYXJyYXkgOiBuZXcgTWF0cml4KGFycmF5KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmFuZ2Ugd2l0aCBudW1iZXJzLiBFbmQgaXMgZXhjbHVkZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcbiAgICogQHJldHVybnMge0FycmF5fSByYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3JhbmdlIChzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgdmFyIGFycmF5ID0gW10sXG4gICAgICAgIHggPSBzdGFydDtcbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIHdoaWxlICh4IDwgZW5kKSB7XG4gICAgICAgIGFycmF5LnB1c2goeCk7XG4gICAgICAgIHggKz0gc3RlcDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIHdoaWxlICh4ID4gZW5kKSB7XG4gICAgICAgIGFycmF5LnB1c2goeCk7XG4gICAgICAgIHggKz0gc3RlcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmFuZ2Ugd2l0aCBudW1iZXJzLiBFbmQgaXMgaW5jbHVkZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcbiAgICogQHJldHVybnMge0FycmF5fSByYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3JhbmdlSW5jIChzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgdmFyIGFycmF5ID0gW10sXG4gICAgICAgIHggPSBzdGFydDtcbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIHdoaWxlICh4IDw9IGVuZCkge1xuICAgICAgICBhcnJheS5wdXNoKHgpO1xuICAgICAgICB4ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICB3aGlsZSAoeCA+PSBlbmQpIHtcbiAgICAgICAgYXJyYXkucHVzaCh4KTtcbiAgICAgICAgeCArPSBzdGVwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByYW5nZSB3aXRoIGJpZyBudW1iZXJzLiBFbmQgaXMgZXhjbHVkZWRcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSBlbmRcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IHN0ZXBcbiAgICogQHJldHVybnMge0FycmF5fSByYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2JpZ1JhbmdlIChzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgdmFyIGFycmF5ID0gW10sXG4gICAgICAgIHggPSBzdGFydC5jbG9uZSgpLFxuICAgICAgICB6ZXJvID0gbmV3IEJpZ051bWJlcigwKTtcbiAgICBpZiAoc3RlcC5ndCh6ZXJvKSkge1xuICAgICAgd2hpbGUgKHgubHQoZW5kKSkge1xuICAgICAgICBhcnJheS5wdXNoKHgpO1xuICAgICAgICB4ID0geC5wbHVzKHN0ZXApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGVwLmx0KHplcm8pKSB7XG4gICAgICB3aGlsZSAoeC5ndChlbmQpKSB7XG4gICAgICAgIGFycmF5LnB1c2goeCk7XG4gICAgICAgIHggPSB4LnBsdXMoc3RlcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJhbmdlIHdpdGggYmlnIG51bWJlcnMuIEVuZCBpcyBpbmNsdWRlZFxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IGVuZFxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gc3RlcFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHJhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfYmlnUmFuZ2VJbmMgKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICB2YXIgYXJyYXkgPSBbXSxcbiAgICAgICAgeCA9IHN0YXJ0LmNsb25lKCksXG4gICAgICAgIHplcm8gPSBuZXcgQmlnTnVtYmVyKDApO1xuICAgIGlmIChzdGVwLmd0KHplcm8pKSB7XG4gICAgICB3aGlsZSAoeC5sdGUoZW5kKSkge1xuICAgICAgICBhcnJheS5wdXNoKHgpO1xuICAgICAgICB4ID0geC5wbHVzKHN0ZXApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGVwLmx0KHplcm8pKSB7XG4gICAgICB3aGlsZSAoeC5ndGUoZW5kKSkge1xuICAgICAgICBhcnJheS5wdXNoKHgpO1xuICAgICAgICB4ID0geC5wbHVzKHN0ZXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHN0cmluZyBpbnRvIGEgcmFuZ2UsXG4gICAqIFRoZSBzdHJpbmcgY29udGFpbnMgdGhlIHN0YXJ0LCBvcHRpb25hbCBzdGVwLCBhbmQgZW5kLCBzZXBhcmF0ZWQgYnkgYSBjb2xvbi5cbiAgICogSWYgdGhlIHN0cmluZyBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgcmFuZ2UsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAqIEZvciBleGFtcGxlIHN0cj0nMDoyOjExJy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSByYW5nZSBPYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHN0YXJ0LCBlbmQsIHN0ZXBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9wYXJzZSAoc3RyKSB7XG4gICAgdmFyIGFyZ3MgPSBzdHIuc3BsaXQoJzonKSxcbiAgICAgICAgbnVtcyA9IG51bGw7XG5cbiAgICBpZiAoY29uZmlnLm51bWJlciA9PT0gJ2JpZ251bWJlcicpIHtcbiAgICAgIC8vIGJpZ251bWJlclxuICAgICAgdHJ5IHtcbiAgICAgICAgbnVtcyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihhcmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gbnVtYmVyXG4gICAgICBudW1zID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAvLyB1c2UgTnVtYmVyIGFuZCBub3QgcGFyc2VGbG9hdCBhcyBOdW1iZXIgcmV0dXJucyBOYU4gb24gaW52YWxpZCBnYXJiYWdlIGluIHRoZSBzdHJpbmdcbiAgICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBpbnZhbGlkID0gbnVtcy5zb21lKGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgcmV0dXJuIGlzTmFOKG51bSk7XG4gICAgICB9KTtcbiAgICAgIGlmKGludmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChudW1zLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0OiBudW1zWzBdLFxuICAgICAgICAgIGVuZDogbnVtc1sxXSxcbiAgICAgICAgICBzdGVwOiAxXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFydDogbnVtc1swXSxcbiAgICAgICAgICBlbmQ6IG51bXNbMl0sXG4gICAgICAgICAgc3RlcDogbnVtc1sxXVxuICAgICAgICB9O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCwgY29uZmlnKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKSxcblxuICAgICAgYXJyYXkgPSB1dGlsLmFycmF5LFxuICAgICAgY2xvbmUgPSB1dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIHN0cmluZyA9IHV0aWwuc3RyaW5nLFxuICAgICAgaXNTdHJpbmcgPSB1dGlsLnN0cmluZy5pc1N0cmluZyxcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0ludGVnZXIgPSB1dGlsLm51bWJlci5pc0ludGVnZXIsXG4gICAgICBpc0FycmF5ID0gYXJyYXkuaXNBcnJheTtcblxuICAvKipcbiAgICogUmVzaXplIGEgbWF0cml4XG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGgucmVzaXplKHgsIHNpemUpXG4gICAqICAgICBtYXRoLnJlc2l6ZSh4LCBzaXplLCBkZWZhdWx0VmFsdWUpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5yZXNpemUoWzEsIDIsIDMsIDQsIDVdLCBbM10pOyAvLyByZXR1cm5zIEFycmF5ICBbMSwgMiwgM11cbiAgICogICAgIG1hdGgucmVzaXplKFsxLCAyLCAzXSwgWzVdLCAwKTsgICAgLy8gcmV0dXJucyBBcnJheSAgWzEsIDIsIDMsIDAsIDBdXG4gICAqICAgICBtYXRoLnJlc2l6ZSgyLCBbMiwgM10sIDApOyAgICAgICAgIC8vIHJldHVybnMgTWF0cml4IFtbMiwgMCwgMF0sIFswLCAwLCAwXV1cbiAgICogICAgIG1hdGgucmVzaXplKFwiaGVsbG9cIiwgWzhdLCBcIiFcIik7ICAgIC8vIHJldHVybnMgU3RyaW5nICdoZWxsbyEhISdcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBzaXplLCBzcXVlZXplLCBzdWJzZXRcbiAgICpcbiAgICogQHBhcmFtIHsqIHwgQXJyYXkgfCBNYXRyaXh9IHggICAgICAgICAgICAgTWF0cml4IHRvIGJlIHJlc2l6ZWRcbiAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeH0gc2l6ZSAgICAgICAgICAgICAgT25lIGRpbWVuc2lvbmFsIGFycmF5IHdpdGggbnVtYmVyc1xuICAgKiBAcGFyYW0ge051bWJlciB8IFN0cmluZ30gW2RlZmF1bHRWYWx1ZT0wXSBaZXJvIGJ5IGRlZmF1bHQsIGV4Y2VwdCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG9mIGEgc3RyaW5nLCBpbiB0aGF0IGNhc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gJyAnXG4gICAqIEByZXR1cm4geyogfCBBcnJheSB8IE1hdHJpeH0gQSByZXNpemVkIGNsb25lIG9mIG1hdHJpeCBgeGBcbiAgICovXG4gIG1hdGgucmVzaXplID0gZnVuY3Rpb24gcmVzaXplICh4LCBzaXplLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyICYmIGFyZ3VtZW50cy5sZW5ndGggIT0gMykge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3Jlc2l6ZScsIGFyZ3VtZW50cy5sZW5ndGgsIDIsIDMpO1xuICAgIH1cblxuICAgIHZhciBhc01hdHJpeCA9ICh4IGluc3RhbmNlb2YgTWF0cml4KSA/IHRydWUgOiBpc0FycmF5KHgpID8gZmFsc2UgOiAoY29uZmlnLm1hdHJpeCAhPT0gJ2FycmF5Jyk7XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgeCA9IHgudmFsdWVPZigpOyAvLyBnZXQgQXJyYXlcbiAgICB9XG4gICAgaWYgKHNpemUgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgIHNpemUgPSBzaXplLnZhbHVlT2YoKTsgLy8gZ2V0IEFycmF5XG4gICAgfVxuXG4gICAgaWYgKHNpemUubGVuZ3RoICYmIHNpemVbMF0gaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIGNvbnZlcnQgYmlnbnVtYmVycyB0byBudW1iZXJzXG4gICAgICBzaXplID0gc2l6ZS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBCaWdOdW1iZXIpID8gdmFsdWUudG9OdW1iZXIoKSA6IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKHgpKSB7XG4gICAgICByZXR1cm4gX3Jlc2l6ZVN0cmluZyh4LCBzaXplLCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChzaXplLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIC8vIG91dHB1dCBhIHNjYWxhclxuICAgICAgICB3aGlsZSAoaXNBcnJheSh4KSkge1xuICAgICAgICAgIHggPSB4WzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb25lKHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG91dHB1dCBhbiBhcnJheS9tYXRyaXhcbiAgICAgICAgaWYgKCFpc0FycmF5KHgpKSB7XG4gICAgICAgICAgeCA9IFt4XTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gY2xvbmUoeCk7XG5cbiAgICAgICAgdmFyIHJlcyA9IGFycmF5LnJlc2l6ZSh4LCBzaXplLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICByZXR1cm4gYXNNYXRyaXggPyBuZXcgTWF0cml4KHJlcykgOiByZXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNpemUgYSBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge051bWJlcltdfSBzaXplXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGVmYXVsdENoYXI9JyAnXVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3Jlc2l6ZVN0cmluZyhzdHIsIHNpemUsIGRlZmF1bHRDaGFyKSB7XG4gICAgaWYgKGRlZmF1bHRDaGFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghaXNTdHJpbmcoZGVmYXVsdENoYXIpIHx8IGRlZmF1bHRDaGFyLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaW5nbGUgY2hhcmFjdGVyIGV4cGVjdGVkIGFzIGRlZmF1bHRWYWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRlZmF1bHRDaGFyID0gJyAnO1xuICAgIH1cblxuICAgIGlmIChzaXplLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuRGltZW5zaW9uRXJyb3Ioc2l6ZS5sZW5ndGgsIDEpO1xuICAgIH1cbiAgICB2YXIgbGVuID0gc2l6ZVswXTtcbiAgICBpZiAoIWlzTnVtYmVyKGxlbikgfHwgIWlzSW50ZWdlcihsZW4pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNpemUsIG11c3QgY29udGFpbiBwb3NpdGl2ZSBpbnRlZ2VycyAnICtcbiAgICAgICAgICAnKHNpemU6ICcgKyBzdHJpbmcuZm9ybWF0KHNpemUpICsgJyknKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyLmxlbmd0aCA+IGxlbikge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgbGVuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RyLmxlbmd0aCA8IGxlbikge1xuICAgICAgdmFyIHJlcyA9IHN0cjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxlbiAtIHN0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHJlcyArPSBkZWZhdWx0Q2hhcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgsIGNvbmZpZykge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIFVuaXQgPSByZXF1aXJlKCcuLi8uLi90eXBlL1VuaXQnKSxcbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4JyksXG5cbiAgICAgIGFycmF5ID0gdXRpbC5hcnJheSxcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNTdHJpbmcgPSB1dGlsLnN0cmluZy5pc1N0cmluZyxcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxuICAgICAgaXNVbml0ID0gVW5pdC5pc1VuaXQ7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBhIG1hdHJpeCBvciBzY2FsYXIuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGguc2l6ZSh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGguc2l6ZSgyLjMpOyAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW11cbiAgICogICAgIG1hdGguc2l6ZSgnaGVsbG8gd29ybGQnKTsgICAgICAgIC8vIHJldHVybnMgWzExXVxuICAgKlxuICAgKiAgICAgdmFyIEEgPSBbWzEsIDIsIDNdLCBbNCwgNSwgNl1dO1xuICAgKiAgICAgbWF0aC5zaXplKEEpOyAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbMiwgM11cbiAgICogICAgIG1hdGguc2l6ZShtYXRoLnJhbmdlKDEsNikpOyAgICAgIC8vIHJldHVybnMgWzVdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgcmVzaXplLCBzcXVlZXplLCBzdWJzZXRcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFuIHwgTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBTdHJpbmcgfCBBcnJheSB8IE1hdHJpeH0geCAgQSBtYXRyaXhcbiAgICogQHJldHVybiB7QXJyYXkgfCBNYXRyaXh9IEEgdmVjdG9yIHdpdGggc2l6ZSBvZiBgeGAuXG4gICAqL1xuICBtYXRoLnNpemUgPSBmdW5jdGlvbiBzaXplICh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3NpemUnLCBhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB9XG5cbiAgICB2YXIgYXNBcnJheSA9IChjb25maWcubWF0cml4ID09PSAnYXJyYXknKTtcblxuICAgIGlmIChpc051bWJlcih4KSB8fCBpc0NvbXBsZXgoeCkgfHwgaXNVbml0KHgpIHx8IGlzQm9vbGVhbih4KSB8fFxuICAgICAgICB4ID09IG51bGwgfHwgeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuIGFzQXJyYXkgPyBbXSA6IG5ldyBNYXRyaXgoW10pO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh4KSkge1xuICAgICAgcmV0dXJuIGFzQXJyYXkgPyBbeC5sZW5ndGhdIDogbmV3IE1hdHJpeChbeC5sZW5ndGhdKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgcmV0dXJuIGFycmF5LnNpemUoeCk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgIHJldHVybiBuZXcgTWF0cml4KHguc2l6ZSgpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignc2l6ZScsIG1hdGhbJ3R5cGVvZiddKHgpKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4JyksXG5cbiAgICAgIG9iamVjdCA9IHV0aWwub2JqZWN0LFxuICAgICAgYXJyYXkgPSB1dGlsLmFycmF5LFxuICAgICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgLyoqXG4gICAqIFNxdWVlemUgYSBtYXRyaXgsIHJlbW92ZSBpbm5lciBhbmQgb3V0ZXIgc2luZ2xldG9uIGRpbWVuc2lvbnMgZnJvbSBhIG1hdHJpeC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5zcXVlZXplKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5zcXVlZXplKFszXSk7ICAgICAgICAgICAvLyByZXR1cm5zIDNcbiAgICogICAgIG1hdGguc3F1ZWV6ZShbWzNdXSk7ICAgICAgICAgLy8gcmV0dXJucyAzXG4gICAqXG4gICAqICAgICB2YXIgQSA9IG1hdGguemVyb3MoMywgMSk7ICAgIC8vIHJldHVybnMgW1swXSwgWzBdLCBbMF1dIChzaXplIDN4MSlcbiAgICogICAgIG1hdGguc3F1ZWV6ZShBKTsgICAgICAgICAgICAgLy8gcmV0dXJucyBbMCwgMCwgMF0gKHNpemUgMylcbiAgICpcbiAgICogICAgIHZhciBCID0gbWF0aC56ZXJvcygxLCAzKTsgICAgLy8gcmV0dXJucyBbWzAsIDAsIDBdXSAoc2l6ZSAxeDMpXG4gICAqICAgICBtYXRoLnNxdWVlemUoQik7ICAgICAgICAgICAgIC8vIHJldHVybnMgWzAsIDAsIDBdIChzaXplIDMpXG4gICAqXG4gICAqICAgICAvLyBvbmx5IGlubmVyIGFuZCBvdXRlciBkaW1lbnNpb25zIGFyZSByZW1vdmVkXG4gICAqICAgICB2YXIgQyA9IG1hdGguemVyb3MoMiwgMSwgMyk7IC8vIHJldHVybnMgW1tbMCwgMCwgMF1dLCBbWzAsIDAsIDBdXV0gKHNpemUgMngxeDMpXG4gICAqICAgICBtYXRoLnNxdWVlemUoQyk7ICAgICAgICAgICAgIC8vIHJldHVybnMgW1tbMCwgMCwgMF1dLCBbWzAsIDAsIDBdXV0gKHNpemUgMngxeDMpXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgc3Vic2V0XG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4IHwgQXJyYXl9IHggICAgICBNYXRyaXggdG8gYmUgc3F1ZWV6ZWRcbiAgICogQHJldHVybiB7TWF0cml4IHwgQXJyYXl9IFNxdWVlemVkIG1hdHJpeFxuICAgKi9cbiAgbWF0aC5zcXVlZXplID0gZnVuY3Rpb24gc3F1ZWV6ZSAoeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdzcXVlZXplJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoeCkpIHtcbiAgICAgIHJldHVybiBhcnJheS5zcXVlZXplKG9iamVjdC5jbG9uZSh4KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgIHZhciByZXMgPSBhcnJheS5zcXVlZXplKHgudG9BcnJheSgpKTtcbiAgICAgIHJldHVybiBpc0FycmF5KHJlcykgPyBuZXcgTWF0cml4KHJlcykgOiByZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gc2NhbGFyXG4gICAgICByZXR1cm4gb2JqZWN0LmNsb25lKHgpO1xuICAgIH1cbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4JyksXG4gICAgICBJbmRleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvSW5kZXgnKSxcblxuICAgICAgYXJyYXkgPSB1dGlsLmFycmF5LFxuICAgICAgaXNTdHJpbmcgPSB1dGlsLnN0cmluZy5pc1N0cmluZyxcbiAgICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IGEgc3Vic2V0IG9mIGEgbWF0cml4IG9yIHN0cmluZy5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKiAgICAgbWF0aC5zdWJzZXQodmFsdWUsIGluZGV4KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0cmlldmUgYSBzdWJzZXRcbiAgICogICAgIG1hdGguc3Vic2V0KHZhbHVlLCBpbmRleCwgcmVwbGFjZW1lbnQgWywgZGVmYXVsdFZhbHVlXSkgIC8vIHJlcGxhY2UgYSBzdWJzZXRcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICAvLyBnZXQgYSBzdWJzZXRcbiAgICogICAgIHZhciBkID0gW1sxLCAyXSwgWzMsIDRdXTtcbiAgICogICAgIG1hdGguc3Vic2V0KGQsIG1hdGguaW5kZXgoMSwgMCkpOyAgICAgICAgLy8gcmV0dXJucyAzXG4gICAqICAgICBtYXRoLnN1YnNldChkLCBtYXRoLmluZGV4KFswLCAyXSwgMSkpOyAgIC8vIHJldHVybnMgW1syXSwgWzRdXVxuICAgKlxuICAgKiAgICAgLy8gcmVwbGFjZSBhIHN1YnNldFxuICAgKiAgICAgdmFyIGUgPSBbXTtcbiAgICogICAgIHZhciBmID0gbWF0aC5zdWJzZXQoZSwgbWF0aC5pbmRleCgwLCBbMCwgMl0pLCBbNSwgNl0pOyAgLy8gZiA9IFtbNSwgNl1dXG4gICAqICAgICB2YXIgZyA9IG1hdGguc3Vic2V0KGYsIG1hdGguaW5kZXgoMSwgMSksIDcsIDApOyAgICAgICAgIC8vIGcgPSBbWzUsIDZdLCBbMCwgN11dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgc2l6ZSwgcmVzaXplLCBzcXVlZXplLCBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4IHwgU3RyaW5nfSBtYXRyaXggIEFuIGFycmF5LCBtYXRyaXgsIG9yIHN0cmluZ1xuICAgKiBAcGFyYW0ge0luZGV4fSBpbmRleCAgICAgICAgICAgICAgICAgICAgIEFuIGluZGV4IGNvbnRhaW5pbmcgcmFuZ2VzIGZvciBlYWNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uXG4gICAqIEBwYXJhbSB7Kn0gW3JlcGxhY2VtZW50XSAgICAgICAgICAgICAgICAgQW4gYXJyYXksIG1hdHJpeCwgb3Igc2NhbGFyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHByb3ZpZGVkLCB0aGUgc3Vic2V0IGlzIHJlcGxhY2VkIHdpdGggcmVwbGFjZW1lbnQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGUgc3Vic2V0IGlzIHJldHVybmVkXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZT11bmRlZmluZWRdICAgICAgRGVmYXVsdCB2YWx1ZSwgZmlsbGVkIGluIG9uIG5ldyBlbnRyaWVzIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbWF0cml4IGlzIHJlc2l6ZWQuIElmIG5vdCBwcm92aWRlZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgbWF0cml4IGVsZW1lbnRzIHdpbGwgYmUgbGVmdCB1bmRlZmluZWQuXG4gICAqIEByZXR1cm4ge0FycmF5IHwgTWF0cml4IHwgU3RyaW5nfSBFaXRoZXIgdGhlIHJldHJpZXZlZCBzdWJzZXQgb3IgdGhlIHVwZGF0ZWQgbWF0cml4LlxuICAgKi9cbiAgbWF0aC5zdWJzZXQgPSBmdW5jdGlvbiBzdWJzZXQgKG1hdHJpeCwgaW5kZXgsIHJlcGxhY2VtZW50LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjogLy8gZ2V0IHN1YnNldFxuICAgICAgICByZXR1cm4gX2dldFN1YnNldChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG5cbiAgICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgY2FzZSAzOiAvLyBzZXQgc3Vic2V0XG4gICAgICBjYXNlIDQ6IC8vIHNldCBzdWJzZXQgd2l0aCBkZWZhdWx0IHZhbHVlXG4gICAgICAgIHJldHVybiBfc2V0U3Vic2V0KGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG5cbiAgICAgIGRlZmF1bHQ6IC8vIHdyb25nIG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3N1YnNldCcsIGFyZ3VtZW50cy5sZW5ndGgsIDIsIDQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgYSBzdWJzZXQgb2YgYW4gdmFsdWUgc3VjaCBhcyBhbiBBcnJheSwgTWF0cml4LCBvciBTdHJpbmdcbiAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeCB8IFN0cmluZ30gdmFsdWUgT2JqZWN0IGZyb20gd2hpY2ggdG8gZ2V0IGEgc3Vic2V0XG4gICAqIEBwYXJhbSB7SW5kZXh9IGluZGV4ICAgICAgICAgICAgICAgICAgIEFuIGluZGV4IGNvbnRhaW5pbmcgcmFuZ2VzIGZvciBlYWNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvblxuICAgKiBAcmV0dXJucyB7QXJyYXkgfCBNYXRyaXggfCAqfSBzdWJzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRTdWJzZXQodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIG0sIHN1YnNldDtcblxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgbSA9IG5ldyBNYXRyaXgodmFsdWUpO1xuICAgICAgc3Vic2V0ID0gbS5zdWJzZXQoaW5kZXgpOyAgICAgICAgICAgLy8gcmV0dXJucyBhIE1hdHJpeFxuICAgICAgcmV0dXJuIHN1YnNldCAmJiBzdWJzZXQudmFsdWVPZigpOyAgLy8gcmV0dXJuIGFuIEFycmF5IChsaWtlIHRoZSBpbnB1dClcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5zdWJzZXQoaW5kZXgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBfZ2V0U3Vic3RyaW5nKHZhbHVlLCBpbmRleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ3N1YnNldCcsIG1hdGhbJ3R5cGVvZiddKHZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgc3Vic2V0IG9mIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgICAgICBTdHJpbmcgZnJvbSB3aGljaCB0byBnZXQgYSBzdWJzdHJpbmdcbiAgICogQHBhcmFtIHtJbmRleH0gaW5kZXggICAgICAgICAgIEFuIGluZGV4IGNvbnRhaW5pbmcgcmFuZ2VzIGZvciBlYWNoIGRpbWVuc2lvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdWJzdHJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRTdWJzdHJpbmcoc3RyLCBpbmRleCkge1xuICAgIGlmICghKGluZGV4IGluc3RhbmNlb2YgSW5kZXgpKSB7XG4gICAgICAvLyBUT0RPOiBiZXR0ZXIgZXJyb3IgbWVzc2FnZVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5kZXggZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgaWYgKGluZGV4LnNpemUoKS5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuRGltZW5zaW9uRXJyb3IoaW5kZXguc2l6ZSgpLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgd2hldGhlciB0aGUgcmFuZ2UgaXMgb3V0IG9mIHJhbmdlXG4gICAgdmFyIHN0ckxlbiA9IHN0ci5sZW5ndGg7XG4gICAgYXJyYXkudmFsaWRhdGVJbmRleChpbmRleC5taW4oKVswXSwgc3RyTGVuKTtcbiAgICBhcnJheS52YWxpZGF0ZUluZGV4KGluZGV4Lm1heCgpWzBdLCBzdHJMZW4pO1xuXG4gICAgdmFyIHJhbmdlID0gaW5kZXgucmFuZ2UoMCk7XG5cbiAgICB2YXIgc3Vic3RyID0gJyc7XG4gICAgcmFuZ2UuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgc3Vic3RyICs9IHN0ci5jaGFyQXQodik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3Vic3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYSBzdWJzZXQgaW4gYW4gdmFsdWUgc3VjaCBhcyBhbiBBcnJheSwgTWF0cml4LCBvciBTdHJpbmdcbiAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeCB8IFN0cmluZ30gdmFsdWUgT2JqZWN0IHRvIGJlIHJlcGxhY2VkXG4gICAqIEBwYXJhbSB7SW5kZXh9IGluZGV4ICAgICAgICAgICAgICAgICAgIEFuIGluZGV4IGNvbnRhaW5pbmcgcmFuZ2VzIGZvciBlYWNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvblxuICAgKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4IHwgKn0gcmVwbGFjZW1lbnRcbiAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlPTBdICAgICAgRGVmYXVsdCB2YWx1ZSwgZmlsbGVkIGluIG9uIG5ldyBlbnRyaWVzIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG1hdHJpeCBpcyByZXNpemVkLiBJZiBub3QgcHJvdmlkZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBtYXRyaXggZWxlbWVudHMgd2lsbCBiZSBmaWxsZWQgd2l0aCB6ZXJvcy5cbiAgICogQHJldHVybnMgeyp9IHJlc3VsdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3NldFN1YnNldCh2YWx1ZSwgaW5kZXgsIHJlcGxhY2VtZW50LCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgbTtcblxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgbSA9IG5ldyBNYXRyaXgobWF0aC5jbG9uZSh2YWx1ZSkpO1xuICAgICAgbS5zdWJzZXQoaW5kZXgsIHJlcGxhY2VtZW50LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgcmV0dXJuIG0udmFsdWVPZigpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgcmV0dXJuIHZhbHVlLmNsb25lKCkuc3Vic2V0KGluZGV4LCByZXBsYWNlbWVudCwgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gX3NldFN1YnN0cmluZyh2YWx1ZSwgaW5kZXgsIHJlcGxhY2VtZW50LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdzdWJzZXQnLCBtYXRoWyd0eXBlb2YnXSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgICAgICBTdHJpbmcgdG8gYmUgcmVwbGFjZWRcbiAgICogQHBhcmFtIHtJbmRleH0gaW5kZXggICAgICAgICAgIEFuIGluZGV4IGNvbnRhaW5pbmcgcmFuZ2VzIGZvciBlYWNoIGRpbWVuc2lvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVwbGFjZW1lbnQgICAgUmVwbGFjZW1lbnQgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZGVmYXVsdFZhbHVlXSBEZWZhdWx0IHZhbHVlIHRvIGJlIHVzZXMgd2hlbiByZXNpemluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHN0cmluZy4gaXMgJyAnIGJ5IGRlZmF1bHRcbiAgICogQHJldHVybnMge3N0cmluZ30gcmVzdWx0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfc2V0U3Vic3RyaW5nKHN0ciwgaW5kZXgsIHJlcGxhY2VtZW50LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoIShpbmRleCBpbnN0YW5jZW9mIEluZGV4KSkge1xuICAgICAgLy8gVE9ETzogYmV0dGVyIGVycm9yIG1lc3NhZ2VcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luZGV4IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGlmIChpbmRleC5zaXplKCkubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkRpbWVuc2lvbkVycm9yKGluZGV4LnNpemUoKS5sZW5ndGgsIDEpO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghaXNTdHJpbmcoZGVmYXVsdFZhbHVlKSB8fCBkZWZhdWx0VmFsdWUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NpbmdsZSBjaGFyYWN0ZXIgZXhwZWN0ZWQgYXMgZGVmYXVsdFZhbHVlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyAnO1xuICAgIH1cblxuICAgIHZhciByYW5nZSA9IGluZGV4LnJhbmdlKDApO1xuICAgIHZhciBsZW4gPSByYW5nZS5zaXplKClbMF07XG5cbiAgICBpZiAobGVuICE9IHJlcGxhY2VtZW50Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuRGltZW5zaW9uRXJyb3IocmFuZ2Uuc2l6ZSgpWzBdLCByZXBsYWNlbWVudC5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIHdoZXRoZXIgdGhlIHJhbmdlIGlzIG91dCBvZiByYW5nZVxuICAgIHZhciBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuICAgIGFycmF5LnZhbGlkYXRlSW5kZXgoaW5kZXgubWluKClbMF0pO1xuICAgIGFycmF5LnZhbGlkYXRlSW5kZXgoaW5kZXgubWF4KClbMF0pO1xuXG4gICAgLy8gY29weSB0aGUgc3RyaW5nIGludG8gYW4gYXJyYXkgd2l0aCBjaGFyYWN0ZXJzXG4gICAgdmFyIGNoYXJzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJMZW47IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBzdHIuY2hhckF0KGkpO1xuICAgIH1cblxuICAgIHJhbmdlLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgIGNoYXJzW3ZdID0gcmVwbGFjZW1lbnQuY2hhckF0KGkpO1xuICAgIH0pO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB1bmRlZmluZWQgY2hhcmFjdGVycyB3aXRoIGEgc3BhY2VcbiAgICBpZiAoY2hhcnMubGVuZ3RoID4gc3RyTGVuKSB7XG4gICAgICBmb3IgKGkgPSBzdHJMZW4gLSAxLCBsZW4gPSBjaGFycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWNoYXJzW2ldKSB7XG4gICAgICAgICAgY2hhcnNbaV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4JyksXG5cbiAgICAgIG9iamVjdCA9IHV0aWwub2JqZWN0LFxuICAgICAgc3RyaW5nID0gdXRpbC5zdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRyYW5zcG9zZSBhIG1hdHJpeC4gQWxsIHZhbHVlcyBvZiB0aGUgbWF0cml4IGFyZSByZWZsZWN0ZWQgb3ZlciBpdHNcbiAgICogbWFpbiBkaWFnb25hbC4gT25seSB0d28gZGltZW5zaW9uYWwgbWF0cmljZXMgYXJlIHN1cHBvcnRlZC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC50cmFuc3Bvc2UoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICB2YXIgQSA9IFtbMSwgMiwgM10sIFs0LCA1LCA2XV07XG4gICAqICAgICBtYXRoLnRyYW5zcG9zZShBKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIFtbMSwgNF0sIFsyLCA1XSwgWzMsIDZdXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgIGRpYWcsIGludiwgc3Vic2V0LCBzcXVlZXplXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IHggIE1hdHJpeCB0byBiZSB0cmFuc3Bvc2VkXG4gICAqIEByZXR1cm4ge0FycmF5IHwgTWF0cml4fSAgIFRoZSB0cmFuc3Bvc2VkIG1hdHJpeFxuICAgKi9cbiAgbWF0aC50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UgKHgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcigndHJhbnNwb3NlJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgdmFyIHNpemUgPSBtYXRoLnNpemUoeCkudmFsdWVPZigpO1xuICAgIHN3aXRjaCAoc2l6ZS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLy8gc2NhbGFyXG4gICAgICAgIHJldHVybiBvYmplY3QuY2xvbmUoeCk7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLy8gdmVjdG9yXG4gICAgICAgIHJldHVybiBvYmplY3QuY2xvbmUoeCk7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gdHdvIGRpbWVuc2lvbmFsIGFycmF5XG4gICAgICAgIHZhciByb3dzID0gc2l6ZVsxXSxcbiAgICAgICAgICAgIGNvbHMgPSBzaXplWzBdLFxuICAgICAgICAgICAgYXNNYXRyaXggPSAoeCBpbnN0YW5jZW9mIE1hdHJpeCksXG4gICAgICAgICAgICBkYXRhID0geC52YWx1ZU9mKCksXG4gICAgICAgICAgICB0cmFuc3Bvc2VkID0gW10sXG4gICAgICAgICAgICB0cmFuc3Bvc2VkUm93LFxuICAgICAgICAgICAgY2xvbmUgPSBvYmplY3QuY2xvbmU7XG5cbiAgICAgICAgaWYgKHJvd3MgPT09IDApIHtcbiAgICAgICAgICAvLyB3aG9vcHNcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ2Fubm90IHRyYW5zcG9zZSBhIDJEIG1hdHJpeCB3aXRoIG5vIHJvd3MnICtcbiAgICAgICAgICAgICAgJyhzaXplOiAnICsgc3RyaW5nLmZvcm1hdChzaXplKSArICcpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgICAgIHRyYW5zcG9zZWRSb3cgPSB0cmFuc3Bvc2VkW3JdID0gW107XG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb2xzOyBjKyspIHtcbiAgICAgICAgICAgIHRyYW5zcG9zZWRSb3dbY10gPSBjbG9uZShkYXRhW2NdW3JdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNNYXRyaXggPyBuZXcgTWF0cml4KHRyYW5zcG9zZWQpIDogdHJhbnNwb3NlZDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHR3byBkaW1lbnNpb25hbCAnICtcbiAgICAgICAgICAgICcoc2l6ZTogJyArIHN0cmluZy5mb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgIH1cbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgsIGNvbmZpZykge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGFycmF5ID0gdXRpbC5hcnJheSxcbiAgICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtYXRyaXggZmlsbGVkIHdpdGggemVyb3MuIFRoZSBjcmVhdGVkIG1hdHJpeCBjYW4gaGF2ZSBvbmUgb3JcbiAgICogbXVsdGlwbGUgZGltZW5zaW9ucy5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnplcm9zKG0pXG4gICAqICAgIG1hdGguemVyb3MobSwgbilcbiAgICogICAgbWF0aC56ZXJvcyhbbSwgbl0pXG4gICAqICAgIG1hdGguemVyb3MoW20sIG4sIHAsIC4uLl0pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnplcm9zKDMpOyAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgWzAsIDAsIDBdXG4gICAqICAgIG1hdGguemVyb3MoMywgMik7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbWzAsIDBdLCBbMCwgMF0sIFswLCAwXV1cbiAgICpcbiAgICogICAgdmFyIEEgPSBbWzEsIDIsIDNdLCBbNCwgNSwgNl1dO1xuICAgKiAgICBtYXRoLnplcm9zKG1hdGguc2l6ZShBKSk7ICAgICAgIC8vIHJldHVybnMgW1swLCAwLCAwXSwgWzAsIDAsIDBdXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgb25lcywgZXllLCBzaXplLCByYW5nZVxuICAgKlxuICAgKiBAcGFyYW0gey4uLk51bWJlciB8IEFycmF5fSBzaXplICAgIFRoZSBzaXplIG9mIGVhY2ggZGltZW5zaW9uIG9mIHRoZSBtYXRyaXhcbiAgICogQHJldHVybiB7QXJyYXkgfCBNYXRyaXggfCBOdW1iZXJ9ICBBIG1hdHJpeCBmaWxsZWQgd2l0aCB6ZXJvc1xuICAgKi9cbiAgbWF0aC56ZXJvcyA9IGZ1bmN0aW9uIHplcm9zIChzaXplKSB7XG4gICAgdmFyIGFyZ3MgPSBjb2xsZWN0aW9uLmFyZ3NUb0FycmF5KGFyZ3VtZW50cyk7XG4gICAgdmFyIGFzTWF0cml4ID0gKHNpemUgaW5zdGFuY2VvZiBNYXRyaXgpID8gdHJ1ZSA6XG4gICAgICAgIChpc0FycmF5KHNpemUpID8gZmFsc2UgOiAoY29uZmlnLm1hdHJpeCA9PT0gJ21hdHJpeCcpKTtcblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAvLyBvdXRwdXQgYW4gZW1wdHkgbWF0cml4XG4gICAgICByZXR1cm4gYXNNYXRyaXggPyBuZXcgTWF0cml4KCkgOiBbXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBvdXRwdXQgYW4gYXJyYXkgb3IgbWF0cml4XG5cbiAgICAgIC8vIGNvbnZlcnQgYXJndW1lbnRzIGZyb20gYmlnbnVtYmVyIHRvIG51bWJlcnMgaWYgbmVlZGVkXG4gICAgICB2YXIgYXNCaWdOdW1iZXIgPSBmYWxzZTtcbiAgICAgIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgICAgYXNCaWdOdW1iZXIgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB2YWx1ZS50b051bWJlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIHJlc2l6ZSB0aGUgbWF0cml4XG4gICAgICB2YXIgcmVzID0gW107XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXNCaWdOdW1iZXIgPyBuZXcgQmlnTnVtYmVyKDApIDogMDtcbiAgICAgIHJlcyA9IGFycmF5LnJlc2l6ZShyZXMsIGFyZ3MsIGRlZmF1bHRWYWx1ZSk7XG5cbiAgICAgIHJldHVybiBhc01hdHJpeCA/IG5ldyBNYXRyaXgocmVzKSA6IHJlcztcbiAgICB9XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzSW50ZWdlciA9IHV0aWwubnVtYmVyLmlzSW50ZWdlcixcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBmYWN0b3JpYWwgb2YgYSB2YWx1ZVxuICAgKlxuICAgKiBGYWN0b3JpYWwgb25seSBzdXBwb3J0cyBhbiBpbnRlZ2VyIHZhbHVlIGFzIGFyZ3VtZW50LlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZmFjdG9yaWFsKG4pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmZhY3RvcmlhbCg1KTsgICAgLy8gcmV0dXJucyAxMjBcbiAgICogICAgbWF0aC5mYWN0b3JpYWwoMyk7ICAgIC8vIHJldHVybnMgNlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY29tYmluYXRpb25zLCBwZXJtdXRhdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeCB8IEJvb2xlYW4gfCBudWxsfSBuICAgQW4gaW50ZWdlciBudW1iZXJcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9ICAgIFRoZSBmYWN0b3JpYWwgb2YgYG5gXG4gICAqL1xuICBtYXRoLmZhY3RvcmlhbCA9IGZ1bmN0aW9uIGZhY3RvcmlhbCAobikge1xuICAgIHZhciB2YWx1ZSwgcmVzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2ZhY3RvcmlhbCcsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihuKSkge1xuICAgICAgaWYgKCFpc0ludGVnZXIobikgfHwgbiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUG9zaXRpdmUgaW50ZWdlciB2YWx1ZSBleHBlY3RlZCBpbiBmdW5jdGlvbiBmYWN0b3JpYWwnKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBuIC0gMTtcbiAgICAgIHJlcyA9IG47XG4gICAgICB3aGlsZSAodmFsdWUgPiAxKSB7XG4gICAgICAgIHJlcyAqPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUtLTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcyA9PSAwKSB7XG4gICAgICAgIHJlcyA9IDE7ICAgICAgICAvLyAwISBpcyBwZXIgZGVmaW5pdGlvbiAxXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKG4gaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIGlmICghKGlzUG9zaXRpdmVJbnRlZ2VyKG4pKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlIGV4cGVjdGVkIGluIGZ1bmN0aW9uIGZhY3RvcmlhbCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb25lID0gbmV3IEJpZ051bWJlcigxKTtcblxuICAgICAgdmFsdWUgPSBuLm1pbnVzKG9uZSk7XG4gICAgICByZXMgPSBuO1xuICAgICAgd2hpbGUgKHZhbHVlLmd0KG9uZSkpIHtcbiAgICAgICAgcmVzID0gcmVzLnRpbWVzKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5taW51cyhvbmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzLmVxdWFscygwKSkge1xuICAgICAgICByZXMgPSBvbmU7ICAgICAgICAvLyAwISBpcyBwZXIgZGVmaW5pdGlvbiAxXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbihuKSB8fCBuID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMTsgLy8gZmFjdG9yaWFsKDEpID0gMSwgZmFjdG9yaWFsKDApID0gMVxuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24obikpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAobiwgZmFjdG9yaWFsKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignZmFjdG9yaWFsJywgbWF0aFsndHlwZW9mJ10obikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgQmlnTnVtYmVyIG4gaXMgYSBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSBuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBpc1Bvc2l0aXZlSW50ZWdlclxuICAgKi9cbiAgdmFyIGlzUG9zaXRpdmVJbnRlZ2VyID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBuLmlzSW50ZWdlcigpICYmIG4uZ3RlKDApO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgZGlzdHJpYnV0aW9uID0gcmVxdWlyZSgnLi9kaXN0cmlidXRpb24nKShtYXRoKTtcblxuICAvKipcbiAgICogUmV0dXJuIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCB1c2luZyBhIHVuaWZvcm0gZGlzdHJpYnV0aW9uLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLnJhbmRvbSgpICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICogICAgIG1hdGgucmFuZG9tKG1heCkgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gMCBhbmQgbWF4XG4gICAqICAgICBtYXRoLnJhbmRvbShtaW4sIG1heCkgICAgICAgIC8vIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gICAqICAgICBtYXRoLnJhbmRvbShzaXplKSAgICAgICAgICAgIC8vIGdlbmVyYXRlIGEgbWF0cml4IHdpdGggcmFuZG9tIG51bWJlcnMgYmV0d2VlbiAwIGFuZCAxXG4gICAqICAgICBtYXRoLnJhbmRvbShzaXplLCBtYXgpICAgICAgIC8vIGdlbmVyYXRlIGEgbWF0cml4IHdpdGggcmFuZG9tIG51bWJlcnMgYmV0d2VlbiAwIGFuZCBtYXhcbiAgICogICAgIG1hdGgucmFuZG9tKHNpemUsIG1pbiwgbWF4KSAgLy8gZ2VuZXJhdGUgYSBtYXRyaXggd2l0aCByYW5kb20gbnVtYmVycyBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5yYW5kb20oKTsgICAgICAgLy8gcmV0dXJucyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAqICAgICBtYXRoLnJhbmRvbSgxMDApOyAgICAvLyByZXR1cm5zIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEwMFxuICAgKiAgICAgbWF0aC5yYW5kb20oMzAsIDQwKTsgLy8gcmV0dXJucyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAzMCBhbmQgNDBcbiAgICogICAgIG1hdGgucmFuZG9tKFsyLCAzXSk7IC8vIHJldHVybnMgYSAyeDMgbWF0cml4IHdpdGggcmFuZG9tIG51bWJlcnMgYmV0d2VlbiAwIGFuZCAxXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgcmFuZG9tSW50LCBwaWNrUmFuZG9tXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZV0gSWYgcHJvdmlkZWQsIGFuIGFycmF5IHdpdGggYHNpemVgIG51bWJlciBvZiByYW5kb20gdmFsdWVzIGlzIHJldHVybmVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluXSAgTWluaW11bSBib3VuZGFyeSBmb3IgdGhlIHJhbmRvbSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heF0gIE1heGltdW0gYm91bmRhcnkgZm9yIHRoZSByYW5kb20gdmFsdWVcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IEEgcmFuZG9tIG51bWJlclxuICAgKi9cbiAgbWF0aC5yYW5kb20gPSBkaXN0cmlidXRpb24oJ3VuaWZvcm0nKS5yYW5kb207XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciBkaXN0cmlidXRpb24gPSByZXF1aXJlKCcuL2Rpc3RyaWJ1dGlvbicpKG1hdGgpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgdXNpbmcgYSB1bmlmb3JtIGRpc3RyaWJ1dGlvbi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5yYW5kb21JbnQoKSAgICAgICAgICAgICAgICAvLyBnZW5lcmF0ZSBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMVxuICAgKiAgICAgbWF0aC5yYW5kb21JbnQobWF4KSAgICAgICAgICAgICAvLyBnZW5lcmF0ZSBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgbWF4XG4gICAqICAgICBtYXRoLnJhbmRvbUludChtaW4sIG1heCkgICAgICAgIC8vIGdlbmVyYXRlIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgKiAgICAgbWF0aC5yYW5kb21JbnQoc2l6ZSkgICAgICAgICAgICAvLyBnZW5lcmF0ZSBhIG1hdHJpeCB3aXRoIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMVxuICAgKiAgICAgbWF0aC5yYW5kb21JbnQoc2l6ZSwgbWF4KSAgICAgICAvLyBnZW5lcmF0ZSBhIG1hdHJpeCB3aXRoIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgbWF4XG4gICAqICAgICBtYXRoLnJhbmRvbUludChzaXplLCBtaW4sIG1heCkgIC8vIGdlbmVyYXRlIGEgbWF0cml4IHdpdGggcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGgucmFuZG9tSW50KCk7ICAgICAgIC8vIHJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICogICAgIG1hdGgucmFuZG9tSW50KDEwMCk7ICAgIC8vIHJldHVybnMgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDEwMFxuICAgKiAgICAgbWF0aC5yYW5kb21JbnQoMzAsIDQwKTsgLy8gcmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMzAgYW5kIDQwXG4gICAqICAgICBtYXRoLnJhbmRvbUludChbMiwgM10pOyAvLyByZXR1cm5zIGEgMngzIG1hdHJpeCB3aXRoIHJhbmRvbSBpbnRlZ2VycyBiZXR3ZWVuIDAgYW5kIDFcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICByYW5kb21JbnQsIHBpY2tSYW5kb21cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtzaXplXSBJZiBwcm92aWRlZCwgYW4gYXJyYXkgd2l0aCBgc2l6ZWAgbnVtYmVyIG9mIHJhbmRvbSB2YWx1ZXMgaXMgcmV0dXJuZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttaW5dICBNaW5pbXVtIGJvdW5kYXJ5IGZvciB0aGUgcmFuZG9tIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4XSAgTWF4aW11bSBib3VuZGFyeSBmb3IgdGhlIHJhbmRvbSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0gQSByYW5kb20gaW50ZWdlciB2YWx1ZVxuICAgKi9cbiAgbWF0aC5yYW5kb21JbnQgPSBkaXN0cmlidXRpb24oJ3VuaWZvcm0nKS5yYW5kb21JbnQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciBkaXN0cmlidXRpb24gPSByZXF1aXJlKCcuL2Rpc3RyaWJ1dGlvbicpKG1hdGgpO1xuXG4gIC8qKlxuICAgKiBSYW5kb20gcGljayBhIHZhbHVlIGZyb20gYSBvbmUgZGltZW5zaW9uYWwgYXJyYXkuXG4gICAqIEFycmF5IGVsZW1lbnQgaXMgcGlja2VkIHVzaW5nIGEgcmFuZG9tIGZ1bmN0aW9uIHdpdGggdW5pZm9ybSBkaXN0cmlidXRpb24uXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGgucGlja1JhbmRvbShhcnJheSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLnBpY2tSYW5kb20oWzMsIDYsIDEyLCAyXSk7ICAgICAgIC8vIHJldHVybnMgb25lIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgcmFuZG9tLCByYW5kb21JbnRcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgICAgIEEgb25lIGRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEByZXR1cm4ge051bWJlcn0gT25lIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgcHJvdmlkZWQgaW5wdXQgYXJyYXlcbiAgICovXG4gIG1hdGgucGlja1JhbmRvbSA9IGRpc3RyaWJ1dGlvbigndW5pZm9ybScpLnBpY2tSYW5kb207XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxuICAgICAgaXNJbnRlZ2VyID0gdXRpbC5udW1iZXIuaXNJbnRlZ2VyO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBudW1iZXIgb2Ygd2F5cyBvZiBvYnRhaW5pbmcgYW4gb3JkZXJlZCBzdWJzZXQgb2YgYGtgIGVsZW1lbnRzXG4gICAqIGZyb20gYSBzZXQgb2YgYG5gIGVsZW1lbnRzLlxuICAgKlxuICAgKiBQZXJtdXRhdGlvbnMgb25seSB0YWtlcyBpbnRlZ2VyIGFyZ3VtZW50cy5cbiAgICogVGhlIGZvbGxvd2luZyBjb25kaXRpb24gbXVzdCBiZSBlbmZvcmNlZDogayA8PSBuLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLnBlcm11dGF0aW9ucyhuKVxuICAgKiAgICAgbWF0aC5wZXJtdXRhdGlvbnMobiwgaylcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgucGVybXV0YXRpb25zKDUpOyAgICAgLy8gMTIwXG4gICAqICAgIG1hdGgucGVybXV0YXRpb25zKDUsIDMpOyAgLy8gNjBcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGNvbWJpbmF0aW9ucywgZmFjdG9yaWFsXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQmlnTnVtYmVyfSBuICBUaGUgbnVtYmVyIG9mIG9iamVjdHMgaW4gdG90YWxcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCaWdOdW1iZXJ9IGsgIFRoZSBudW1iZXIgb2Ygb2JqZWN0cyBpbiB0aGUgc3Vic2V0XG4gICAqIEByZXR1cm4ge051bWJlciB8IEJpZ051bWJlcn0gICBUaGUgbnVtYmVyIG9mIHBlcm11dGF0aW9uc1xuICAgKi9cbiAgbWF0aC5wZXJtdXRhdGlvbnMgPSBmdW5jdGlvbiBwZXJtdXRhdGlvbnMgKG4sIGspIHtcbiAgICB2YXIgcmVzdWx0LCBpO1xuXG4gICAgdmFyIGFyaXR5ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAoYXJpdHkgPiAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcigncGVybXV0YXRpb25zJywgYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKG4pKSB7XG4gICAgICBpZiAoIWlzSW50ZWdlcihuKSB8fCBuIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlIGV4cGVjdGVkIGluIGZ1bmN0aW9uIHBlcm11dGF0aW9ucycpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBQZXJtdXRlIG4gb2JqZWN0c1xuICAgICAgaWYgKGFyaXR5ID09IDEpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguZmFjdG9yaWFsKG4pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBQZXJtdXRlIG4gb2JqZWN0cywgayBhdCBhIHRpbWVcbiAgICAgIGlmIChhcml0eSA9PSAyKSB7XG4gICAgICAgIGlmIChpc051bWJlcihrKSkge1xuICAgICAgICAgIGlmICghaXNJbnRlZ2VyKGspIHx8IGsgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlIGV4cGVjdGVkIGluIGZ1bmN0aW9uIHBlcm11dGF0aW9ucycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoayA+IG4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NlY29uZCBhcmd1bWVudCBrIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGZpcnN0IGFyZ3VtZW50IG4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSAxO1xuICAgICAgICAgIGZvciAoaSA9IG4gLSBrICsgMTsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobiBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgaWYgKGsgPT09IHVuZGVmaW5lZCAmJiBpc1Bvc2l0aXZlSW50ZWdlcihuKSkge1xuICAgICAgICByZXR1cm4gbWF0aC5mYWN0b3JpYWwobik7XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBrIGlzIGEgQmlnTnVtYmVyIGFzIHdlbGxcbiAgICAgIC8vIG5vdCBhbGwgbnVtYmVycyBjYW4gYmUgY29udmVydGVkIHRvIEJpZ051bWJlclxuICAgICAgayA9IEJpZ051bWJlci5jb252ZXJ0KGspO1xuXG4gICAgICBpZiAoIShrIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB8fCAhaXNQb3NpdGl2ZUludGVnZXIobikgfHwgIWlzUG9zaXRpdmVJbnRlZ2VyKGspKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Bvc2l0aXZlIGludGVnZXIgdmFsdWUgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gcGVybXV0YXRpb25zJyk7XG4gICAgICB9XG4gICAgICBpZiAoay5ndChuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzZWNvbmQgYXJndW1lbnQgayBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBmaXJzdCBhcmd1bWVudCBuJyk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBCaWdOdW1iZXIoMSk7XG4gICAgICBmb3IgKGkgPSBuLm1pbnVzKGspLnBsdXMoMSk7IGkubHRlKG4pOyBpID0gaS5wbHVzKDEpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50aW1lcyhpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ3Blcm11dGF0aW9ucycsIG1hdGhbJ3R5cGVvZiddKG4pKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIEJpZ051bWJlciBuIGlzIGEgcG9zaXRpdmUgaW50ZWdlclxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gblxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXNQb3NpdGl2ZUludGVnZXJcbiAgICovXG4gIHZhciBpc1Bvc2l0aXZlSW50ZWdlciA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gbi5pc0ludGVnZXIoKSAmJiBuLmd0ZSgwKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0ludGVnZXIgPSB1dGlsLm51bWJlci5pc0ludGVnZXI7XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIG51bWJlciBvZiB3YXlzIG9mIHBpY2tpbmcgYGtgIHVub3JkZXJlZCBvdXRjb21lcyBmcm9tIGBuYFxuICAgKiBwb3NzaWJpbGl0aWVzLlxuICAgKlxuICAgKiBDb21iaW5hdGlvbnMgb25seSB0YWtlcyBpbnRlZ2VyIGFyZ3VtZW50cy5cbiAgICogVGhlIGZvbGxvd2luZyBjb25kaXRpb24gbXVzdCBiZSBlbmZvcmNlZDogayA8PSBuLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmNvbWJpbmF0aW9ucyhuLCBrKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5jb21iaW5hdGlvbnMoNywgNSk7IC8vIHJldHVybnMgMjFcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHBlcm11dGF0aW9ucywgZmFjdG9yaWFsXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQmlnTnVtYmVyfSBuICAgIFRvdGFsIG51bWJlciBvZiBvYmplY3RzIGluIHRoZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCaWdOdW1iZXJ9IGsgICAgTnVtYmVyIG9mIG9iamVjdHMgaW4gdGhlIHN1YnNldFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBCaWdOdW1iZXJ9ICAgICBOdW1iZXIgb2YgcG9zc2libGUgY29tYmluYXRpb25zLlxuICAgKi9cbiAgbWF0aC5jb21iaW5hdGlvbnMgPSBmdW5jdGlvbiBjb21iaW5hdGlvbnMgKG4sIGspIHtcbiAgICB2YXIgbWF4LCByZXN1bHQsIGksaWk7XG5cbiAgICB2YXIgYXJpdHkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChhcml0eSAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignY29tYmluYXRpb25zJywgYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKG4pKSB7XG4gICAgICBpZiAoIWlzSW50ZWdlcihuKSB8fCBuIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQb3NpdGl2ZSBpbnRlZ2VyIHZhbHVlIGVucGVjdGVkIGluIGZ1bmN0aW9uIGNvbWJpbmF0aW9ucycpO1xuICAgICAgfVxuICAgICAgaWYgKGsgPiBuKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2sgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbicpO1xuICAgICAgfVxuXG4gICAgICBtYXggPSBNYXRoLm1heChrLCBuIC0gayk7XG4gICAgICByZXN1bHQgPSAxO1xuICAgICAgZm9yIChpID0gMTsgaSA8PSBuIC0gbWF4OyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICogKG1heCArIGkpIC8gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKG4gaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBrIGlzIGEgQmlnTnVtYmVyIGFzIHdlbGxcbiAgICAgIC8vIG5vdCBhbGwgbnVtYmVycyBjYW4gYmUgY29udmVydGVkIHRvIEJpZ051bWJlclxuICAgICAgayA9IEJpZ051bWJlci5jb252ZXJ0KGspO1xuXG4gICAgICBpZiAoIShrIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB8fCAhaXNQb3NpdGl2ZUludGVnZXIobikgfHwgIWlzUG9zaXRpdmVJbnRlZ2VyKGspKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Bvc2l0aXZlIGludGVnZXIgdmFsdWUgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gY29tYmluYXRpb25zJyk7XG4gICAgICB9XG4gICAgICBpZiAoay5ndChuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrIG11c3QgYmUgbGVzcyB0aGFuIG4gaW4gZnVuY3Rpb24gY29tYmluYXRpb25zJyk7XG4gICAgICB9XG5cbiAgICAgIG1heCA9IG4ubWludXMoayk7XG4gICAgICBpZiAoay5sdChtYXgpKSBtYXggPSBrO1xuICAgICAgcmVzdWx0ID0gbmV3IEJpZ051bWJlcigxKTtcbiAgICAgIGZvciAoaSA9IG5ldyBCaWdOdW1iZXIoMSksIGlpID0gbi5taW51cyhtYXgpOyBpLmx0ZShpaSk7IGkgPSBpLnBsdXMoMSkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRpbWVzKG1heC5wbHVzKGkpKS5kaXZpZGVkQnkoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdjb21iaW5hdGlvbnMnLCBtYXRoWyd0eXBlb2YnXShuKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciBCaWdOdW1iZXIgbiBpcyBhIHBvc2l0aXZlIGludGVnZXJcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IG5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IGlzUG9zaXRpdmVJbnRlZ2VyXG4gICAqL1xuICB2YXIgaXNQb3NpdGl2ZUludGVnZXIgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIG4uaXNJbnRlZ2VyKCkgJiYgbi5ndGUoMCk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbWF4aW11bSB2YWx1ZSBvZiBhIG1hdHJpeCBvciBhICBsaXN0IG9mIHZhbHVlcy5cbiAgICogSW4gY2FzZSBvZiBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5LCB0aGUgbWF4aW11bSBvZiB0aGUgZmxhdHRlbmVkIGFycmF5XG4gICAqIHdpbGwgYmUgY2FsY3VsYXRlZC4gV2hlbiBgZGltYCBpcyBwcm92aWRlZCwgdGhlIG1heGltdW0gb3ZlciB0aGUgc2VsZWN0ZWRcbiAgICogZGltZW5zaW9uIHdpbGwgYmUgY2FsY3VsYXRlZC4gUGFyYW1ldGVyIGBkaW1gIGlzIHplcm8tYmFzZWQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGgubWluKGEsIGIsIGMsIC4uLilcbiAgICogICAgIG1hdGgubWluKEEpXG4gICAqICAgICBtYXRoLm1pbihBLCBkaW0pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5taW4oMiwgMSwgNCwgMyk7ICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAxXG4gICAqICAgICBtYXRoLm1pbihbMiwgMSwgNCwgM10pOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDFcbiAgICpcbiAgICogICAgIC8vIG1heGltdW0gb3ZlciBhIHNwZWNpZmllZCBkaW1lbnNpb24gKHplcm8tYmFzZWQpXG4gICAqICAgICBtYXRoLm1pbihbWzIsIDVdLCBbNCwgM10sIFsxLCA3XV0sIDApOyAvLyByZXR1cm5zIFsxLCAzXVxuICAgKiAgICAgbWF0aC5taW4oW1syLCA1XSwgWzQsIDNdLCBbMSwgN11dLCAxKTsgLy8gcmV0dXJucyBbMiwgMywgMV1cbiAgICpcbiAgICogICAgIG1hdGgubWF4KDIuNywgNy4xLCAtNC41LCAyLjAsIDQuMSk7ICAgIC8vIHJldHVybnMgNy4xXG4gICAqICAgICBtYXRoLm1pbigyLjcsIDcuMSwgLTQuNSwgMi4wLCA0LjEpOyAgICAvLyByZXR1cm5zIC00LjVcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIG1lYW4sIG1lZGlhbiwgbWF4LCBwcm9kLCBzdGQsIHN1bSwgdmFyXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uICp9IGFyZ3MgIEEgc2luZ2xlIG1hdHJpeCBvciBvciBtdWx0aXBsZSBzY2FsYXIgdmFsdWVzXG4gICAqIEByZXR1cm4geyp9IFRoZSBtaW5pbXVtIHZhbHVlXG4gICAqL1xuICBtYXRoLm1pbiA9IGZ1bmN0aW9uIG1pbihhcmdzKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdGdW5jdGlvbiBtaW4gcmVxdWlyZXMgb25lIG9yIG1vcmUgcGFyYW1ldGVycyAoMCBwcm92aWRlZCknKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKGFyZ3MpKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIG1pbihbYSwgYiwgYywgZCwgLi4uXSlcbiAgICAgICAgcmV0dXJuIF9taW4oYXJncyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gbWluKFthLCBiLCBjLCBkLCAuLi5dLCBkaW0pXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnJlZHVjZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgX2dldFNtYWxsZXIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignV3JvbmcgbnVtYmVyIG9mIHBhcmFtZXRlcnMnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBtaW4oYSwgYiwgYywgZCwgLi4uKVxuICAgICAgcmV0dXJuIF9taW4oYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gX2dldFNtYWxsZXIoeCwgeSl7XG5cdCAgcmV0dXJuIG1hdGguc21hbGxlcih4LCB5KSAgPyB4IDogeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBjYWxjdWxhdGUgdGhlIG1pbmltdW0gdmFsdWUgaW4gYW4gbi1kaW1lbnNpb25hbCBhcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG1pblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX21pbihhcnJheSkge1xuICAgIHZhciBtaW4gPSB1bmRlZmluZWQ7XG5cbiAgICBjb2xsZWN0aW9uLmRlZXBGb3JFYWNoKGFycmF5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCB8fCBtYXRoLnNtYWxsZXIodmFsdWUsIG1pbikpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBtaW4gb2YgYW4gZW1wdHkgYXJyYXknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbWF4aW11bSB2YWx1ZSBvZiBhIG1hdHJpeCBvciBhICBsaXN0IHdpdGggdmFsdWVzLlxuICAgKiBJbiBjYXNlIG9mIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXksIHRoZSBtYXhpbXVtIG9mIHRoZSBmbGF0dGVuZWQgYXJyYXlcbiAgICogd2lsbCBiZSBjYWxjdWxhdGVkLiBXaGVuIGBkaW1gIGlzIHByb3ZpZGVkLCB0aGUgbWF4aW11bSBvdmVyIHRoZSBzZWxlY3RlZFxuICAgKiBkaW1lbnNpb24gd2lsbCBiZSBjYWxjdWxhdGVkLiBQYXJhbWV0ZXIgYGRpbWAgaXMgemVyby1iYXNlZC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5tYXgoYSwgYiwgYywgLi4uKVxuICAgKiAgICAgbWF0aC5tYXgoQSlcbiAgICogICAgIG1hdGgubWF4KEEsIGRpbSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLm1heCgyLCAxLCA0LCAzKTsgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDRcbiAgICogICAgIG1hdGgubWF4KFsyLCAxLCA0LCAzXSk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgNFxuICAgKlxuICAgKiAgICAgLy8gbWF4aW11bSBvdmVyIGEgc3BlY2lmaWVkIGRpbWVuc2lvbiAoemVyby1iYXNlZClcbiAgICogICAgIG1hdGgubWF4KFtbMiwgNV0sIFs0LCAzXSwgWzEsIDddXSwgMCk7IC8vIHJldHVybnMgWzQsIDddXG4gICAqICAgICBtYXRoLm1heChbWzIsIDVdLCBbNCwgM11dLCBbMSwgN10sIDEpOyAvLyByZXR1cm5zIFs1LCA0LCA3XVxuICAgKlxuICAgKiAgICAgbWF0aC5tYXgoMi43LCA3LjEsIC00LjUsIDIuMCwgNC4xKTsgICAgLy8gcmV0dXJucyA3LjFcbiAgICogICAgIG1hdGgubWluKDIuNywgNy4xLCAtNC41LCAyLjAsIDQuMSk7ICAgIC8vIHJldHVybnMgLTQuNVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbWVhbiwgbWVkaWFuLCBtaW4sIHByb2QsIHN0ZCwgc3VtLCB2YXJcbiAgICpcbiAgICogQHBhcmFtIHsuLi4gKn0gYXJncyAgQSBzaW5nbGUgbWF0cml4IG9yIG9yIG11bHRpcGxlIHNjYWxhciB2YWx1ZXNcbiAgICogQHJldHVybiB7Kn0gVGhlIG1heGltdW0gdmFsdWVcbiAgICovXG4gIG1hdGgubWF4ID0gZnVuY3Rpb24gbWF4KGFyZ3MpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Z1bmN0aW9uIG1heCByZXF1aXJlcyBvbmUgb3IgbW9yZSBwYXJhbWV0ZXJzICgwIHByb3ZpZGVkKScpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oYXJncykpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gbWF4KFthLCBiLCBjLCBkLCAuLi5dKVxuICAgICAgICByZXR1cm4gX21heChhcmdzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBtYXgoW2EsIGIsIGMsIGQsIC4uLl0sIGRpbSlcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24ucmVkdWNlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBfZ2V0TGFyZ2VyKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1dyb25nIG51bWJlciBvZiBwYXJhbWV0ZXJzJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gbWF4KGEsIGIsIGMsIGQsIC4uLilcbiAgICAgIHJldHVybiBfbWF4KGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIF9nZXRMYXJnZXIoeCwgeSl7XG5cdCAgcmV0dXJuIG1hdGgubGFyZ2VyKHgsIHkpID8geCA6IHk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgY2FsY3VsYXRlIHRoZSBtYXhpbXVtIHZhbHVlIGluIGFuIG4tZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybiB7TnVtYmVyfSBtYXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9tYXgoYXJyYXkpIHtcbiAgICB2YXIgbWF4ID0gdW5kZWZpbmVkO1xuXG4gICAgY29sbGVjdGlvbi5kZWVwRm9yRWFjaChhcnJheSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgfHwgbWF0aC5sYXJnZXIodmFsdWUsIG1heCkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBtYXggb2YgYW4gZW1wdHkgYXJyYXknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4O1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbixcblxuICAgICAgc2l6ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYXJyYXknKS5zaXplLFxuICAgICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIG1lYW4gdmFsdWUgb2YgbWF0cml4IG9yIGEgbGlzdCB3aXRoIHZhbHVlcy5cbiAgICogSW4gY2FzZSBvZiBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5LCB0aGUgbWVhbiBvZiB0aGUgZmxhdHRlbmVkIGFycmF5XG4gICAqIHdpbGwgYmUgY2FsY3VsYXRlZC4gV2hlbiBgZGltYCBpcyBwcm92aWRlZCwgdGhlIG1heGltdW0gb3ZlciB0aGUgc2VsZWN0ZWRcbiAgICogZGltZW5zaW9uIHdpbGwgYmUgY2FsY3VsYXRlZC4gUGFyYW1ldGVyIGBkaW1gIGlzIHplcm8tYmFzZWQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1lYW4ubWVhbihhLCBiLCBjLCAuLi4pXG4gICAqICAgICBtZWFuLm1lYW4oQSlcbiAgICogICAgIG1lYW4ubWVhbihBLCBkaW0pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5tZWFuKDIsIDEsIDQsIDMpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMi41XG4gICAqICAgICBtYXRoLm1lYW4oWzEsIDIuNywgMy4yLCA0XSk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyAyLjcyNVxuICAgKlxuICAgKiAgICAgbWF0aC5tZWFuKFtbMiwgNV0sIFs2LCAzXSwgWzEsIDddXSwgMCk7ICAgIC8vIHJldHVybnMgWzMsIDVdXG4gICAqICAgICBtYXRoLm1lYW4oW1syLCA1XSwgWzYsIDNdLCBbMSwgN11dLCAxKTsgICAgLy8gcmV0dXJucyBbMy41LCA0LjUsIDRdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgbWVkaWFuLCBtaW4sIG1heCwgc3VtLCBwcm9kLCBzdGQsIHZhclxuICAgKlxuICAgKiBAcGFyYW0gey4uLiAqfSBhcmdzICBBIHNpbmdsZSBtYXRyaXggb3Igb3IgbXVsdGlwbGUgc2NhbGFyIHZhbHVlc1xuICAgKiBAcmV0dXJuIHsqfSBUaGUgbWVhbiBvZiBhbGwgdmFsdWVzXG4gICAqL1xuICBtYXRoLm1lYW4gPSBmdW5jdGlvbiBtZWFuKGFyZ3MpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Z1bmN0aW9uIG1lYW4gcmVxdWlyZXMgb25lIG9yIG1vcmUgcGFyYW1ldGVycyAoMCBwcm92aWRlZCknKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKGFyZ3MpKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIG1lYW4oW2EsIGIsIGMsIGQsIC4uLl0pXG4gICAgICAgIHJldHVybiBfbWVhbihhcmdzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBtZWFuKFthLCBiLCBjLCBkLCAuLi5dLCBkaW0pXG4gICAgICAgIHJldHVybiBfbm1lYW4oYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignV3JvbmcgbnVtYmVyIG9mIHBhcmFtZXRlcnMnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBtZWFuKGEsIGIsIGMsIGQsIC4uLilcbiAgICAgIHJldHVybiBfbWVhbihhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBtZWFuIHZhbHVlIGluIGFuIG4tZGltZW5zaW9uYWwgYXJyYXksIHJldHVybmluZyBhXG4gICAqIG4tMSBkaW1lbnNpb25hbCBhcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGltXG4gICAqIEByZXR1cm4ge051bWJlcn0gbWVhblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX25tZWFuKGFycmF5LCBkaW0pe1xuXHQgIHZhciBzdW0gPSBjb2xsZWN0aW9uLnJlZHVjZShhcnJheSwgZGltLCBtYXRoLmFkZCk7XG4gICAgdmFyIHMgPSBpc0FycmF5KGFycmF5KSA/IHNpemUoYXJyYXkpIDogYXJyYXkuc2l6ZSgpO1xuICAgIHJldHVybiBtYXRoLmRpdmlkZShzdW0sIHNbZGltXSk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgY2FsY3VsYXRlIHRoZSBtZWFuIHZhbHVlIGluIGFuIG4tZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybiB7TnVtYmVyfSBtZWFuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfbWVhbihhcnJheSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBudW0gPSAwO1xuXG4gICAgY29sbGVjdGlvbi5kZWVwRm9yRWFjaChhcnJheSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBzdW0gPSBtYXRoLmFkZChzdW0sIHZhbHVlKTtcbiAgICAgIG51bSsrO1xuICAgIH0pO1xuXG4gICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIG1lYW4gb2YgYW4gZW1wdHkgYXJyYXknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0aC5kaXZpZGUoc3VtLCBudW0pO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpLFxuICAgICAgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpLFxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpLmlzTnVtYmVyLFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb24sXG5cbiAgICAgIGZsYXR0ZW4gPSByZXF1aXJlKCcuLi8uLi91dGlsL2FycmF5JykuZmxhdHRlbjtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbWVkaWFuIG9mIGEgbWF0cml4IG9yIGEgbGlzdCB3aXRoIHZhbHVlcy4gVGhlIHZhbHVlcyBhcmVcbiAgICogc29ydGVkIGFuZCB0aGUgbWlkZGxlIHZhbHVlIGlzIHJldHVybmVkLiBJbiBjYXNlIG9mIGFuIGV2ZW4gbnVtYmVyIG9mXG4gICAqIHZhbHVlcywgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBtaWRkbGUgdmFsdWVzIGlzIHJldHVybmVkLlxuICAgKiBTdXBwb3J0ZWQgdHlwZXMgb2YgdmFsdWVzIGFyZTogTnVtYmVyLCBCaWdOdW1iZXIsIFVuaXRcbiAgICpcbiAgICogSW4gY2FzZSBvZiBhIChtdWx0aSBkaW1lbnNpb25hbCkgYXJyYXkgb3IgbWF0cml4LCB0aGUgbWVkaWFuIG9mIGFsbFxuICAgKiBlbGVtZW50cyB3aWxsIGJlIGNhbGN1bGF0ZWQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1lYW4ubWVkaWFuKGEsIGIsIGMsIC4uLilcbiAgICogICAgIG1lYW4ubWVkaWFuKEEpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5tZWRpYW4oNSwgMiwgNyk7ICAgICAgICAvLyByZXR1cm5zIDVcbiAgICogICAgIG1hdGgubWVkaWFuKFszLCAtMSwgNSwgN10pOyAgLy8gcmV0dXJucyA0XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgbWVhbiwgbWluLCBtYXgsIHN1bSwgcHJvZCwgc3RkLCB2YXJcbiAgICpcbiAgICogQHBhcmFtIHsuLi4gKn0gYXJncyAgQSBzaW5nbGUgbWF0cml4IG9yIG9yIG11bHRpcGxlIHNjYWxhciB2YWx1ZXNcbiAgICogQHJldHVybiB7Kn0gVGhlIG1lZGlhblxuICAgKi9cbiAgbWF0aC5tZWRpYW4gPSBmdW5jdGlvbiBtZWRpYW4oYXJncykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRnVuY3Rpb24gbWVkaWFuIHJlcXVpcmVzIG9uZSBvciBtb3JlIHBhcmFtZXRlcnMgKDAgcHJvdmlkZWQpJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbihhcmdzKSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAvLyBtZWRpYW4oW2EsIGIsIGMsIGQsIC4uLl0pXG4gICAgICAgIHJldHVybiBfbWVkaWFuKGFyZ3MudmFsdWVPZigpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBtZWRpYW4oW2EsIGIsIGMsIGQsIC4uLl0sIGRpbSlcbiAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IG1lZGlhbihBLCBkaW0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWVkaWFuKEEsIGRpbSkgaXMgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgLy9yZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIC4uLik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdXcm9uZyBudW1iZXIgb2YgcGFyYW1ldGVycycpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIG1lZGlhbihhLCBiLCBjLCBkLCAuLi4pXG4gICAgICByZXR1cm4gX21lZGlhbihBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGNhbGN1bGF0ZSB0aGUgbWVkaWFuIG9mIGFuIG4tZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybiB7TnVtYmVyfSBtZWRpYW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9tZWRpYW4oYXJyYXkpIHtcbiAgICB2YXIgZmxhdCA9IGZsYXR0ZW4oYXJyYXkpO1xuXG4gICAgZmxhdC5zb3J0KG1hdGguY29tcGFyZSk7XG5cbiAgICB2YXIgbnVtID0gZmxhdC5sZW5ndGg7XG5cbiAgICBpZiAobnVtID09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBtZWRpYW4gb2YgYW4gZW1wdHkgYXJyYXknKTtcbiAgICB9XG5cbiAgICBpZiAobnVtICUgMiA9PSAwKSB7XG4gICAgICAvLyBldmVuOiByZXR1cm4gdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBtaWRkbGUgdmFsdWVzXG4gICAgICB2YXIgbGVmdCA9IGZsYXRbbnVtIC8gMiAtIDFdO1xuICAgICAgdmFyIHJpZ2h0ID0gZmxhdFtudW0gLyAyXTtcblxuICAgICAgaWYgKCFpc051bWJlcihsZWZ0KSAmJiAhKGxlZnQgaW5zdGFuY2VvZiBCaWdOdW1iZXIpICYmICEobGVmdCBpbnN0YW5jZW9mIFVuaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdtZWRpYW4nLCBtYXRoWyd0eXBlb2YnXShsZWZ0KSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTnVtYmVyKHJpZ2h0KSAmJiAhKHJpZ2h0IGluc3RhbmNlb2YgQmlnTnVtYmVyKSAmJiAhKHJpZ2h0IGluc3RhbmNlb2YgVW5pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ21lZGlhbicsIG1hdGhbJ3R5cGVvZiddKHJpZ2h0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRoLmRpdmlkZShtYXRoLmFkZChsZWZ0LCByaWdodCksIDIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIG9kZDogcmV0dXJuIHRoZSBtaWRkbGUgdmFsdWVcbiAgICAgIHZhciBtaWRkbGUgPSBmbGF0WyhudW0gLSAxKSAvIDJdO1xuXG4gICAgICBpZiAoIWlzTnVtYmVyKG1pZGRsZSkgJiYgIShtaWRkbGUgaW5zdGFuY2VvZiBCaWdOdW1iZXIpICYmICEobWlkZGxlIGluc3RhbmNlb2YgVW5pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ21lZGlhbicsIG1hdGhbJ3R5cGVvZiddKG1pZGRsZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIHByb2R1Y3Qgb2YgYSBtYXRyaXggb3IgYSBsaXN0IHdpdGggdmFsdWVzLlxuICAgKiBJbiBjYXNlIG9mIGEgKG11bHRpIGRpbWVuc2lvbmFsKSBhcnJheSBvciBtYXRyaXgsIHRoZSBzdW0gb2YgYWxsXG4gICAqIGVsZW1lbnRzIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5wcm9kKGEsIGIsIGMsIC4uLilcbiAgICogICAgIG1hdGgucHJvZChBKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGgubXVsdGlwbHkoMiwgMyk7ICAgICAgICAgICAvLyByZXR1cm5zIDZcbiAgICogICAgIG1hdGgucHJvZCgyLCAzKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIDZcbiAgICogICAgIG1hdGgucHJvZCgyLCAzLCA0KTsgICAgICAgICAgICAvLyByZXR1cm5zIDI0XG4gICAqICAgICBtYXRoLnByb2QoWzIsIDMsIDRdKTsgICAgICAgICAgLy8gcmV0dXJucyAyNFxuICAgKiAgICAgbWF0aC5wcm9kKFtbMiwgNV0sIFs0LCAzXV0pOyAgIC8vIHJldHVybnMgMTIwXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBtZWFuLCBtZWRpYW4sIG1pbiwgbWF4LCBzdW0sIHN0ZCwgdmFyXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uICp9IGFyZ3MgIEEgc2luZ2xlIG1hdHJpeCBvciBvciBtdWx0aXBsZSBzY2FsYXIgdmFsdWVzXG4gICAqIEByZXR1cm4geyp9IFRoZSBwcm9kdWN0IG9mIGFsbCB2YWx1ZXNcbiAgICovXG4gIG1hdGgucHJvZCA9IGZ1bmN0aW9uIHByb2QoYXJncykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignRnVuY3Rpb24gcHJvZCByZXF1aXJlcyBvbmUgb3IgbW9yZSBwYXJhbWV0ZXJzICgwIHByb3ZpZGVkKScpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oYXJncykpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gcHJvZChbYSwgYiwgYywgZCwgLi4uXSlcbiAgICAgICAgcmV0dXJuIF9wcm9kKGFyZ3MpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIC8vIHByb2QoW2EsIGIsIGMsIGQsIC4uLl0sIGRpbSlcbiAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHByb2QoQSwgZGltKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2QoQSwgZGltKSBpcyBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICAgICAgICAvL3JldHVybiBjb2xsZWN0aW9uLnJlZHVjZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgbWF0aC5wcm9kKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1dyb25nIG51bWJlciBvZiBwYXJhbWV0ZXJzJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gcHJvZChhLCBiLCBjLCBkLCAuLi4pXG4gICAgICByZXR1cm4gX3Byb2QoYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGNhbGN1bGF0ZSB0aGUgcHJvZHVjdCBvZiBhbiBuLWRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEByZXR1cm4ge051bWJlcn0gcHJvZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3Byb2QoYXJyYXkpIHtcbiAgICB2YXIgcHJvZCA9IHVuZGVmaW5lZDtcblxuICAgIGNvbGxlY3Rpb24uZGVlcEZvckVhY2goYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcHJvZCA9IChwcm9kID09PSB1bmRlZmluZWQpID8gdmFsdWUgOiBtYXRoLm11bHRpcGx5KHByb2QsIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIGlmIChwcm9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBwcm9kIG9mIGFuIGVtcHR5IGFycmF5Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2Q7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBzdW0gb2YgYSBtYXRyaXggb3IgYSBsaXN0IHdpdGggdmFsdWVzLlxuICAgKiBJbiBjYXNlIG9mIGEgKG11bHRpIGRpbWVuc2lvbmFsKSBhcnJheSBvciBtYXRyaXgsIHRoZSBzdW0gb2YgYWxsXG4gICAqIGVsZW1lbnRzIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5zdW0oYSwgYiwgYywgLi4uKVxuICAgKiAgICAgbWF0aC5zdW0oQSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLnN1bSgyLCAxLCA0LCAzKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIDEwXG4gICAqICAgICBtYXRoLnN1bShbMiwgMSwgNCwgM10pOyAgICAgICAgICAgICAvLyByZXR1cm5zIDEwXG4gICAqICAgICBtYXRoLnN1bShbWzIsIDVdLCBbNCwgM10sIFsxLCA3XV0pOyAvLyByZXR1cm5zIDIyXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBtZWFuLCBtZWRpYW4sIG1pbiwgbWF4LCBwcm9kLCBzdGQsIHZhclxuICAgKlxuICAgKiBAcGFyYW0gey4uLiAqfSBhcmdzICBBIHNpbmdsZSBtYXRyaXggb3Igb3IgbXVsdGlwbGUgc2NhbGFyIHZhbHVlc1xuICAgKiBAcmV0dXJuIHsqfSBUaGUgc3VtIG9mIGFsbCB2YWx1ZXNcbiAgICovXG4gIG1hdGguc3VtID0gZnVuY3Rpb24gc3VtKGFyZ3MpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Z1bmN0aW9uIHN1bSByZXF1aXJlcyBvbmUgb3IgbW9yZSBwYXJhbWV0ZXJzICgwIHByb3ZpZGVkKScpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oYXJncykpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gc3VtKFthLCBiLCBjLCBkLCAuLi5dKVxuICAgICAgICByZXR1cm4gX3N1bShhcmdzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBzdW0oW2EsIGIsIGMsIGQsIC4uLl0sIGRpbSlcbiAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHN1bShBLCBkaW0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3VtKEEsIGRpbSkgaXMgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgLy9yZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIG1hdGguYWRkKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1dyb25nIG51bWJlciBvZiBwYXJhbWV0ZXJzJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gc3VtKGEsIGIsIGMsIGQsIC4uLilcbiAgICAgIHJldHVybiBfc3VtKGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBjYWxjdWxhdGUgdGhlIHN1bSBvZiBhbiBuLWRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEByZXR1cm4ge051bWJlcn0gc3VtXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfc3VtKGFycmF5KSB7XG4gICAgdmFyIHN1bSA9IHVuZGVmaW5lZDtcblxuICAgIGNvbGxlY3Rpb24uZGVlcEZvckVhY2goYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgc3VtID0gKHN1bSA9PT0gdW5kZWZpbmVkKSA/IHZhbHVlIDogbWF0aC5hZGQoc3VtLCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoc3VtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBzdW0gb2YgYW4gZW1wdHkgYXJyYXknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpLFxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb24sXG4gICAgICBpc1N0cmluZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc3RyaW5nJykuaXNTdHJpbmcsXG5cbiAgICAgIERFRkFVTFRfTk9STUFMSVpBVElPTiA9ICd1bmJpYXNlZCc7XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIHZhcmlhbmNlIG9mIGEgbWF0cml4IG9yIGEgIGxpc3Qgd2l0aCB2YWx1ZXMuXG4gICAqIEluIGNhc2Ugb2YgYSAobXVsdGkgZGltZW5zaW9uYWwpIGFycmF5IG9yIG1hdHJpeCwgdGhlIHZhcmlhbmNlIG92ZXIgYWxsXG4gICAqIGVsZW1lbnRzIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICpcbiAgICogT3B0aW9uYWxseSwgdGhlIHR5cGUgb2Ygbm9ybWFsaXphdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGFzIHNlY29uZFxuICAgKiBwYXJhbWV0ZXIuIFRoZSBwYXJhbWV0ZXIgYG5vcm1hbGl6YXRpb25gIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gICAqXG4gICAqIC0gJ3VuYmlhc2VkJyAoZGVmYXVsdCkgVGhlIHN1bSBvZiBzcXVhcmVkIGVycm9ycyBpcyBkaXZpZGVkIGJ5IChuIC0gMSlcbiAgICogLSAndW5jb3JyZWN0ZWQnICAgICAgICBUaGUgc3VtIG9mIHNxdWFyZWQgZXJyb3JzIGlzIGRpdmlkZWQgYnkgblxuICAgKiAtICdiaWFzZWQnICAgICAgICAgICAgIFRoZSBzdW0gb2Ygc3F1YXJlZCBlcnJvcnMgaXMgZGl2aWRlZCBieSAobiArIDEpXG5cbiAgICogTm90ZSB0aGF0IG9sZGVyIGJyb3dzZXIgbWF5IG5vdCBsaWtlIHRoZSB2YXJpYWJsZSBuYW1lIGB2YXJgLiBJbiB0aGF0XG4gICAqIGNhc2UsIHRoZSBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGFzIGBtYXRoWyd2YXInXSguLi4pYCBpbnN0ZWFkIG9mXG4gICAqIGBtYXRoLnZhciguLi4pYC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC52YXIoYSwgYiwgYywgLi4uKVxuICAgKiAgICAgbWF0aC52YXIoQSlcbiAgICogICAgIG1hdGgudmFyKEEsIG5vcm1hbGl6YXRpb24pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC52YXIoMiwgNCwgNik7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyA0XG4gICAqICAgICBtYXRoLnZhcihbMiwgNCwgNiwgOF0pOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDYuNjY2NjY2NjY2NjY2NjY3XG4gICAqICAgICBtYXRoLnZhcihbMiwgNCwgNiwgOF0sICd1bmNvcnJlY3RlZCcpOyAvLyByZXR1cm5zIDVcbiAgICogICAgIG1hdGgudmFyKFsyLCA0LCA2LCA4XSwgJ2JpYXNlZCcpOyAgICAgIC8vIHJldHVybnMgNFxuICAgKlxuICAgKiAgICAgbWF0aC52YXIoW1sxLCAyLCAzXSwgWzQsIDUsIDZdXSk7ICAgICAgLy8gcmV0dXJucyAzLjVcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIG1lYW4sIG1lZGlhbiwgbWF4LCBtaW4sIHByb2QsIHN0ZCwgc3VtXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IGFycmF5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgQSBzaW5nbGUgbWF0cml4IG9yIG9yIG11bHRpcGxlIHNjYWxhciB2YWx1ZXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtub3JtYWxpemF0aW9uPSd1bmJpYXNlZCddXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgRGV0ZXJtaW5lcyBob3cgdG8gbm9ybWFsaXplIHRoZSB2YXJpYW5jZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICBDaG9vc2UgJ3VuYmlhc2VkJyAoZGVmYXVsdCksICd1bmNvcnJlY3RlZCcsIG9yICdiaWFzZWQnLlxuICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFyaWFuY2VcbiAgICovXG4gIG1hdGhbJ3ZhciddID0gZnVuY3Rpb24gdmFyaWFuY2UoYXJyYXksIG5vcm1hbGl6YXRpb24pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Z1bmN0aW9uIHZhciByZXF1aXJlcyBvbmUgb3IgbW9yZSBwYXJhbWV0ZXJzICgwIHByb3ZpZGVkKScpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oYXJyYXkpKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIHZhcihbYSwgYiwgYywgZCwgLi4uXSlcbiAgICAgICAgcmV0dXJuIF92YXIoYXJyYXksIERFRkFVTFRfTk9STUFMSVpBVElPTik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gdmFyKFthLCBiLCBjLCBkLCAuLi5dLCBub3JtYWxpemF0aW9uKVxuXG4gICAgICAgIGlmICghaXNTdHJpbmcobm9ybWFsaXphdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIG5vcm1hbGl6YXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdmFyKGFycmF5LCBub3JtYWxpemF0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8qIFRPRE86IGltcGxlbWVudCB2YXIoQSBbLCBub3JtYWxpemF0aW9uXSwgZGltKVxuICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgIC8vIHZhcihbYSwgYiwgYywgZCwgLi4uXSwgZGltKVxuICAgICAgICAvLyB2YXIoW2EsIGIsIGMsIGQsIC4uLl0sIG5vcm1hbGl6YXRpb24sIGRpbSlcbiAgICAgICAgLy9yZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIC4uLik7XG4gICAgICB9XG4gICAgICAqL1xuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignV3JvbmcgbnVtYmVyIG9mIHBhcmFtZXRlcnMnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB2YXIoYSwgYiwgYywgZCwgLi4uKVxuICAgICAgcmV0dXJuIF92YXIoYXJndW1lbnRzLCBERUZBVUxUX05PUk1BTElaQVRJT04pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgY2FsY3VsYXRlIHRoZSB2YXJpYW5jZSBvZiBhbiBuLWRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBub3JtYWxpemF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgRGV0ZXJtaW5lcyBob3cgdG8gbm9ybWFsaXplIHRoZSB2YXJpYW5jZTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAtICd1bmJpYXNlZCcgICAgVGhlIHN1bSBvZiBzcXVhcmVkIGVycm9ycyBpcyBkaXZpZGVkIGJ5IChuIC0gMSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAtICd1bmNvcnJlY3RlZCcgVGhlIHN1bSBvZiBzcXVhcmVkIGVycm9ycyBpcyBkaXZpZGVkIGJ5IG5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAtICdiaWFzZWQnICAgICAgVGhlIHN1bSBvZiBzcXVhcmVkIGVycm9ycyBpcyBkaXZpZGVkIGJ5IChuICsgMSlcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQmlnTnVtYmVyfSB2YXJpYW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3ZhcihhcnJheSwgbm9ybWFsaXphdGlvbikge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBudW0gPSAwO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBtZWFuIGFuZCBudW1iZXIgb2YgZWxlbWVudHNcbiAgICBjb2xsZWN0aW9uLmRlZXBGb3JFYWNoKGFycmF5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHN1bSA9IG1hdGguYWRkKHN1bSwgdmFsdWUpO1xuICAgICAgbnVtKys7XG4gICAgfSk7XG4gICAgaWYgKG51bSA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIHZhciBvZiBhbiBlbXB0eSBhcnJheScpO1xuXG4gICAgdmFyIG1lYW4gPSBtYXRoLmRpdmlkZShzdW0sIG51bSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHZhcmlhbmNlXG4gICAgc3VtID0gMDtcbiAgICBjb2xsZWN0aW9uLmRlZXBGb3JFYWNoKGFycmF5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBkaWZmID0gbWF0aC5zdWJ0cmFjdCh2YWx1ZSwgbWVhbik7XG4gICAgICBzdW0gPSBtYXRoLmFkZChzdW0sIG1hdGgubXVsdGlwbHkoZGlmZiwgZGlmZikpO1xuICAgIH0pO1xuXG4gICAgc3dpdGNoIChub3JtYWxpemF0aW9uKSB7XG4gICAgICBjYXNlICd1bmNvcnJlY3RlZCc6XG4gICAgICAgIHJldHVybiBtYXRoLmRpdmlkZShzdW0sIG51bSk7XG5cbiAgICAgIGNhc2UgJ2JpYXNlZCc6XG4gICAgICAgIHJldHVybiBtYXRoLmRpdmlkZShzdW0sIG51bSArIDEpO1xuXG4gICAgICBjYXNlICd1bmJpYXNlZCc6XG4gICAgICAgIHZhciB6ZXJvID0gKHN1bSBpbnN0YW5jZW9mIEJpZ051bWJlcikgPyBuZXcgQmlnTnVtYmVyKDApIDogMDtcbiAgICAgICAgcmV0dXJuIChudW0gPT0gMSkgPyB6ZXJvIDogbWF0aC5kaXZpZGUoc3VtLCBudW0gLSAxKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vcm1hbGl6YXRpb24gXCInICsgbm9ybWFsaXphdGlvbiArICdcIi4gJyArXG4gICAgICAgICAgICAnQ2hvb3NlIFwidW5iaWFzZWRcIiAoZGVmYXVsdCksIFwidW5jb3JyZWN0ZWRcIiwgb3IgXCJiaWFzZWRcIi4nKTtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBpbnZlcnNlIGNvc2luZSBvZiBhIHZhbHVlLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYWNvcyh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hY29zKDAuNSk7ICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAxLjA0NzE5NzU1MTE5NjU5NzlcbiAgICogICAgbWF0aC5hY29zKG1hdGguY29zKDEuNSkpOyAvLyByZXR1cm5zIE51bWJlciAxLjVcbiAgICpcbiAgICogICAgbWF0aC5hY29zKDIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMCArIDEuMzE2OTU3ODk2OTI0ODE2NiBpXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjb3MsIGF0YW4sIGFzaW5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBUaGUgYXJjIGNvc2luZSBvZiB4XG4gICAqL1xuICBtYXRoLmFjb3MgPSBmdW5jdGlvbiBhY29zKHgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignYWNvcycsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgaWYgKHggPj0gLTEgJiYgeCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoeCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFjb3MobmV3IENvbXBsZXgoeCwgMCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIC8vIGFjb3MoeikgPSAwLjUqcGkgKyBpKmxvZyhpeiArIHNxcnQoMS16XjIpKVxuICAgICAgdmFyIHRlbXAxID0gbmV3IENvbXBsZXgoXG4gICAgICAgICAgeC5pbSAqIHguaW0gLSB4LnJlICogeC5yZSArIDEuMCxcbiAgICAgICAgICAtMi4wICogeC5yZSAqIHguaW1cbiAgICAgICk7XG4gICAgICB2YXIgdGVtcDIgPSBtYXRoLnNxcnQodGVtcDEpO1xuICAgICAgdmFyIHRlbXAzID0gbmV3IENvbXBsZXgoXG4gICAgICAgICAgdGVtcDIucmUgLSB4LmltLFxuICAgICAgICAgIHRlbXAyLmltICsgeC5yZVxuICAgICAgKTtcbiAgICAgIHZhciB0ZW1wNCA9IG1hdGgubG9nKHRlbXAzKTtcblxuICAgICAgLy8gMC41KnBpID0gMS41NzA3OTYzMjY3OTQ4OTY2MTkyMzEzMjE2OTE2Mzk4XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgMS41NzA3OTYzMjY3OTQ4OTY2MTkyMyAtIHRlbXA0LmltLFxuICAgICAgICAgIHRlbXA0LnJlXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAoeCwgYWNvcyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTWF0aC5hY29zKHgpO1xuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgQmlnTnVtYmVyIHN1cHBvcnRcbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgIHJldHVybiBhY29zKHgudG9OdW1iZXIoKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2Fjb3MnLCBtYXRoWyd0eXBlb2YnXSh4KSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSBzaW5lIG9mIGEgdmFsdWUuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hc2luKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFzaW4oMC41KTsgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDAuNTIzNTk4Nzc1NTk4Mjk4OVxuICAgKiAgICBtYXRoLmFzaW4obWF0aC5zaW4oMS41KSk7IC8vIHJldHVybnMgTnVtYmVyIH4xLjVcbiAgICpcbiAgICogICAgbWF0aC5hc2luKDIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMS41NzA3OTYzMjY3OTQ4OTY2IC0xLjMxNjk1Nzg5NjkyNDgxNjYgaVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgc2luLCBhdGFuLCBhY29zXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFRoZSBhcmMgc2luZSBvZiB4XG4gICAqL1xuICBtYXRoLmFzaW4gPSBmdW5jdGlvbiBhc2luKHgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignYXNpbicsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgaWYgKHggPj0gLTEgJiYgeCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFzaW4oeCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFzaW4obmV3IENvbXBsZXgoeCwgMCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIC8vIGFzaW4oeikgPSAtaSpsb2coaXogKyBzcXJ0KDEtel4yKSlcbiAgICAgIHZhciByZSA9IHgucmU7XG4gICAgICB2YXIgaW0gPSB4LmltO1xuICAgICAgdmFyIHRlbXAxID0gbmV3IENvbXBsZXgoXG4gICAgICAgICAgaW0gKiBpbSAtIHJlICogcmUgKyAxLjAsXG4gICAgICAgICAgLTIuMCAqIHJlICogaW1cbiAgICAgICk7XG4gICAgICB2YXIgdGVtcDIgPSBtYXRoLnNxcnQodGVtcDEpO1xuICAgICAgdmFyIHRlbXAzID0gbmV3IENvbXBsZXgoXG4gICAgICAgICAgdGVtcDIucmUgLSBpbSxcbiAgICAgICAgICB0ZW1wMi5pbSArIHJlXG4gICAgICApO1xuICAgICAgdmFyIHRlbXA0ID0gbWF0aC5sb2codGVtcDMpO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgodGVtcDQuaW0sIC10ZW1wNC5yZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCBhc2luKTtcbiAgICB9XG5cbiAgICBpZiAoaXNCb29sZWFuKHgpIHx8IHggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBNYXRoLmFzaW4oeCk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBCaWdOdW1iZXIgc3VwcG9ydFxuICAgICAgLy8gZG93bmdyYWRlIHRvIE51bWJlclxuICAgICAgcmV0dXJuIGFzaW4oeC50b051bWJlcigpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignYXNpbicsIG1hdGhbJ3R5cGVvZiddKHgpKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBpbnZlcnNlIHRhbmdlbnQgb2YgYSB2YWx1ZS5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmF0YW4oeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguYXRhbigwLjUpOyAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgMC40NjM2NDc2MDkwMDA4MDYxXG4gICAqICAgIG1hdGguYXRhbihtYXRoLnRhbigxLjUpKTsgLy8gcmV0dXJucyBOdW1iZXIgMS41XG4gICAqXG4gICAqICAgIG1hdGguYXRhbigyKTsgICAgICAgICAgICAgLy8gcmV0dXJucyBDb21wbGV4IDEuNTcwNzk2MzI2Nzk0ODk2NiAtMS4zMTY5NTc4OTY5MjQ4MTY2IGlcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHRhbiwgYXNpbiwgYWNvc1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4ICAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBUaGUgYXJjIHRhbmdlbnQgb2YgeFxuICAgKi9cbiAgbWF0aC5hdGFuID0gZnVuY3Rpb24gYXRhbih4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2F0YW4nLCBhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4oeCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgLy8gYXRhbih6KSA9IDEvMiAqIGkgKiAobG4oMS1peikgLSBsbigxK2l6KSlcbiAgICAgIHZhciByZSA9IHgucmU7XG4gICAgICB2YXIgaW0gPSB4LmltO1xuICAgICAgdmFyIGRlbiA9IHJlICogcmUgKyAoMS4wIC0gaW0pICogKDEuMCAtIGltKTtcblxuICAgICAgdmFyIHRlbXAxID0gbmV3IENvbXBsZXgoXG4gICAgICAgICAgKDEuMCAtIGltICogaW0gLSByZSAqIHJlKSAvIGRlbixcbiAgICAgICAgICAoLTIuMCAqIHJlKSAvIGRlblxuICAgICAgKTtcbiAgICAgIHZhciB0ZW1wMiA9IG1hdGgubG9nKHRlbXAxKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgIC0wLjUgKiB0ZW1wMi5pbSxcbiAgICAgICAgICAwLjUgKiB0ZW1wMi5yZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHgsIGF0YW4pO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE1hdGguYXRhbih4KTtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IEJpZ051bWJlciBzdXBwb3J0XG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gYXRhbih4LnRvTnVtYmVyKCkpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdhdGFuJywgbWF0aFsndHlwZW9mJ10oeCkpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2UgdGFuZ2VudCBmdW5jdGlvbiB3aXRoIHR3byBhcmd1bWVudHMsIHkveC5cbiAgICogQnkgcHJvdmlkaW5nIHR3byBhcmd1bWVudHMsIHRoZSByaWdodCBxdWFkcmFudCBvZiB0aGUgY29tcHV0ZWQgYW5nbGUgY2FuIGJlXG4gICAqIGRldGVybWluZWQuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hdGFuMih5LCB4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hdGFuMigyLCAyKSAvIG1hdGgucGk7ICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDAuMjVcbiAgICpcbiAgICogICAgdmFyIGFuZ2xlID0gbWF0aC51bml0KDYwLCAnZGVnJyk7IC8vIHJldHVybnMgVW5pdCA2MCBkZWdcbiAgICogICAgdmFyIHggPSBtYXRoLmNvcyhhbmdsZSk7XG4gICAqICAgIHZhciB5ID0gbWF0aC5zaW4oYW5nbGUpO1xuICAgKlxuICAgKiAgICBtYXRoLmF0YW4oMik7ICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAxLjU3MDc5NjMyNjc5NDg5NjYgLTEuMzE2OTU3ODk2OTI0ODE2NiBpXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICB0YW4sIGF0YW4sIHNpbiwgY29zXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHkgIFNlY29uZCBkaW1lbnNpb25cbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCAgRmlyc3QgZGltZW5zaW9uXG4gICAqIEByZXR1cm4ge051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gRm91ci1xdWFkcmFudCBpbnZlcnNlIHRhbmdlbnRcbiAgICovXG4gIG1hdGguYXRhbjIgPSBmdW5jdGlvbiBhdGFuMih5LCB4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2F0YW4yJywgYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHkpKSB7XG4gICAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogc3VwcG9ydCBmb3IgY29tcGxleCBjb21wdXRhdGlvbiBvZiBhdGFuMlxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih5KSB8fCBpc0NvbGxlY3Rpb24oeCkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAyKHksIHgsIGF0YW4yKTtcbiAgICB9XG5cbiAgICBpZiAoaXNCb29sZWFuKHkpIHx8IHkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBhdGFuMigreSwgeCk7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGF0YW4yKHksICt4KTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYmlnbnVtYmVyIHN1cHBvcnRcbiAgICBpZiAoeSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgcmV0dXJuIGF0YW4yKHkudG9OdW1iZXIoKSwgeCk7XG4gICAgfVxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICByZXR1cm4gYXRhbjIoeSwgeC50b051bWJlcigpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignYXRhbjInLCBtYXRoWyd0eXBlb2YnXSh5KSwgbWF0aFsndHlwZW9mJ10oeCkpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIFVuaXQgPSByZXF1aXJlKCcuLi8uLi90eXBlL1VuaXQnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzVW5pdCA9IFVuaXQuaXNVbml0LFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29zaW5lIG9mIGEgdmFsdWUuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5jb3MoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguY29zKDIpOyAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAtMC40MTYxNDY4MzY1NDcxNDIyXG4gICAqICAgIG1hdGguY29zKG1hdGgucGkgLyA0KTsgICAgICAgICAgICAvLyByZXR1cm5zIE51bWJlciAgMC43MDcxMDY3ODExODY1NDc1XG4gICAqICAgIG1hdGguY29zKG1hdGgudW5pdCgxODAsICdkZWcnKSk7ICAvLyByZXR1cm5zIE51bWJlciAtMVxuICAgKiAgICBtYXRoLmNvcyhtYXRoLnVuaXQoNjAsICdkZWcnKSk7ICAgLy8gcmV0dXJucyBOdW1iZXIgIDAuNVxuICAgKlxuICAgKiAgICB2YXIgYW5nbGUgPSAwLjI7XG4gICAqICAgIG1hdGgucG93KG1hdGguc2luKGFuZ2xlKSwgMikgKyBtYXRoLnBvdyhtYXRoLmNvcyhhbmdsZSksIDIpOyAvLyByZXR1cm5zIE51bWJlciB+MVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY29zLCB0YW5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gQ29zaW5lIG9mIHhcbiAgICovXG4gIG1hdGguY29zID0gZnVuY3Rpb24gY29zKHgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignY29zJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICByZXR1cm4gTWF0aC5jb3MoeCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xuICAgICAgLy8gY29zKHopID0gKGV4cChpeikgKyBleHAoLWl6KSkgLyAyXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgMC41ICogTWF0aC5jb3MoeC5yZSkgKiAoTWF0aC5leHAoLXguaW0pICsgTWF0aC5leHAoeC5pbSkpLFxuICAgICAgICAgIDAuNSAqIE1hdGguc2luKHgucmUpICogKE1hdGguZXhwKC14LmltKSAtIE1hdGguZXhwKHguaW0pKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNVbml0KHgpKSB7XG4gICAgICBpZiAoIXguaGFzQmFzZShVbml0LkJBU0VfVU5JVFMuQU5HTEUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdVbml0IGluIGZ1bmN0aW9uIGNvcyBpcyBubyBhbmdsZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguY29zKHgudmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAoeCwgY29zKTtcbiAgICB9XG5cbiAgICBpZiAoaXNCb29sZWFuKHgpIHx8IHggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBNYXRoLmNvcyh4KTtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IEJpZ051bWJlciBzdXBwb3J0XG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXG4gICAgICByZXR1cm4gY29zKHgudG9OdW1iZXIoKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2NvcycsIG1hdGhbJ3R5cGVvZiddKHgpKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XHJcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXHJcblxyXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxyXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXHJcbiAgICAgIFVuaXQgPSByZXF1aXJlKCcuLi8uLi90eXBlL1VuaXQnKSxcclxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxyXG5cclxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcclxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcclxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXHJcbiAgICAgIGlzVW5pdCA9IFVuaXQuaXNVbml0LFxyXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhIHZhbHVlLFxyXG4gICAqIGRlZmluZWQgYXMgYGNvc2goeCkgPSAxLzIgKiAoZXhwKHgpICsgZXhwKC14KSlgLlxyXG4gICAqXHJcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cclxuICAgKlxyXG4gICAqIFN5bnRheDpcclxuICAgKlxyXG4gICAqICAgIG1hdGguY29zaCh4KVxyXG4gICAqXHJcbiAgICogRXhhbXBsZXM6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLmNvc2goMC41KTsgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgMS4xMjc2MjU5NjUyMDYzODA3XHJcbiAgICpcclxuICAgKiBTZWUgYWxzbzpcclxuICAgKlxyXG4gICAqICAgIHNpbmgsIHRhbmhcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4ICBGdW5jdGlvbiBpbnB1dFxyXG4gICAqIEByZXR1cm4ge051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gSHlwZXJib2xpYyBjb3NpbmUgb2YgeFxyXG4gICAqL1xyXG4gIG1hdGguY29zaCA9IGZ1bmN0aW9uIGNvc2goeCkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xyXG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignY29zaCcsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc051bWJlcih4KSkge1xyXG4gICAgICByZXR1cm4gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKSAvIDI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xyXG4gICAgICB2YXIgZXAgPSBNYXRoLmV4cCh4LnJlKTtcclxuICAgICAgdmFyIGVuID0gTWF0aC5leHAoLXgucmUpO1xyXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5jb3MoeC5pbSkgKiAoZXAgKyBlbikgLyAyLCBNYXRoLnNpbih4LmltKSAqIChlcCAtIGVuKSAvIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1VuaXQoeCkpIHtcclxuICAgICAgaWYgKCF4Lmhhc0Jhc2UoVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdVbml0IGluIGZ1bmN0aW9uIGNvc2ggaXMgbm8gYW5nbGUnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29zaCh4LnZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpKSB7XHJcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAoeCwgY29zaCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBjb3NoKHggPyAxIDogMCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcclxuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IEJpZ051bWJlciBzdXBwb3J0XHJcbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcclxuICAgICAgcmV0dXJuIGNvc2goeC50b051bWJlcigpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignY29zaCcsIG1hdGhbJ3R5cGVvZiddKHgpKTtcclxuICB9O1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc1VuaXQgPSBVbml0LmlzVW5pdCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvdGFuZ2VudCBvZiBhIHZhbHVlLiBgY290KHgpYCBpcyBkZWZpbmVkIGFzIGAxIC8gdGFuKHgpYC5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmNvdCh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5jb3QoMik7ICAgICAgLy8gcmV0dXJucyBOdW1iZXIgLTAuNDU3NjU3NTU0MzYwMjg1NzdcbiAgICogICAgMSAvIG1hdGgudGFuKDIpOyAgLy8gcmV0dXJucyBOdW1iZXIgLTAuNDU3NjU3NTU0MzYwMjg1NzdcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHRhbiwgc2VjLCBjc2NcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gQ290YW5nZW50IG9mIHhcbiAgICovXG4gIG1hdGguY290ID0gZnVuY3Rpb24gY290KHgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignY290JywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICByZXR1cm4gMSAvIE1hdGgudGFuKHgpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIHZhciBkZW4gPSBNYXRoLmV4cCgtNC4wICogeC5pbSkgLVxuICAgICAgICAgIDIuMCAqIE1hdGguZXhwKC0yLjAgKiB4LmltKSAqIE1hdGguY29zKDIuMCAqIHgucmUpICsgMS4wO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgMi4wICogTWF0aC5leHAoLTIuMCAqIHguaW0pICogTWF0aC5zaW4oMi4wICogeC5yZSkgLyBkZW4sXG4gICAgICAgICAgKE1hdGguZXhwKC00LjAgKiB4LmltKSAtIDEuMCkgLyBkZW5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5pdCh4KSkge1xuICAgICAgaWYgKCF4Lmhhc0Jhc2UoVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVW5pdCBpbiBmdW5jdGlvbiBjb3QgaXMgbm8gYW5nbGUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxIC8gTWF0aC50YW4oeC52YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCBjb3QpO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvdCgreCk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBCaWdOdW1iZXIgc3VwcG9ydFxuICAgICAgLy8gZG93bmdyYWRlIHRvIE51bWJlclxuICAgICAgcmV0dXJuIGNvdCh4LnRvTnVtYmVyKCkpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdjb3QnLCBtYXRoWyd0eXBlb2YnXSh4KSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xyXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxyXG5cclxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcclxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxyXG4gICAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXHJcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcclxuXHJcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXHJcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXHJcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxyXG4gICAgICBpc1VuaXQgPSBVbml0LmlzVW5pdCxcclxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBjb3RhbmdlbnQgb2YgYSB2YWx1ZSxcclxuICAgKiBkZWZpbmVkIGFzIGBjb3RoKHgpID0gMSAvIHRhbmgoeClgLlxyXG4gICAqXHJcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cclxuICAgKlxyXG4gICAqIFN5bnRheDpcclxuICAgKlxyXG4gICAqICAgIG1hdGguY290aCh4KVxyXG4gICAqXHJcbiAgICogRXhhbXBsZXM6XHJcbiAgICpcclxuICAgKiAgICAvLyBjb3RoKHgpID0gMSAvIHRhbmgoeClcclxuICAgKiAgICBtYXRoLmNvdGgoMik7ICAgICAgICAgLy8gcmV0dXJucyAxLjAzNzMxNDcyMDcyNzU0ODJcclxuICAgKiAgICAxIC8gbWF0aC50YW5oKDIpOyAgICAgLy8gcmV0dXJucyAxLjAzNzMxNDcyMDcyNzU0ODJcclxuICAgKlxyXG4gICAqIFNlZSBhbHNvOlxyXG4gICAqXHJcbiAgICogICAgc2luaCwgdGFuaCwgY29zaFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggIEZ1bmN0aW9uIGlucHV0XHJcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBIeXBlcmJvbGljIGNvdGFuZ2VudCBvZiB4XHJcbiAgICovXHJcbiAgbWF0aC5jb3RoID0gZnVuY3Rpb24gY290aCh4KSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XHJcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdjb3RoJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XHJcbiAgICAgIHZhciBlID0gTWF0aC5leHAoMiAqIHgpO1xyXG4gICAgICByZXR1cm4gKGUgKyAxKSAvIChlIC0gMSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xyXG4gICAgICB2YXIgciA9IE1hdGguZXhwKDIgKiB4LnJlKTtcclxuICAgICAgdmFyIHJlID0gciAqIE1hdGguY29zKDIgKiB4LmltKTtcclxuICAgICAgdmFyIGltID0gciAqIE1hdGguc2luKDIgKiB4LmltKTtcclxuICAgICAgdmFyIGRlbiA9IChyZSAtIDEpICogKHJlIC0gMSkgKyBpbSAqIGltO1xyXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXHJcbiAgICAgICAgKChyZSArIDEpICogKHJlIC0gMSkgKyBpbSAqIGltKSAvIGRlbixcclxuICAgICAgICAtMiAqIGltIC8gZGVuXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzVW5pdCh4KSkge1xyXG4gICAgICBpZiAoIXguaGFzQmFzZShVbml0LkJBU0VfVU5JVFMuQU5HTEUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gY290aCBpcyBubyBhbmdsZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb3RoKHgudmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkpIHtcclxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCBjb3RoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNCb29sZWFuKHgpIHx8IHggPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGNvdGgoeCA/IDEgOiAwKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xyXG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgQmlnTnVtYmVyIHN1cHBvcnRcclxuICAgICAgLy8gZG93bmdyYWRlIHRvIE51bWJlclxyXG4gICAgICByZXR1cm4gY290aCh4LnRvTnVtYmVyKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdjb3RoJywgbWF0aFsndHlwZW9mJ10oeCkpO1xyXG4gIH07XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcbiAgICAgIFVuaXQgPSByZXF1aXJlKCcuLi8uLi90eXBlL1VuaXQnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcbiAgICAgIGlzVW5pdCA9IFVuaXQuaXNVbml0LFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY29zZWNhbnQgb2YgYSB2YWx1ZSwgZGVmaW5lZCBhcyBgY3NjKHgpID0gMS9zaW4oeClgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguY3NjKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNzYygyKTsgICAgICAvLyByZXR1cm5zIE51bWJlciAxLjA5OTc1MDE3MDI5NDYxN1xuICAgKiAgICAxIC8gbWF0aC5zaW4oMik7ICAvLyByZXR1cm5zIE51bWJlciAxLjA5OTc1MDE3MDI5NDYxN1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgc2luLCBzZWMsIGNvdFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBDb3NlY2FudCBvZiB4XG4gICAqL1xuICBtYXRoLmNzYyA9IGZ1bmN0aW9uIGNzYyh4KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2NzYycsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih4KSkge1xuICAgICAgcmV0dXJuIDEgLyBNYXRoLnNpbih4KTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb21wbGV4KHgpKSB7XG4gICAgICAvLyBjc2MoeikgPSAxL3Npbih6KSA9ICgyaSkgLyAoZXhwKGl6KSAtIGV4cCgtaXopKVxuICAgICAgdmFyIGRlbiA9IDAuMjUgKiAoTWF0aC5leHAoLTIuMCAqIHguaW0pICsgTWF0aC5leHAoMi4wICogeC5pbSkpIC1cbiAgICAgICAgICAwLjUgKiBNYXRoLmNvcygyLjAgKiB4LnJlKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4IChcbiAgICAgICAgICAwLjUgKiBNYXRoLnNpbih4LnJlKSAqIChNYXRoLmV4cCgteC5pbSkgKyBNYXRoLmV4cCh4LmltKSkgLyBkZW4sXG4gICAgICAgICAgMC41ICogTWF0aC5jb3MoeC5yZSkgKiAoTWF0aC5leHAoLXguaW0pIC0gTWF0aC5leHAoeC5pbSkpIC8gZGVuXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc1VuaXQoeCkpIHtcbiAgICAgIGlmICgheC5oYXNCYXNlKFVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gY3NjIGlzIG5vIGFuZ2xlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMSAvIE1hdGguc2luKHgudmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAoeCwgY3NjKTtcbiAgICB9XG5cbiAgICBpZiAoaXNCb29sZWFuKHgpIHx8IHggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjc2MoK3gpO1xuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgQmlnTnVtYmVyIHN1cHBvcnRcbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgIHJldHVybiBjc2MoeC50b051bWJlcigpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignY3NjJywgbWF0aFsndHlwZW9mJ10oeCkpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcclxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcclxuXHJcbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXHJcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcclxuICAgICAgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpLFxyXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXHJcbiAgICAgIG51bWJlciA9IHV0aWwubnVtYmVyLFxyXG4gICAgICBcclxuICAgICAgaXNOdW1iZXIgPSB1dGlsLm51bWJlci5pc051bWJlcixcclxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcclxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXHJcbiAgICAgIGlzVW5pdCA9IFVuaXQuaXNVbml0LFxyXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGNvc2VjYW50IG9mIGEgdmFsdWUsXHJcbiAgICogZGVmaW5lZCBhcyBgY3NjaCh4KSA9IDEgLyBzaW5oKHgpYC5cclxuICAgKlxyXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXHJcbiAgICpcclxuICAgKiBTeW50YXg6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLmNzY2goeClcclxuICAgKlxyXG4gICAqIEV4YW1wbGVzOlxyXG4gICAqXHJcbiAgICogICAgLy8gY3NjaCh4KSA9IDEvIHNpbmgoeClcclxuICAgKiAgICBtYXRoLmNzY2goMC41KTsgICAgICAgLy8gcmV0dXJucyAxLjkxOTAzNDc1MTMzNDk0MzdcclxuICAgKiAgICAxIC8gbWF0aC5zaW5oKDAuNSk7ICAgLy8gcmV0dXJucyAxLjkxOTAzNDc1MTMzNDk0MzdcclxuICAgKlxyXG4gICAqIFNlZSBhbHNvOlxyXG4gICAqXHJcbiAgICogICAgc2luaCwgc2VjaCwgY290aFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggIEZ1bmN0aW9uIGlucHV0XHJcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBIeXBlcmJvbGljIGNvc2VjYW50IG9mIHhcclxuICAgKi9cclxuICBtYXRoLmNzY2ggPSBmdW5jdGlvbiBjc2NoKHgpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcclxuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2NzY2gnLCBhcmd1bWVudHMubGVuZ3RoLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNOdW1iZXIoeCkpIHtcclxuICAgICAgLy8geCA9PSAwXHJcbiAgICAgIGlmICh4ID09IDApIHJldHVybiBOdW1iZXIuTmFOO1xyXG4gICAgICAvLyBjb25zaWRlciB2YWx1ZXMgY2xvc2UgdG8gemVybyAoKy8tKVxyXG4gICAgICByZXR1cm4gTWF0aC5hYnMoMiAvIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkpICogbnVtYmVyLnNpZ24oeCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQ29tcGxleCh4KSkge1xyXG4gICAgICB2YXIgZXAgPSBNYXRoLmV4cCh4LnJlKTtcclxuICAgICAgdmFyIGVuID0gTWF0aC5leHAoLXgucmUpO1xyXG4gICAgICB2YXIgcmUgPSBNYXRoLmNvcyh4LmltKSAqIChlcCAtIGVuKTtcclxuICAgICAgdmFyIGltID0gTWF0aC5zaW4oeC5pbSkgKiAoZXAgKyBlbik7XHJcbiAgICAgIHZhciBkZW4gPSByZSAqIHJlICsgaW0gKiBpbTtcclxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDIgKiByZSAvIGRlbiwgLTIgKiBpbSAvZGVuKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNVbml0KHgpKSB7XHJcbiAgICAgIGlmICgheC5oYXNCYXNlKFVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVW5pdCBpbiBmdW5jdGlvbiBjc2NoIGlzIG5vIGFuZ2xlJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNzY2goeC52YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xyXG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHgsIGNzY2gpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gY3NjaCh4ID8gMSA6IDApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XHJcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBCaWdOdW1iZXIgc3VwcG9ydFxyXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXHJcbiAgICAgIHJldHVybiBjc2NoKHgudG9OdW1iZXIoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2NzY2gnLCBtYXRoWyd0eXBlb2YnXSh4KSk7XHJcbiAgfTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxuICAgICAgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxuICAgICAgaXNVbml0ID0gVW5pdC5pc1VuaXQsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBzZWNhbnQgb2YgYSB2YWx1ZSwgZGVmaW5lZCBhcyBgc2VjKHgpID0gMS9jb3MoeClgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc2VjKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnNlYygyKTsgICAgICAvLyByZXR1cm5zIE51bWJlciAtMi40MDI5OTc5NjE3MjIzODIyXG4gICAqICAgIDEgLyBtYXRoLmNvcygyKTsgIC8vIHJldHVybnMgTnVtYmVyIC0yLjQwMjk5Nzk2MTcyMjM4MjJcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGNvcywgY3NjLCBjb3RcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gU2VjYW50IG9mIHhcbiAgICovXG4gIG1hdGguc2VjID0gZnVuY3Rpb24gc2VjKHgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignc2VjJywgYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICByZXR1cm4gMSAvIE1hdGguY29zKHgpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcbiAgICAgIC8vIHNlYyh6KSA9IDEvY29zKHopID0gMiAvIChleHAoaXopICsgZXhwKC1peikpXG4gICAgICB2YXIgZGVuID0gMC4yNSAqIChNYXRoLmV4cCgtMi4wICogeC5pbSkgKyBNYXRoLmV4cCgyLjAgKiB4LmltKSkgK1xuICAgICAgICAgIDAuNSAqIE1hdGguY29zKDIuMCAqIHgucmUpO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgMC41ICogTWF0aC5jb3MoeC5yZSkgKiAoTWF0aC5leHAoLXguaW0pICsgTWF0aC5leHAoIHguaW0pKSAvIGRlbixcbiAgICAgICAgICAwLjUgKiBNYXRoLnNpbih4LnJlKSAqIChNYXRoLmV4cCggeC5pbSkgLSBNYXRoLmV4cCgteC5pbSkpIC8gZGVuXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc1VuaXQoeCkpIHtcbiAgICAgIGlmICgheC5oYXNCYXNlKFVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gc2VjIGlzIG5vIGFuZ2xlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMSAvIE1hdGguY29zKHgudmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAoeCwgc2VjKTtcbiAgICB9XG5cbiAgICBpZiAoaXNCb29sZWFuKHgpIHx8IHggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZWMoK3gpO1xuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgQmlnTnVtYmVyIHN1cHBvcnRcbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgIHJldHVybiBzZWMoeC50b051bWJlcigpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignc2VjJywgbWF0aFsndHlwZW9mJ10oeCkpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcclxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcclxuXHJcbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXHJcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcclxuICAgICAgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpLFxyXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXHJcblxyXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxyXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxyXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcclxuICAgICAgaXNVbml0ID0gVW5pdC5pc1VuaXQsXHJcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgc2VjYW50IG9mIGEgdmFsdWUsXHJcbiAgICogZGVmaW5lZCBhcyBgc2VjaCh4KSA9IDEgLyBjb3NoKHgpYC5cclxuICAgKlxyXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXHJcbiAgICpcclxuICAgKiBTeW50YXg6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLnNlY2goeClcclxuICAgKlxyXG4gICAqIEV4YW1wbGVzOlxyXG4gICAqXHJcbiAgICogICAgLy8gc2VjaCh4KSA9IDEvIGNvc2goeClcclxuICAgKiAgICBtYXRoLnNlY2goMC41KTsgICAgICAgLy8gcmV0dXJucyAwLjg4NjgxODg4Mzk3MDA3NFxyXG4gICAqICAgIDEgLyBtYXRoLmNvc2goMC41KTsgICAvLyByZXR1cm5zIDEuOTE5MDM0NzUxMzM0OTQzN1xyXG4gICAqXHJcbiAgICogU2VlIGFsc286XHJcbiAgICpcclxuICAgKiAgICBjb3NoLCBjc2NoLCBjb3RoXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlciB8IEJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4IHwgbnVsbH0geCAgRnVuY3Rpb24gaW5wdXRcclxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgc2VjYW50IG9mIHhcclxuICAgKi9cclxuICBtYXRoLnNlY2ggPSBmdW5jdGlvbiBzZWNoKHgpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcclxuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3NlY2gnLCBhcmd1bWVudHMubGVuZ3RoLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNOdW1iZXIoeCkpIHtcclxuICAgICAgcmV0dXJuIDIgLyAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcclxuICAgICAgdmFyIGVwID0gTWF0aC5leHAoeC5yZSk7XHJcbiAgICAgIHZhciBlbiA9IE1hdGguZXhwKC14LnJlKTtcclxuICAgICAgdmFyIHJlID0gTWF0aC5jb3MoeC5pbSkgKiAoZXAgKyBlbik7XHJcbiAgICAgIHZhciBpbSA9IE1hdGguc2luKHguaW0pICogKGVwIC0gZW4pO1xyXG4gICAgICB2YXIgZGVuID0gcmUgKiByZSArIGltICogaW07XHJcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleCgyICogcmUgLyBkZW4sIC0yICogaW0gLyBkZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1VuaXQoeCkpIHtcclxuICAgICAgaWYgKCF4Lmhhc0Jhc2UoVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdVbml0IGluIGZ1bmN0aW9uIHNlY2ggaXMgbm8gYW5nbGUnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VjaCh4LnZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpKSB7XHJcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmRlZXBNYXAoeCwgc2VjaCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBzZWNoKHggPyAxIDogMCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcclxuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IEJpZ051bWJlciBzdXBwb3J0XHJcbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcclxuICAgICAgcmV0dXJuIHNlY2goeC50b051bWJlcigpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignc2VjaCcsIG1hdGhbJ3R5cGVvZiddKHgpKTtcclxuICB9O1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG5cbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc1VuaXQgPSBVbml0LmlzVW5pdCxcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNpbmUgb2YgYSB2YWx1ZS5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnNpbih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5zaW4oMik7ICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDAuOTA5Mjk3NDI2ODI1NjgxM1xuICAgKiAgICBtYXRoLnNpbihtYXRoLnBpIC8gNCk7ICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgMC43MDcxMDY3ODExODY1NDc1XG4gICAqICAgIG1hdGguc2luKG1hdGgudW5pdCg5MCwgJ2RlZycpKTsgICAvLyByZXR1cm5zIE51bWJlciAxXG4gICAqICAgIG1hdGguc2luKG1hdGgudW5pdCgzMCwgJ2RlZycpKTsgICAvLyByZXR1cm5zIE51bWJlciAwLjVcbiAgICpcbiAgICogICAgdmFyIGFuZ2xlID0gMC4yO1xuICAgKiAgICBtYXRoLnBvdyhtYXRoLnNpbihhbmdsZSksIDIpICsgbWF0aC5wb3cobWF0aC5jb3MoYW5nbGUpLCAyKTsgLy8gcmV0dXJucyBOdW1iZXIgfjFcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGNvcywgdGFuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4ICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFNpbmUgb2YgeFxuICAgKi9cbiAgbWF0aC5zaW4gPSBmdW5jdGlvbiBzaW4oeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdzaW4nLCBhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgIHJldHVybiBNYXRoLnNpbih4KTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb21wbGV4KHgpKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgMC41ICogTWF0aC5zaW4oeC5yZSkgKiAoTWF0aC5leHAoLXguaW0pICsgTWF0aC5leHAoIHguaW0pKSxcbiAgICAgICAgICAwLjUgKiBNYXRoLmNvcyh4LnJlKSAqIChNYXRoLmV4cCggeC5pbSkgLSBNYXRoLmV4cCgteC5pbSkpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc1VuaXQoeCkpIHtcbiAgICAgIGlmICgheC5oYXNCYXNlKFVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gc2luIGlzIG5vIGFuZ2xlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5zaW4oeC52YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCBzaW4pO1xuICAgIH1cblxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE1hdGguc2luKHgpO1xuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgQmlnTnVtYmVyIHN1cHBvcnRcbiAgICAgIC8vIGRvd25ncmFkZSB0byBOdW1iZXJcbiAgICAgIHJldHVybiBzaW4oeC50b051bWJlcigpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignc2luJywgbWF0aFsndHlwZW9mJ10oeCkpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcclxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcclxuXHJcbiAgICAgIEJpZ051bWJlciA9IG1hdGgudHlwZS5CaWdOdW1iZXIsXHJcbiAgICAgIENvbXBsZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0NvbXBsZXgnKSxcclxuICAgICAgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpLFxyXG4gICAgICBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJyksXHJcblxyXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxyXG4gICAgICBpc0Jvb2xlYW4gPSB1dGlsWydib29sZWFuJ10uaXNCb29sZWFuLFxyXG4gICAgICBpc0NvbXBsZXggPSBDb21wbGV4LmlzQ29tcGxleCxcclxuICAgICAgaXNVbml0ID0gVW5pdC5pc1VuaXQsXHJcbiAgICAgIGlzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uaXNDb2xsZWN0aW9uO1xyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgc2luZSBvZiBhIHZhbHVlLFxyXG4gICAqIGRlZmluZWQgYXMgYHNpbmgoeCkgPSAxLzIgKiAoZXhwKHgpIC0gZXhwKC14KSlgLlxyXG4gICAqXHJcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cclxuICAgKlxyXG4gICAqIFN5bnRheDpcclxuICAgKlxyXG4gICAqICAgIG1hdGguc2luaCh4KVxyXG4gICAqXHJcbiAgICogRXhhbXBsZXM6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLnNpbmgoMC41KTsgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgMC41MjEwOTUzMDU0OTM3NDc0XHJcbiAgICpcclxuICAgKiBTZWUgYWxzbzpcclxuICAgKlxyXG4gICAqICAgIGNvc2gsIHRhbmhcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4ICBGdW5jdGlvbiBpbnB1dFxyXG4gICAqIEByZXR1cm4ge051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gSHlwZXJib2xpYyBzaW5lIG9mIHhcclxuICAgKi9cclxuICBtYXRoLnNpbmggPSBmdW5jdGlvbiBzaW5oKHgpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcclxuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3NpbmgnLCBhcmd1bWVudHMubGVuZ3RoLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNOdW1iZXIoeCkpIHtcclxuICAgICAgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcclxuICAgICAgdmFyIGNpbSA9IE1hdGguY29zKHguaW0pO1xyXG4gICAgICB2YXIgc2ltID0gTWF0aC5zaW4oeC5pbSk7XHJcbiAgICAgIHZhciBlcCA9IE1hdGguZXhwKHgucmUpO1xyXG4gICAgICB2YXIgZW4gPSBNYXRoLmV4cCgteC5yZSk7XHJcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChjaW0gKiAoZXAgLSBlbikgLyAyLCBzaW0gKiAoZXAgKyBlbikgLyAyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNVbml0KHgpKSB7XHJcbiAgICAgIGlmICgheC5oYXNCYXNlKFVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVW5pdCBpbiBmdW5jdGlvbiBzaW5oIGlzIG5vIGFuZ2xlJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNpbmgoeC52YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQ29sbGVjdGlvbih4KSkge1xyXG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHgsIHNpbmgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0Jvb2xlYW4oeCkgfHwgeCA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gc2luaCh4ID8gMSA6IDApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XHJcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBCaWdOdW1iZXIgc3VwcG9ydFxyXG4gICAgICAvLyBkb3duZ3JhZGUgdG8gTnVtYmVyXHJcbiAgICAgIHJldHVybiBzaW5oKHgudG9OdW1iZXIoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ3NpbmgnLCBtYXRoWyd0eXBlb2YnXSh4KSk7XHJcbiAgfTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBCaWdOdW1iZXIgPSBtYXRoLnR5cGUuQmlnTnVtYmVyLFxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxuICAgICAgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxuICAgICAgaXNCb29sZWFuID0gdXRpbFsnYm9vbGVhbiddLmlzQm9vbGVhbixcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxuICAgICAgaXNVbml0ID0gVW5pdC5pc1VuaXQsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSB0YW5nZW50IG9mIGEgdmFsdWUuIGB0YW4oeClgIGlzIGVxdWFsIHRvIGBzaW4oeCkgLyBjb3MoeClgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgudGFuKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnRhbigwLjUpOyAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBOdW1iZXIgMC41NDYzMDI0ODk4NDM3OTA1XG4gICAqICAgIG1hdGguc2luKDAuNSkgLyBtYXRoLmNvcygwLjUpOyAgICAvLyByZXR1cm5zIE51bWJlciAwLjU0NjMwMjQ4OTg0Mzc5MDVcbiAgICogICAgbWF0aC50YW4obWF0aC5waSAvIDQpOyAgICAgICAgICAgIC8vIHJldHVybnMgTnVtYmVyIDFcbiAgICogICAgbWF0aC50YW4obWF0aC51bml0KDQ1LCAnZGVnJykpOyAgIC8vIHJldHVybnMgTnVtYmVyIDFcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGF0YW4sIHNpbiwgY29zXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQm9vbGVhbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXggfCBudWxsfSB4ICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFRhbmdlbnQgb2YgeFxuICAgKi9cbiAgbWF0aC50YW4gPSBmdW5jdGlvbiB0YW4oeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCd0YW4nLCBhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoeCkpIHtcbiAgICAgIHJldHVybiBNYXRoLnRhbih4KTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb21wbGV4KHgpKSB7XG4gICAgICB2YXIgZGVuID0gTWF0aC5leHAoLTQuMCAqIHguaW0pICtcbiAgICAgICAgICAyLjAgKiBNYXRoLmV4cCgtMi4wICogeC5pbSkgKiBNYXRoLmNvcygyLjAgKiB4LnJlKSArXG4gICAgICAgICAgMS4wO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgMi4wICogTWF0aC5leHAoLTIuMCAqIHguaW0pICogTWF0aC5zaW4oMi4wICogeC5yZSkgLyBkZW4sXG4gICAgICAgICAgKDEuMCAtIE1hdGguZXhwKC00LjAgKiB4LmltKSkgLyBkZW5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5pdCh4KSkge1xuICAgICAgaWYgKCF4Lmhhc0Jhc2UoVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVW5pdCBpbiBmdW5jdGlvbiB0YW4gaXMgbm8gYW5nbGUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnRhbih4LnZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb2xsZWN0aW9uKHgpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwKHgsIHRhbik7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih4KSB8fCB4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTWF0aC50YW4oeCk7XG4gICAgfVxuXG4gICAgaWYgKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBCaWdOdW1iZXIgc3VwcG9ydFxuICAgICAgLy8gZG93bmdyYWRlIHRvIE51bWJlclxuICAgICAgcmV0dXJuIHRhbih4LnRvTnVtYmVyKCkpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCd0YW4nLCBtYXRoWyd0eXBlb2YnXSh4KSk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xyXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxyXG5cclxuICAgICAgQmlnTnVtYmVyID0gbWF0aC50eXBlLkJpZ051bWJlcixcclxuICAgICAgQ29tcGxleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvQ29tcGxleCcpLFxyXG4gICAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXHJcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcclxuXHJcbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXHJcbiAgICAgIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW4sXHJcbiAgICAgIGlzQ29tcGxleCA9IENvbXBsZXguaXNDb21wbGV4LFxyXG4gICAgICBpc1VuaXQgPSBVbml0LmlzVW5pdCxcclxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIGEgdmFsdWUsXHJcbiAgICogZGVmaW5lZCBhcyBgdGFuaCh4KSA9IChleHAoMiAqIHgpIC0gMSkgLyAoZXhwKDIgKiB4KSArIDEpYC5cclxuICAgKlxyXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXHJcbiAgICpcclxuICAgKiBTeW50YXg6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLnRhbmgoeClcclxuICAgKlxyXG4gICAqIEV4YW1wbGVzOlxyXG4gICAqXHJcbiAgICogICAgLy8gdGFuaCh4KSA9IHNpbmgoeCkgLyBjb3NoKHgpID0gMSAvIGNvdGgoeClcclxuICAgKiAgICBtYXRoLnRhbmgoMC41KTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAwLjQ2MjExNzE1NzI2MDAwOTc0XHJcbiAgICogICAgbWF0aC5zaW5oKDAuNSkgLyBtYXRoLmNvc2goMC41KTsgIC8vIHJldHVybnMgMC40NjIxMTcxNTcyNjAwMDk3NFxyXG4gICAqICAgIDEgLyBtYXRoLmNvdGgoMC41KTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIDAuNDYyMTE3MTU3MjYwMDA5NzRcclxuICAgKlxyXG4gICAqIFNlZSBhbHNvOlxyXG4gICAqXHJcbiAgICogICAgc2luaCwgY29zaCwgY290aFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBCb29sZWFuIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeCB8IG51bGx9IHggIEZ1bmN0aW9uIGlucHV0XHJcbiAgICogQHJldHVybiB7TnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBIeXBlcmJvbGljIHRhbmdlbnQgb2YgeFxyXG4gICAqL1xyXG4gIG1hdGgudGFuaCA9IGZ1bmN0aW9uIHRhbmgoeCkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMSkge1xyXG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcigndGFuaCcsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc051bWJlcih4KSkge1xyXG4gICAgICB2YXIgZSA9IE1hdGguZXhwKDIgKiB4KTtcclxuICAgICAgcmV0dXJuIChlIC0gMSkgLyAoZSArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0NvbXBsZXgoeCkpIHtcclxuICAgICAgdmFyIHIgPSBNYXRoLmV4cCgyICogeC5yZSk7XHJcbiAgICAgIHZhciByZSA9IHIgKiBNYXRoLmNvcygyICogeC5pbSk7XHJcbiAgICAgIHZhciBpbSA9IHIgKiBNYXRoLnNpbigyICogeC5pbSk7XHJcbiAgICAgIHZhciBkZW4gPSAocmUgKyAxKSAqIChyZSArIDEpICsgaW0gKiBpbTtcclxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxyXG4gICAgICAgICgocmUgLSAxKSAqIChyZSArIDEpICsgaW0gKiBpbSkgLyBkZW4sXHJcbiAgICAgICAgaW0gKiAyIC8gZGVuXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzVW5pdCh4KSkge1xyXG4gICAgICBpZiAoIXguaGFzQmFzZShVbml0LkJBU0VfVU5JVFMuQU5HTEUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gdGFuaCBpcyBubyBhbmdsZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YW5oKHgudmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkpIHtcclxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZGVlcE1hcCh4LCB0YW5oKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNCb29sZWFuKHgpIHx8IHggPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHRhbmgoeCA/IDEgOiAwKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xyXG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgQmlnTnVtYmVyIHN1cHBvcnRcclxuICAgICAgLy8gZG93bmdyYWRlIHRvIE51bWJlclxyXG4gICAgICByZXR1cm4gdGFuaCh4LnRvTnVtYmVyKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCd0YW5oJywgbWF0aFsndHlwZW9mJ10oeCkpO1xyXG4gIH07XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpLFxuICAgICAgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpLFxuXG4gICAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nLFxuICAgICAgaXNVbml0ID0gVW5pdC5pc1VuaXQsXG4gICAgICBpc0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmlzQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSB1bml0IG9mIGEgdmFsdWUuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC50byh4LCB1bml0KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC50byhtYXRoLnVuaXQoJzIgaW5jaCcpLCAnY20nKTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBVbml0IDUuMDggY21cbiAgICogICAgbWF0aC50byhtYXRoLnVuaXQoJzIgaW5jaCcpLCBtYXRoLnVuaXQobnVsbCwgJ2NtJykpOyAgLy8gcmV0dXJucyBVbml0IDUuMDggY21cbiAgICogICAgbWF0aC50byhtYXRoLnVuaXQoMTYsICdieXRlcycpLCAnYml0cycpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyBVbml0IDEyOCBiaXRzXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICB1bml0XG4gICAqXG4gICAqIEBwYXJhbSB7VW5pdCB8IEFycmF5IHwgTWF0cml4fSB4ICAgICBUaGUgdW5pdCB0byBiZSBjb252ZXJ0ZWQuXG4gICAqIEBwYXJhbSB7VW5pdCB8IEFycmF5IHwgTWF0cml4fSB1bml0ICBOZXcgdW5pdC4gQ2FuIGJlIGEgc3RyaW5nIGxpa2UgXCJjbVwiXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIHVuaXQgd2l0aG91dCB2YWx1ZS5cbiAgICogQHJldHVybiB7VW5pdCB8IEFycmF5IHwgTWF0cml4fSB2YWx1ZSB3aXRoIGNoYW5nZWQsIGZpeGVkIHVuaXQuXG4gICAqL1xuICBtYXRoLnRvID0gZnVuY3Rpb24gdG8oeCwgdW5pdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCd0bycsIGFyZ3VtZW50cy5sZW5ndGgsIDIpO1xuICAgIH1cblxuICAgIGlmIChpc1VuaXQoeCkpIHtcbiAgICAgIGlmIChpc1VuaXQodW5pdCkgfHwgaXNTdHJpbmcodW5pdCkpIHtcbiAgICAgICAgcmV0dXJuIHgudG8odW5pdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIHN0cmluZywgaW4gdGhhdCBjYXNlLCBjb252ZXJ0IHRvIHVuaXRcblxuICAgIGlmIChpc0NvbGxlY3Rpb24oeCkgfHwgaXNDb2xsZWN0aW9uKHVuaXQpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5kZWVwTWFwMih4LCB1bml0LCB0byk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ3RvJywgbWF0aFsndHlwZW9mJ10oeCksIG1hdGhbJ3R5cGVvZiddKHVuaXQpKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2luZGV4JyksXG4gICAgICBvYmplY3QgPSB1dGlsLm9iamVjdDtcblxuICAvKipcbiAgICogQ2xvbmUgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmNsb25lKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNsb25lKDMuNSk7ICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAzLjVcbiAgICogICAgbWF0aC5jbG9uZSgyIC0gNGkpOyAgICAgICAgICAgLy8gcmV0dXJucyBDb21wbGV4IDIgLSA0aVxuICAgKiAgICBtYXRoLmNsb25lKDQ1IGRlZyk7ICAgICAgICAgICAvLyByZXR1cm5zIFVuaXQgNDUgZGVnXG4gICAqICAgIG1hdGguY2xvbmUoW1sxLCAyXSwgWzMsIDRdXSk7IC8vIHJldHVybnMgQXJyYXkgW1sxLCAyXSwgWzMsIDRdXVxuICAgKiAgICBtYXRoLmNsb25lKFwiaGVsbG8gd29ybGRcIik7ICAgIC8vIHJldHVybnMgc3RyaW5nIFwiaGVsbG8gd29ybGRcIlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHggICBPYmplY3QgdG8gYmUgY2xvbmVkXG4gICAqIEByZXR1cm4geyp9IEEgY2xvbmUgb2Ygb2JqZWN0IHhcbiAgICovXG4gIG1hdGguY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdjbG9uZScsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3QuY2xvbmUoeCk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpO1xuXG4gIC8qKlxuICAgKiBTb3J0IHRoZSBpdGVtcyBpbiBhIG1hdHJpeC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmZpbHRlcih4LCB0ZXN0KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgZnVuY3Rpb24gaXNQb3NpdGl2ZSAoeCkge1xuICAgKiAgICAgIHJldHVybiB4ID4gMDtcbiAgICogICAgfVxuICAgKiAgICBtYXRoLmZpbHRlcihbNiwgLTIsIC0xLCA0LCAzXSwgaXNQb3NpdGl2ZSk7IC8vIHJldHVybnMgWzYsIDQsIDNdXG4gICAqXG4gICAqICAgIG1hdGguZmlsdGVyKFtcIjIzXCIsIFwiZm9vXCIsIFwiMTAwXCIsIFwiNTVcIiwgXCJiYXJcIl0sIC9bMC05XSsvKTsgLy8gcmV0dXJucyBbXCIyM1wiLCBcIjEwMFwiLCBcIjU1XCJdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBmb3JFYWNoLCBtYXAsIHNvcnRcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXggfCBBcnJheX0geCAgICBBIG9uZSBkaW1lbnNpb25hbCBtYXRyaXggb3IgYXJyYXkgdG8gZmlsdGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb24gfCBSZWdFeHB9IHRlc3RcbiAgICogICAgICAgIEEgZnVuY3Rpb24gb3IgcmVndWxhciBleHByZXNzaW9uIHRvIHRlc3QgaXRlbXMuXG4gICAqICAgICAgICBXaGVuIGB0ZXN0YCBpcyBhIGZ1bmN0aW9uLCBpdCBtdXN0IHJldHVybiBhIGJvb2xlYW4uXG4gICAqICAgICAgICBBbGwgZW50cmllcyBmb3Igd2hpY2ggYHRlc3RgIHJldHVybnMgdHJ1ZSBhcmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge01hdHJpeCB8IEFycmF5fSBSZXR1cm5zIHRoZSBmaWx0ZXJlZCBtYXRyaXguXG4gICAqL1xuICBtYXRoLmZpbHRlciA9IGZ1bmN0aW9uICh4LCB0ZXN0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdmaWx0ZXInLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICBpZiAoeCBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgdmFyIHNpemUgPSB4LnNpemUoKTtcbiAgICAgIGlmIChzaXplLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9uZSBkaW1lbnNpb25hbCBtYXRyaWNlcyBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTWF0cml4KF9maWx0ZXIoeC50b0FycmF5KCksIHRlc3QpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgcmV0dXJuIF9maWx0ZXIoeCwgdGVzdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2ZpbHRlcicsIG1hdGhbJ3R5cGVvZiddKHgpLCBtYXRoWyd0eXBlb2YnXShjb21wYXJlKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSB4XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24gfCBSZWdFeHB9IHRlc3RcbiAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgdGhlIGZpbHRlcmVkIGFycmF5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZmlsdGVyKHgsIHRlc3QpIHtcbiAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB4LmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHRlc3QoZW50cnkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRlc3QgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB4LmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHRlc3QudGVzdChlbnRyeSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbiBvciBSZWdFeHAgZXhwZWN0ZWQnKTtcbiAgICB9XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuICAgICAgc3RyaW5nID0gdXRpbC5zdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhIHZhbHVlIG9mIGFueSB0eXBlIGludG8gYSBzdHJpbmcuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5mb3JtYXQodmFsdWUpXG4gICAqICAgIG1hdGguZm9ybWF0KHZhbHVlLCBvcHRpb25zKVxuICAgKiAgICBtYXRoLmZvcm1hdCh2YWx1ZSwgcHJlY2lzaW9uKVxuICAgKiAgICBtYXRoLmZvcm1hdCh2YWx1ZSwgZm4pXG4gICAqXG4gICAqIFdoZXJlOlxuICAgKlxuICAgKiAgLSBgdmFsdWU6ICpgXG4gICAqICAgIFRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcbiAgICogIC0gYG9wdGlvbnM6IE9iamVjdGBcbiAgICogICAgQW4gb2JqZWN0IHdpdGggZm9ybWF0dGluZyBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgLSBgbm90YXRpb246IFN0cmluZ2BcbiAgICogICAgICBOdW1iZXIgbm90YXRpb24uIENob29zZSBmcm9tOlxuICAgKiAgICAgIC0gJ2ZpeGVkJ1xuICAgKiAgICAgICAgQWx3YXlzIHVzZSByZWd1bGFyIG51bWJlciBub3RhdGlvbi5cbiAgICogICAgICAgIEZvciBleGFtcGxlICcxMjMuNDAnIGFuZCAnMTQwMDAwMDAnXG4gICAqICAgICAgLSAnZXhwb25lbnRpYWwnXG4gICAqICAgICAgICBBbHdheXMgdXNlIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICAgKiAgICAgICAgRm9yIGV4YW1wbGUgJzEuMjM0ZSsyJyBhbmQgJzEuNGUrNydcbiAgICogICAgICAtICdhdXRvJyAoZGVmYXVsdClcbiAgICogICAgICAgIFJlZ3VsYXIgbnVtYmVyIG5vdGF0aW9uIGZvciBudW1iZXJzIGhhdmluZyBhbiBhYnNvbHV0ZSB2YWx1ZSBiZXR3ZWVuXG4gICAqICAgICAgICBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcywgYW5kIHVzZXMgZXhwb25lbnRpYWwgbm90YXRpb24gZWxzZXdoZXJlLlxuICAgKiAgICAgICAgTG93ZXIgYm91bmQgaXMgaW5jbHVkZWQsIHVwcGVyIGJvdW5kIGlzIGV4Y2x1ZGVkLlxuICAgKiAgICAgICAgRm9yIGV4YW1wbGUgJzEyMy40JyBhbmQgJzEuNGU3Jy5cbiAgICogICAgLSBgcHJlY2lzaW9uOiBOdW1iZXJgXG4gICAqICAgICAgQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxNiB0byByb3VuZCB0aGUgZGlnaXRzIG9mIHRoZSBudW1iZXIuIEluIGNhc2VcbiAgICogICAgICBvZiBub3RhdGlvbnMgJ2V4cG9uZW50aWFsJyBhbmQgJ2F1dG8nLCBgcHJlY2lzaW9uYCBkZWZpbmVzIHRoZSB0b3RhbFxuICAgKiAgICAgIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgcmV0dXJuZWQgYW5kIGlzIHVuZGVmaW5lZCBieSBkZWZhdWx0LlxuICAgKiAgICAgIEluIGNhc2Ugb2Ygbm90YXRpb24gJ2ZpeGVkJywgYHByZWNpc2lvbmAgZGVmaW5lcyB0aGUgbnVtYmVyIG9mXG4gICAqICAgICAgc2lnbmlmaWNhbnQgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBhbmQgaXMgMCBieSBkZWZhdWx0LlxuICAgKiAgICAtIGBleHBvbmVudGlhbDogT2JqZWN0YFxuICAgKiAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHR3byBwYXJhbWV0ZXJzLCB7TnVtYmVyfSBsb3dlciBhbmQge051bWJlcn0gdXBwZXIsXG4gICAqICAgICAgdXNlZCBieSBub3RhdGlvbiAnYXV0bycgdG8gZGV0ZXJtaW5lIHdoZW4gdG8gcmV0dXJuIGV4cG9uZW50aWFsXG4gICAqICAgICAgbm90YXRpb24uIERlZmF1bHQgdmFsdWVzIGFyZSBgbG93ZXI9MWUtM2AgYW5kIGB1cHBlcj0xZTVgLiBPbmx5XG4gICAqICAgICAgYXBwbGljYWJsZSBmb3Igbm90YXRpb24gYGF1dG9gLlxuICAgKiAtIGBmbjogRnVuY3Rpb25gXG4gICAqICAgQSBjdXN0b20gZm9ybWF0dGluZyBmdW5jdGlvbi4gQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGJ1aWx0LWluIG5vdGF0aW9ucy5cbiAgICogICBGdW5jdGlvbiBgZm5gIGlzIGNhbGxlZCB3aXRoIGB2YWx1ZWAgYXMgcGFyYW1ldGVyIGFuZCBtdXN0IHJldHVybiBhIHN0cmluZy5cbiAgICogICBJcyB1c2VmdWwgZm9yIGV4YW1wbGUgdG8gZm9ybWF0IGFsbCB2YWx1ZXMgaW5zaWRlIGEgbWF0cml4IGluIGEgcGFydGljdWxhciB3YXkuXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmZvcm1hdCg2LjQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zICc2LjQnXG4gICAqICAgIG1hdGguZm9ybWF0KDEyNDAwMDApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgJzEuMjRlNidcbiAgICogICAgbWF0aC5mb3JtYXQoMS8zKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAnMC4zMzMzMzMzMzMzMzMzMzMzJ1xuICAgKiAgICBtYXRoLmZvcm1hdCgxLzMsIDMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zICcwLjMzMydcbiAgICogICAgbWF0aC5mb3JtYXQoMjEzODUsIDIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAnMjEwMDAnXG4gICAqICAgIG1hdGguZm9ybWF0KDEyLjA3MSwge25vdGF0aW9uOiAnZml4ZWQnfSk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgJzEyJ1xuICAgKiAgICBtYXRoLmZvcm1hdCgyLjMsICAgIHtub3RhdGlvbjogJ2ZpeGVkJywgcHJlY2lzaW9uOiAyfSk7ICAvLyByZXR1cm5zICcyLjMwJ1xuICAgKiAgICBtYXRoLmZvcm1hdCg1Mi44LCAgIHtub3RhdGlvbjogJ2V4cG9uZW50aWFsJ30pOyAgICAgICAgICAvLyByZXR1cm5zICc1LjI4ZSsxJ1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgcHJpbnRcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZSB0byBiZSBzdHJpbmdpZmllZFxuICAgKiBAcGFyYW0ge09iamVjdCB8IEZ1bmN0aW9uIHwgTnVtYmVyfSBbb3B0aW9uc10gIEZvcm1hdHRpbmcgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdmFsdWVcbiAgICovXG4gIG1hdGguZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0ICh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBudW0gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChudW0gIT09IDEgJiYgbnVtICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignZm9ybWF0JywgbnVtLCAxLCAyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nLmZvcm1hdCh2YWx1ZSwgb3B0aW9ucyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXG5cbiAgICAgIGlzTnVtYmVyID0gdXRpbC5udW1iZXIuaXNOdW1iZXIsXG4gICAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nLFxuICAgICAgaXNDb21wbGV4ID0gQ29tcGxleC5pc0NvbXBsZXgsXG4gICAgICBpc1VuaXQgPSBVbml0LmlzVW5pdDtcblxuICAvKipcbiAgICogSW1wb3J0IGZ1bmN0aW9ucyBmcm9tIGFuIG9iamVjdCBvciBhIG1vZHVsZVxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguaW1wb3J0KG9iamVjdClcbiAgICogICAgbWF0aC5pbXBvcnQob2JqZWN0LCBvcHRpb25zKVxuICAgKlxuICAgKiBXaGVyZTpcbiAgICpcbiAgICogLSBgb2JqZWN0OiBPYmplY3RgXG4gICAqICAgQW4gb2JqZWN0IHdpdGggZnVuY3Rpb25zIHRvIGJlIGltcG9ydGVkLlxuICAgKiAtIGBvcHRpb25zOiBPYmplY3RgIEFuIG9iamVjdCB3aXRoIGltcG9ydCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAtIGBvdmVycmlkZTogYm9vbGVhbmBcbiAgICogICAgIElmIHRydWUsIGV4aXN0aW5nIGZ1bmN0aW9ucyB3aWxsIGJlIG92ZXJ3cml0dGVuLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgKiAgIC0gYHdyYXA6IGJvb2xlYW5gXG4gICAqICAgICBJZiB0cnVlLCB0aGUgZnVuY3Rpb25zIHdpbGwgYmUgd3JhcHBlZCBpbiBhIHdyYXBwZXIgZnVuY3Rpb25cbiAgICogICAgIHdoaWNoIGNvbnZlcnRzIGRhdGEgdHlwZXMgbGlrZSBNYXRyaXggdG8gcHJpbWl0aXZlIGRhdGEgdHlwZXMgbGlrZSBBcnJheS5cbiAgICogICAgIFRoZSB3cmFwcGVyIGlzIG5lZWRlZCB3aGVuIGV4dGVuZGluZyBtYXRoLmpzIHdpdGggbGlicmFyaWVzIHdoaWNoIGRvIG5vdFxuICAgKiAgICAgc3VwcG9ydCB0aGVzZSBkYXRhIHR5cGVzLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgLy8gZGVmaW5lIG5ldyBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlc1xuICAgKiAgICBtYXRoLmltcG9ydCh7XG4gICAqICAgICAgbXl2YWx1ZTogNDIsXG4gICAqICAgICAgaGVsbG86IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAqICAgICAgICByZXR1cm4gJ2hlbGxvLCAnICsgbmFtZSArICchJztcbiAgICogICAgICB9XG4gICAqICAgIH0pO1xuICAgKlxuICAgKiAgICAvLyB1c2UgdGhlIGltcG9ydGVkIGZ1bmN0aW9uIGFuZCB2YXJpYWJsZVxuICAgKiAgICBtYXRoLm15dmFsdWUgKiAyOyAgICAgICAgICAgICAgIC8vIDg0XG4gICAqICAgIG1hdGguaGVsbG8oJ3VzZXInKTsgICAgICAgICAgICAgLy8gJ2hlbGxvLCB1c2VyISdcbiAgICpcbiAgICogICAgLy8gaW1wb3J0IHRoZSBucG0gbW9kdWxlIG51bWJlcnNcbiAgICogICAgLy8gKG11c3QgYmUgaW5zdGFsbGVkIGZpcnN0IHdpdGggYG5wbSBpbnN0YWxsIG51bWJlcnNgKVxuICAgKiAgICBtYXRoLmltcG9ydCgnbnVtYmVycycsIHt3cmFwOiB0cnVlfSk7XG4gICAqXG4gICAqICAgIG1hdGguZmlib25hY2NpKDcpOyAvLyByZXR1cm5zIDEzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgT2JqZWN0fSBvYmplY3QgIE9iamVjdCB3aXRoIGZ1bmN0aW9ucyB0byBiZSBpbXBvcnRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgSW1wb3J0IG9wdGlvbnMuXG4gICAqL1xuICAvLyBUT0RPOiByZXR1cm4gc3RhdHVzIGluZm9ybWF0aW9uXG4gIG1hdGhbJ2ltcG9ydCddID0gZnVuY3Rpb24gbWF0aF9pbXBvcnQob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgdmFyIG51bSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKG51bSAhPSAxICYmIG51bSAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignaW1wb3J0JywgbnVtLCAxLCAyKTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIG92ZXJyaWRlOiBvcHRpb25zICYmIG9wdGlvbnMub3ZlcnJpZGUgfHwgZmFsc2UsXG4gICAgICB3cmFwOiAgICAgb3B0aW9ucyAmJiBvcHRpb25zLndyYXAgfHwgZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKGlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgIC8vIGEgc3RyaW5nIHdpdGggYSBmaWxlbmFtZVxuXG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAod2UgY2Fubm90IHVuaXQgdGVzdCB0aGUgZWxzZSBjYXNlIGluIGEgbm9kZS5qcyBlbnZpcm9ubWVudClcbiAgICAgIGlmICh0eXBlb2YgKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBsb2FkIHRoZSBmaWxlIHVzaW5nIHJlcXVpcmVcbiAgICAgICAgdmFyIF9tb2R1bGUgPSByZXF1aXJlKG9iamVjdCk7XG4gICAgICAgIG1hdGhfaW1wb3J0KF9tb2R1bGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxvYWQgbW9kdWxlOiByZXF1aXJlIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBhIG1hcCB3aXRoIGZ1bmN0aW9uc1xuICAgICAgZm9yIChuYW1lIGluIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W25hbWVdO1xuICAgICAgICAgIGlmIChpc1N1cHBvcnRlZFR5cGUodmFsdWUpKSB7XG4gICAgICAgICAgICBfaW1wb3J0KG5hbWUsIHZhbHVlLCBvcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXRoX2ltcG9ydCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0IG9yIG1vZHVsZSBuYW1lIGV4cGVjdGVkJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBwcm9wZXJ0eSB0byB0aGUgbWF0aCBuYW1lc3BhY2UgYW5kIGNyZWF0ZSBhIGNoYWluIHByb3h5IGZvciBpdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgU2VlIGltcG9ydCBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2ltcG9ydChuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlIHx8IG1hdGhbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYWRkIHRvIG1hdGggbmFtZXNwYWNlXG4gICAgICBpZiAob3B0aW9ucy53cmFwICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBjcmVhdGUgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZnVuY3Rpb25cbiAgICAgICAgbWF0aFtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBhcmdzW2ldID0gYXJnICYmIGFyZy52YWx1ZU9mKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseShtYXRoLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBqdXN0IGNyZWF0ZSBhIGxpbmsgdG8gdGhlIGZ1bmN0aW9uIG9yIHZhbHVlXG4gICAgICAgIG1hdGhbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIGEgcHJveHkgZm9yIHRoZSBTZWxlY3RvclxuICAgICAgbWF0aC5jaGFpbmluZy5TZWxlY3Rvci5jcmVhdGVQcm94eShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgc3VwcG9ydGVkIHR5cGVcbiAgICogQHBhcmFtIG9iamVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNTdXBwb3J0ZWRUeXBlKG9iamVjdCkge1xuICAgIHJldHVybiAodHlwZW9mIG9iamVjdCA9PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgICBpc051bWJlcihvYmplY3QpIHx8IGlzU3RyaW5nKG9iamVjdCkgfHxcbiAgICAgICAgaXNDb21wbGV4KG9iamVjdCkgfHwgaXNVbml0KG9iamVjdCk7XG4gICAgLy8gVE9ETzogYWRkIGJvb2xlYW4/XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIGlzTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKS5pc01hdHJpeDtcblxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbWF0cml4IG9yIGFycmF5IHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIG9uXG4gICAqIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeC9hcnJheS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLm1hcCh4LCBjYWxsYmFjaylcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubWFwKFsxLCAyLCAzXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICogICAgICByZXR1cm4gdmFsdWUgKiB2YWx1ZTtcbiAgICogICAgfSk7ICAvLyByZXR1cm5zIFsxLCA0LCA5XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZmlsdGVyLCBmb3JFYWNoLCBzb3J0XG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4IHwgQXJyYXl9IHggICAgVGhlIG1hdHJpeCB0byBpdGVyYXRlIG9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgIFRoZSBjYWxsYmFjayBtZXRob2QgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50LCB0aGUgaW5kZXhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgZWxlbWVudCwgYW5kIHRoZSBtYXRyaXggYmVpbmcgdHJhdmVyc2VkLlxuICAgKiBAcmV0dXJuIHtNYXRyaXggfCBhcnJheX0gICAgIFRyYW5zZm9ybWVkIG1hcCBvZiB4XG4gICAqL1xuICBtYXRoLm1hcCA9IGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdtYXAnLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgcmV0dXJuIF9tYXBBcnJheSh4LCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIGlmIChpc01hdHJpeCh4KSkge1xuICAgICAgcmV0dXJuIHgubWFwKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ21hcCcsIG1hdGhbJ3R5cGVvZiddKHgpKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gX21hcEFycmF5IChhcnJheUluLCBjYWxsYmFjaykge1xuICAgIHZhciBpbmRleCA9IFtdO1xuICAgIHZhciByZWN1cnNlID0gZnVuY3Rpb24gKHZhbHVlLCBkaW0pIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICAgIGluZGV4W2RpbV0gPSBpO1xuICAgICAgICAgIHJldHVybiByZWN1cnNlKGNoaWxkLCBkaW0gKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgYXJyYXlJbik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiByZWN1cnNlKGFycmF5SW4sIDApO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgICBpc1N0cmluZyA9IHV0aWwuc3RyaW5nLmlzU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJbnRlcnBvbGF0ZSB2YWx1ZXMgaW50byBhIHN0cmluZyB0ZW1wbGF0ZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5wcmludCh0ZW1wbGF0ZSwgdmFsdWVzKVxuICAgKiAgICAgbWF0aC5wcmludCh0ZW1wbGF0ZSwgdmFsdWVzLCBwcmVjaXNpb24pXG4gICAqXG4gICAqIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgICAvLyB0aGUgZm9sbG93aW5nIG91dHB1dHM6ICdMdWN5IGlzIDUgeWVhcnMgb2xkJ1xuICAgKiAgICAgbWF0aC5wcmludCgnTHVjeSBpcyAkYWdlIHllYXJzIG9sZCcsIHthZ2U6IDV9KTtcbiAgICpcbiAgICogICAgIC8vIHRoZSBmb2xsb3dpbmcgb3V0cHV0czogJ1RoZSB2YWx1ZSBvZiBwaSBpcyAzLjE0MTU5MjY1NCdcbiAgICogICAgIG1hdGgucHJpbnQoJ1RoZSB2YWx1ZSBvZiBwaSBpcyAkcGknLCB7cGk6IG1hdGgucGl9LCAxMCk7XG4gICAqXG4gICAqICAgICAvLyB0aGUgZm9sbG93aW5nIG91dHB1dHM6ICdoZWxsbyBNYXJ5ISBUaGUgZGF0ZSBpcyAyMDEzLTAzLTIzJ1xuICAgKiAgICAgbWF0aC5wcmludCgnSGVsbG8gJHVzZXIubmFtZSEgVGhlIGRhdGUgaXMgJGRhdGUnLCB7XG4gICAqICAgICAgIHVzZXI6IHtcbiAgICogICAgICAgICBuYW1lOiAnTWFyeScsXG4gICAqICAgICAgIH0sXG4gICAqICAgICAgIGRhdGU6IG5ldyBEYXRlKDIwMTMsIDIsIDIzKS50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMClcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgIGZvcm1hdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGUgICAgIEEgc3RyaW5nIGNvbnRhaW5pbmcgdmFyaWFibGUgcGxhY2Vob2xkZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHZhcmlhYmxlcyB3aGljaCB3aWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgZmlsbGVkIGluIGluIHRoZSB0ZW1wbGF0ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwcmVjaXNpb25dICBOdW1iZXIgb2YgZGlnaXRzIHRvIGZvcm1hdCBudW1iZXJzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBwcm92aWRlZCwgdGhlIHZhbHVlIHdpbGwgbm90IGJlIHJvdW5kZWQuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gSW50ZXJwb2xhdGVkIHN0cmluZ1xuICAgKi9cbiAgbWF0aC5wcmludCA9IGZ1bmN0aW9uIHByaW50ICh0ZW1wbGF0ZSwgdmFsdWVzLCBwcmVjaXNpb24pIHtcbiAgICB2YXIgbnVtID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobnVtICE9IDIgJiYgbnVtICE9IDMpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdwcmludCcsIG51bSwgMiwgMyk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1N0cmluZyh0ZW1wbGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZyBleHBlY3RlZCBhcyBmaXJzdCBwYXJhbWV0ZXIgaW4gZnVuY3Rpb24gZm9ybWF0Jyk7XG4gICAgfVxuICAgIGlmICghKHZhbHVlcyBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBleHBlY3RlZCBhcyBzZWNvbmQgcGFyYW1ldGVyIGluIGZ1bmN0aW9uIGZvcm1hdCcpO1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCB2YWx1ZXMgaW50byBhIHN0cmluZ1xuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCQoW1xcd1xcLl0rKS9nLCBmdW5jdGlvbiAob3JpZ2luYWwsIGtleSkge1xuICAgICAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2tleXMuc2hpZnQoKV07XG4gICAgICAgICAgd2hpbGUgKGtleXMubGVuZ3RoICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBrID0ga2V5cy5zaGlmdCgpO1xuICAgICAgICAgICAgdmFsdWUgPSBrID8gdmFsdWVba10gOiB2YWx1ZSArICcuJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGguZm9ybWF0KHZhbHVlLCBwcmVjaXNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIH1cbiAgICApO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKTtcblxuICAvKipcbiAgICogU29ydCB0aGUgaXRlbXMgaW4gYSBtYXRyaXguXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5zb3J0KHgpXG4gICAqICAgIG1hdGguc29ydCh4LCBjb21wYXJlKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5zb3J0KFs1LCAxMCwgMV0pOyAvLyByZXR1cm5zIFsxLCA1LCAxMF1cbiAgICogICAgbWF0aC5zb3J0KFsnQycsICdCJywgJ0EnLCAnRCddKTsgLy8gcmV0dXJucyBbJ0EnLCAnQicsICdDJywgJ0QnXVxuICAgKlxuICAgKiAgICBmdW5jdGlvbiBzb3J0QnlMZW5ndGggKGEsIGIpIHtcbiAgICogICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICogICAgfVxuICAgKiAgICBtYXRoLnNvcnQoWydMYW5nZG9uJywgJ1RvbScsICdTYXJhJ10sIHNvcnRCeUxlbmd0aCk7IC8vIHJldHVybnMgWydUb20nLCAnU2FyYScsICdMYW5nZG9uJ11cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGZpbHRlciwgZm9yRWFjaCwgbWFwXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4IHwgQXJyYXl9IHggICAgQSBvbmUgZGltZW5zaW9uYWwgbWF0cml4IG9yIGFycmF5IHRvIHNvcnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbiB8ICdhc2MnIHwgJ2Rlc2MnfSBbY29tcGFyZT0nYXNjJ11cbiAgICogICAgICAgIEFuIG9wdGlvbmFsIGNvbXBhcmF0b3IgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgYXNcbiAgICogICAgICAgIGBjb21wYXJlKGEsIGIpYCwgYW5kIG11c3QgcmV0dXJuIDEgd2hlbiBhID4gYiwgLTEgd2hlbiBhIDwgYixcbiAgICogICAgICAgIGFuZCAwIHdoZW4gYSA9PSBiLlxuICAgKiBAcmV0dXJuIHtNYXRyaXggfCBBcnJheX0gUmV0dXJucyB0aGUgc29ydGVkIG1hdHJpeC5cbiAgICovXG4gIG1hdGguc29ydCA9IGZ1bmN0aW9uICh4LCBjb21wYXJlKSB7XG4gICAgdmFyIF9jb21wYXJlID0gbnVsbDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBfY29tcGFyZSA9IG1hdGguY29tcGFyZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKHR5cGVvZiBjb21wYXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIF9jb21wYXJlID0gY29tcGFyZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvbXBhcmUgPT09ICdhc2MnKSB7XG4gICAgICAgIF9jb21wYXJlID0gbWF0aC5jb21wYXJlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29tcGFyZSA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgIF9jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gLW1hdGguY29tcGFyZShhLCBiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdzb3J0JywgbWF0aFsndHlwZW9mJ10oeCksIG1hdGhbJ3R5cGVvZiddKGNvbXBhcmUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignc29ydCcsIGFyZ3VtZW50cy5sZW5ndGgsIDEsIDIpO1xuICAgIH1cblxuICAgIGlmICh4IGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICB2YXIgc2l6ZSA9IHguc2l6ZSgpO1xuICAgICAgaWYgKHNpemUubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIGRpbWVuc2lvbmFsIG1hdHJpY2VzIHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoeC50b0FycmF5KCkuc29ydChfY29tcGFyZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICByZXR1cm4geC5zb3J0KF9jb21wYXJlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignc29ydCcsIG1hdGhbJ3R5cGVvZiddKHgpLCBtYXRoWyd0eXBlb2YnXShjb21wYXJlKSk7XG4gICAgfVxuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIHR5cGVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90eXBlcycpLFxuXG4gICAgICBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4JyksXG4gICAgICBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpLFxuICAgICAgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpLFxuICAgICAgSW5kZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0luZGV4JyksXG4gICAgICBSYW5nZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvUmFuZ2UnKSxcbiAgICAgIEhlbHAgPSByZXF1aXJlKCcuLi8uLi90eXBlL0hlbHAnKTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEZ1bmN0aW9uIGB0eXBlb2ZgIHJlY29nbml6ZXMgdGhlIGZvbGxvd2luZyB0eXBlcyBvZiBvYmplY3RzOlxuICAgKlxuICAgKiBPYmplY3QgICAgICAgICAgICAgICAgIHwgUmV0dXJucyAgICAgICB8IEV4YW1wbGVcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQXJyYXkgICAgICAgICAgICAgICAgICB8IGAnYXJyYXknYCAgICAgfCBgbWF0aC50eXBlb2YgKFsxLCAyLCAzXSlgXG4gICAqIGJvb2xlYW4gICAgICAgICAgICAgICAgfCBgJ2Jvb2xlYW4nYCAgIHwgYG1hdGgudHlwZW9mICh0cnVlKWBcbiAgICogRGF0ZSAgICAgICAgICAgICAgICAgICB8IGAnZGF0ZSdgICAgICAgfCBgbWF0aC50eXBlb2YgKG5ldyBEYXRlKCkpYFxuICAgKiBudWxsICAgICAgICAgICAgICAgICAgIHwgYCdudWxsJ2AgICAgICB8IGBtYXRoLnR5cGVvZihudWxsKWBcbiAgICogbnVtYmVyICAgICAgICAgICAgICAgICB8IGAnbnVtYmVyJ2AgICAgfCBgbWF0aC50eXBlb2YoMy41KWBcbiAgICogT2JqZWN0ICAgICAgICAgICAgICAgICB8IGAnb2JqZWN0J2AgICAgfCBgbWF0aC50eXBlb2YgKHthOiAyLCBiOiAzfSlgXG4gICAqIFJlZ0V4cCAgICAgICAgICAgICAgICAgfCBgJ3JlZ2V4cCdgICAgIHwgYG1hdGgudHlwZW9mICgvYSByZWdleHAvKWBcbiAgICogc3RyaW5nICAgICAgICAgICAgICAgICB8IGAnc3RyaW5nJ2AgICAgfCBgbWF0aC50eXBlb2YgKCdoZWxsbyB3b3JsZCcpYFxuICAgKiB1bmRlZmluZWQgICAgICAgICAgICAgIHwgYCd1bmRlZmluZWQnYCB8IGBtYXRoLnR5cGVvZih1bmRlZmluZWQpYFxuICAgKiBtYXRoLmNoYWluaW5nLlNlbGVjdG9yIHwgYCdzZWxlY3RvcidgICB8IGBtYXRoLnR5cGVvZiAobWF0aC5zZWxlY3QoMikpYFxuICAgKiBtYXRoLnR5cGUuQmlnTnVtYmVyICAgIHwgYCdiaWdudW1iZXInYCB8IGBtYXRoLnR5cGVvZiAobWF0aC5iaWdudW1iZXIoJzIuM2U1MDAnKSlgXG4gICAqIG1hdGgudHlwZS5Db21wbGV4ICAgICAgfCBgJ2NvbXBsZXgnYCAgIHwgYG1hdGgudHlwZW9mIChtYXRoLmNvbXBsZXgoMiwgMykpYFxuICAgKiBtYXRoLnR5cGUuSGVscCAgICAgICAgIHwgYCdoZWxwJ2AgICAgICB8IGBtYXRoLnR5cGVvZiAobWF0aC5oZWxwKCdzcXJ0JykpYFxuICAgKiBtYXRoLnR5cGUuSW5kZXggICAgICAgIHwgYCdpbmRleCdgICAgICB8IGBtYXRoLnR5cGVvZiAobWF0aC5pbmRleCgxLCAzKSlgXG4gICAqIG1hdGgudHlwZS5NYXRyaXggICAgICAgfCBgJ21hdHJpeCdgICAgIHwgYG1hdGgudHlwZW9mIChtYXRoLm1hdHJpeChbWzEsMl0sIFszLCA0XV0pKWBcbiAgICogbWF0aC50eXBlLlJhbmdlICAgICAgICB8IGAncmFuZ2UnYCAgICAgfCBgbWF0aC50eXBlb2YgKG1hdGgucmFuZ2UoMCwgMTApKWBcbiAgICogbWF0aC50eXBlLlVuaXQgICAgICAgICB8IGAndW5pdCdgICAgICAgfCBgbWF0aC50eXBlb2YgKG1hdGgudW5pdCgnNDUgZGVnJykpYFxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgudHlwZW9mKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnR5cGVvZigzLjUpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgJ251bWJlcidcbiAgICogICAgbWF0aC50eXBlb2YobWF0aC5jb21wbGV4KCcyIC0gNGknKSk7ICAvLyByZXR1cm5zICdjb21wbGV4J1xuICAgKiAgICBtYXRoLnR5cGVvZihtYXRoLnVuaXQoJzQ1IGRlZycpKTsgICAgIC8vIHJldHVybnMgJ3VuaXQnXG4gICAqICAgIG1hdGgudHlwZW9mKCdoZWxsbyB3b3JsZCcpOyAgICAgICAgICAgLy8gcmV0dXJucyAnc3RyaW5nJ1xuICAgKlxuICAgKiBAcGFyYW0geyp9IHggIFRoZSB2YXJpYWJsZSBmb3Igd2hpY2ggdG8gdGVzdCB0aGUgdHlwZS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBMb3dlciBjYXNlIHR5cGUsIGZvciBleGFtcGxlICdudW1iZXInLCAnc3RyaW5nJywgJ2FycmF5Jy5cbiAgICovXG4gIG1hdGhbJ3R5cGVvZiddID0gZnVuY3Rpb24gX3R5cGVvZiAoeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCd0eXBlb2YnLCBhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB9XG5cbiAgICAvLyBKYXZhU2NyaXB0IHR5cGVzXG4gICAgdmFyIHR5cGUgPSB0eXBlcy50eXBlKHgpO1xuXG4gICAgLy8gbWF0aC5qcyB0eXBlc1xuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHggaW5zdGFuY2VvZiBDb21wbGV4KSByZXR1cm4gJ2NvbXBsZXgnO1xuICAgICAgaWYgKHggaW5zdGFuY2VvZiBNYXRyaXgpIHJldHVybiAnbWF0cml4JztcbiAgICAgIGlmICh4IGluc3RhbmNlb2YgVW5pdCkgcmV0dXJuICd1bml0JztcbiAgICAgIGlmICh4IGluc3RhbmNlb2YgSW5kZXgpIHJldHVybiAnaW5kZXgnO1xuICAgICAgaWYgKHggaW5zdGFuY2VvZiBSYW5nZSkgcmV0dXJuICdyYW5nZSc7XG4gICAgICBpZiAoeCBpbnN0YW5jZW9mIEhlbHApIHJldHVybiAnaGVscCc7XG5cbiAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdHlwZXMgYXJlIGRpZmZlcmVudCBpbnN0YW5jZXMgcGVyIG1hdGguanMgaW5zdGFuY2VcbiAgICAgIGlmICh4IGluc3RhbmNlb2YgbWF0aC50eXBlLkJpZ051bWJlcikgcmV0dXJuICdiaWdudW1iZXInO1xuICAgICAgaWYgKHggaW5zdGFuY2VvZiBtYXRoLmNoYWluaW5nLlNlbGVjdG9yKSByZXR1cm4gJ3NlbGVjdG9yJztcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIGlzTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKS5pc01hdHJpeDtcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGFsbCBlbGVtZW50cyBvZiBhIG1hdHJpeC9hcnJheSwgYW5kIGV4ZWN1dGVzIHRoZSBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmZvckVhY2goeCwgY2FsbGJhY2spXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmZvckVhY2goWzEsIDIsIDNdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgKiAgICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICogICAgfSk7XG4gICAqICAgIC8vIG91dHB1dHMgMSwgMiwgM1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZmlsdGVyLCBtYXAsIHNvcnRcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXggfCBBcnJheX0geCAgICBUaGUgbWF0cml4IHRvIGl0ZXJhdGUgb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCwgdGhlIGluZGV4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGVsZW1lbnQsIGFuZCB0aGUgTWF0cml4L2FycmF5IGJlaW5nIHRyYXZlcnNlZC5cbiAgICovXG4gIG1hdGguZm9yRWFjaCA9IGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkFyZ3VtZW50c0Vycm9yKCdmb3JFYWNoJywgYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgIHJldHVybiBfZm9yRWFjaEFycmF5KHgsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKGlzTWF0cml4KHgpKSB7XG4gICAgICByZXR1cm4geC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ2ZvckVhY2gnLCBtYXRoWyd0eXBlb2YnXSh4KSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIF9mb3JFYWNoQXJyYXkgKGFycmF5LCBjYWxsYmFjaykge1xuICAgIHZhciBpbmRleCA9IFtdO1xuICAgIHZhciByZWN1cnNlID0gZnVuY3Rpb24gKHZhbHVlLCBkaW0pIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICAgIGluZGV4W2RpbV0gPSBpOyAvLyB6ZXJvLWJhc2VkIGluZGV4XG4gICAgICAgICAgcmVjdXJzZShjaGlsZCwgZGltICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVjdXJzZShhcnJheSwgMCk7XG4gIH1cblxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBTeW1ib2xOb2RlID0gcmVxdWlyZSgnLi4vLi4vZXhwcmVzc2lvbi9ub2RlL1N5bWJvbE5vZGUnKTtcbnZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCcuLi8uLi91dGlsL2Jvb2xlYW4nKS5pc0Jvb2xlYW47XG52YXIgYXJnc1RvQXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlsL2FycmF5JykuYXJnc1RvQXJyYXk7XG52YXIgQXJndW1lbnRzRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9Bcmd1bWVudHNFcnJvcicpO1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLmZpbHRlclxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gYWRkcyBzdXBwb3J0IGZvciBlcXVhdGlvbnMgYXMgdGVzdCBmdW5jdGlvbiBmb3IgbWF0aC5maWx0ZXIsXG4gKiBzbyB5b3UgY2FuIGRvIHNvbWV0aGluZyBsaWtlICdmaWx0ZXIoWzMsIC0yLCA1XSwgeCA+IDApJy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgdmFyIF9maWx0ZXIgPSBtYXRoLmZpbHRlcjtcblxuICBfZmlsdGVyLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChhcmdzLCBtYXRoLCBzY29wZSkge1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50c0Vycm9yKCdmaWx0ZXInLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IGFyZ3NbMF0uY29tcGlsZShtYXRoKS5ldmFsKHNjb3BlKTtcbiAgICB2YXIgdGVzdDtcbiAgICBpZiAoYXJnc1sxXSBpbnN0YW5jZW9mIFN5bWJvbE5vZGUpIHtcbiAgICAgIC8vIGEgZnVuY3Rpb24gcG9pbnRlciwgbGlrZSBmaWx0ZXIoWzMsIC0yLCA1XSwgbXlUZXN0RnVuY3Rpb24pO1xuICAgICAgdGVzdCA9IGFyZ3NbMV0uY29tcGlsZShtYXRoKS5ldmFsKHNjb3BlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhbiBlcXVhdGlvbiBsaWtlIGZpbHRlcihbMywgLTIsIDVdLCB4ID4gMClcblxuICAgICAgLy8gZmluZCBhbiB1bmRlZmluZWQgc3ltYm9sXG4gICAgICB2YXIgX3Njb3BlID0gc2NvcGUgfHwge307XG4gICAgICB2YXIgc3ltYm9sID0gYXJnc1sxXVxuICAgICAgICAgIC5maW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFN5bWJvbE5vZGVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuICEoc3ltYm9sLm5hbWUgaW4gbWF0aCkgJiYgIShzeW1ib2wubmFtZSBpbiBfc2NvcGUpO1xuICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAvLyBjcmVhdGUgYSB0ZXN0IGZ1bmN0aW9uIGZvciB0aGlzIGVxdWF0aW9uXG4gICAgICB2YXIgc3ViID0gT2JqZWN0LmNyZWF0ZShfc2NvcGUpO1xuICAgICAgdmFyIGVxID0gYXJnc1sxXS5jb21waWxlKG1hdGgpO1xuICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICB2YXIgbmFtZSA9IHN5bWJvbC5uYW1lO1xuICAgICAgICB0ZXN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICBzdWJbbmFtZV0gPSB4O1xuICAgICAgICAgIHJldHVybiBlcS5ldmFsKHN1Yik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHVuZGVmaW5lZCB2YXJpYWJsZSBmb3VuZCBpbiBmaWx0ZXIgZXF1YXRpb24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2ZpbHRlcih4LCB0ZXN0KTtcbiAgfTtcblxuICBtYXRoLmZpbHRlci50cmFuc2Zvcm0ucmF3QXJncyA9IHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNCb29sZWFuID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ib29sZWFuJykuaXNCb29sZWFuO1xudmFyIGFyZ3NUb0FycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9hcnJheScpLmFyZ3NUb0FycmF5O1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLnJhbmdlXG4gKiBBZGRzIGEgcHJvcGVydHkgdHJhbnNmb3JtIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIHRyYW5zZm9ybSBjcmVhdGVzIGEgcmFuZ2Ugd2hpY2ggaW5jbHVkZXMgdGhlIGVuZCB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICBtYXRoLnJhbmdlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3NUb0FycmF5KGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgbGFzdEluZGV4ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHZhciBsYXN0ID0gYXJnc1tsYXN0SW5kZXhdO1xuICAgIGlmICghaXNCb29sZWFuKGxhc3QpKSB7XG4gICAgICBhcmdzLnB1c2godHJ1ZSk7IC8vIGFwcGVuZCBhIHBhcmFtZXRlciBpbmNsdWRlRW5kPXRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0aC5yYW5nZS5hcHBseShtYXRoLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZXJyb3IudHJhbnNmb3JtJykudHJhbnNmb3JtO1xudmFyIGlzQm9vbGVhbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYm9vbGVhbicpLmlzQm9vbGVhbjtcbnZhciBhcmdzVG9BcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYXJyYXknKS5hcmdzVG9BcnJheTtcblxuLyoqXG4gKiBBdHRhY2ggYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gbWF0aC5zdWJzZXRcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0cmFuc2Zvcm0gY29udGFpbmluZyB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgdHJhbnNmb3JtIGNyZWF0ZXMgYSByYW5nZSB3aGljaCBpbmNsdWRlcyB0aGUgZW5kIHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIG1hdGguc3Vic2V0LnRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1hdGguc3Vic2V0LmFwcGx5KG1hdGgsIGFyZ3NUb0FycmF5KGFyZ3VtZW50cykpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnJvclRyYW5zZm9ybShlcnIpO1xuICAgIH1cbiAgfTtcbn07XG4iLCIoZnVuY3Rpb24ocHJvY2Vzcyl7XG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG5cbi8vIGxpbmtlZCBsaXN0IG9mIHRhc2tzIChzaW5nbGUsIHdpdGggaGVhZCBub2RlKVxudmFyIGhlYWQgPSB7dGFzazogdm9pZCAwLCBuZXh0OiBudWxsfTtcbnZhciB0YWlsID0gaGVhZDtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIHJlcXVlc3RGbHVzaCA9IHZvaWQgMDtcbnZhciBpc05vZGVKUyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cblxuICAgIHdoaWxlIChoZWFkLm5leHQpIHtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgICAgdmFyIHRhc2sgPSBoZWFkLnRhc2s7XG4gICAgICAgIGhlYWQudGFzayA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xuXG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgIGhlYWQuZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFzaygpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICAgICAgICAgIC8vIEluIG5vZGUsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIGNvbnNpZGVyZWQgZmF0YWwgZXJyb3JzLlxuICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gc3luY2hyb25vdXNseSB0byBpbnRlcnJ1cHQgZmx1c2hpbmchXG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29udGludWF0aW9uIGlmIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaXMgc3VwcHJlc3NlZFxuICAgICAgICAgICAgICAgIC8vIGxpc3RlbmluZyBcInVuY2F1Z2h0RXhjZXB0aW9uXCIgZXZlbnRzIChhcyBkb21haW5zIGRvZXMpLlxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGluIG5leHQgZXZlbnQgdG8gYXZvaWQgdGljayByZWN1cnNpb24uXG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gYnJvd3NlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHNsb3ctZG93bnMuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLm5leHRUaWNrKSB7XG4gICAgLy8gTm9kZS5qcyBiZWZvcmUgMC45LiBOb3RlIHRoYXQgc29tZSBmYWtlLU5vZGUgZW52aXJvbm1lbnRzLCBsaWtlIHRoZVxuICAgIC8vIE1vY2hhIHRlc3QgcnVubmVyLCBpbnRyb2R1Y2UgYSBgcHJvY2Vzc2AgZ2xvYmFsIHdpdGhvdXQgYSBgbmV4dFRpY2tgLlxuICAgIGlzTm9kZUpTID0gdHJ1ZTtcblxuICAgIHJlcXVlc3RGbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcblxufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBJbiBJRTEwLCBOb2RlLmpzIDAuOSssIG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Ob2JsZUpTL3NldEltbWVkaWF0ZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJlcXVlc3RGbHVzaCA9IHNldEltbWVkaWF0ZS5iaW5kKHdpbmRvdywgZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RGbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbHVzaCk7XG4gICAgICAgIH07XG4gICAgfVxuXG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIG1vZGVybiBicm93c2Vyc1xuICAgIC8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG4gICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICAgIHJlcXVlc3RGbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICB9O1xuXG59IGVsc2Uge1xuICAgIC8vIG9sZCBicm93c2Vyc1xuICAgIHJlcXVlc3RGbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYXNhcCh0YXNrKSB7XG4gICAgdGFpbCA9IHRhaWwubmV4dCA9IHtcbiAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgZG9tYWluOiBpc05vZGVKUyAmJiBwcm9jZXNzLmRvbWFpbixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgcmVxdWVzdEZsdXNoKCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc2FwO1xuXG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSkiLCJtb2R1bGUuZXhwb3J0cyA9ICcxLjAuMSc7XG4vLyBOb3RlOiBUaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgd2hlbiBidWlsZGluZyBtYXRoLmpzLlxuLy8gQ2hhbmdlcyBtYWRlIGluIHRoaXMgZmlsZSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZSBhIHN5bnRheCBlcnJvciB3aXRoIHRoZSBtZXNzYWdlOlxuICogICAgICdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGluIGZ1bmN0aW9uIDxmbj4gKDxjb3VudD4gcHJvdmlkZWQsIDxtaW4+LTxtYXg+IGV4cGVjdGVkKSdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbiAgICAgRnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50ICBBY3R1YWwgYXJndW1lbnQgY291bnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gICAgTWluaW11bSByZXF1aXJlZCBhcmd1bWVudCBjb3VudFxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhdICBNYXhpbXVtIHJlcXVpcmVkIGFyZ3VtZW50IGNvdW50XG4gKiBAZXh0ZW5kcyBFcnJvclxuICovXG5mdW5jdGlvbiBBcmd1bWVudHNFcnJvcihmbiwgY291bnQsIG1pbiwgbWF4KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBcmd1bWVudHNFcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICB9XG5cbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvdW50ID0gY291bnQ7XG4gIHRoaXMubWluID0gbWluO1xuICB0aGlzLm1heCA9IG1heDtcblxuICB0aGlzLm1lc3NhZ2UgPSAnV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiBmdW5jdGlvbiAnICsgZm4gK1xuICAgICAgJyAoJyArIGNvdW50ICsgJyBwcm92aWRlZCwgJyArXG4gICAgICBtaW4gKyAoKG1heCAhPSB1bmRlZmluZWQpID8gKCctJyArIG1heCkgOiAnJykgKyAnIGV4cGVjdGVkKSc7XG5cbiAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5cbkFyZ3VtZW50c0Vycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuQXJndW1lbnRzRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXJyb3I7XG5Bcmd1bWVudHNFcnJvci5wcm90b3R5cGUubmFtZSA9ICdBcmd1bWVudHNFcnJvcic7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJndW1lbnRzRXJyb3I7XG4iLCIoZnVuY3Rpb24oKXsvKiEgZGVjaW1hbC5qcyB2My4wLjEgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvZGVjaW1hbC5qcy9MSUNFTkNFICovXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIGRlY2ltYWwuanMgdjMuMC4xXHJcbiAgICAgKiAgQW4gYXJiaXRyYXJ5LXByZWNpc2lvbiBEZWNpbWFsIHR5cGUgZm9yIEphdmFTY3JpcHQuXHJcbiAgICAgKiAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvZGVjaW1hbC5qc1xyXG4gICAgICogIENvcHlyaWdodCAoYykgMjAxNCBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gICAgICogIE1JVCBFeHBhdCBMaWNlbmNlXHJcbiAgICAgKi9cclxuXHJcblxyXG4gICAgdmFyIGNvbnZlcnRCYXNlLCBEZWNpbWFsQ29uc3RydWN0b3IsIG5vQ29uZmxpY3QsXHJcbiAgICAgICAgY3J5cHRvID0gZ2xvYmFsWydjcnlwdG8nXSxcclxuICAgICAgICBleHRlcm5hbCA9IHRydWUsXHJcbiAgICAgICAgaWQgPSAwLFxyXG4gICAgICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcbiAgICAgICAgbWF0aHBvdyA9IE1hdGgucG93LFxyXG4gICAgICAgIG91dE9mUmFuZ2UsXHJcbiAgICAgICAgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxyXG4gICAgICAgIEJBU0UgPSAxZTcsXHJcbiAgICAgICAgTE9HQkFTRSA9IDcsXHJcbiAgICAgICAgTlVNRVJBTFMgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXycsXHJcbiAgICAgICAgUCA9IHt9LFxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICBUaGUgbWF4aW11bSBleHBvbmVudCBtYWduaXR1ZGUuXHJcbiAgICAgICAgIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgdG9FeHBOZWcsIHRvRXhwUG9zLCBtaW5FIGFuZCBtYXhFLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVYUF9MSU1JVCA9IDllMTUsICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOWUxNVxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIHByZWNpc2lvbiwgYW5kIG9uIHRoZSBhcmd1bWVudCB0byB0b0RlY2ltYWxQbGFjZXMsXHJcbiAgICAgICAgIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCB0b1ByZWNpc2lvbiBhbmQgdG9TaWduaWZpY2FudERpZ2l0cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNQVhfRElHSVRTID0gMUU5LCAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDFlKzlcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgVG8gZGVjaWRlIHdoZXRoZXIgb3Igbm90IHRvIGNhbGN1bGF0ZSB4LnBvdyhpbnRlZ2VyIHkpIHVzaW5nIHRoZSAnZXhwb25lbnRpYXRpb24gYnlcclxuICAgICAgICAgc3F1YXJpbmcnIGFsZ29yaXRobSBvciBieSBleHAoeSpsbih4KSksIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHggaXMgbXVsdGlwbGllZFxyXG4gICAgICAgICBieSB5LiBJZiB0aGlzIG51bWJlciBpcyBsZXNzIHRoYW4gSU5UX1BPV19MSU1JVCB0aGVuIHRoZSBmb3JtZXIgYWxnb3JpdGhtIGlzIHVzZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSU5UX1BPV19MSU1JVCA9IDMwMDAsICAgICAgICAgICAgICAgICAgLy8gMCB0byA1MDAwXHJcblxyXG4gICAgICAgIC8vIFRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiAxMCAoMTAyNSBkaWdpdHMpLlxyXG4gICAgICAgIExOMTAgPSAnMi4zMDI1ODUwOTI5OTQwNDU2ODQwMTc5OTE0NTQ2ODQzNjQyMDc2MDExMDE0ODg2Mjg3NzI5NzYwMzMzMjc5MDA5Njc1NzI2MDk2NzczNTI0ODAyMzU5OTcyMDUwODk1OTgyOTgzNDE5Njc3ODQwNDIyODYyNDg2MzM0MDk1MjU0NjUwODI4MDY3NTY2NjYyODczNjkwOTg3ODE2ODk0ODI5MDcyMDgzMjU1NTQ2ODA4NDM3OTk4OTQ4MjYyMzMxOTg1MjgzOTM1MDUzMDg5NjUzNzc3MzI2Mjg4NDYxNjMzNjYyMjIyODc2OTgyMTk4ODY3NDY1NDM2Njc0NzQ0MDQyNDMyNzQzNjUxNTUwNDg5MzQzMTQ5MzkzOTE0Nzk2MTk0MDQ0MDAyMjIxMDUxMDE3MTQxNzQ4MDAzNjg4MDg0MDEyNjQ3MDgwNjg1NTY3NzQzMjE2MjI4MzU1MjIwMTE0ODA0NjYzNzE1NjU5MTIxMzczNDUwNzQ3ODU2OTQ3NjgzNDYzNjE2NzkyMTAxODA2NDQ1MDcwNjQ4MDAwMjc3NTAyNjg0OTE2NzQ2NTUwNTg2ODU2OTM1NjczNDIwNjcwNTgxMTM2NDI5MjI0NTU0NDA1NzU4OTI1NzI0MjA4MjQxMzE0Njk1Njg5MDE2NzU4OTQwMjU2Nzc2MzExMzU2OTE5MjkyMDMzMzc2NTg3MTQxNjYwMjMwMTA1NzAzMDg5NjM0NTcyMDc1NDQwMzcwODQ3NDY5OTQwMTY4MjY5MjgyODA4NDgxMTg0Mjg5MzE0ODQ4NTI0OTQ4NjQ0ODcxOTI3ODA5Njc2MjcxMjc1Nzc1Mzk3MDI3NjY4NjA1OTUyNDk2NzE2Njc0MTgzNDg1NzA0NDIyNTA3MTk3OTY1MDA0NzE0OTUxMDUwNDkyMjE0Nzc2NTY3NjM2OTM4NjYyOTc2OTc5NTIyMTEwNzE4MjY0NTQ5NzM0NzcyNjYyNDI1NzA5NDI5MzIyNTgyNzk4NTAyNTg1NTA5Nzg1MjY1MzgzMjA3NjA2NzI2MzE3MTY0MzA5NTA1OTk1MDg3ODA3NTIzNzEwMzMzMTAxMTk3ODU3NTQ3MzMxNTQxNDIxODA4NDI3NTQzODYzNTkxNzc4MTE3MDU0MzA5ODI3NDgyMzg1MDQ1NjQ4MDE5MDk1NjEwMjk5MjkxODI0MzE4MjM3NTI1MzU3NzA5NzUwNTM5NTY1MTg3Njk3NTEwMzc0OTcwODg4NjkyMTgwMjA1MTg5MzM5NTA3MjM4NTM5MjA1MTQ0NjM0MTk3MjY1Mjg3Mjg2OTY1MTEwODYyNTcxNDkyMTk4ODQ5OTc4NzQ4ODczNzcxMzQ1Njg2MjA5MTY3MDU4JztcclxuXHJcblxyXG4gICAgLy8gRGVjaW1hbCBwcm90b3R5cGUgbWV0aG9kc1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ2Fic29sdXRlVmFsdWUnXSA9IFBbJ2FicyddID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB4ID0gbmV3IHRoaXNbJ2NvbnN0cnVjdG9yJ10odGhpcyk7XHJcblxyXG4gICAgICAgIGlmICggeFsncyddIDwgMCApIHtcclxuICAgICAgICAgICAgeFsncyddID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBybmQoeCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgd2hvbGUgbnVtYmVyIGluXHJcbiAgICAgKiB0aGUgZGlyZWN0aW9uIG9mIHBvc2l0aXZlIEluZmluaXR5LlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUFsnY2VpbCddID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gcm5kKCBuZXcgdGhpc1snY29uc3RydWN0b3InXSh0aGlzKSwgdGhpc1snZSddICsgMSwgMiApO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVyblxyXG4gICAgICogICAxICAgIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBEZWNpbWFsKHksIGIpLFxyXG4gICAgICogIC0xICAgIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBEZWNpbWFsKHksIGIpLFxyXG4gICAgICogICAwICAgIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAqICBudWxsICBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIERlY2ltYWwgaXMgTmFOLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUFsnY29tcGFyZWRUbyddID0gUFsnY21wJ10gPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgdmFyIGEsXHJcbiAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICB4YyA9IHhbJ2MnXSxcclxuICAgICAgICAgICAgeWMgPSAoIGlkID0gLWlkLCB5ID0gbmV3IHhbJ2NvbnN0cnVjdG9yJ10oIHksIGIgKSwgeVsnYyddICksXHJcbiAgICAgICAgICAgIGkgPSB4WydzJ10sXHJcbiAgICAgICAgICAgIGogPSB5WydzJ10sXHJcbiAgICAgICAgICAgIGsgPSB4WydlJ10sXHJcbiAgICAgICAgICAgIGwgPSB5WydlJ107XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgICAgaWYgKCAhaSB8fCAhaiApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICggYSB8fCBiICkge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgIGlmICggaSAhPSBqICkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGEgPSBpIDwgMDtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICggIXhjIHx8ICF5YyApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGsgPT0gbCA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICAgICAgaWYgKCBrICE9IGwgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGZvciAoIGkgPSAtMSxcclxuICAgICAgICAgICAgICBqID0gKCBrID0geGMubGVuZ3RoICkgPCAoIGwgPSB5Yy5sZW5ndGggKSA/IGsgOiBsO1xyXG4gICAgICAgICAgICAgICsraSA8IGo7ICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB4Y1tpXSAhPSB5Y1tpXSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICAgUFsnZGVjaW1hbFBsYWNlcyddID0gUFsnZHAnXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYywgdixcclxuICAgICAgICAgICAgbiA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmICggYyA9IHRoaXNbJ2MnXSApIHtcclxuICAgICAgICAgICAgbiA9ICggKCB2ID0gYy5sZW5ndGggLSAxICkgLSBtYXRoZmxvb3IoIHRoaXNbJ2UnXSAvIExPR0JBU0UgKSApICogTE9HQkFTRTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdiA9IGNbdl0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBuIDwgMCApIHtcclxuICAgICAgICAgICAgICAgIG4gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBkaXZpZGVkIGJ5IERlY2ltYWwoeSwgYiksXHJcbiAgICAgKiByb3VuZGVkIHRvIHByZWNpc2lvbiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSByb3VuZGluZy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ2RpdmlkZWRCeSddID0gUFsnZGl2J10gPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgaWQgPSAyO1xyXG5cclxuICAgICAgICByZXR1cm4gZGl2KCB0aGlzLCBuZXcgdGhpc1snY29uc3RydWN0b3InXSggeSwgYiApICk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGJ5XHJcbiAgICAgKiB0aGUgdmFsdWUgb2YgRGVjaW1hbCh5LCBiKSwgcm91bmRlZCB0byBwcmVjaXNpb24gc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGVcclxuICAgICAqIHJvdW5kaW5nLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUFsnZGl2aWRlZFRvSW50ZWdlckJ5J10gPSBQWydkaXZUb0ludCddID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgICAgICAgRGVjaW1hbCA9IHhbJ2NvbnN0cnVjdG9yJ107XHJcbiAgICAgICAgaWQgPSAxODtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJuZChcclxuICAgICAgICAgIGRpdiggeCwgbmV3IERlY2ltYWwoIHksIGIgKSwgMCwgMSwgMSApLCBEZWNpbWFsWydwcmVjaXNpb24nXSwgRGVjaW1hbFsncm91bmRpbmcnXVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgRGVjaW1hbChuLCBiKSwgb3RoZXJ3aXNlXHJcbiAgICAgKiByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBQWydlcXVhbHMnXSA9IFBbJ2VxJ10gPSBmdW5jdGlvbiAoIG4sIGIgKSB7XHJcbiAgICAgICAgaWQgPSAzO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpc1snY21wJ10oIG4sIGIgKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgZXhwb25lbnRpYWwgb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCwgaS5lLiB0aGVcclxuICAgICAqIGJhc2UgZSByYWlzZWQgdG8gdGhlIHBvd2VyIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsIHJvdW5kZWQgdG8gcHJlY2lzaW9uIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSByb3VuZGluZy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ2V4cG9uZW50aWFsJ10gPSBQWydleHAnXSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGV4cCh0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSB3aG9sZSBudW1iZXIgaW5cclxuICAgICAqIHRoZSBkaXJlY3Rpb24gb2YgbmVnYXRpdmUgSW5maW5pdHkuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBQWydmbG9vciddID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gcm5kKCBuZXcgdGhpc1snY29uc3RydWN0b3InXSh0aGlzKSwgdGhpc1snZSddICsgMSwgMyApO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBEZWNpbWFsKG4sIGIpLCBvdGhlcndpc2VcclxuICAgICAqIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ2dyZWF0ZXJUaGFuJ10gPSBQWydndCddID0gZnVuY3Rpb24gKCBuLCBiICkge1xyXG4gICAgICAgIGlkID0gNDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXNbJ2NtcCddKCBuLCBiICkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogRGVjaW1hbChuLCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ2dyZWF0ZXJUaGFuT3JFcXVhbFRvJ10gPSBQWydndGUnXSA9IGZ1bmN0aW9uICggbiwgYiApIHtcclxuICAgICAgICBpZCA9IDU7XHJcbiAgICAgICAgYiA9IHRoaXNbJ2NtcCddKCBuLCBiICk7XHJcblxyXG4gICAgICAgIHJldHVybiBiID09IDEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ2lzRmluaXRlJ10gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAhIXRoaXNbJ2MnXTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBQWydpc0ludGVnZXInXSA9IFBbJ2lzSW50J10gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAhIXRoaXNbJ2MnXSAmJiBtYXRoZmxvb3IoIHRoaXNbJ2UnXSAvIExPR0JBU0UgKSA+IHRoaXNbJ2MnXS5sZW5ndGggLSAyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUFsnaXNOYU4nXSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICF0aGlzWydzJ107XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ2lzTmVnYXRpdmUnXSA9IFBbJ2lzTmVnJ10gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzWydzJ10gPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ2lzWmVybyddID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICByZXR1cm4gISF0aGlzWydjJ10gJiYgdGhpc1snYyddWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBsZXNzIHRoYW4gRGVjaW1hbChuLCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ2xlc3NUaGFuJ10gPSBQWydsdCddID0gZnVuY3Rpb24gKCBuLCBiICkge1xyXG4gICAgICAgIGlkID0gNjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXNbJ2NtcCddKCBuLCBiICkgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIERlY2ltYWwobiwgYiksIG90aGVyd2lzZVxyXG4gICAgICogcmV0dXJuIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUFsnbGVzc1RoYW5PckVxdWFsVG8nXSA9IFBbJ2x0ZSddID0gZnVuY3Rpb24gKCBuLCBiICkge1xyXG4gICAgICAgIGlkID0gNztcclxuICAgICAgICBiID0gdGhpc1snY21wJ10oIG4sIGIgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGIgPT0gLTEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdGhlIGxvZ2FyaXRobSBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHRvIHRoZSBzcGVjaWZpZWQgYmFzZSwgcm91bmRlZFxyXG4gICAgICogdG8gcHJlY2lzaW9uIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJvdW5kaW5nLlxyXG4gICAgICpcclxuICAgICAqIElmIG5vIGJhc2UgaXMgc3BlY2lmaWVkLCByZXR1cm4gbG9nWzEwXShhcmcpLlxyXG4gICAgICpcclxuICAgICAqIGxvZ1tiYXNlXShhcmcpID0gbG4oYXJnKSAvIGxuKGJhc2UpXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBjb3JyZWN0bHkgcm91bmRlZCBpZiB0aGUgYmFzZSBvZiB0aGUgbG9nIGlzIDIgb3IgMTAsIGFuZFxyXG4gICAgICogJ2FsbW9zdCBhbHdheXMnIGlmIG5vdDpcclxuICAgICAqXHJcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIHJvdW5kaW5nIG1vZGUsIHRoZSByZXN1bHQgbWF5IGJlIGluY29ycmVjdGx5IHJvdW5kZWQgaWYgdGhlIGZpcnN0IGZpZnRlZW5cclxuICAgICAqIHJvdW5kaW5nIGRpZ2l0cyBhcmUgWzQ5XTk5OTk5OTk5OTk5OTk5IG9yIFs1MF0wMDAwMDAwMDAwMDAwMC4gSW4gdGhhdCBjYXNlLCB0aGUgbWF4aW11bSBlcnJvclxyXG4gICAgICogYmV0d2VlbiB0aGUgcmVzdWx0IGFuZCB0aGUgY29ycmVjdGx5IHJvdW5kZWQgcmVzdWx0IHdpbGwgYmUgb25lIHVscCAodW5pdCBpbiB0aGUgbGFzdCBwbGFjZSkuXHJcbiAgICAgKlxyXG4gICAgICogbG9nWy1iXShhKSAgICAgICA9IE5hTlxyXG4gICAgICogbG9nWzBdKGEpICAgICAgICA9IE5hTlxyXG4gICAgICogbG9nWzFdKGEpICAgICAgICA9IE5hTlxyXG4gICAgICogbG9nW05hTl0oYSkgICAgICA9IE5hTlxyXG4gICAgICogbG9nW0luZmluaXR5XShhKSA9IE5hTlxyXG4gICAgICogbG9nW2JdKDApICAgICAgICA9IC1JbmZpbml0eVxyXG4gICAgICogbG9nW2JdKC0wKSAgICAgICA9IC1JbmZpbml0eVxyXG4gICAgICogbG9nW2JdKC1hKSAgICAgICA9IE5hTlxyXG4gICAgICogbG9nW2JdKDEpICAgICAgICA9IDBcclxuICAgICAqIGxvZ1tiXShJbmZpbml0eSkgPSBJbmZpbml0eVxyXG4gICAgICogbG9nW2JdKE5hTikgICAgICA9IE5hTlxyXG4gICAgICpcclxuICAgICAqIFtiYXNlXSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgYmFzZSBvZiB0aGUgbG9nYXJpdGhtLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIGJhc2UuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBQWydsb2dhcml0aG0nXSA9IFBbJ2xvZyddID0gZnVuY3Rpb24gKCBiYXNlLCBiICkge1xyXG4gICAgICAgIHZhciBiYXNlMTAsIGMsIGRlbm9tLCBpLCBpbmYsIG51bSwgc2QsIHNkMTAsIHIsXHJcbiAgICAgICAgICAgIGFyZyA9IHRoaXMsXHJcbiAgICAgICAgICAgIERlY2ltYWwgPSBhcmdbJ2NvbnN0cnVjdG9yJ10sXHJcbiAgICAgICAgICAgIHByID0gRGVjaW1hbFsncHJlY2lzaW9uJ10sXHJcbiAgICAgICAgICAgIHJtID0gRGVjaW1hbFsncm91bmRpbmcnXSxcclxuICAgICAgICAgICAgZ3VhcmQgPSA1O1xyXG5cclxuICAgICAgICAvLyBEZWZhdWx0IGJhc2UgaXMgMTAuXHJcbiAgICAgICAgaWYgKCBiYXNlID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIGJhc2UgPSBuZXcgRGVjaW1hbCgxMCk7XHJcbiAgICAgICAgICAgIGJhc2UxMCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWQgPSAxNTtcclxuICAgICAgICAgICAgYmFzZSA9IG5ldyBEZWNpbWFsKCBiYXNlLCBiICk7XHJcbiAgICAgICAgICAgIGMgPSBiYXNlWydjJ107XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBiYXNlIDwgMCBvciArLUluZmluaXR5L05hTiBvciAwIG9yIDEuXHJcbiAgICAgICAgICAgIGlmICggYmFzZVsncyddIDwgMCB8fCAhYyB8fCAhY1swXSB8fCAhYmFzZVsnZSddICYmIGNbMF0gPT0gMSAmJiBjLmxlbmd0aCA9PSAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbChOYU4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJhc2UxMCA9IGJhc2VbJ2VxJ10oMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjID0gYXJnWydjJ107XHJcblxyXG4gICAgICAgIC8vIElmIGFyZyA8IDAgb3IgKy1JbmZpbml0eS9OYU4gb3IgMCBvciAxLlxyXG4gICAgICAgIGlmICggYXJnWydzJ10gPCAwIHx8ICFjIHx8ICFjWzBdIHx8ICFhcmdbJ2UnXSAmJiBjWzBdID09IDEgJiYgYy5sZW5ndGggPT0gMSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbCggYyAmJiAhY1swXSA/IC0xIC8gMCA6IGFyZ1sncyddICE9IDEgPyBOYU4gOiBjID8gMCA6IDEgLyAwICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAgVGhlIHJlc3VsdCB3aWxsIGhhdmUgYW4gaW5maW5pdGUgZGVjaW1hbCBleHBhbnNpb24gaWYgYmFzZSBpcyAxMCBhbmQgYXJnIGlzIG5vdCBhblxyXG4gICAgICAgICAgaW50ZWdlciBwb3dlciBvZiAxMC4uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluZiA9IGJhc2UxMCAmJiAoIGkgPSBjWzBdLCBjLmxlbmd0aCA+IDEgfHwgaSAhPSAxICYmIGkgIT0gMTAgJiZcclxuICAgICAgICAgIGkgIT0gMWUyICYmIGkgIT0gMWUzICYmIGkgIT0gMWU0ICYmIGkgIT0gMWU1ICYmIGkgIT0gMWU2ICk7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIC8vIG9yIGlmIGJhc2UgbGFzdCBkaWdpdCdzIGV2ZW5uZXNzIGlzIG5vdCB0aGUgc2FtZSBhcyBhcmcgbGFzdCBkaWdpdCdzIGV2ZW5uZXNzLi4uXHJcbiAgICAgICAgICAgIC8vIChGQUlMUyB3aGVuIGUuZy4gYmFzZS5jWzBdID0gMTAgYW5kIGNbMF0gPSAxKVxyXG4gICAgICAgICAgICB8fCAoIGJhc2VbJ2MnXVsgYmFzZVsnYyddLmxlbmd0aCAtIDEgXSAmIDEgKSAhPSAoIGNbIGMubGVuZ3RoIC0gMSBdICYgMSApXHJcbiAgICAgICAgICAgICAgLy8gb3IgaWYgYmFzZSBpcyAyIGFuZCB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIDEgaW4gYXJnIGluIGJhc2UgMi5cclxuICAgICAgICAgICAgICAvLyAoU0xPV1MgdGhlIG1ldGhvZCBkb3duIHNpZ25pZmljYW50bHkpXHJcbiAgICAgICAgICAgICAgfHwgYmFzZVsnZXEnXSgyKSAmJiBhcmcudG9TdHJpbmcoMikucmVwbGFjZSggL1teMV0rL2csICcnICkgIT0gJzEnO1xyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgICAgICBzZCA9IHByICsgZ3VhcmQ7XHJcbiAgICAgICAgc2QxMCA9IHNkICsgMTA7XHJcblxyXG4gICAgICAgIG51bSA9IGxuKCBhcmcsIHNkICk7XHJcblxyXG4gICAgICAgIGlmIChiYXNlMTApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggc2QxMCA+IExOMTAubGVuZ3RoICkge1xyXG4gICAgICAgICAgICAgICAgaWZFeGNlcHRpb25zVGhyb3coIERlY2ltYWwsIDEsIHNkMTAsICdsb2cnICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVub20gPSBuZXcgRGVjaW1hbCggTE4xMC5zbGljZSggMCwgc2QxMCApICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGVub20gPSBsbiggYmFzZSwgc2QgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSByZXN1bHQgd2lsbCBoYXZlIDUgcm91bmRpbmcgZGlnaXRzLlxyXG4gICAgICAgIHIgPSBkaXYoIG51bSwgZGVub20sIHNkLCAxICk7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIElmIGF0IGEgcm91bmRpbmcgYm91bmRhcnksIGkuZS4gdGhlIHJlc3VsdCdzIHJvdW5kaW5nIGRpZ2l0cyBhcmUgWzQ5XTk5OTkgb3IgWzUwXTAwMDAsXHJcbiAgICAgICAgIGNhbGN1bGF0ZSAxMCBmdXJ0aGVyIGRpZ2l0cy5cclxuXHJcbiAgICAgICAgIElmIHRoZSByZXN1bHQgaXMga25vd24gdG8gaGF2ZSBhbiBpbmZpbml0ZSBkZWNpbWFsIGV4cGFuc2lvbiwgcmVwZWF0IHRoaXMgdW50aWwgaXQgaXNcclxuICAgICAgICAgY2xlYXIgdGhhdCB0aGUgcmVzdWx0IGlzIGFib3ZlIG9yIGJlbG93IHRoZSBib3VuZGFyeS4gT3RoZXJ3aXNlLCBpZiBhZnRlciBjYWxjdWxhdGluZ1xyXG4gICAgICAgICB0aGUgMTAgZnVydGhlciBkaWdpdHMsIHRoZSBsYXN0IDE0IGFyZSBuaW5lcywgcm91bmQgdXAgYW5kIGFzc3VtZSB0aGUgcmVzdWx0IGlzIGV4YWN0LlxyXG4gICAgICAgICBBbHNvIGFzc3VtZSB0aGUgcmVzdWx0IGlzIGV4YWN0IGlmIHRoZSBsYXN0IDE0IGFyZSB6ZXJvLlxyXG5cclxuICAgICAgICAgRXhhbXBsZSBvZiBhIHJlc3VsdCB0aGF0IHdpbGwgYmUgaW5jb3JyZWN0bHkgcm91bmRlZDpcclxuICAgICAgICAgbG9nWzEwNDg1NzZdKDQ1MDM1OTk2MjczNzA1MDIpID0gMi42MDAwMDAwMDAwMDAwMDAwOTYxMDI3OTUxMTQ0NDc0Ni4uLlxyXG4gICAgICAgICBUaGUgYWJvdmUgcmVzdWx0IGNvcnJlY3RseSByb3VuZGVkIHVzaW5nIFJPVU5EX0NFSUwgdG8gMSBkZWNpbWFsIHBsYWNlIHNob3VsZCBiZSAyLjcsXHJcbiAgICAgICAgIGJ1dCBpdCB3aWxsIGJlIGdpdmVuIGFzIDIuNiBhcyB0aGVyZSBhcmUgMTUgemVyb3MgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHJlcXVlc3RlZFxyXG4gICAgICAgICBkZWNpbWFsIHBsYWNlLCBzbyB0aGUgZXhhY3QgcmVzdWx0IHdvdWxkIGJlIGFzc3VtZWQgdG8gYmUgMi42LCB3aGljaCByb3VuZGVkIHVzaW5nXHJcbiAgICAgICAgIFJPVU5EX0NFSUwgdG8gMSBkZWNpbWFsIHBsYWNlIGlzIHN0aWxsIDIuNi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoIGNoZWNrUm91bmRpbmdEaWdpdHMoIHJbJ2MnXSwgaSA9IHByLCBybSApICkge1xyXG5cclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgc2QgKz0gMTA7XHJcbiAgICAgICAgICAgICAgICBudW0gPSBsbiggYXJnLCBzZCApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiYXNlMTApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZDEwID0gc2QgKyAxMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZDEwID4gTE4xMC5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBEZWNpbWFsLCAxLCBzZDEwLCAnbG9nJyApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZW5vbSA9IG5ldyBEZWNpbWFsKCBMTjEwLnNsaWNlKCAwLCBzZDEwICkgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVub20gPSBsbiggYmFzZSwgc2QgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByID0gZGl2KCBudW0sIGRlbm9tLCBzZCwgMSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggIWluZiApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIDE0IG5pbmVzIGZyb20gdGhlIDJuZCByb3VuZGluZyBkaWdpdCwgYXMgdGhlIGZpcnN0IG1heSBiZSA0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggK2NvZWZmaWNpZW50VG9TdHJpbmcoIHJbJ2MnXSApLnNsaWNlKCBpICsgMSwgaSArIDE1ICkgKyAxID09IDFlMTQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBybmQoIHIsIHByICsgMSwgMCApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKCBjaGVja1JvdW5kaW5nRGlnaXRzKCByWydjJ10sIGkgKz0gMTAsIHJtICkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gcm5kKCByLCBwciwgcm0gKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAtIDAgPSBuXHJcbiAgICAgKiAgbiAtIE4gPSBOXHJcbiAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICogIDAgLSBuID0gLW5cclxuICAgICAqICAwIC0gMCA9IDBcclxuICAgICAqICAwIC0gTiA9IE5cclxuICAgICAqICAwIC0gSSA9IC1JXHJcbiAgICAgKiAgTiAtIG4gPSBOXHJcbiAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgKiAgTiAtIE4gPSBOXHJcbiAgICAgKiAgTiAtIEkgPSBOXHJcbiAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgKiAgSSAtIDAgPSBJXHJcbiAgICAgKiAgSSAtIE4gPSBOXHJcbiAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBtaW51cyBEZWNpbWFsKHksIGIpLCByb3VuZGVkXHJcbiAgICAgKiB0byBwcmVjaXNpb24gc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm91bmRpbmcuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBQWydtaW51cyddID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgIHZhciB0LCBpLCBqLCB4TFR5LFxyXG4gICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgRGVjaW1hbCA9IHhbJ2NvbnN0cnVjdG9yJ10sXHJcbiAgICAgICAgICAgIGEgPSB4WydzJ107XHJcblxyXG4gICAgICAgIGlkID0gODtcclxuICAgICAgICB5ID0gbmV3IERlY2ltYWwoIHksIGIgKTtcclxuICAgICAgICBiID0geVsncyddO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICAgIGlmICggIWEgfHwgIWIgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoTmFOKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICBpZiAoIGEgIT0gYiApIHtcclxuICAgICAgICAgICAgeVsncyddID0gLWI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geFsncGx1cyddKHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHhjID0geFsnYyddLFxyXG4gICAgICAgICAgICB5YyA9IHlbJ2MnXSxcclxuICAgICAgICAgICAgZSA9IG1hdGhmbG9vciggeVsnZSddIC8gTE9HQkFTRSApLFxyXG4gICAgICAgICAgICBrID0gbWF0aGZsb29yKCB4WydlJ10gLyBMT0dCQVNFICksXHJcbiAgICAgICAgICAgIHByID0gRGVjaW1hbFsncHJlY2lzaW9uJ10sXHJcbiAgICAgICAgICAgIHJtID0gRGVjaW1hbFsncm91bmRpbmcnXTtcclxuXHJcbiAgICAgICAgaWYgKCAhayB8fCAhZSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICAgICAgaWYgKCAheGMgfHwgIXljICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB4YyA/ICggeVsncyddID0gLWIsIHkgKSA6IG5ldyBEZWNpbWFsKCB5YyA/IHggOiBOYU4gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgICAgIGlmICggIXhjWzBdIHx8ICF5Y1swXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgICAgICAgIHggPSB5Y1swXSA/ICggeVsncyddID0gLWIsIHkgKSA6IG5ldyBEZWNpbWFsKCB4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgICBybSA9PSAzID8gLTAgOiAwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVybmFsID8gcm5kKCB4LCBwciwgcm0gKSA6IHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuICAgICAgICBpID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgIGlmICggYSA9IGsgLSBlICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB4TFR5ID0gYSA8IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgICAgICAgICBpID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZSA9IGs7XHJcbiAgICAgICAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggKCBrID0gTWF0aC5jZWlsKCBwciAvIExPR0JBU0UgKSApID4gaSApIHtcclxuICAgICAgICAgICAgICAgIGkgPSBrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgTnVtYmVycyB3aXRoIG1hc3NpdmVseSBkaWZmZXJlbnQgZXhwb25lbnRzIHdvdWxkIHJlc3VsdCBpbiBhIG1hc3NpdmUgbnVtYmVyIG9mXHJcbiAgICAgICAgICAgICB6ZXJvcyBuZWVkaW5nIHRvIGJlIHByZXBlbmRlZCwgYnV0IHRoaXMgY2FuIGJlIGF2b2lkZWQgd2hpbGUgc3RpbGwgZW5zdXJpbmcgY29ycmVjdFxyXG4gICAgICAgICAgICAgcm91bmRpbmcgYnkgbGltaXRpbmcgdGhlIG51bWJlciBvZiB6ZXJvcyB0byBtYXgoIHByZWNpc2lvbiwgaSApICsgMiwgd2hlcmUgcHIgaXNcclxuICAgICAgICAgICAgIHByZWNpc2lvbiBhbmQgaSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBjb2VmZmljaWVudCBvZiB3aGljaGV2ZXIgaXMgZ3JlYXRlciB4IG9yIHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAoIGEgPiAoIGkgKz0gMiApICkge1xyXG4gICAgICAgICAgICAgICAgYSA9IGk7XHJcbiAgICAgICAgICAgICAgICB0Lmxlbmd0aCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoIHQucmV2ZXJzZSgpLCBiID0gYTsgYi0tOyB0LnB1c2goMCkgKTtcclxuICAgICAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdHMuXHJcblxyXG4gICAgICAgICAgICBpZiAoIHhMVHkgPSBpIDwgKCBqID0geWMubGVuZ3RoICkgKSB7XHJcbiAgICAgICAgICAgICAgICBqID0gaTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICggYSA9IGIgPSAwOyBiIDwgajsgYisrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggeGNbYl0gIT0geWNbYl0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICAgIGlmICggeExUeSApIHtcclxuICAgICAgICAgICAgdCA9IHhjLCB4YyA9IHljLCB5YyA9IHQ7XHJcbiAgICAgICAgICAgIHlbJ3MnXSA9IC15WydzJ107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci4gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdGlvbiBvbmx5XHJcbiAgICAgICAgIG5lZWRzIHRvIHN0YXJ0IGF0IHljIGxlbmd0aC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoICggYiA9IC0oICggaiA9IHhjLmxlbmd0aCApIC0geWMubGVuZ3RoICkgKSA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCA7IGItLTsgeGNbaisrXSA9IDAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgICAgZm9yICggayA9IEJBU0UgLSAxLCBiID0geWMubGVuZ3RoOyBiID4gYTsgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHhjWy0tYl0gPCB5Y1tiXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gYjsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBrICk7XHJcbiAgICAgICAgICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgICAgICAgICAgeGNbYl0gKz0gQkFTRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4Y1tiXSAtPSB5Y1tiXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKCA7IHhjWy0tal0gPT0gMDsgeGMucG9wKCkgKTtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICBmb3IgKCA7IHhjWzBdID09IDA7IHhjLnNoaWZ0KCksIC0tZSApO1xyXG5cclxuICAgICAgICBpZiAoICF4Y1swXSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgIHhjID0gWyBlID0gMCBdO1xyXG5cclxuICAgICAgICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsIG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICAgICAgeVsncyddID0gcm0gPT0gMyA/IC0xIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHlbJ2MnXSA9IHhjO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgeGNbMF0uXHJcbiAgICAgICAgZm9yICggYSA9IDEsIGIgPSB4Y1swXTsgYiA+PSAxMDsgYiAvPSAxMCwgYSsrICk7XHJcbiAgICAgICAgeVsnZSddID0gYSArIGUgKiBMT0dCQVNFIC0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGV4dGVybmFsID8gcm5kKCB5LCBwciwgcm0gKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAqICAgbiAlIEkgPSAgblxyXG4gICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAqICAgMCAlIDAgPSAgTlxyXG4gICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAqICAgTiAlIG4gPSAgTlxyXG4gICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAqICAgTiAlIEkgPSAgTlxyXG4gICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAqICAgSSAlIE4gPSAgTlxyXG4gICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBtb2R1bG8gRGVjaW1hbCh5LCBiKSwgcm91bmRlZFxyXG4gICAgICogdG8gcHJlY2lzaW9uIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJvdW5kaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgbW9kdWxvIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBQWydtb2R1bG8nXSA9IFBbJ21vZCddID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgIHZhciBuLCBxLFxyXG4gICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgRGVjaW1hbCA9IHhbJ2NvbnN0cnVjdG9yJ10sXHJcbiAgICAgICAgICAgIG0gPSBEZWNpbWFsWydtb2R1bG8nXTtcclxuXHJcbiAgICAgICAgaWQgPSA5O1xyXG4gICAgICAgIHkgPSBuZXcgRGVjaW1hbCggeSwgYiApO1xyXG4gICAgICAgIGIgPSB5WydzJ107XHJcbiAgICAgICAgbiA9ICF4WydjJ10gfHwgIWIgfHwgeVsnYyddICYmICF5WydjJ11bMF07XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8sIGVsc2UgcmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eVxyXG4gICAgICAgICBvciB4IGlzIHplcm8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKCBuIHx8ICF5WydjJ10gfHwgeFsnYyddICYmICF4WydjJ11bMF0gKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gblxyXG4gICAgICAgICAgICAgID8gbmV3IERlY2ltYWwoTmFOKVxyXG4gICAgICAgICAgICAgIDogcm5kKCBuZXcgRGVjaW1hbCh4KSwgRGVjaW1hbFsncHJlY2lzaW9uJ10sIERlY2ltYWxbJ3JvdW5kaW5nJ10gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICggbSA9PSA5ICkge1xyXG5cclxuICAgICAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxyXG4gICAgICAgICAgICB5WydzJ10gPSAxO1xyXG4gICAgICAgICAgICBxID0gZGl2KCB4LCB5LCAwLCAzLCAxICk7XHJcbiAgICAgICAgICAgIHlbJ3MnXSA9IGI7XHJcbiAgICAgICAgICAgIHFbJ3MnXSAqPSBiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHEgPSBkaXYoIHgsIHksIDAsIG0sIDEgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBxWyd0aW1lcyddKHkpO1xyXG4gICAgICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHhbJ21pbnVzJ10ocSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsXHJcbiAgICAgKiByb3VuZGVkIHRvIHByZWNpc2lvbiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSByb3VuZGluZy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ25hdHVyYWxMb2dhcml0aG0nXSA9IFBbJ2xuJ10gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBsbih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIG5lZ2F0ZWQsIGkuZS4gYXMgaWZcclxuICAgICAqIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBQWyduZWdhdGVkJ10gPSBQWyduZWcnXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgeCA9IG5ldyB0aGlzWydjb25zdHJ1Y3RvciddKHRoaXMpO1xyXG4gICAgICAgIHhbJ3MnXSA9IC14WydzJ10gfHwgbnVsbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJuZCh4KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBwbHVzIERlY2ltYWwoeSwgYiksIHJvdW5kZWRcclxuICAgICAqIHRvIHByZWNpc2lvbiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSByb3VuZGluZy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ3BsdXMnXSA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICB2YXIgdCxcclxuICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgIERlY2ltYWwgPSB4Wydjb25zdHJ1Y3RvciddLFxyXG4gICAgICAgICAgICBhID0geFsncyddO1xyXG5cclxuICAgICAgICBpZCA9IDEwO1xyXG4gICAgICAgIHkgPSBuZXcgRGVjaW1hbCggeSwgYiApO1xyXG4gICAgICAgIGIgPSB5WydzJ107XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgICAgaWYgKCAhYSB8fCAhYiApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbChOYU4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgIGlmICggYSAhPSBiICkge1xyXG4gICAgICAgICAgICB5WydzJ10gPSAtYjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4WydtaW51cyddKHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHhjID0geFsnYyddLFxyXG4gICAgICAgICAgICB5YyA9IHlbJ2MnXSxcclxuICAgICAgICAgICAgZSA9IG1hdGhmbG9vciggeVsnZSddIC8gTE9HQkFTRSApLFxyXG4gICAgICAgICAgICBrID0gbWF0aGZsb29yKCB4WydlJ10gLyBMT0dCQVNFICksXHJcbiAgICAgICAgICAgIHByID0gRGVjaW1hbFsncHJlY2lzaW9uJ10sXHJcbiAgICAgICAgICAgIHJtID0gRGVjaW1hbFsncm91bmRpbmcnXTtcclxuXHJcbiAgICAgICAgaWYgKCAhayB8fCAhZSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICAgICAgaWYgKCAheGMgfHwgIXljICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldHVybiArLUluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKCBhIC8gMCApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAgICAgaWYgKCAheGNbMF0gfHwgIXljWzBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgICAgICAgeCA9IHljWzBdID8geTogbmV3IERlY2ltYWwoIHhjWzBdID8geCA6IGEgKiAwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVybmFsID8gcm5kKCB4LCBwciwgcm0gKSA6IHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIE5vdGU6IEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgICAgIGlmICggYSA9IGsgLSBlICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBhIDwgMCApIHtcclxuICAgICAgICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICAgICAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlID0gaztcclxuICAgICAgICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICAgICAgICAgIGIgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggKCBrID0gTWF0aC5jZWlsKCBwciAvIExPR0JBU0UgKSApID4gYiApIHtcclxuICAgICAgICAgICAgICAgIGIgPSBrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMaW1pdCBudW1iZXIgb2YgemVyb3MgcHJlcGVuZGVkIHRvIG1heCggcHIsIGIgKSArIDEuXHJcbiAgICAgICAgICAgIGlmICggYSA+ICsrYiApIHtcclxuICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgdC5sZW5ndGggPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB0LnJldmVyc2UoKTsgYS0tOyB0LnB1c2goMCkgKTtcclxuICAgICAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LlxyXG4gICAgICAgIGlmICggeGMubGVuZ3RoIC0geWMubGVuZ3RoIDwgMCApIHtcclxuICAgICAgICAgICAgdCA9IHljLCB5YyA9IHhjLCB4YyA9IHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgbGVmdCBhcyB0aGV5IGFyZS5cclxuICAgICAgICBmb3IgKCBhID0geWMubGVuZ3RoLCBiID0gMCwgayA9IEJBU0U7IGE7IHhjW2FdICU9IGsgKSB7XHJcbiAgICAgICAgICAgIGIgPSAoIHhjWy0tYV0gPSB4Y1thXSArIHljW2FdICsgYiApIC8gayB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICB4Yy51bnNoaWZ0KGIpO1xyXG4gICAgICAgICAgICArK2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICggYSA9IHhjLmxlbmd0aDsgeGNbLS1hXSA9PSAwOyB4Yy5wb3AoKSApO1xyXG5cclxuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcblxyXG4gICAgICAgIHlbJ2MnXSA9IHhjO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgeGNbMF0uXHJcbiAgICAgICAgZm9yICggYSA9IDEsIGIgPSB4Y1swXTsgYiA+PSAxMDsgYiAvPSAxMCwgYSsrICk7XHJcbiAgICAgICAgeVsnZSddID0gYSArIGUgKiBMT0dCQVNFIC0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGV4dGVybmFsID8gcm5kKCB5LCBwciwgcm0gKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgICAqXHJcbiAgICAgKiB6IHtib29sZWFufG51bWJlcn0gV2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUsIGZhbHNlLCAxIG9yIDAuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBQWydwcmVjaXNpb24nXSA9IFBbJ3NkJ10gPSBmdW5jdGlvbiAoeikge1xyXG4gICAgICAgIHZhciBuID0gbnVsbCxcclxuICAgICAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmICggeiAhPSBuICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCB6ICE9PSAhIXogJiYgeiAhPT0gMSAmJiB6ICE9PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICdwcmVjaXNpb24oKSBhcmd1bWVudCBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdDoge3p9J1xyXG4gICAgICAgICAgICAgICAgaWZFeGNlcHRpb25zVGhyb3coIHhbJ2NvbnN0cnVjdG9yJ10sICdhcmd1bWVudCcsIHosICdwcmVjaXNpb24nLCAxICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggeFsnYyddICkge1xyXG4gICAgICAgICAgICBuID0gZ2V0Q29lZmZMZW5ndGgoIHhbJ2MnXSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB6ICYmIHhbJ2UnXSArIDEgPiBuICkge1xyXG4gICAgICAgICAgICAgICAgbiA9IHhbJ2UnXSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBhIHdob2xlIG51bWJlciB1c2luZ1xyXG4gICAgICogcm91bmRpbmcgbW9kZSByb3VuZGluZy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ3JvdW5kJ10gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBEZWNpbWFsID0geFsnY29uc3RydWN0b3InXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJuZCggbmV3IERlY2ltYWwoeCksIHhbJ2UnXSArIDEsIERlY2ltYWxbJ3JvdW5kaW5nJ10gKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICogIHNxcnQoIE4pID0gIE5cclxuICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgKiAgc3FydCggSSkgPSAgSVxyXG4gICAgICogIHNxcnQoIDApID0gIDBcclxuICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoaXMgRGVjaW1hbCwgcm91bmRlZCB0byBwcmVjaXNpb25cclxuICAgICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJvdW5kaW5nLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUFsnc3F1YXJlUm9vdCddID0gUFsnc3FydCddID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtLCBuLCBzZCwgciwgcmVwLCB0LFxyXG4gICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgYyA9IHhbJ2MnXSxcclxuICAgICAgICAgICAgcyA9IHhbJ3MnXSxcclxuICAgICAgICAgICAgZSA9IHhbJ2UnXSxcclxuICAgICAgICAgICAgRGVjaW1hbCA9IHhbJ2NvbnN0cnVjdG9yJ10sXHJcbiAgICAgICAgICAgIGhhbGYgPSBuZXcgRGVjaW1hbCgwLjUpO1xyXG5cclxuICAgICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgICBpZiAoIHMgIT09IDEgfHwgIWMgfHwgIWNbMF0gKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoICFzIHx8IHMgPCAwICYmICggIWMgfHwgY1swXSApID8gTmFOIDogYyA/IHggOiAxIC8gMCApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgICBzID0gTWF0aC5zcXJ0KCAreCApO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAgICBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICggcyA9PSAwIHx8IHMgPT0gMSAvIDAgKSB7XHJcbiAgICAgICAgICAgIG4gPSBjb2VmZmljaWVudFRvU3RyaW5nKGMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCAoIG4ubGVuZ3RoICsgZSApICUgMiA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgbiArPSAnMCc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHMgPSBNYXRoLnNxcnQobik7XHJcbiAgICAgICAgICAgIGUgPSBtYXRoZmxvb3IoICggZSArIDEgKSAvIDIgKSAtICggZSA8IDAgfHwgZSAlIDIgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcyA9PSAxIC8gMCApIHtcclxuICAgICAgICAgICAgICAgIG4gPSAnMWUnICsgZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgICAgICAgIG4gPSBuLnNsaWNlKCAwLCBuLmluZGV4T2YoJ2UnKSArIDEgKSArIGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHIgPSBuZXcgRGVjaW1hbChuKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByID0gbmV3IERlY2ltYWwoIHMudG9TdHJpbmcoKSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2QgPSAoIGUgPSBEZWNpbWFsWydwcmVjaXNpb24nXSApICsgMztcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGZvciAoIDsgOyApIHtcclxuICAgICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICAgIHIgPSBoYWxmWyd0aW1lcyddKCB0WydwbHVzJ10oIGRpdiggeCwgdCwgc2QgKyAyLCAxICkgKSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjb2VmZmljaWVudFRvU3RyaW5nKCB0WydjJ10gKS5zbGljZSggMCwgc2QgKSA9PT1cclxuICAgICAgICAgICAgICAgICggbiA9IGNvZWZmaWNpZW50VG9TdHJpbmcoIHJbJ2MnXSApICkuc2xpY2UoIDAsIHNkICkgKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5zbGljZSggc2QgLSAzLCBzZCArIDEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0cyBhcmVcclxuICAgICAgICAgICAgICAgICA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKCBuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGUgZXhhY3QgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgIGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhcmVwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBybmQoIHQsIGUgKyAxLCAwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRbJ3RpbWVzJ10odClbJ2VxJ10oeCkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICBJZiB0aGUgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGFuIGV4YWN0IHJlc3VsdC5cclxuICAgICAgICAgICAgICAgICAgICAgSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBybmQoIHIsIGUgKyAxLCAxICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAhclsndGltZXMnXShyKVsnZXEnXSh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJuZCggciwgZSwgRGVjaW1hbFsncm91bmRpbmcnXSwgbSApO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICogMCA9IDBcclxuICAgICAqICBuICogTiA9IE5cclxuICAgICAqICBuICogSSA9IElcclxuICAgICAqICAwICogbiA9IDBcclxuICAgICAqICAwICogMCA9IDBcclxuICAgICAqICAwICogTiA9IE5cclxuICAgICAqICAwICogSSA9IE5cclxuICAgICAqICBOICogbiA9IE5cclxuICAgICAqICBOICogMCA9IE5cclxuICAgICAqICBOICogTiA9IE5cclxuICAgICAqICBOICogSSA9IE5cclxuICAgICAqICBJICogbiA9IElcclxuICAgICAqICBJICogMCA9IE5cclxuICAgICAqICBJICogTiA9IE5cclxuICAgICAqICBJICogSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGlzIERlY2ltYWwgdGltZXMgRGVjaW1hbCh5KSwgcm91bmRlZCB0byBwcmVjaXNpb25cclxuICAgICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJvdW5kaW5nLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUFsndGltZXMnXSA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICB2YXIgYywgZSxcclxuICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgIERlY2ltYWwgPSB4Wydjb25zdHJ1Y3RvciddLFxyXG4gICAgICAgICAgICB4YyA9IHhbJ2MnXSxcclxuICAgICAgICAgICAgeWMgPSAoIGlkID0gMTEsIHkgPSBuZXcgRGVjaW1hbCggeSwgYiApLCB5WydjJ10gKSxcclxuICAgICAgICAgICAgaSA9IG1hdGhmbG9vciggeFsnZSddIC8gTE9HQkFTRSApLFxyXG4gICAgICAgICAgICBqID0gbWF0aGZsb29yKCB5WydlJ10gLyBMT0dCQVNFICksXHJcbiAgICAgICAgICAgIGEgPSB4WydzJ107XHJcblxyXG4gICAgICAgIGIgPSB5WydzJ107XHJcblxyXG4gICAgICAgIHlbJ3MnXSA9IGEgPT0gYiA/IDEgOiAtMTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTi9JbmZpbml0eS8wP1xyXG4gICAgICAgIGlmICggIWkgJiYgKCAheGMgfHwgIXhjWzBdICkgfHwgIWogJiYgKCAheWMgfHwgIXljWzBdICkgKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoICFhIHx8ICFiIHx8XHJcblxyXG4gICAgICAgICAgICAgIC8vIHggaXMgMCBhbmQgeSBpcyBJbmZpbml0eSAgb3IgeSBpcyAwIGFuZCB4IGlzIEluZmluaXR5P1xyXG4gICAgICAgICAgICAgIHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Y1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldHVybiBOYU4uXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICAgICAgICAgIDogIXhjIHx8ICF5Y1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuICstSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAgICAgID8geVsncyddIC8gMFxyXG5cclxuICAgICAgICAgICAgICAgICAgLy8geCBvciB5IGlzIDAuIFJldHVybiArLTAuXHJcbiAgICAgICAgICAgICAgICAgIDogeVsncyddICogMCApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZSA9IGkgKyBqO1xyXG4gICAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKCBhIDwgYiApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFN3YXAuXHJcbiAgICAgICAgICAgIGMgPSB4YywgeGMgPSB5YywgeWMgPSBjO1xyXG4gICAgICAgICAgICBqID0gYSwgYSA9IGIsIGIgPSBqO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggaiA9IGEgKyBiLCBjID0gW107IGotLTsgYy5wdXNoKDApICk7XHJcblxyXG4gICAgICAgIC8vIE11bHRpcGx5IVxyXG4gICAgICAgIGZvciAoIGkgPSBiIC0gMTsgaSA+IC0xOyBpLS0gKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBiID0gMCwgaiA9IGEgKyBpOyBqID4gaTsgYiA9IGIgLyBCQVNFIHwgMCApIHtcclxuICAgICAgICAgICAgICAgICAgYiA9IGNbal0gKyB5Y1tpXSAqIHhjW2ogLSBpIC0gMV0gKyBiO1xyXG4gICAgICAgICAgICAgICAgICBjW2otLV0gPSBiICUgQkFTRSB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgICBjW2pdID0gKCBjW2pdICsgYiApICUgQkFTRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgKytlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBsZWFkaW5nIHplcm8uXHJcbiAgICAgICAgaWYgKCAhY1swXSApIHtcclxuICAgICAgICAgICAgYy5zaGlmdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoIGogPSBjLmxlbmd0aDsgIWNbLS1qXTsgYy5wb3AoKSApO1xyXG5cclxuICAgICAgICB5WydjJ10gPSBjO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICBmb3IgKCBhID0gMSwgYiA9IGNbMF07IGIgPj0gMTA7IGIgLz0gMTAsIGErKyApO1xyXG4gICAgICAgIHlbJ2UnXSA9IGEgKyBlICogTE9HQkFTRSAtIDE7XHJcblxyXG4gICAgICAgIHJldHVybiBleHRlcm5hbCA/IHJuZCggeSwgRGVjaW1hbFsncHJlY2lzaW9uJ10sIERlY2ltYWxbJ3JvdW5kaW5nJ10gKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcFxyXG4gICAgICogZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciByb3VuZGluZyBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIElmIGRwIGlzIG9taXR0ZWQsIHJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAndG9EUCgpIGRwIG91dCBvZiByYW5nZToge2RwfSdcclxuICAgICAqICd0b0RQKCkgZHAgbm90IGFuIGludGVnZXI6IHtkcH0nXHJcbiAgICAgKiAndG9EUCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAgICAgKiAndG9EUCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUFsndG9EZWNpbWFsUGxhY2VzJ10gPSBQWyd0b0RQJ10gPSBmdW5jdGlvbiAoIGRwLCBybSApIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXM7XHJcbiAgICAgICAgeCA9IG5ldyB4Wydjb25zdHJ1Y3RvciddKHgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZHAgPT0gbnVsbCB8fCAhY2hlY2tBcmcoIHgsIGRwLCAndG9EUCcgKVxyXG4gICAgICAgICAgPyB4XHJcbiAgICAgICAgICA6IHJuZCggeCwgKCBkcCB8IDAgKSArIHhbJ2UnXSArIDEsIGNoZWNrUk0oIHgsIHJtLCAndG9EUCcgKSApO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBleHBvbmVudGlhbCBub3RhdGlvbiByb3VuZGVkIHRvIGRwXHJcbiAgICAgKiBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJvdW5kaW5nLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogZXJyb3JzIHRydWU6IFRocm93IGlmIGRwIGFuZCBybSBhcmUgbm90IHVuZGVmaW5lZCwgbnVsbCBvciBpbnRlZ2VycyBpbiByYW5nZS5cclxuICAgICAqIGVycm9ycyBmYWxzZTogSWdub3JlIGRwIGFuZCBybSBpZiBub3QgbnVtYmVycyBvciBub3QgaW4gcmFuZ2UsIGFuZCB0cnVuY2F0ZSBub24taW50ZWdlcnMuXHJcbiAgICAgKlxyXG4gICAgICogJ3RvRXhwb25lbnRpYWwoKSBkcCBub3QgYW4gaW50ZWdlcjoge2RwfSdcclxuICAgICAqICd0b0V4cG9uZW50aWFsKCkgZHAgb3V0IG9mIHJhbmdlOiB7ZHB9J1xyXG4gICAgICogJ3RvRXhwb25lbnRpYWwoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICogJ3RvRXhwb25lbnRpYWwoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ3RvRXhwb25lbnRpYWwnXSA9IGZ1bmN0aW9uICggZHAsIHJtICkge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHhbJ2MnXVxyXG4gICAgICAgICAgPyBmb3JtYXQoIHgsIGRwICE9IG51bGwgJiYgY2hlY2tBcmcoIHgsIGRwLCAndG9FeHBvbmVudGlhbCcgKSA/IGRwIHwgMCA6IG51bGwsXHJcbiAgICAgICAgICAgIGRwICE9IG51bGwgJiYgY2hlY2tSTSggeCwgcm0sICd0b0V4cG9uZW50aWFsJyApLCAxIClcclxuICAgICAgICAgIDogeC50b1N0cmluZygpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBub3JtYWwgKGZpeGVkLXBvaW50KSBub3RhdGlvbiB0b1xyXG4gICAgICogZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgYW5kIHJvdW5kZWQgdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciByb3VuZGluZyBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGFzIHdpdGggSlMgbnVtYmVycywgKC0wKS50b0ZpeGVkKDApIGlzICcwJywgYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgLU1BWF9ESUdJVFMgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogZXJyb3JzIHRydWU6IFRocm93IGlmIGRwIGFuZCBybSBhcmUgbm90IHVuZGVmaW5lZCwgbnVsbCBvciBpbnRlZ2VycyBpbiByYW5nZS5cclxuICAgICAqIGVycm9ycyBmYWxzZTogSWdub3JlIGRwIGFuZCBybSBpZiBub3QgbnVtYmVycyBvciBub3QgaW4gcmFuZ2UsIGFuZCB0cnVuY2F0ZSBub24taW50ZWdlcnMuXHJcbiAgICAgKlxyXG4gICAgICogJ3RvRml4ZWQoKSBkcCBub3QgYW4gaW50ZWdlcjoge2RwfSdcclxuICAgICAqICd0b0ZpeGVkKCkgZHAgb3V0IG9mIHJhbmdlOiB7ZHB9J1xyXG4gICAgICogJ3RvRml4ZWQoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICogJ3RvRml4ZWQoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ3RvRml4ZWQnXSA9IGZ1bmN0aW9uICggZHAsIHJtICkge1xyXG4gICAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBEZWNpbWFsID0geFsnY29uc3RydWN0b3InXSxcclxuICAgICAgICAgICAgbmVnID0gRGVjaW1hbFsndG9FeHBOZWcnXSxcclxuICAgICAgICAgICAgcG9zID0gRGVjaW1hbFsndG9FeHBQb3MnXTtcclxuXHJcbiAgICAgICAgaWYgKCBkcCAhPSBudWxsICkge1xyXG4gICAgICAgICAgICBkcCA9IGNoZWNrQXJnKCB4LCBkcCwgc3RyID0gJ3RvRml4ZWQnICkgPyB4WydlJ10gKyAoIGRwIHwgMCApIDogbnVsbDtcclxuICAgICAgICAgICAgcm0gPSBjaGVja1JNKCB4LCBybSwgc3RyICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IHRvU3RyaW5nIHJldHVybmluZyBleHBvbmVudGlhbCBub3RhdGlvbjtcclxuICAgICAgICBEZWNpbWFsWyd0b0V4cE5lZyddID0gLSggRGVjaW1hbFsndG9FeHBQb3MnXSA9IDEgLyAwICk7XHJcblxyXG4gICAgICAgIGlmICggZHAgPT0gbnVsbCB8fCAheFsnYyddICkge1xyXG4gICAgICAgICAgICBzdHIgPSB4LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RyID0gZm9ybWF0KCB4LCBkcCwgcm0gKTtcclxuXHJcbiAgICAgICAgICAgIC8vICgtMCkudG9GaXhlZCgpIGlzICcwJywgYnV0ICgtMC4xKS50b0ZpeGVkKCkgaXMgJy0wJy5cclxuICAgICAgICAgICAgLy8gKC0wKS50b0ZpeGVkKDEpIGlzICcwLjAnLCBidXQgKC0wLjAxKS50b0ZpeGVkKDEpIGlzICctMC4wJy5cclxuICAgICAgICAgICAgaWYgKCB4WydzJ10gPCAwICYmIHhbJ2MnXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcyBlLmcuICgtMCkudG9GaXhlZCgzKSwgd2lsbCB3cm9uZ2x5IGJlIHJldHVybmVkIGFzIC0wLjAwMCBmcm9tIHRvU3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgaWYgKCAheFsnYyddWzBdICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCAnLScsICcnICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXMgZS5nLiAtMC41IGlmIHJvdW5kZWQgdG8gLTAgd2lsbCBjYXVzZSB0b1N0cmluZyB0byBvbWl0IHRoZSBtaW51cyBzaWduLlxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggc3RyLmluZGV4T2YoJy0nKSA8IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERlY2ltYWxbJ3RvRXhwTmVnJ10gPSBuZWc7XHJcbiAgICAgICAgRGVjaW1hbFsndG9FeHBQb3MnXSA9IHBvcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gbm9ybWFsIG5vdGF0aW9uIHJvdW5kZWQgdXNpbmdcclxuICAgICAqIHJvdW5kaW5nIG1vZGUgcm91bmRpbmcgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMsIHdpdGggdGhlIGludGVnZXIgcGFydCBvZiB0aGUgbnVtYmVyXHJcbiAgICAgKiBzZXBhcmF0ZWQgaW50byB0aG91c2FuZHMgYnkgc3RyaW5nIHNlcDEgb3IgJywnIGlmIHNlcDEgaXMgbnVsbCBvciB1bmRlZmluZWQsIGFuZCB0aGVcclxuICAgICAqIGZyYWN0aW9uIHBhcnQgc2VwYXJhdGVkIGludG8gZ3JvdXBzIG9mIGZpdmUgZGlnaXRzIGJ5IHN0cmluZyBzZXAyLlxyXG4gICAgICpcclxuICAgICAqIFtzZXAxXSB7c3RyaW5nfSBUaGUgZ3JvdXBpbmcgc2VwYXJhdG9yIG9mIHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIG51bWJlci5cclxuICAgICAqIFtzZXAyXSB7c3RyaW5nfSBUaGUgZ3JvdXBpbmcgc2VwYXJhdG9yIG9mIHRoZSBmcmFjdGlvbiBwYXJ0IG9mIHRoZSBudW1iZXIuXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAtTUFYX0RJR0lUUyB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiBOb24tYnJlYWtpbmcgdGhpbi1zcGFjZTogXFx1MjAyZlxyXG4gICAgICpcclxuICAgICAqIElmIGRwIGlzIGludmFsaWQgdGhlIGVycm9yIG1lc3NhZ2Ugd2lsbCBpbmNvcnJlY3RseSBnaXZlIHRoZSBtZXRob2QgYXMgdG9GaXhlZC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ3RvRm9ybWF0J10gPSBmdW5jdGlvbiAoIHNlcDEsIGRwLCBzZXAyICkge1xyXG4gICAgICAgIHZhciBhcnIgPSB0aGlzLnRvRml4ZWQoZHApLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJbMF0ucmVwbGFjZSggL1xcQig/PShcXGR7M30pKyQpL2csIHNlcDEgPT0gbnVsbCA/ICcsJyA6IHNlcDEgKyAnJyApICtcclxuICAgICAgICAgICAgKCBhcnJbMV0gPyAnLicgKyAoIHNlcDIgPyBhcnJbMV0ucmVwbGFjZSggL1xcZHs1fVxcQi9nLCAnJCYnICsgc2VwMiApIDogYXJyWzFdICkgOiAnJyApO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyBhcnJheSByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBhcyBhIHNpbXBsZSBmcmFjdGlvbiB3aXRoIGFuXHJcbiAgICAgKiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogW21heERdIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IE1heGltdW0gZGVub21pbmF0b3IuIEludGVnZXIgPj0gMSBhbmQgPCBJbmZpbml0eS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ3RvRnJhY3Rpb24nXSA9IGZ1bmN0aW9uIChtYXhEKSB7XHJcbiAgICAgICAgdmFyIGQwLCBkMiwgZSwgZnJhYywgbiwgbjAsIHAsIHEsXHJcbiAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBEZWNpbWFsID0geFsnY29uc3RydWN0b3InXSxcclxuICAgICAgICAgICAgbjEgPSBkMCA9IG5ldyBEZWNpbWFsKCBEZWNpbWFsWydPTkUnXSApLFxyXG4gICAgICAgICAgICBkMSA9IG4wID0gbmV3IERlY2ltYWwoMCksXHJcbiAgICAgICAgICAgIHhjID0geFsnYyddLFxyXG4gICAgICAgICAgICBkID0gbmV3IERlY2ltYWwoZDEpO1xyXG5cclxuICAgICAgICAvLyBOYU4sIEluZmluaXR5LlxyXG4gICAgICAgIGlmICggIXhjICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGUgPSBkWydlJ10gPSBnZXRDb2VmZkxlbmd0aCh4YykgLSB4WydlJ10gLSAxO1xyXG4gICAgICAgIGRbJ2MnXVswXSA9IG1hdGhwb3coIDEwLCAoIHAgPSBlICUgTE9HQkFTRSApIDwgMCA/IExPR0JBU0UgKyBwIDogcCApO1xyXG5cclxuICAgICAgICAvLyBJZiBtYXhEIGlzIHVuZGVmaW5lZCBvciBudWxsLi4uXHJcbiAgICAgICAgaWYgKCBtYXhEID09IG51bGwgfHxcclxuXHJcbiAgICAgICAgICAgICAvLyBvciBOYU4uLi5cclxuICAgICAgICAgICAgICggISggaWQgPSAxMiwgbiA9IG5ldyBEZWNpbWFsKG1heEQpIClbJ3MnXSB8fFxyXG5cclxuICAgICAgICAgICAgICAgLy8gb3IgbGVzcyB0aGFuIDEsIG9yIEluZmluaXR5Li4uXHJcbiAgICAgICAgICAgICAgICggb3V0T2ZSYW5nZSA9IG5bJ2NtcCddKG4xKSA8IDAgfHwgIW5bJ2MnXSApIHx8XHJcblxyXG4gICAgICAgICAgICAgICAgIC8vIG9yIG5vdCBhbiBpbnRlZ2VyLi4uXHJcbiAgICAgICAgICAgICAgICAgKCBEZWNpbWFsWydlcnJvcnMnXSAmJiBtYXRoZmxvb3IoIG5bJ2UnXSAvIExPR0JBU0UgKSA8IG5bJ2MnXS5sZW5ndGggLSAxICkgKSAmJlxyXG5cclxuICAgICAgICAgICAgICAgICAgIC8vICd0b0ZyYWN0aW9uKCkgbWF4IGRlbm9taW5hdG9yIG5vdCBhbiBpbnRlZ2VyOiB7bWF4RH0nXHJcbiAgICAgICAgICAgICAgICAgICAvLyAndG9GcmFjdGlvbigpIG1heCBkZW5vbWluYXRvciBvdXQgb2YgcmFuZ2U6IHttYXhEfSdcclxuICAgICAgICAgICAgICAgICAgICFpZkV4Y2VwdGlvbnNUaHJvdyggRGVjaW1hbCwgJ21heCBkZW5vbWluYXRvcicsIG1heEQsICd0b0ZyYWN0aW9uJywgMCApIHx8XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAvLyBvciBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gZGVub21pbmF0b3IgbmVlZGVkIHRvIHNwZWNpZnkgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICggbWF4RCA9IG4gKVsnY21wJ10oZCkgPiAwICkge1xyXG5cclxuICAgICAgICAgICAgLy8gZCBpcyAxMCoqZSwgbjEgaXMgMS5cclxuICAgICAgICAgICAgbWF4RCA9IGUgPiAwID8gZCA6IG4xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgICAgICBuID0gbmV3IERlY2ltYWwoIGNvZWZmaWNpZW50VG9TdHJpbmcoeGMpICk7XHJcbiAgICAgICAgcCA9IERlY2ltYWxbJ3ByZWNpc2lvbiddO1xyXG4gICAgICAgIERlY2ltYWxbJ3ByZWNpc2lvbiddID0gZSA9IHhjLmxlbmd0aCAqIExPR0JBU0UgKiAyO1xyXG5cclxuICAgICAgICBmb3IgKCA7IDsgKSAge1xyXG4gICAgICAgICAgICBxID0gZGl2KCBuLCBkLCAwLCAxLCAxICk7XHJcbiAgICAgICAgICAgIGQyID0gZDBbJ3BsdXMnXSggcVsndGltZXMnXShkMSkgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZDJbJ2NtcCddKG1heEQpID09IDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZDAgPSBkMSwgZDEgPSBkMjtcclxuXHJcbiAgICAgICAgICAgIG4xID0gbjBbJ3BsdXMnXSggcVsndGltZXMnXSggZDIgPSBuMSApICk7XHJcbiAgICAgICAgICAgIG4wID0gZDI7XHJcblxyXG4gICAgICAgICAgICBkID0gblsnbWludXMnXSggcVsndGltZXMnXSggZDIgPSBkICkgKTtcclxuICAgICAgICAgICAgbiA9IGQyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZDIgPSBkaXYoIG1heERbJ21pbnVzJ10oZDApLCBkMSwgMCwgMSwgMSApO1xyXG4gICAgICAgIG4wID0gbjBbJ3BsdXMnXSggZDJbJ3RpbWVzJ10objEpICk7XHJcbiAgICAgICAgZDAgPSBkMFsncGx1cyddKCBkMlsndGltZXMnXShkMSkgKTtcclxuICAgICAgICBuMFsncyddID0gbjFbJ3MnXSA9IHhbJ3MnXTtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMT9cclxuICAgICAgICBmcmFjID0gZGl2KCBuMSwgZDEsIGUsIDEgKVsnbWludXMnXSh4KVsnYWJzJ10oKVsnY21wJ10oXHJcbiAgICAgICAgICAgICAgIGRpdiggbjAsIGQwLCBlLCAxIClbJ21pbnVzJ10oeClbJ2FicyddKCkgKSA8IDFcclxuICAgICAgICAgID8gWyBuMSArICcnLCBkMSArICcnIF1cclxuICAgICAgICAgIDogWyBuMCArICcnLCBkMCArICcnIF07XHJcblxyXG4gICAgICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuICAgICAgICBEZWNpbWFsWydwcmVjaXNpb24nXSA9IHA7XHJcblxyXG4gICAgICAgIHJldHVybiBmcmFjO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybnMgYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmVhcmVzdCBtdWx0aXBsZSBvZiB0aGUgbWFnbml0dWRlIG9mIG4gdG8gdGhlIHZhbHVlXHJcbiAgICAgKiBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBlcXVpZGlzdGFudCBmcm9tIHR3byBtdWx0aXBsZXMgb2YgbiwgdGhlIHJvdW5kaW5nIG1vZGUgcm0sXHJcbiAgICAgKiBvciByb3VuZGluZyBpZiBybSBpcyBvbWl0dGVkIG9yIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBkZXRlcm1pbmVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlXHJcbiAgICAgKiBuZWFyZXN0IG11bHRpcGxlLlxyXG4gICAgICpcclxuICAgICAqIEluIHRoZSBjb250ZXh0IG9mIHRoaXMgbWV0aG9kLCByb3VuZGluZyBtb2RlIDQgKFJPVU5EX0hBTEZfVVApIGlzIHRoZSBzYW1lIGFzIHJvdW5kaW5nIG1vZGUgMFxyXG4gICAgICogKFJPVU5EX1VQKSwgYW5kIHNvIG9uLlxyXG4gICAgICpcclxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBhbHdheXMgaGF2ZSB0aGUgc2FtZSBzaWduIGFzIHRoaXMgRGVjaW1hbCwgdW5sZXNzIGVpdGhlciB0aGlzIERlY2ltYWxcclxuICAgICAqIG9yIG4gaXMgTmFOLCBpbiB3aGljaCBjYXNlIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBhbHNvIGJlIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGlzIG5vdCByb3VuZGVkIHRvIHByZWNpc2lvbiBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbiB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgbWFnbml0dWRlIHRvIHJvdW5kIHRvIGEgbXVsdGlwbGUgb2YuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ3RvTmVhcmVzdCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAgICAgKiAndG9OZWFyZXN0KCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBQWyd0b05lYXJlc3QnXSA9IGZ1bmN0aW9uICggbiwgcm0gKSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBEZWNpbWFsID0geFsnY29uc3RydWN0b3InXTtcclxuXHJcbiAgICAgICAgeCA9IG5ldyBEZWNpbWFsKHgpO1xyXG5cclxuICAgICAgICBpZiAoIG4gPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgbiA9IG5ldyBEZWNpbWFsKCBEZWNpbWFsWydPTkUnXSApO1xyXG4gICAgICAgICAgICBybSA9IERlY2ltYWxbJ3JvdW5kaW5nJ107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWQgPSAxNztcclxuICAgICAgICAgICAgbiA9IG5ldyBEZWNpbWFsKG4pO1xyXG4gICAgICAgICAgICBybSA9IGNoZWNrUk0oIHgsIHJtLCAndG9OZWFyZXN0JyApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgbiBpcyBmaW5pdGUuLi5cclxuICAgICAgICBpZiAoIG5bJ2MnXSApIHtcclxuXHJcbiAgICAgICAgICAgLy8gSWYgeCBpcyBmaW5pdGUuLi5cclxuICAgICAgICAgICAgaWYgKCB4WydjJ10gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBuWydjJ11bMF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gZGl2KCB4LCBuLCAwLCBybSA8IDQgPyBbNCwgNSwgNywgOF1bcm1dIDogcm0sIDEgKVsndGltZXMnXShuKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcm5kKHgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4WydjJ10gPSBbIHhbJ2UnXSA9IDAgXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBuIGlzIE5hTiBvciArLUluZmluaXR5LiBJZiB4IGlzIG5vdCBOYU4uLi5cclxuICAgICAgICB9IGVsc2UgaWYgKCB4WydzJ10gKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBuIGlzICstSW5maW5pdHkuLi5cclxuICAgICAgICAgICAgaWYgKCBuWydzJ10gKSB7XHJcbiAgICAgICAgICAgICAgICBuWydzJ10gPSB4WydzJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeCA9IG47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUFsndG9OdW1iZXInXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSB6ZXJvIGhhcyBjb3JyZWN0IHNpZ24uXHJcbiAgICAgICAgcmV0dXJuICt4IHx8ICggeFsncyddID8gMCAqIHhbJ3MnXSA6IE5hTiApO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcmFpc2VkIHRvIHRoZSBwb3dlclxyXG4gICAgICogRGVjaW1hbCh5LCBiKSwgcm91bmRlZCB0byBwcmVjaXNpb24gc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm91bmRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogRUNNQVNjcmlwdCBjb21wbGlhbnQuXHJcbiAgICAgKlxyXG4gICAgICogICB4IGlzIGFueSB2YWx1ZSwgaW5jbHVkaW5nIE5hTi5cclxuICAgICAqICAgbiBpcyBhbnkgbnVtYmVyLCBpbmNsdWRpbmcg77+9SW5maW5pdHkgdW5sZXNzIHN0YXRlZC5cclxuICAgICAqXHJcbiAgICAgKiAgIHBvdyggeCwgTmFOICkgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE5hTlxyXG4gICAgICogICBwb3coIHgsIO+/vTAgKSAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDFcclxuXHJcbiAgICAgKiAgIHBvdyggTmFOLCBub256ZXJvICkgICAgICAgICAgICAgICAgICAgICA9IE5hTlxyXG4gICAgICogICBwb3coIGFicyhuKSA+IDEsICtJbmZpbml0eSApICAgICAgICAgICAgPSArSW5maW5pdHlcclxuICAgICAqICAgcG93KCBhYnMobikgPiAxLCAtSW5maW5pdHkgKSAgICAgICAgICAgID0gKzBcclxuICAgICAqICAgcG93KCBhYnMobikgPT0gMSwg77+9SW5maW5pdHkgKSAgICAgICAgICAgPSBOYU5cclxuICAgICAqICAgcG93KCBhYnMobikgPCAxLCArSW5maW5pdHkgKSAgICAgICAgICAgID0gKzBcclxuICAgICAqICAgcG93KCBhYnMobikgPCAxLCAtSW5maW5pdHkgKSAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAgICAgKiAgIHBvdyggK0luZmluaXR5LCBuID4gMCApICAgICAgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gICAgICogICBwb3coICtJbmZpbml0eSwgbiA8IDAgKSAgICAgICAgICAgICAgICAgPSArMFxyXG4gICAgICogICBwb3coIC1JbmZpbml0eSwgb2RkIGludGVnZXIgPiAwICkgICAgICAgPSAtSW5maW5pdHlcclxuICAgICAqICAgcG93KCAtSW5maW5pdHksIGV2ZW4gaW50ZWdlciA+IDAgKSAgICAgID0gK0luZmluaXR5XHJcbiAgICAgKiAgIHBvdyggLUluZmluaXR5LCBvZGQgaW50ZWdlciA8IDAgKSAgICAgICA9IC0wXHJcbiAgICAgKiAgIHBvdyggLUluZmluaXR5LCBldmVuIGludGVnZXIgPCAwICkgICAgICA9ICswXHJcbiAgICAgKiAgIHBvdyggKzAsIG4gPiAwICkgICAgICAgICAgICAgICAgICAgICAgICA9ICswXHJcbiAgICAgKiAgIHBvdyggKzAsIG4gPCAwICkgICAgICAgICAgICAgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gICAgICogICBwb3coIC0wLCBvZGQgaW50ZWdlciA+IDAgKSAgICAgICAgICAgICAgPSAtMFxyXG4gICAgICogICBwb3coIC0wLCBldmVuIGludGVnZXIgPiAwICkgICAgICAgICAgICAgPSArMFxyXG4gICAgICogICBwb3coIC0wLCBvZGQgaW50ZWdlciA8IDAgKSAgICAgICAgICAgICAgPSAtSW5maW5pdHlcclxuICAgICAqICAgcG93KCAtMCwgZXZlbiBpbnRlZ2VyIDwgMCApICAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAgICAgKiAgIHBvdyggZmluaXRlIG4gPCAwLCBmaW5pdGUgbm9uLWludGVnZXIgKSA9IE5hTlxyXG4gICAgICpcclxuICAgICAqIEZvciBub24taW50ZWdlciBhbmQgbGFyZ2VyIGV4cG9uZW50cyBwb3coeCwgeSkgaXMgY2FsY3VsYXRlZCB1c2luZ1xyXG4gICAgICpcclxuICAgICAqICAgeF55ID0gZXhwKHkqbG4oeCkpXHJcbiAgICAgKlxyXG4gICAgICogQXNzdW1pbmcgdGhlIGZpcnN0IDE1IHJvdW5kaW5nIGRpZ2l0cyBhcmUgZWFjaCBlcXVhbGx5IGxpa2VseSB0byBiZSBhbnkgZGlnaXQgMC05LCB0aGVcclxuICAgICAqIHByb2JhYmlsaXR5IG9mIGFuIGluY29ycmVjdGx5IHJvdW5kZWQgcmVzdWx0XHJcbiAgICAgKiBQKCBbNDldOXsxNH0gfCBbNTBdMHsxNH0gKSA9IDIgKiAwLjIgKiAxMF4tMTQgPSA0ZS0xNSA9IDEvMi41ZSsxNFxyXG4gICAgICogaS5lLiAxIGluIDI1MCwwMDAsMDAwLDAwMCwwMDBcclxuICAgICAqXHJcbiAgICAgKiBJZiBhIHJlc3VsdCBpcyBpbmNvcnJlY3RseSByb3VuZGVkIHRoZSBtYXhpbXVtIGVycm9yIHdpbGwgYmUgMSB1bHAgKHVuaXQgaW4gbGFzdCBwbGFjZSkuXHJcbiAgICAgKlxyXG4gICAgICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgcG93ZXIgdG8gd2hpY2ggdG8gcmFpc2UgdGhpcyBEZWNpbWFsLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHkuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBQWyd0b1Bvd2VyJ10gPSBQWydwb3cnXSA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICB2YXIgYSwgZSwgbiwgcixcclxuICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgIERlY2ltYWwgPSB4Wydjb25zdHJ1Y3RvciddLFxyXG4gICAgICAgICAgICBzID0geFsncyddLFxyXG4gICAgICAgICAgICB5TiA9ICsoIGlkID0gMTMsIHkgPSBuZXcgRGVjaW1hbCggeSwgYiApICksXHJcbiAgICAgICAgICAgIGkgPSB5TiA8IDAgPyAteU4gOiB5TixcclxuICAgICAgICAgICAgcHIgPSBEZWNpbWFsWydwcmVjaXNpb24nXSxcclxuICAgICAgICAgICAgcm0gPSBEZWNpbWFsWydyb3VuZGluZyddO1xyXG5cclxuICAgICAgICAvLyBIYW5kbGUgKy1JbmZpbml0eSwgTmFOIGFuZCArLTAuXHJcbiAgICAgICAgaWYgKCAheFsnYyddIHx8ICF5WydjJ10gfHwgKCBuID0gIXhbJ2MnXVswXSApIHx8ICF5WydjJ11bMF0gKSB7XHJcblxyXG4gICAgICAgICAgICAvLyB2YWx1ZU9mIC0wIGlzIDAsIHNvIGNoZWNrIGZvciAwIHRoZW4gbXVsdGlwbHkgaXQgYnkgdGhlIHNpZ24uXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbCggbWF0aHBvdyggbiA/IHMgKiAwIDogK3gsIHlOICkgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSBuZXcgRGVjaW1hbCh4KTtcclxuICAgICAgICBhID0geFsnYyddLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gaWYgeCA9PSAxXHJcbiAgICAgICAgaWYgKCAheFsnZSddICYmIHhbJ2MnXVswXSA9PSB4WydzJ10gJiYgYSA9PSAxICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBiID0geVsnYyddLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgIC8vIGlmIHkgPT0gMVxyXG4gICAgICAgIGlmICggIXlbJ2UnXSAmJiB5WydjJ11bMF0gPT0geVsncyddICYmICFiICkge1xyXG4gICAgICAgICAgICByID0gcm5kKCB4LCBwciwgcm0gKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlID0gbWF0aGZsb29yKCB5WydlJ10gLyBMT0dCQVNFICk7XHJcbiAgICAgICAgICAgIG4gPSBlID49IGI7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB5IGlzIG5vdCBhbiBpbnRlZ2VyIGFuZCB4IGlzIG5lZ2F0aXZlLCByZXR1cm4gTmFOLlxyXG4gICAgICAgICAgICBpZiAoICFuICYmIHMgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgciA9IG5ldyBEZWNpbWFsKE5hTik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICBJZiB0aGUgYXBwcm94aW1hdGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB4IG11bHRpcGxpZWQgYnkgYWJzKHkpIGlzIGxlc3NcclxuICAgICAgICAgICAgICAgICB0aGFuIElOVF9QT1dfTElNSVQgdXNlIHRoZSAnZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcnIGFsZ29yaXRobS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKCBuICYmIGEgKiBMT0dCQVNFICogaSA8IElOVF9QT1dfTElNSVQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IGludFBvdyggRGVjaW1hbCwgeCwgaSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHlbJ3MnXSA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjaW1hbFsnT05FJ11bJ2RpdiddKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3VsdCBpcyBuZWdhdGl2ZSBpZiB4IGlzIG5lZ2F0aXZlIGFuZCB0aGUgbGFzdCBkaWdpdCBvZiBpbnRlZ2VyIHkgaXMgb2RkLlxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBzIDwgMCAmJiB5WydjJ11bIE1hdGgubWF4KCBlLCBiICkgXSAmIDEgPyAtMSA6IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBtYXRocG93KCAreCwgeU4gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgRXN0aW1hdGUgcmVzdWx0IGV4cG9uZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICB4XnkgPSAxMF5lLCAgd2hlcmUgZSA9IHkgKiBsb2cxMCh4KVxyXG4gICAgICAgICAgICAgICAgICAgICBsb2cxMCh4KSA9IGxvZzEwKHhfc2lnbmlmaWNhbmQpICsgeF9leHBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICBsb2cxMCh4X3NpZ25pZmljYW5kKSA9IGxuKHhfc2lnbmlmaWNhbmQpIC8gbG4oMTApXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IGIgPT0gMCB8fCAhaXNGaW5pdGUoYilcclxuICAgICAgICAgICAgICAgICAgICAgID8gbWF0aGZsb29yKCB5TiAqIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5sb2coICcwLicgKyBjb2VmZmljaWVudFRvU3RyaW5nKCB4WydjJ10gKSApIC8gTWF0aC5MTjEwICsgeFsnZSddICsgMSApIClcclxuICAgICAgICAgICAgICAgICAgICAgIDogbmV3IERlY2ltYWwoIGIgKyAnJyApWydlJ107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVzdGltYXRlIG1heSBiZSBpbmNvcnJlY3QgZS5nLjogeDogMC45OTk5OTk5OTk5OTk5OTk5OTksIHk6IDIuMjksIGU6IDAsIHIuZTotMVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPdmVyZmxvdy91bmRlcmZsb3c/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlID4gRGVjaW1hbFsnbWF4RSddICsgMSB8fCBlIDwgRGVjaW1hbFsnbWluRSddIC0gMSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbCggZSA+IDAgPyBzIC8gMCA6IDAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVjaW1hbFsncm91bmRpbmcnXSA9IHhbJ3MnXSA9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgIEVzdGltYXRlIGV4dHJhIGRpZ2l0cyBuZWVkZWQgZnJvbSBsbih4KSB0byBlbnN1cmUgZml2ZSBjb3JyZWN0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAgICAgICAgICBpbiByZXN1bHQgKGkgd2FzIHVubmVjZXNzYXJ5IGJlZm9yZSBtYXggZXhwb25lbnQgd2FzIGV4dGVuZGVkPykuXHJcbiAgICAgICAgICAgICAgICAgICAgIEV4YW1wbGUgb2YgZmFpbHVyZSBiZWZvcmUgaSB3YXMgaW50cm9kdWNlZDogKHByZWNpc2lvbjogMTApLFxyXG4gICAgICAgICAgICAgICAgICAgICBuZXcgRGVjaW1hbCgyLjMyNDU2KS5wb3coJzIwODc5ODc0MzY1MzQ1NjYuNDY0MTEnKVxyXG4gICAgICAgICAgICAgICAgICAgICBzaG91bGQgYmUgMS4xNjIzNzc4MjNlKzc2NDkxNDkwNTE3MzgxNSwgYnV0IGlzIDEuMTYyMzU1ODIzZSs3NjQ5MTQ5MDUxNzM4MTVcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBpID0gTWF0aC5taW4oIDEyLCAoIGUgKyAnJyApLmxlbmd0aCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyByID0geF55ID0gZXhwKHkqbG4oeCkpXHJcbiAgICAgICAgICAgICAgICAgICAgciA9IGV4cCggeVsndGltZXMnXSggbG4oIHgsIHByICsgaSApICksIHByICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSByZXF1aXJlZCBwcmVjaXNpb24gcGx1cyBmaXZlIHJvdW5kaW5nIGRpZ2l0cy5cclxuICAgICAgICAgICAgICAgICAgICByID0gcm5kKCByLCBwciArIDUsIDEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgSWYgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhcmUgWzQ5XTk5OTkgb3IgWzUwXTAwMDAgaW5jcmVhc2UgdGhlIHByZWNpc2lvbiBieSAxMFxyXG4gICAgICAgICAgICAgICAgICAgICBhbmQgcmVjYWxjdWxhdGUgdGhlIHJlc3VsdC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNoZWNrUm91bmRpbmdEaWdpdHMoIHJbJ2MnXSwgcHIsIHJtICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBwciArIDEwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGluY3JlYXNlZCBwcmVjaXNpb24gcGx1cyBmaXZlIHJvdW5kaW5nIGRpZ2l0cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHJuZCggZXhwKCB5Wyd0aW1lcyddKCBsbiggeCwgZSArIGkgKSApLCBlICksIGUgKyA1LCAxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIENoZWNrIGZvciAxNCBuaW5lcyBmcm9tIHRoZSAybmQgcm91bmRpbmcgZGlnaXQgKHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1heSBiZSA0IG9yIDkpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCArY29lZmZpY2llbnRUb1N0cmluZyggclsnYyddICkuc2xpY2UoIHByICsgMSwgcHIgKyAxNSApICsgMSA9PSAxZTE0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHJuZCggciwgcHIgKyAxLCAwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJbJ3MnXSA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIERlY2ltYWxbJ3JvdW5kaW5nJ10gPSBybTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByID0gcm5kKCByLCBwciwgcm0gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJvdW5kaW5nLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudFxyXG4gICAgICogdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gbm9ybWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiBlcnJvcnMgdHJ1ZTogVGhyb3cgaWYgc2QgYW5kIHJtIGFyZSBub3QgdW5kZWZpbmVkLCBudWxsIG9yIGludGVnZXJzIGluIHJhbmdlLlxyXG4gICAgICogZXJyb3JzIGZhbHNlOiBJZ25vcmUgc2QgYW5kIHJtIGlmIG5vdCBudW1iZXJzIG9yIG5vdCBpbiByYW5nZSwgYW5kIHRydW5jYXRlIG5vbi1pbnRlZ2Vycy5cclxuICAgICAqXHJcbiAgICAgKiAndG9QcmVjaXNpb24oKSBzZCBub3QgYW4gaW50ZWdlcjoge3NkfSdcclxuICAgICAqICd0b1ByZWNpc2lvbigpIHNkIG91dCBvZiByYW5nZToge3NkfSdcclxuICAgICAqICd0b1ByZWNpc2lvbigpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAgICAgKiAndG9QcmVjaXNpb24oKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ3RvUHJlY2lzaW9uJ10gPSBmdW5jdGlvbiAoIHNkLCBybSApIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBzZCAhPSBudWxsICYmIGNoZWNrQXJnKCB4LCBzZCwgJ3RvUHJlY2lzaW9uJywgMSApICYmIHhbJ2MnXVxyXG4gICAgICAgICAgPyBmb3JtYXQoIHgsIC0tc2QgfCAwLCBjaGVja1JNKCB4LCBybSwgJ3RvUHJlY2lzaW9uJyApLCAyIClcclxuICAgICAgICAgIDogeC50b1N0cmluZygpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkIHNpZ25pZmljYW50XHJcbiAgICAgKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgdG8gcHJlY2lzaW9uIGFuZCByb3VuZGluZyByZXNwZWN0aXZlbHkgaWYgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICd0b1NEKCkgZGlnaXRzIG91dCBvZiByYW5nZToge2R9J1xyXG4gICAgICogJ3RvU0QoKSBkaWdpdHMgbm90IGFuIGludGVnZXI6IHtkfSdcclxuICAgICAqICd0b1NEKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICAgICAqICd0b1NEKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBQWyd0b1NpZ25pZmljYW50RGlnaXRzJ10gPSBQWyd0b1NEJ10gPSBmdW5jdGlvbiAoIGQsIHJtICkge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgICAgICAgRGVjaW1hbCA9IHhbJ2NvbnN0cnVjdG9yJ107XHJcblxyXG4gICAgICAgIHggPSBuZXcgRGVjaW1hbCh4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGQgPT0gbnVsbCB8fCAhY2hlY2tBcmcoIHgsIGQsICd0b1NEJywgMSApXHJcbiAgICAgICAgICA/IHJuZCggeCwgRGVjaW1hbFsncHJlY2lzaW9uJ10sIERlY2ltYWxbJ3JvdW5kaW5nJ10gKVxyXG4gICAgICAgICAgOiBybmQoIHgsIGQgfCAwLCBjaGVja1JNKCB4LCBybSwgJ3RvU0QnICkgKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCB0byBwcmVjaXNpb24gc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJvdW5kaW5nLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgRGVjaW1hbCBoYXMgYSBwb3NpdGl2ZVxyXG4gICAgICogZXhwb25lbnQgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIHRvRXhwUG9zLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogdG9FeHBOZWcuXHJcbiAgICAgKlxyXG4gICAgICogW2JdIHtudW1iZXJ9IEJhc2UuIEludGVnZXIsIDIgdG8gNjQgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgIFBbJ3RvU3RyaW5nJ10gPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgIHZhciB1LCBzdHIsIHN0ckwsXHJcbiAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBEZWNpbWFsID0geFsnY29uc3RydWN0b3InXSxcclxuICAgICAgICAgICAgeGUgPSB4WydlJ107XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgICBpZiAoIHhlID09PSBudWxsICkge1xyXG4gICAgICAgICAgICBzdHIgPSB4WydzJ10gPyAnSW5maW5pdHknIDogJ05hTic7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm1hdD9cclxuICAgICAgICB9IGVsc2UgaWYgKCBiID09PSB1ICYmICggeGUgPD0gRGVjaW1hbFsndG9FeHBOZWcnXSB8fCB4ZSA+PSBEZWNpbWFsWyd0b0V4cFBvcyddICkgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KCB4LCBudWxsLCBEZWNpbWFsWydyb3VuZGluZyddLCAxICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RyID0gY29lZmZpY2llbnRUb1N0cmluZyggeFsnYyddICk7XHJcblxyXG4gICAgICAgICAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgICAgICAgICAgaWYgKCB4ZSA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIGZvciAoIDsgKyt4ZTsgc3RyID0gJzAnICsgc3RyICk7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSAnMC4nICsgc3RyO1xyXG5cclxuICAgICAgICAgICAgLy8gUG9zaXRpdmUgZXhwb25lbnQ/XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHN0ckwgPSBzdHIubGVuZ3RoLCB4ZSA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCArK3hlID4gc3RyTCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHhlIC09IHN0ckw7IHhlLS0gOyBzdHIgKz0gJzAnICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggeGUgPCBzdHJMICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSggMCwgeGUgKSArICcuJyArIHN0ci5zbGljZSh4ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFeHBvbmVudCB6ZXJvLlxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdSA9IHN0ci5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBzdHJMID4gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSB1ICsgJy4nICsgc3RyLnNsaWNlKDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkICctMCdcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHUgPT0gJzAnICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBiICE9IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhKCBvdXRPZlJhbmdlID0gISggYiA+PSAyICYmIGIgPCA2NSApICkgJiZcclxuICAgICAgICAgICAgICAgICAgKCBiID09IChiIHwgMCkgfHwgIURlY2ltYWxbJ2Vycm9ycyddICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gY29udmVydEJhc2UoIERlY2ltYWwsIHN0ciwgYiB8IDAsIDEwLCB4WydzJ10gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgJy0wJ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RyID09ICcwJyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ3RvU3RyaW5nKCkgYmFzZSBub3QgYW4gaW50ZWdlcjoge2J9J1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICd0b1N0cmluZygpIGJhc2Ugb3V0IG9mIHJhbmdlOiB7Yn0nXHJcbiAgICAgICAgICAgICAgICAgICAgaWZFeGNlcHRpb25zVGhyb3coIERlY2ltYWwsICdiYXNlJywgYiwgJ3RvU3RyaW5nJywgMCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geFsncyddIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHRydW5jYXRlZCB0byBhIHdob2xlIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFBbJ3RydW5jYXRlZCddID0gUFsndHJ1bmMnXSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJuZCggbmV3IHRoaXNbJ2NvbnN0cnVjdG9yJ10odGhpcyksIHRoaXNbJ2UnXSArIDEsIDEgKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudC5cclxuICAgICAqXHJcbiAgICAgKiBFbnN1cmVzIHRoYXQgSlNPTi5zdHJpbmdpZnkoKSB1c2VzIHRvU3RyaW5nIGZvciBzZXJpYWxpemF0aW9uLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUFsndmFsdWVPZiddID0gUFsndG9KU09OJ10gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgLy8gQWRkIGFsaWFzZXMgdG8gbWF0Y2ggQmlnRGVjaW1hbCBtZXRob2QgbmFtZXMuXHJcbiAgICBQWydhZGQnXSA9IFBbJ3BsdXMnXTtcclxuICAgIFBbJ3N1YnRyYWN0J10gPSBQWydtaW51cyddO1xyXG4gICAgUFsnbXVsdGlwbHknXSA9IFBbJ3RpbWVzJ107XHJcbiAgICBQWydkaXZpZGUnXSA9IFBbJ2RpdiddO1xyXG4gICAgUFsncmVtYWluZGVyJ10gPSBQWydtb2QnXTtcclxuICAgIFBbJ2NvbXBhcmVUbyddID0gUFsnY21wJ107XHJcbiAgICBQWyduZWdhdGUnXSA9IFBbJ25lZyddO1xyXG4gICAgICovXHJcblxyXG5cclxuICAgIC8vIFByaXZhdGUgZnVuY3Rpb25zIGZvciBEZWNpbWFsLnByb3RvdHlwZSBtZXRob2RzLlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIGNvZWZmaWNpZW50VG9TdHJpbmdcclxuICAgICAqICBjaGVja1JvdW5kaW5nRGlnaXRzXHJcbiAgICAgKiAgY2hlY2tSTVxyXG4gICAgICogIGNoZWNrQXJnXHJcbiAgICAgKiAgY29udmVydEJhc2VcclxuICAgICAqICBkaXZcclxuICAgICAqICBleHBcclxuICAgICAqICBmb3JtYXRcclxuICAgICAqICBnZXRDb2VmZkxlbmd0aFxyXG4gICAgICogIGlmRXhjZXB0aW9uc1Rocm93XHJcbiAgICAgKiAgaW50UG93XHJcbiAgICAgKiAgbG5cclxuICAgICAqICBybmRcclxuICAgICAqL1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBjb2VmZmljaWVudFRvU3RyaW5nKGEpIHtcclxuICAgICAgICB2YXIgcywgeixcclxuICAgICAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICAgICAgZm9yICggOyBpIDwgajsgaSsrICkge1xyXG4gICAgICAgICAgICBzID0gYVtpXSArICcnO1xyXG5cclxuICAgICAgICAgICAgZm9yICggeiA9IExPR0JBU0UgLSBzLmxlbmd0aDsgei0tOyApIHtcclxuICAgICAgICAgICAgICAgIHMgPSAnMCcgKyBzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByICs9IHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCBqID0gci5sZW5ndGg7IHIuY2hhckF0KC0taikgPT0gJzAnOyApO1xyXG5cclxuICAgICAgICByZXR1cm4gci5zbGljZSggMCwgaiArIDEgfHwgMSApO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ2hlY2sgNSByb3VuZGluZyBkaWdpdHMgaWYgcmVwZWF0aW5nIGlzIG51bGwsIDQgb3RoZXJ3aXNlLlxyXG4gICAgICogcmVwZWF0aW5nID09IG51bGwgaWYgY2FsbGVyIGlzIGxvZyBvciBwb3csXHJcbiAgICAgKiByZXBlYXRpbmcgIT0gbnVsbCBpZiBjYWxsZXIgaXMgbG4gb3IgZXhwLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgLy8gUHJldmlvdXMsIG11Y2ggc2ltcGxlciBpbXBsZW1lbnRhdGlvbiB3aGVuIGNvZWZmaWNpZW50IHdhcyBiYXNlIDEwLlxyXG4gICAgIGZ1bmN0aW9uIGNoZWNrUm91bmRpbmdEaWdpdHMoIGMsIGksIHJtLCByZXBlYXRpbmcgKSB7XHJcbiAgICAgICAgIHJldHVybiAoICFyZXBlYXRpbmcgJiYgcm0gPiAzICYmIGNbaV0gPT0gNCB8fFxyXG4gICAgICAgICAgICggcmVwZWF0aW5nIHx8IHJtIDwgNCApICYmIGNbaV0gPT0gOSApICYmIGNbaSArIDFdID09IDkgJiYgY1tpICsgMl0gPT0gOSAmJlxyXG4gICAgICAgICAgICAgY1tpICsgM10gPT0gOSAmJiAoIHJlcGVhdGluZyAhPSBudWxsIHx8IGNbaSArIDRdID09IDkgKSB8fFxyXG4gICAgICAgICAgICAgICByZXBlYXRpbmcgPT0gbnVsbCAmJiAoIGNbaV0gPT0gNSB8fCAhY1tpXSApICYmICFjW2kgKyAxXSAmJiAhY1tpICsgMl0gJiZcclxuICAgICAgICAgICAgICAgICAhY1tpICsgM10gJiYgIWNbaSArIDRdO1xyXG4gICAgIH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2hlY2tSb3VuZGluZ0RpZ2l0cyggYywgaSwgcm0sIHJlcGVhdGluZyApIHtcclxuICAgICAgICB2YXIgY2ksIGssIG4sIHIsIHJkO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYXJyYXkgYy5cclxuICAgICAgICBmb3IgKCBrID0gMSwgbiA9IGNbMF07IG4gPj0gMTA7IG4gLz0gMTAsIGsrKyApO1xyXG5cclxuICAgICAgICBuID0gaSAtIGs7XHJcblxyXG4gICAgICAgIC8vIElzIHRoZSByb3VuZGluZyBkaWdpdCBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjP1xyXG4gICAgICAgIGlmICggbiA8IDAgKSB7XHJcbiAgICAgICAgICAgIG4gKz0gTE9HQkFTRTtcclxuICAgICAgICAgICAgY2kgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNpID0gTWF0aC5jZWlsKCAoIG4gKyAxICkgLyBMT0dCQVNFICk7XHJcbiAgICAgICAgICAgIG4gJT0gTE9HQkFTRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsgPW1hdGhwb3coIDEwLCBMT0dCQVNFIC0gbiApO1xyXG4gICAgICAgIHJkID0gY1tjaV0gJSBrIHwgMDtcclxuXHJcbiAgICAgICAgaWYgKCByZXBlYXRpbmcgPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIGlmICggbiA8IDMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBuID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmQgPSByZCAvIDEwMCB8IDA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBuID09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmQgPSByZCAvIDEwIHwgMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByID0gcm0gPCA0ICYmIHJkID09IDk5OTk5IHx8IHJtID4gMyAmJiByZCA9PSA0OTk5OSB8fCByZCA9PSA1MDAwMCB8fCByZCA9PSAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgciA9ICggcm0gPCA0ICYmIHJkICsgMSA9PSBrIHx8IHJtID4gMyAmJiByZCArIDEgPT0gayAvIDIgKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICggY1tjaSArIDFdIC8gayAvIDEwMCB8IDAgKSA9PSBtYXRocG93KCAxMCwgbiAtIDIgKSAtIDEgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCByZCA9PSBrIC8gMiB8fCByZCA9PSAwICkgJiYgKCBjW2NpICsgMV0gLyBrIC8gMTAwIHwgMCApID09IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBuIDwgNCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIG4gPT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZCA9IHJkIC8gMTAwMCB8IDA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBuID09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmQgPSByZCAvIDEwMCB8IDA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBuID09IDIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmQgPSByZCAvIDEwIHwgMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByID0gKCByZXBlYXRpbmcgfHwgcm0gPCA0ICkgJiYgcmQgPT0gOTk5OSB8fCAhcmVwZWF0aW5nICYmIHJtID4gMyAmJiByZCA9PSA0OTk5O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgciA9ICggKCByZXBlYXRpbmcgfHwgcm0gPCA0ICkgJiYgcmQgKyAxID09IGsgfHxcclxuICAgICAgICAgICAgICAgICggIXJlcGVhdGluZyAmJiBybSA+IDMgKSAmJiByZCArIDEgPT0gayAvIDIgKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICggY1tjaSArIDFdIC8gayAvIDEwMDAgfCAwICkgPT0gbWF0aHBvdyggMTAsIG4gLSAzICkgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENoZWNrIGFuZCByZXR1cm4gcm91bmRpbmcgbW9kZS4gSWYgcm0gaXMgaW52YWxpZCwgcmV0dXJuIHJvdW5kaW5nIG1vZGUgcm91bmRpbmcuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNoZWNrUk0oIHgsIHJtLCBtZXRob2QgKSB7XHJcbiAgICAgICAgdmFyIERlY2ltYWwgPSB4Wydjb25zdHJ1Y3RvciddO1xyXG5cclxuICAgICAgICByZXR1cm4gcm0gPT0gbnVsbCB8fCAoICggb3V0T2ZSYW5nZSA9IHJtIDwgMCB8fCBybSA+IDggKSB8fFxyXG4gICAgICAgICAgcm0gIT09IDAgJiYgKCBEZWNpbWFsWydlcnJvcnMnXSA/IHBhcnNlSW50IDogcGFyc2VGbG9hdCApKHJtKSAhPSBybSApICYmXHJcbiAgICAgICAgICAgICFpZkV4Y2VwdGlvbnNUaHJvdyggRGVjaW1hbCwgJ3JvdW5kaW5nIG1vZGUnLCBybSwgbWV0aG9kLCAwIClcclxuICAgICAgICAgICAgICA/IERlY2ltYWxbJ3JvdW5kaW5nJ10gOiBybSB8IDA7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDaGVjayB0aGF0IGFyZ3VtZW50IG4gaXMgaW4gcmFuZ2UsIHJldHVybiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjaGVja0FyZyggeCwgbiwgbWV0aG9kLCBtaW4gKSB7XHJcbiAgICAgICAgdmFyIERlY2ltYWwgPSB4Wydjb25zdHJ1Y3RvciddO1xyXG5cclxuICAgICAgICByZXR1cm4gISggb3V0T2ZSYW5nZSA9IG4gPCAoIG1pbiB8fCAwICkgfHwgbiA+PSBNQVhfRElHSVRTICsgMSApICYmXHJcblxyXG4gICAgICAgICAgLypcclxuICAgICAgICAgICAqIEluY2x1ZGUgJ24gPT09IDAnIGJlY2F1c2UgT3BlcmEgaGFzICdwYXJzZUZsb2F0KC0wKSA9PSAtMCcgYXMgZmFsc2VcclxuICAgICAgICAgICAqIGRlc3BpdGUgaGF2aW5nICdwYXJzZUZsb2F0KC0wKSA9PT0gLTAgJiYgcGFyc2VGbG9hdCgnLTAnKSA9PT0gLTAgJiYgMCA9PSAtMCcgYXMgdHJ1ZS5cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgKCBuID09PSAwIHx8ICggRGVjaW1hbFsnZXJyb3JzJ10gPyBwYXJzZUludCA6IHBhcnNlRmxvYXQgKShuKSA9PSBuICkgfHxcclxuICAgICAgICAgICAgaWZFeGNlcHRpb25zVGhyb3coIERlY2ltYWwsICdhcmd1bWVudCcsIG4sIG1ldGhvZCwgMCApO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICAgICAqIEVnLiBjb252ZXJ0QmFzZSgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICAgICAqIEVnLiBjb252ZXJ0QmFzZSgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHRvQmFzZU91dCggc3RyLCBiYXNlSW4sIGJhc2VPdXQgKSB7XHJcbiAgICAgICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgICAgICAgYXJyTCxcclxuICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgc3RyTCA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCA7IGkgPCBzdHJMOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluICk7XHJcblxyXG4gICAgICAgICAgICAgICAgYXJyWyBqID0gMCBdICs9IE5VTUVSQUxTLmluZGV4T2YoIHN0ci5jaGFyQXQoIGkrKyApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggOyBqIDwgYXJyLmxlbmd0aDsgaisrICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGFycltqXSA+IGJhc2VPdXQgLSAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhcnJbaiArIDFdID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggRGVjaW1hbCwgc3RyLCBiYXNlT3V0LCBiYXNlSW4sIHNpZ24gKSB7XHJcbiAgICAgICAgICAgIHZhciBlLCBqLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZiggJy4nICksXHJcbiAgICAgICAgICAgICAgICBwciA9IERlY2ltYWxbJ3ByZWNpc2lvbiddLFxyXG4gICAgICAgICAgICAgICAgcm0gPSBEZWNpbWFsWydyb3VuZGluZyddO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBiYXNlSW4gPCAzNyApIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICAgICAgaWYgKCBpID49IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSggJy4nLCAnJyApO1xyXG4gICAgICAgICAgICAgICAgeSA9IG5ldyBEZWNpbWFsKGJhc2VJbik7XHJcbiAgICAgICAgICAgICAgICB4ID0gaW50UG93KCBEZWNpbWFsLCB5LCBzdHIubGVuZ3RoIC0gaSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiBkaXZpZGUgdGhlIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlclxyXG4gICAgICAgICAgICAgICAgIHN1Y2ggdGhhdCB0aGUgZnJhY3Rpb24gcGFydCB3aWxsIGJlIHJlc3RvcmVkLlxyXG4gICAgICAgICAgICAgICAgIFVzZSB0b0ZpeGVkIHRvIGF2b2lkIHBvc3NpYmxlIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB5WydjJ10gPSB0b0Jhc2VPdXQoIHgudG9GaXhlZCgpLCAxMCwgYmFzZU91dCApO1xyXG4gICAgICAgICAgICAgICAgeVsnZSddID0geVsnYyddLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcbiAgICAgICAgICAgIHhjID0gdG9CYXNlT3V0KCBzdHIsIGJhc2VJbiwgYmFzZU91dCApO1xyXG4gICAgICAgICAgICBlID0gaiA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggOyB4Y1stLWpdID09IDA7IHhjLnBvcCgpICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoICF4Y1swXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzAnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIGkgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgZS0tO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeFsnYyddID0geGM7XHJcbiAgICAgICAgICAgICAgICB4WydlJ10gPSBlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgICAgICAgeFsncyddID0gc2lnbjtcclxuICAgICAgICAgICAgICAgIHggPSBkaXYoIHgsIHksIHByLCBybSwgMCwgYmFzZU91dCApO1xyXG4gICAgICAgICAgICAgICAgeGMgPSB4WydjJ107XHJcbiAgICAgICAgICAgICAgICByID0geFsnciddO1xyXG4gICAgICAgICAgICAgICAgZSA9IHhbJ2UnXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAgICAgaSA9IHhjW3ByXTtcclxuICAgICAgICAgICAgaiA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgICAgICByID0gciB8fCB4Y1twciArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHJtIDwgNFxyXG4gICAgICAgICAgICAgID8gKCBpICE9IG51bGwgfHwgciApICYmICggcm0gPT0gMCB8fCBybSA9PSAoIHhbJ3MnXSA8IDAgPyAzIDogMiApIClcclxuICAgICAgICAgICAgICA6IGkgPiBqIHx8IGkgPT0gaiAmJiAoIHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW3ByIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgICBybSA9PSAoIHhbJ3MnXSA8IDAgPyA4IDogNyApICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgeGMubGVuZ3RoID0gcHI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgICAgIGZvciAoIC0tYmFzZU91dDsgKyt4Y1stLXByXSA+IGJhc2VPdXQ7ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhjW3ByXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXByICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjLnVuc2hpZnQoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGMubGVuZ3RoID0gcHI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggaiA9IHhjLmxlbmd0aDsgIXhjWy0tal07ICk7XHJcblxyXG4gICAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgICBmb3IgKCBpID0gMCwgc3RyID0gJyc7IGkgPD0gajsgc3RyICs9IE5VTUVSQUxTLmNoYXJBdCggeGNbaSsrXSApICk7XHJcblxyXG4gICAgICAgICAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgICAgICAgICAgaWYgKCBlIDwgMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgZm9yICggOyArK2U7IHN0ciA9ICcwJyArIHN0ciApO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0ciA9ICcwLicgKyBzdHI7XHJcblxyXG4gICAgICAgICAgICAvLyBQb3NpdGl2ZSBleHBvbmVudD9cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGkgPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggKytlID4gaSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGUgLT0gaTsgZS0tIDsgc3RyICs9ICcwJyApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCBpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSggMCwgZSApICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBObyBuZWdhdGl2ZSBudW1iZXJzOiB0aGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBkaXYgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy8gQXNzdW1lcyBub24temVybyB4IGFuZCBrLCBhbmQgaGVuY2Ugbm9uLXplcm8gcmVzdWx0LlxyXG4gICAgICAgIGZ1bmN0aW9uIG11bHRpcGx5SW50ZWdlciggeCwgaywgYmFzZSApIHtcclxuICAgICAgICAgICAgdmFyIHRlbXAsXHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICAgICAgICBpID0geC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCB4ID0geC5zbGljZSgpOyBpLS07ICkge1xyXG4gICAgICAgICAgICAgICAgdGVtcCA9IHhbaV0gKiBrICsgY2Fycnk7XHJcbiAgICAgICAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2UgfCAwO1xyXG4gICAgICAgICAgICAgICAgY2FycnkgPSB0ZW1wIC8gYmFzZSB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjYXJyeSkge1xyXG4gICAgICAgICAgICAgICAgeC51bnNoaWZ0KGNhcnJ5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlKCBhLCBiLCBhTCwgYkwgKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGFMICE9IGJMICkge1xyXG4gICAgICAgICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gY21wID0gMDsgaSA8IGFMOyBpKysgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggYVtpXSAhPSBiW2ldICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KCBhLCBiLCBhTCwgYmFzZSApIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgICAgIGZvciAoIDsgYUwtLTsgKSB7XHJcbiAgICAgICAgICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc2hpZnQoKSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggeCwgeSwgcHIsIHJtLCBkcCwgYmFzZSApIHtcclxuICAgICAgICAgICAgdmFyIGNtcCwgZSwgaSwgbG9nYmFzZSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHQsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgICAgICAgICAgRGVjaW1hbCA9IHhbJ2NvbnN0cnVjdG9yJ10sXHJcbiAgICAgICAgICAgICAgICBzID0geFsncyddID09IHlbJ3MnXSA/IDEgOiAtMSxcclxuICAgICAgICAgICAgICAgIHhjID0geFsnYyddLFxyXG4gICAgICAgICAgICAgICAgeWMgPSB5WydjJ107XHJcblxyXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgICAgICBpZiAoICF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoXHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAgICAgICAgIXhbJ3MnXSB8fCAheVsncyddIHx8ICggeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YyApID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuICstMCBpZiB4IGlzIDAgb3IgeSBpcyArLUluZmluaXR5LCBvciByZXR1cm4gKy1JbmZpbml0eSBhcyB5IGlzIDAuXHJcbiAgICAgICAgICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYmFzZSkge1xyXG4gICAgICAgICAgICAgICAgbG9nYmFzZSA9IDE7XHJcbiAgICAgICAgICAgICAgICBlID0geFsnZSddIC0geVsnZSddO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICAgICAgICBsb2diYXNlID0gTE9HQkFTRTtcclxuICAgICAgICAgICAgICAgIGUgPSBtYXRoZmxvb3IoIHhbJ2UnXSAvIGxvZ2Jhc2UgKSAtIG1hdGhmbG9vciggeVsnZSddIC8gbG9nYmFzZSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHEgPSBuZXcgRGVjaW1hbChzKTtcclxuICAgICAgICAgICAgcWMgPSBxWydjJ10gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBEZWNpbWFscyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgeWNbaV0gPT0gKCB4Y1tpXSB8fCAwICk7IGkrKyApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB5Y1tpXSA+ICggeGNbaV0gfHwgMCApICkge1xyXG4gICAgICAgICAgICAgICAgZS0tO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHByID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcHIgPSBEZWNpbWFsWydwcmVjaXNpb24nXTtcclxuICAgICAgICAgICAgICAgIHJtID0gRGVjaW1hbFsncm91bmRpbmcnXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkcCkge1xyXG4gICAgICAgICAgICAgICAgcyA9IHByICsgKCB4WydlJ10gLSB5WydlJ10gKSArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcHI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggcyA8IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBiYXNlIDEwIGRlY2ltYWwgcGxhY2VzIHRvIGJhc2UgMWU3IGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgICAgcyA9IHMgLyBsb2diYXNlICsgMiB8IDA7XHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgMWU3XHJcbiAgICAgICAgICAgICAgICBpZiAoIHlMID09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgeWMgPSB5Y1swXTtcclxuICAgICAgICAgICAgICAgICAgICBzKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vICduJyBpcyB0aGUgY2FycnkuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyAoIGkgPCB4TCB8fCBuICkgJiYgcy0tOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBuICogYmFzZSArICggeGNbaV0gfHwgMCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxY1tpXSA9IHQgLyB5YyB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB0ICUgeWMgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZSA9IG4gfHwgaSA8IHhMO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPj0gMWU3XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZS8yXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IGJhc2UgLyAoIHljWzBdICsgMSApIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuID4gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWMgPSBtdWx0aXBseUludGVnZXIoIHljLCBuLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjID0gbXVsdGlwbHlJbnRlZ2VyKCB4YywgbiwgYmFzZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHhjLnNsaWNlKCAwLCB5TCApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgcmVtTCA8IHlMOyByZW1bcmVtTCsrXSA9IDAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHl6LnVuc2hpZnQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeWMwID0geWNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggeWNbMV0gPj0gYmFzZSAvIDIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHljMCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKCB5YywgcmVtLCB5TCwgcmVtTCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjbXAgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB5TCAhPSByZW1MICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbTAgPSByZW0wICogYmFzZSArICggcmVtWzFdIHx8IDAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuIHdpbGwgYmUgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSByZW0wIC8geWMwIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEuIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQgKG4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIuIGlmIHByb2R1Y3QgPiByZW1haW5kZXI6IHByb2R1Y3QgLT0gZGl2aXNvciwgbi0tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMuIHJlbWFpbmRlciAtPSBwcm9kdWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQuIGlmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyIGF0IDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNS4gY29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNi4gSWYgcmVtYWluZGVyID4gZGl2aXNvcjogcmVtYWluZGVyIC09IGRpdmlzb3IsIG4rK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG4gPiAxICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG4gPj0gYmFzZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGJhc2UgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHlJbnRlZ2VyKCB5YywgbiwgYmFzZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoIHByb2QsIHJlbSwgcHJvZEwsIHJlbUwgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA+IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNtcCA9PSAxICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidHJhY3QoIHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LCBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxIHRoZXJlIElTIGEgbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3cuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwcm9kTCA8IHJlbUwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZC51bnNoaWZ0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCggcmVtLCBwcm9kLCByZW1MLCBiYXNlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCBwcmV2aW91cyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNtcCA9PSAtMSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoIHljLCByZW0sIHlMLCByZW1MICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY21wIDwgMSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidHJhY3QoIHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNtcCA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAvLyBpZiBjbXAgPT09IDEsIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY21wICYmIHJlbVswXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBbIHhjW3hpXSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoICggeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsICkgJiYgcy0tICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICAgICAgICBpZiAoICFxY1swXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBxYy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXYgaXMgYmVpbmcgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLlxyXG4gICAgICAgICAgICBpZiAoIGxvZ2Jhc2UgPT0gMSApIHtcclxuICAgICAgICAgICAgICAgIHFbJ2UnXSA9IGU7XHJcbiAgICAgICAgICAgICAgICBxWydyJ10gPSArbW9yZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKysgKTtcclxuICAgICAgICAgICAgICAgIHFbJ2UnXSA9IGkgKyBlICogbG9nYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgcm5kKCBxLCBkcCA/IHByICsgcVsnZSddICsgMSA6IHByLCBybSwgbW9yZSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcTtcclxuICAgICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogVGF5bG9yL01hY2xhdXJpbiBzZXJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogZXhwKHgpID0geF4wLzAhICsgeF4xLzEhICsgeF4yLzIhICsgeF4zLzMhICsgLi4uXHJcbiAgICAgKlxyXG4gICAgICogQXJndW1lbnQgcmVkdWN0aW9uOlxyXG4gICAgICogICBSZXBlYXQgeCA9IHggLyAzMiwgayArPSA1LCB1bnRpbCB8eHwgPCAwLjFcclxuICAgICAqICAgZXhwKHgpID0gZXhwKHggLyAyXmspXigyXmspXHJcbiAgICAgKlxyXG4gICAgICogUHJldmlvdXNseSwgdGhlIGFyZ3VtZW50IHdhcyBpbml0aWFsbHkgcmVkdWNlZCBieVxyXG4gICAgICogZXhwKHgpID0gZXhwKHIpICogMTBeayAgd2hlcmUgciA9IHggLSBrICogbG4xMCwgayA9IGZsb29yKHggLyBsbjEwKVxyXG4gICAgICogdG8gZmlyc3QgcHV0IHIgaW4gdGhlIHJhbmdlIFswLCBsbjEwXSwgYmVmb3JlIGRpdmlkaW5nIGJ5IDMyIHVudGlsIHx4fCA8IDAuMSwgYnV0IHRoaXMgd2FzXHJcbiAgICAgKiBmb3VuZCB0byBiZSBzbG93ZXIgdGhhbiBqdXN0IGRpdmlkaW5nIHJlcGVhdGVkbHkgYnkgMzIgYXMgYWJvdmUuXHJcbiAgICAgKlxyXG4gICAgICogTWF4IGludGVnZXIgYXJndW1lbnQ6IGV4cCgnMjA3MjMyNjU4MzY5NDY0MTMnKSA9IDYuM2UrOTAwMDAwMDAwMDAwMDAwMFxyXG4gICAgICogTWluIGludGVnZXIgYXJndW1lbnQ6IGV4cCgnLTIwNzIzMjY1ODM2OTQ2NDExJykgPSAxLjJlLTkwMDAwMDAwMDAwMDAwMDBcclxuICAgICAqICggTWF0aCBvYmplY3QgaW50ZWdlciBtaW4vbWF4OiBNYXRoLmV4cCg3MDkpID0gOC4yZSszMDcsIE1hdGguZXhwKC03NDUpID0gNWUtMzI0IClcclxuICAgICAqXHJcbiAgICAgKiAgZXhwKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gICAgICogIGV4cCgtSW5maW5pdHkpID0gMFxyXG4gICAgICogIGV4cChOYU4pICAgICAgID0gTmFOXHJcbiAgICAgKiAgZXhwKCstMCkgICAgICAgPSAxXHJcbiAgICAgKlxyXG4gICAgICogIGV4cCh4KSBpcyBub24tdGVybWluYXRpbmcgZm9yIGFueSBmaW5pdGUsIG5vbi16ZXJvIHguXHJcbiAgICAgKlxyXG4gICAgICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgY29ycmVjdGx5IHJvdW5kZWQuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBleHAoIHgsIHByICkge1xyXG4gICAgICAgIHZhciBkZW5vbSwgZ3VhcmQsIGosIHBvdywgc2QsIHN1bSwgdCxcclxuICAgICAgICAgICAgcmVwID0gMCxcclxuICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgIGsgPSAwLFxyXG4gICAgICAgICAgICBEZWNpbWFsID0geFsnY29uc3RydWN0b3InXSxcclxuICAgICAgICAgICAgb25lID0gRGVjaW1hbFsnT05FJ10sXHJcbiAgICAgICAgICAgIHJtID0gRGVjaW1hbFsncm91bmRpbmcnXSxcclxuICAgICAgICAgICAgcHJlY2lzaW9uID0gRGVjaW1hbFsncHJlY2lzaW9uJ107XHJcblxyXG4gICAgICAgIC8vIDAvTmFOL0luZmluaXR5P1xyXG4gICAgICAgIGlmICggIXhbJ2MnXSB8fCAheFsnYyddWzBdIHx8IHhbJ2UnXSA+IDE3ICkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKCB4WydjJ11cclxuICAgICAgICAgICAgICA/ICF4WydjJ11bMF0gPyBvbmUgOiB4WydzJ10gPCAwID8gMCA6IDEgLyAwXHJcbiAgICAgICAgICAgICAgOiB4WydzJ10gPyB4WydzJ10gPCAwID8gMCA6IHggOiBOYU4gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggcHIgPT0gbnVsbCApIHtcclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICBFc3RpbWF0ZSByZXN1bHQgZXhwb25lbnQuXHJcbiAgICAgICAgICAgICBlXnggPSAxMF5qLCB3aGVyZSBqID0geCAqIGxvZzEwKGUpIGFuZFxyXG4gICAgICAgICAgICAgbG9nMTAoZSkgPSBsbihlKSAvIGxuKDEwKSA9IDEgLyBsbigxMCksXHJcbiAgICAgICAgICAgICBzbyBqID0geCAvIGxuKDEwKVxyXG4gICAgICAgICAgICBqID0gbWF0aGZsb29yKCB4IC8gTWF0aC5MTjEwICk7XHJcblxyXG4gICAgICAgICAgICAvLyBPdmVyZmxvdy91bmRlcmZsb3c/IEVzdGltYXRlIG1heSBiZSArLTEgb2YgdHJ1ZSB2YWx1ZS5cclxuICAgICAgICAgICAgaWYgKCBqID4gRGVjaW1hbFsnbWF4RSddICsgMSB8fCBqIDwgRGVjaW1hbFsnbWluRSddIC0gMSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoIGogPiAwID8gMSAvIDAgOiAwICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZCA9IHByZWNpc2lvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZCA9IHByO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdCA9IG5ldyBEZWNpbWFsKDAuMDMxMjUpO1xyXG5cclxuICAgICAgICAvLyB3aGlsZSBhYnMoeCkgPj0gMC4xXHJcbiAgICAgICAgd2hpbGUgKCB4WydlJ10gPiAtMiApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHggPSB4IC8gMl41XHJcbiAgICAgICAgICAgIHggPSB4Wyd0aW1lcyddKHQpO1xyXG4gICAgICAgICAgICBrICs9IDU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICBVc2UgMiAqIGxvZzEwKDJeaykgKyA1IHRvIGVzdGltYXRlIHRoZSBpbmNyZWFzZSBpbiBwcmVjaXNpb24gbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGUgZmlyc3RcclxuICAgICAgICAgNCByb3VuZGluZyBkaWdpdHMgYXJlIGNvcnJlY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ3VhcmQgPSBNYXRoLmxvZyggbWF0aHBvdyggMiwgayApICkgLyBNYXRoLkxOMTAgKiAyICsgNSB8IDA7XHJcbiAgICAgICAgc2QgKz0gZ3VhcmQ7XHJcblxyXG4gICAgICAgIGRlbm9tID0gcG93ID0gc3VtID0gbmV3IERlY2ltYWwob25lKTtcclxuICAgICAgICBEZWNpbWFsWydwcmVjaXNpb24nXSA9IHNkO1xyXG5cclxuICAgICAgICBmb3IgKCA7IDsgKSB7XHJcbiAgICAgICAgICAgIHBvdyA9IHJuZCggcG93Wyd0aW1lcyddKHgpLCBzZCwgMSApO1xyXG4gICAgICAgICAgICBkZW5vbSA9IGRlbm9tWyd0aW1lcyddKCsraSk7XHJcbiAgICAgICAgICAgIHQgPSBzdW1bJ3BsdXMnXSggZGl2KCBwb3csIGRlbm9tLCBzZCwgMSApICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGNvZWZmaWNpZW50VG9TdHJpbmcoIHRbJ2MnXSApLnNsaWNlKCAwLCBzZCApID09PVxyXG4gICAgICAgICAgICAgICAgIGNvZWZmaWNpZW50VG9TdHJpbmcoIHN1bVsnYyddICkuc2xpY2UoIDAsIHNkICkgKSB7XHJcbiAgICAgICAgICAgICAgICBqID0gaztcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIGotLSApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdW0gPSBybmQoIHN1bVsndGltZXMnXShzdW0pLCBzZCwgMSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgQ2hlY2sgdG8gc2VlIGlmIHRoZSBmaXJzdCA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgWzQ5XTk5OS5cclxuICAgICAgICAgICAgICAgICBJZiBzbywgcmVwZWF0IHRoZSBzdW1tYXRpb24gd2l0aCBhIGhpZ2hlciBwcmVjaXNpb24sIG90aGVyd2lzZVxyXG4gICAgICAgICAgICAgICAgIEUuZy4gd2l0aCBwcmVjaXNpb246IDE4LCByb3VuZGluZzogMVxyXG4gICAgICAgICAgICAgICAgIGV4cCgxOC40MDQyNzI0NjI1OTUwMzQwODM1Njc3OTM5MTk4NDM3NjEpID0gOTgzNzI1NjAuMTIyOTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiBpdCBzaG91bGQgYmUgOTgzNzI1NjAuMTIzXHJcblxyXG4gICAgICAgICAgICAgICAgIHNkIC0gZ3VhcmQgaXMgdGhlIGluZGV4IG9mIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAoIHByID09IG51bGwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVwIDwgMyAmJiBjaGVja1JvdW5kaW5nRGlnaXRzKCBzdW1bJ2MnXSwgc2QgLSBndWFyZCwgcm0sIHJlcCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWNpbWFsWydwcmVjaXNpb24nXSA9IHNkICs9IDEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5vbSA9IHBvdyA9IHQgPSBuZXcgRGVjaW1hbChvbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBybmQoIHN1bSwgRGVjaW1hbFsncHJlY2lzaW9uJ10gPSBwcmVjaXNpb24sIHJtLCBleHRlcm5hbCA9IHRydWUgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIERlY2ltYWxbJ3ByZWNpc2lvbiddID0gcHJlY2lzaW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1bSA9IHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgRGVjaW1hbCBuIGluIG5vcm1hbCBvciBleHBvbmVudGlhbCBub3RhdGlvblxyXG4gICAgICogcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAqIENhbGxlZCBieSB0b1N0cmluZywgdG9FeHBvbmVudGlhbCAoayBpcyAxKSwgdG9GaXhlZCwgYW5kIHRvUHJlY2lzaW9uIChrIGlzIDIpLlxyXG4gICAgICogaSBpcyB0aGUgaW5kZXggKHdpdGggdGhlIHZhbHVlIGluIG5vcm1hbCBub3RhdGlvbikgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgKiBqIGlzIHRoZSByb3VuZGluZyBtb2RlLCB0aGVuIHRoZSBudW1iZXIgb2YgZGlnaXRzIHJlcXVpcmVkIGluY2x1ZGluZyBmcmFjdGlvbi1wYXJ0IHRyYWlsaW5nXHJcbiAgICAgKiB6ZXJvcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KCBuLCBpLCBqLCBrICkge1xyXG4gICAgICAgIHZhciBzLCB6LFxyXG4gICAgICAgICAgICBEZWNpbWFsID0gblsnY29uc3RydWN0b3InXSxcclxuICAgICAgICAgICAgZSA9ICggbiA9IG5ldyBEZWNpbWFsKG4pIClbJ2UnXTtcclxuXHJcbiAgICAgICAgLy8gaSA9PSBudWxsIHdoZW4gdG9FeHBvbmVudGlhbChubyBhcmcpLCBvciB0b1N0cmluZygpIHdoZW4geCA+PSB0b0V4cFBvcyBldGMuXHJcbiAgICAgICAgaWYgKCBpID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJuZCggbiwgKytpLCBqICk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0b0ZpeGVkLCBuWydlJ10gbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgICAgIGogPSBrID8gaSA6IGkgKyBuWydlJ10gLSBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZSA9IG5bJ2UnXTtcclxuICAgICAgICBzID0gY29lZmZpY2llbnRUb1N0cmluZyggblsnYyddICk7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgc3BlY2lmaWVkXHJcbiAgICAgICAgIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlXHJcbiAgICAgICAgIGluIG5vcm1hbCBub3RhdGlvbi5cclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKCBrID09IDEgfHwgayA9PSAyICYmICggaSA8PSBlIHx8IGUgPD0gRGVjaW1hbFsndG9FeHBOZWcnXSApICkge1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgICBmb3IgKCA7IHMubGVuZ3RoIDwgajsgcyArPSAnMCcgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggcy5sZW5ndGggPiAxICkge1xyXG4gICAgICAgICAgICAgICAgcyA9IHMuY2hhckF0KDApICsgJy4nICsgcy5zbGljZSgxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcyArPSAoIGUgPCAwID8gJ2UnIDogJ2UrJyApICsgZTtcclxuXHJcbiAgICAgICAgLy8gTm9ybWFsIG5vdGF0aW9uLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGsgPSBzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gICAgICAgICAgICBpZiAoIGUgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgeiA9IGogLSBrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7ICsrZTsgcyA9ICcwJyArIHMgKTtcclxuICAgICAgICAgICAgICAgIHMgPSAnMC4nICsgcztcclxuXHJcbiAgICAgICAgICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50P1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggKytlID4gayApIHtcclxuICAgICAgICAgICAgICAgICAgICB6ID0gaiAtIGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBlIC09IGs7IGUtLSA7IHMgKz0gJzAnICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggeiA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gJy4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHogPSBqIC0gaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlIDwgayApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHMuc2xpY2UoIDAsIGUgKSArICcuJyArIHMuc2xpY2UoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggeiA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gJy4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIG1vcmUgemVyb3M/XHJcbiAgICAgICAgICAgIGlmICggeiA+IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggOyB6LS07IHMgKz0gJzAnICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuWydzJ10gPCAwICYmIG5bJ2MnXVswXSA/ICctJyArIHMgOiBzO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDb2VmZkxlbmd0aChjKSB7XHJcbiAgICAgICAgdmFyIHYgPSBjLmxlbmd0aCAtIDEsXHJcbiAgICAgICAgICAgIG4gPSB2ICogTE9HQkFTRSArIDE7XHJcblxyXG4gICAgICAgIGlmICggdiA9IGNbdl0gKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgICAgICAgZm9yICggOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tICk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IG51bWJlci5cclxuICAgICAgICAgICAgZm9yICggdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBBc3NlbWJsZSBlcnJvciBtZXNzYWdlcy4gVGhyb3cgRGVjaW1hbCBFcnJvcnMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlmRXhjZXB0aW9uc1Rocm93KCBEZWNpbWFsLCBtZXNzYWdlLCBhcmcsIG1ldGhvZCwgbW9yZSApIHtcclxuXHJcbiAgICAgICAgaWYgKCBEZWNpbWFsWydlcnJvcnMnXSApIHtcclxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCAoIG1ldGhvZCB8fCBbXHJcbiAgICAgICAgICAgICAgJ25ldyBEZWNpbWFsJywgJ2NtcCcsICdkaXYnLCAnZXEnLCAnZ3QnLCAnZ3RlJywgJ2x0JywgJ2x0ZScsICdtaW51cycsICdtb2QnLFxyXG4gICAgICAgICAgICAgICdwbHVzJywgJ3RpbWVzJywgJ3RvRnJhY3Rpb24nLCAncG93JywgJ3JhbmRvbScsICdsb2cnLCAnc3FydCcsICd0b05lYXJlc3QnLCAnZGl2VG9JbnQnXHJcbiAgICAgICAgICAgICAgXVsgaWQgPyBpZCA8IDAgPyAtaWQgOiBpZCA6IDEgLyBpZCA8IDAgPyAxIDogMCBdICkgKyAnKCkgJyArICggW1xyXG4gICAgICAgICAgICAgICdudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0cycsICdMTjEwIG91dCBvZiBkaWdpdHMnIF1bbWVzc2FnZV1cclxuICAgICAgICAgICAgICB8fCBtZXNzYWdlICsgKCBbIG91dE9mUmFuZ2UgPyAnIG91dCBvZiByYW5nZScgOiAnIG5vdCBhbiBpbnRlZ2VyJyxcclxuICAgICAgICAgICAgICAnIG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0JyBdW21vcmVdIHx8ICcnICkgKSArICc6ICcgKyBhcmdcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZXJyb3JbJ25hbWUnXSA9ICdEZWNpbWFsIEVycm9yJztcclxuICAgICAgICAgICAgb3V0T2ZSYW5nZSA9IGlkID0gMDtcclxuXHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFVzZSAnZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcnIGZvciBzbWFsbCBpbnRlZ2Vycy4gQ2FsbGVkIGJ5IGNvbnZlcnRCYXNlIGFuZCBwb3cuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGludFBvdyggRGVjaW1hbCwgeCwgaSApIHtcclxuICAgICAgICB2YXIgciA9IG5ldyBEZWNpbWFsKCBEZWNpbWFsWydPTkUnXSApO1xyXG5cclxuICAgICAgICBmb3IgKCBleHRlcm5hbCA9IGZhbHNlOyA7ICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpICYgMSApIHtcclxuICAgICAgICAgICAgICAgIHIgPSByWyd0aW1lcyddKHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPj49IDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoICFpICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHggPSB4Wyd0aW1lcyddKHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIGxuKC1uKSAgICAgICAgPSBOYU5cclxuICAgICAqICBsbigwKSAgICAgICAgID0gLUluZmluaXR5XHJcbiAgICAgKiAgbG4oLTApICAgICAgICA9IC1JbmZpbml0eVxyXG4gICAgICogIGxuKDEpICAgICAgICAgPSAwXHJcbiAgICAgKiAgbG4oSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAgICAgKiAgbG4oLUluZmluaXR5KSA9IE5hTlxyXG4gICAgICogIGxuKE5hTikgICAgICAgPSBOYU5cclxuICAgICAqXHJcbiAgICAgKiAgbG4obikgKG4gIT0gMSkgaXMgbm9uLXRlcm1pbmF0aW5nLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbG4oIHksIHByICkge1xyXG4gICAgICAgIHZhciBjLCBjMCwgZGVub20sIGUsIG51bSwgcmVwLCBzZCwgc3VtLCB0LCB4MSwgeDIsXHJcbiAgICAgICAgICAgIG4gPSAxLFxyXG4gICAgICAgICAgICBndWFyZCA9IDEwLFxyXG4gICAgICAgICAgICB4ID0geSxcclxuICAgICAgICAgICAgeGMgPSB4WydjJ10sXHJcbiAgICAgICAgICAgIERlY2ltYWwgPSB4Wydjb25zdHJ1Y3RvciddLFxyXG4gICAgICAgICAgICBvbmUgPSBEZWNpbWFsWydPTkUnXSxcclxuICAgICAgICAgICAgcm0gPSBEZWNpbWFsWydyb3VuZGluZyddLFxyXG4gICAgICAgICAgICBwcmVjaXNpb24gPSBEZWNpbWFsWydwcmVjaXNpb24nXTtcclxuXHJcbiAgICAgICAgLy8geCA8IDAgb3IgKy1JbmZpbml0eS9OYU4gb3IgMCBvciAxLlxyXG4gICAgICAgIGlmICggeFsncyddIDwgMCB8fCAheGMgfHwgIXhjWzBdIHx8ICF4WydlJ10gJiYgeGNbMF0gPT0gMSAmJiB4Yy5sZW5ndGggPT0gMSApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbCggeGMgJiYgIXhjWzBdID8gLTEgLyAwIDogeFsncyddICE9IDEgPyBOYU4gOiB4YyA/IDAgOiB4ICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHByID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNkID0gcHJlY2lzaW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNkID0gcHI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBEZWNpbWFsWydwcmVjaXNpb24nXSA9IHNkICs9IGd1YXJkO1xyXG5cclxuICAgICAgICBjID0gY29lZmZpY2llbnRUb1N0cmluZyh4Yyk7XHJcbiAgICAgICAgYzAgPSBjLmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgaWYgKCBNYXRoLmFicyggZSA9IHhbJ2UnXSApIDwgMS41ZTE1ICkge1xyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgIEFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICAgICAgICAgICAgIFRoZSBzZXJpZXMgY29udmVyZ2VzIGZhc3RlciB0aGUgY2xvc2VyIHRoZSBhcmd1bWVudCBpcyB0byAxLCBzbyB1c2luZ1xyXG4gICAgICAgICAgICAgbG4oYV5iKSA9IGIgKiBsbihhKSwgICBsbihhKSA9IGxuKGFeYikgLyBiXHJcbiAgICAgICAgICAgICBtdWx0aXBseSB0aGUgYXJndW1lbnQgYnkgaXRzZWxmIHVudGlsIHRoZSBsZWFkaW5nIGRpZ2l0cyBvZiB0aGUgc2lnbmlmaWNhbmQgYXJlIDcsIDgsXHJcbiAgICAgICAgICAgICA5LCAxMCwgMTEsIDEyIG9yIDEzLCByZWNvcmRpbmcgdGhlIG51bWJlciBvZiBtdWx0aXBsaWNhdGlvbnMgc28gdGhlIHN1bSBvZiB0aGUgc2VyaWVzXHJcbiAgICAgICAgICAgICBjYW4gbGF0ZXIgYmUgZGl2aWRlZCBieSB0aGlzIG51bWJlciwgdGhlbiBzZXBhcmF0ZSBvdXQgdGhlIHBvd2VyIG9mIDEwIHVzaW5nXHJcbiAgICAgICAgICAgICBsbihhKjEwXmIpID0gbG4oYSkgKyBiKmxuKDEwKS5cclxuICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAvLyBtYXggbiBpcyAyMSAoIGdpdmVzIDAuOSwgMS4wIG9yIDEuMSApICggOWUxNSAvIDIxID0gNC4yZTE0ICkuXHJcbiAgICAgICAgICAgIC8vd2hpbGUgKCBjMCA8IDkgJiYgYzAgIT0gMSB8fCBjMCA9PSAxICYmIGMuY2hhckF0KDEpID4gMSApIHtcclxuICAgICAgICAgICAgLy8gbWF4IG4gaXMgNiAoIGdpdmVzIDAuNyAtIDEuMyApXHJcbiAgICAgICAgICAgIHdoaWxlICggYzAgPCA3ICYmIGMwICE9IDEgfHwgYzAgPT0gMSAmJiBjLmNoYXJBdCgxKSA+IDMgKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0geFsndGltZXMnXSh5KTtcclxuICAgICAgICAgICAgICAgIGMgPSBjb2VmZmljaWVudFRvU3RyaW5nKCB4WydjJ10gKTtcclxuICAgICAgICAgICAgICAgIGMwID0gYy5jaGFyQXQoMCk7XHJcbiAgICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGUgPSB4WydlJ107XHJcblxyXG4gICAgICAgICAgICBpZiAoIGMwID4gMSApIHtcclxuICAgICAgICAgICAgICAgIHggPSBuZXcgRGVjaW1hbCggJzAuJyArIGMgKTtcclxuICAgICAgICAgICAgICAgIGUrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHggPSBuZXcgRGVjaW1hbCggYzAgKyAnLicgKyBjLnNsaWNlKDEpICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgIFRoZSBhcmd1bWVudCByZWR1Y3Rpb24gbWV0aG9kIGFib3ZlIG1heSByZXN1bHQgaW4gb3ZlcmZsb3cgaWYgdGhlIGFyZ3VtZW50IHkgaXMgYVxyXG4gICAgICAgICAgICAgbWFzc2l2ZSBudW1iZXIgd2l0aCBleHBvbmVudCA+PSAxNTAwMDAwMDAwMDAwMDAwICggOWUxNSAvIDYgPSAxLjVlMTUgKSwgc28gaW5zdGVhZFxyXG4gICAgICAgICAgICAgcmVjYWxsIHRoaXMgZnVuY3Rpb24gdXNpbmcgbG4oeCoxMF5lKSA9IGxuKHgpICsgZSpsbigxMCkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB4ID0gbmV3IERlY2ltYWwoIGMwICsgJy4nICsgYy5zbGljZSgxKSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBzZCArIDIgPiBMTjEwLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBEZWNpbWFsLCAxLCBzZCArIDIsICdsbicgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeCA9IGxuKCB4LCBzZCAtIGd1YXJkIClbJ3BsdXMnXShcclxuICAgICAgICAgICAgICAgIG5ldyBEZWNpbWFsKCBMTjEwLnNsaWNlKCAwLCBzZCArIDIgKSApWyd0aW1lcyddKCBlICsgJycgKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgRGVjaW1hbFsncHJlY2lzaW9uJ10gPSBwcmVjaXNpb247XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcHIgPT0gbnVsbCA/IHJuZCggeCwgcHJlY2lzaW9uLCBybSwgZXh0ZXJuYWwgPSB0cnVlICkgOiB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geDEgaXMgeCByZWR1Y2VkIHRvIGEgdmFsdWUgbmVhciAxLlxyXG4gICAgICAgIHgxID0geDtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgVGF5bG9yIHNlcmllcy5cclxuICAgICAgICAgbG4oeSkgPSBsbiggKDEgKyB4KS8oMSAtIHgpICkgPSAyKCB4ICsgeF4zLzMgKyB4XjUvNSArIHheNy83ICsgLi4uIClcclxuICAgICAgICAgd2hlcmVcclxuICAgICAgICAgeCA9ICh5IC0gMSkvKHkgKyAxKSAgICAgICAgICAgICAgKCB8eHwgPCAxIClcclxuICAgICAgICAgKi9cclxuICAgICAgICBzdW0gPSBudW0gPSB4ID0gZGl2KCB4WydtaW51cyddKG9uZSksIHhbJ3BsdXMnXShvbmUpLCBzZCwgMSApO1xyXG4gICAgICAgIHgyID0gcm5kKCB4Wyd0aW1lcyddKHgpLCBzZCwgMSApO1xyXG4gICAgICAgIGRlbm9tID0gMztcclxuXHJcbiAgICAgICAgZm9yICggOyA7ICkge1xyXG4gICAgICAgICAgICBudW0gPSBybmQoIG51bVsndGltZXMnXSh4MiksIHNkLCAxICk7XHJcbiAgICAgICAgICAgIHQgPSBzdW1bJ3BsdXMnXSggZGl2KCBudW0sIG5ldyBEZWNpbWFsKGRlbm9tKSwgc2QsIDEgKSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBjb2VmZmljaWVudFRvU3RyaW5nKCB0WydjJ10gKS5zbGljZSggMCwgc2QgKSA9PT1cclxuICAgICAgICAgICAgICAgICBjb2VmZmljaWVudFRvU3RyaW5nKCBzdW1bJ2MnXSApLnNsaWNlKCAwLCBzZCApICkge1xyXG4gICAgICAgICAgICAgICAgc3VtID0gc3VtWyd0aW1lcyddKDIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgUmV2ZXJzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLiBDaGVjayB0aGF0IGUgaXMgbm90IDAgYmVjYXVzZSwgYXMgd2VsbCBhc1xyXG4gICAgICAgICAgICAgICAgIHByZXZlbnRpbmcgYW4gdW5uZWNlc3NhcnkgY2FsY3VsYXRpb24sIC0wICsgMCA9ICswIGFuZCB0byBlbnN1cmUgY29ycmVjdFxyXG4gICAgICAgICAgICAgICAgIHJvdW5kaW5nIGxhdGVyIC0wIG5lZWRzIHRvIHN0YXkgLTAuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmICggZSAhPT0gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZCArIDIgPiBMTjEwLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWZFeGNlcHRpb25zVGhyb3coIERlY2ltYWwsIDEsIHNkICsgMiwgJ2xuJyApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtWydwbHVzJ10oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEZWNpbWFsKCBMTjEwLnNsaWNlKCAwLCBzZCArIDIgKSApWyd0aW1lcyddKCBlICsgJycgKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3VtID0gZGl2KCBzdW0sIG5ldyBEZWNpbWFsKG4pLCBzZCwgMSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgSXMgcm0gPiAzIGFuZCB0aGUgZmlyc3QgNCByb3VuZGluZyBkaWdpdHMgNDk5OSwgb3Igcm0gPCA0IChvciB0aGUgc3VtbWF0aW9uIGhhc1xyXG4gICAgICAgICAgICAgICAgIGJlZW4gcmVwZWF0ZWQgcHJldmlvdXNseSkgYW5kIHRoZSBmaXJzdCA0IHJvdW5kaW5nIGRpZ2l0cyA5OTk5P1xyXG5cclxuICAgICAgICAgICAgICAgICBJZiBzbywgcmVzdGFydCB0aGUgc3VtbWF0aW9uIHdpdGggYSBoaWdoZXIgcHJlY2lzaW9uLCBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgICBFLmcuIHdpdGggcHJlY2lzaW9uOiAxMiwgcm91bmRpbmc6IDFcclxuICAgICAgICAgICAgICAgICBsbigxMzU1MjAwMjguNjEyNjA5MTcxNDI2NTM4MTUzMykgPSAxOC43MjQ2Mjk5OTk5IHdoZW4gaXQgc2hvdWxkIGJlIDE4LjcyNDYzLlxyXG5cclxuICAgICAgICAgICAgICAgICBzZCAtIGd1YXJkIGlzIHRoZSBpbmRleCBvZiBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKCBwciA9PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNoZWNrUm91bmRpbmdEaWdpdHMoIHN1bVsnYyddLCBzZCAtIGd1YXJkLCBybSwgcmVwICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlY2ltYWxbJ3ByZWNpc2lvbiddID0gc2QgKz0gZ3VhcmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBudW0gPSB4ID0gZGl2KCB4MVsnbWludXMnXShvbmUpLCB4MVsncGx1cyddKG9uZSksIHNkLCAxICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gcm5kKCB4Wyd0aW1lcyddKHgpLCBzZCwgMSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5vbSA9IHJlcCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBybmQoIHN1bSwgRGVjaW1hbFsncHJlY2lzaW9uJ10gPSBwcmVjaXNpb24sIHJtLCBleHRlcm5hbCA9IHRydWUgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIERlY2ltYWxbJ3ByZWNpc2lvbiddID0gcHJlY2lzaW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdW0gPSB0O1xyXG4gICAgICAgICAgICBkZW5vbSArPSAyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgKi9cclxuICAgICBmdW5jdGlvbiBybmQoIHgsIHNkLCBybSwgciApIHtcclxuICAgICAgICB2YXIgZGlnaXRzLCBpLCBqLCBrLCBuLCByZCwgeGMsIHhjaSxcclxuICAgICAgICAgICAgRGVjaW1hbCA9IHhbJ2NvbnN0cnVjdG9yJ107XHJcblxyXG4gICAgICAgIC8vIERvbid0IHJvdW5kIGlmIHNkIGlzIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gICAgICAgIHI6IGlmICggc2QgIT0gaSApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEluZmluaXR5L05hTi5cclxuICAgICAgICAgICAgaWYgKCAhKCB4YyA9IHhbJ2MnXSApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgcmQsIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAsXHJcbiAgICAgICAgICAgICBuLCBhIGJhc2UgMWU3IG51bWJlciwgdGhlIGVsZW1lbnQgb2YgeGMgY29udGFpbmluZyByZCxcclxuICAgICAgICAgICAgIHhjaSwgdGhlIGluZGV4IG9mIG4gd2l0aGluIHhjLFxyXG4gICAgICAgICAgICAgZGlnaXRzLCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLFxyXG4gICAgICAgICAgICAgaSwgd2hhdCB3b3VsZCBiZSB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaWYgYWxsIHRoZSBudW1iZXJzIHdlcmUgNyBkaWdpdHMgbG9uZyAoaS5lLiB0aGV5IGhhZCBsZWFkaW5nIHplcm9zKVxyXG4gICAgICAgICAgICAgaiwgaWYgPiAwLCB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKSxcclxuICAgICAgICAgICAgIG5MZWFkaW5nWmVyb3MsIHRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBuIHdvdWxkIGhhdmUgaWYgaXQgd2VyZSA3IGRpZ2l0cyBsb25nLlxyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheSB4Yy5cclxuICAgICAgICAgICAgZm9yICggZGlnaXRzID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkaWdpdHMrKyApO1xyXG5cclxuICAgICAgICAgICAgaSA9IHNkIC0gZGlnaXRzO1xyXG5cclxuICAgICAgICAgICAgLy8gSXMgdGhlIHJvdW5kaW5nIGRpZ2l0IGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjP1xyXG4gICAgICAgICAgICBpZiAoIGkgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgaSArPSBMT0dCQVNFO1xyXG4gICAgICAgICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgICAgICAgbiA9IHhjWyB4Y2kgPSAwIF07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgICByZCA9IG4gLyBtYXRocG93KCAxMCwgZGlnaXRzIC0gaiAtIDEgKSAlIDEwIHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjaSA9IE1hdGguY2VpbCggKCBpICsgMSApIC8gTE9HQkFTRSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggeGNpID49IHhjLmxlbmd0aCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBleHAsIGxuIGFuZCBzcXJ0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IHhjLmxlbmd0aCA8PSB4Y2k7IHhjLnB1c2goMCkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0cyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgJT0gTE9HQkFTRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dCQVNFICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuID0gayA9IHhjW3hjaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGRpZ2l0cyA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGRpZ2l0cysrICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgICAgICAgaSAlPSBMT0dCQVNFO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dCQVNFIC0gZGlnaXRzLlxyXG4gICAgICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HQkFTRSArIGRpZ2l0cztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmxvb3IgdXNpbmcgTWF0aC5mbG9vciBpbnN0ZWFkIG9mIHwgMCBhcyByZCBtYXkgYmUgb3V0c2lkZSBpbnQgcmFuZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBtYXRoZmxvb3IoIG4gLyBtYXRocG93KCAxMCwgZGlnaXRzIC0gaiAtIDEgKSAlIDEwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG4gICAgICAgICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAgICAgICB4Y1t4Y2kgKyAxXSAhPSBudWxsIHx8ICggaiA8IDAgPyBuIDogbiAlIG1hdGhwb3coIDEwLCBkaWdpdHMgLSBqIC0gMSApICk7XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgVGhlIGV4cHJlc3Npb24gIG4gJSBtYXRocG93KCAxMCwgZGlnaXRzIC0gaiAtIDEgKSAgcmV0dXJucyBhbGwgdGhlIGRpZ2l0cyBvZiBuIHRvIHRoZVxyXG4gICAgICAgICAgICAgcmlnaHQgb2YgdGhlIGRpZ2l0IGF0IChsZWZ0LXRvLXJpZ2h0KSBpbmRleCBqLFxyXG4gICAgICAgICAgICAgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiB3aWxsIGdpdmUgNzE0LlxyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICAgICA/ICggcmQgfHwgciApICYmICggcm0gPT0gMCB8fCBybSA9PSAoIHhbJ3MnXSA8IDAgPyAzIDogMiApIClcclxuICAgICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmICggcm0gPT0gNCB8fCByIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgICAgICAgcm0gPT0gNiAmJiAoICggaSA+IDAgPyBqID4gMCA/IG4gLyBtYXRocG93KCAxMCwgZGlnaXRzIC0gaiApIDogMCA6IHhjW3hjaSAtIDFdICkgJSAxMCApICYgMSB8fFxyXG4gICAgICAgICAgICAgICAgICBybSA9PSAoIHhbJ3MnXSA8IDAgPyA4IDogNyApICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHNkIDwgMSB8fCAheGNbMF0gKSB7XHJcbiAgICAgICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgc2QgLT0geFsnZSddICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICAgICAgICB4Y1swXSA9IG1hdGhwb3coIDEwLCBzZCAlIExPR0JBU0UgKTtcclxuICAgICAgICAgICAgICAgICAgICB4WydlJ10gPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgICAgICAgeGNbMF0gPSB4WydlJ10gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuXHJcbiAgICAgICAgICAgIGlmICggaSA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgeGMubGVuZ3RoID0geGNpO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgICB4Y2ktLTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjLmxlbmd0aCA9IHhjaSArIDE7XHJcbiAgICAgICAgICAgICAgICBrID0gbWF0aHBvdyggMTAsIExPR0JBU0UgLSBpICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgICAgICB4Y1t4Y2ldID0gaiA+IDAgPyAoIG4gLyBtYXRocG93KCAxMCwgZGlnaXRzIC0gaiApICUgbWF0aHBvdyggMTAsIGogKSB8IDAgKSAqIGsgOiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IDsgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElzIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggeGNpID09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKysgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSAhPSBrICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFsnZSddKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB4Y1swXSA9PSBCQVNFICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGNbeGNpXSArPSBrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB4Y1t4Y2ldICE9IEJBU0UgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjW3hjaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICBmb3IgKCBpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV4dGVybmFsKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICAgICAgaWYgKCB4WydlJ10gPiBEZWNpbWFsWydtYXhFJ10gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAgICB4WydjJ10gPSB4WydlJ10gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB4WydlJ10gPCBEZWNpbWFsWydtaW5FJ10gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICAgIHhbJ2MnXSA9IFsgeFsnZSddID0gMCBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgRGVjaW1hbENvbnN0cnVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcblxyXG4gICAgICAgIC8vIFByaXZhdGUgZnVuY3Rpb25zIHVzZWQgYnkgc3RhdGljIERlY2ltYWwgbWV0aG9kcy5cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogIFRoZSBmb2xsb3dpbmcgZW11bGF0aW9ucyBvciB3cmFwcGVycyBvZiBNYXRoIG9iamVjdCBmdW5jdGlvbnMgYXJlIGN1cnJlbnRseVxyXG4gICAgICAgICAqICBjb21tZW50ZWQtb3V0IGFuZCBub3QgaW4gdGhlIHB1YmxpYyBBUEkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgYWJzXHJcbiAgICAgICAgICogIGFjb3NcclxuICAgICAgICAgKiAgYXNpblxyXG4gICAgICAgICAqICBhdGFuXHJcbiAgICAgICAgICogIGF0YW4yXHJcbiAgICAgICAgICogIGNlaWxcclxuICAgICAgICAgKiAgY29zXHJcbiAgICAgICAgICogIGZsb29yXHJcbiAgICAgICAgICogIHJvdW5kXHJcbiAgICAgICAgICogIHNpblxyXG4gICAgICAgICAqICB0YW5cclxuICAgICAgICAgKiAgdHJ1bmNcclxuICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIG4uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICAgICAgICpcclxuICAgICAgICBmdW5jdGlvbiBhYnMobikgeyByZXR1cm4gbmV3IHRoaXMobilbJ2FicyddKCkgfVxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjY29zaW5lIGluIHJhZGlhbnMgb2Ygbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIG4ge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgICAgICAgKlxyXG4gICAgICAgIGZ1bmN0aW9uIGFjb3MobikgeyByZXR1cm4gbmV3IHRoaXMoIE1hdGguYWNvcyhuKSArICcnICkgfVxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjc2luZSBpbiByYWRpYW5zIG9mIG4uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICAgICAgICpcclxuICAgICAgICBmdW5jdGlvbiBhc2luKG4pIHsgcmV0dXJuIG5ldyB0aGlzKCBNYXRoLmFzaW4obikgKyAnJyApIH1cclxuICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY3RhbmdlbnQgaW4gcmFkaWFucyBvZiBuLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogbiB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgZnVuY3Rpb24gYXRhbihuKSB7IHJldHVybiBuZXcgdGhpcyggTWF0aC5hdGFuKG4pICsgJycgKSB9XHJcbiAgICAgICAgICovXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IGluIHJhZGlhbnMgb2YgeS94IGluIHRoZSByYW5nZVxyXG4gICAgICAgICAqIC1QSSB0byBQSSAoaW5jbHVzaXZlKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIHktY29vcmRpbmF0ZS5cclxuICAgICAgICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSB4LWNvb3JkaW5hdGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICBmdW5jdGlvbiBhdGFuMiggeSwgeCApIHsgcmV0dXJuIG5ldyB0aGlzKCBNYXRoLmF0YW4yKCB5LCB4ICkgKyAnJyApIH1cclxuICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgbiByb3VuZCB0byBhbiBpbnRlZ2VyIHVzaW5nIFJPVU5EX0NFSUwuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICAgICAgICpcclxuICAgICAgICBmdW5jdGlvbiBjZWlsKG4pIHsgcmV0dXJuIG5ldyB0aGlzKG4pWydjZWlsJ10oKSB9XHJcbiAgICAgICAgICovXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIENvbmZpZ3VyZSBnbG9iYWwgc2V0dGluZ3MgZm9yIGEgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIG9iaiBpcyBhbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzLFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICBwcmVjaXNpb24gIHtudW1iZXJ9XHJcbiAgICAgICAgICogICByb3VuZGluZyAgIHtudW1iZXJ9XHJcbiAgICAgICAgICogICB0b0V4cE5lZyAgIHtudW1iZXJ9XHJcbiAgICAgICAgICogICB0b0V4cFBvcyAgIHtudW1iZXJ9XHJcbiAgICAgICAgICogICBtaW5FICAgICAgIHtudW1iZXJ9XHJcbiAgICAgICAgICogICBtYXhFICAgICAgIHtudW1iZXJ9XHJcbiAgICAgICAgICogICBlcnJvcnMgICAgIHtib29sZWFufG51bWJlcn1cclxuICAgICAgICAgKiAgIGNyeXB0byAgICAge2Jvb2xlYW58bnVtYmVyfVxyXG4gICAgICAgICAqICAgbW9kdWxvICAgICB7bnVtYmVyfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogRS5nLlxyXG4gICAgICAgICAqICAgRGVjaW1hbC5jb25maWcoeyBwcmVjaXNpb246IDIwLCByb3VuZGluZzogNCB9KVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gY29uZmlnKG9iaikge1xyXG4gICAgICAgICAgICB2YXIgcCwgdSwgdixcclxuICAgICAgICAgICAgICAgIERlY2ltYWwgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYyA9ICdjb25maWcnLFxyXG4gICAgICAgICAgICAgICAgcGFyc2UgPSBEZWNpbWFsWydlcnJvcnMnXSA/IHBhcnNlSW50IDogcGFyc2VGbG9hdDtcclxuXHJcbiAgICAgICAgICAgIGlmICggb2JqID09IHUgfHwgdHlwZW9mIG9iaiAhPSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICFpZkV4Y2VwdGlvbnNUaHJvdyggRGVjaW1hbCwgJ29iamVjdCBleHBlY3RlZCcsIG9iaiwgYyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNpbWFsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBwcmVjaXNpb24ge251bWJlcnxudW1iZXJbXX0gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgaWYgKCAoIHYgPSBvYmpbIHAgPSAncHJlY2lzaW9uJyBdICkgIT0gdSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICEoIG91dE9mUmFuZ2UgPSB2IDwgMSB8fCB2ID4gTUFYX0RJR0lUUyApICYmIHBhcnNlKHYpID09IHYgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVjaW1hbFtwXSA9IHYgfCAwO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2NvbmZpZygpIHByZWNpc2lvbiBub3QgYW4gaW50ZWdlcjoge3Z9J1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICdjb25maWcoKSBwcmVjaXNpb24gb3V0IG9mIHJhbmdlOiB7dn0nXHJcbiAgICAgICAgICAgICAgICAgICAgaWZFeGNlcHRpb25zVGhyb3coIERlY2ltYWwsIHAsIHYsIGMsIDAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gcm91bmRpbmcge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgaWYgKCAoIHYgPSBvYmpbIHAgPSAncm91bmRpbmcnIF0gKSAhPSB1ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggISggb3V0T2ZSYW5nZSA9IHYgPCAwIHx8IHYgPiA4ICkgJiYgcGFyc2UodikgPT0gdiApIHtcclxuICAgICAgICAgICAgICAgICAgICBEZWNpbWFsW3BdID0gdiB8IDA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAnY29uZmlnKCkgcm91bmRpbmcgbm90IGFuIGludGVnZXI6IHt2fSdcclxuICAgICAgICAgICAgICAgICAgICAvLyAnY29uZmlnKCkgcm91bmRpbmcgb3V0IG9mIHJhbmdlOiB7dn0nXHJcbiAgICAgICAgICAgICAgICAgICAgaWZFeGNlcHRpb25zVGhyb3coIERlY2ltYWwsIHAsIHYsIGMsIDAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdG9FeHBOZWcge251bWJlcn0gSW50ZWdlciwgLUVYUF9MSU1JVCB0byAwIGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgaWYgKCAoIHYgPSBvYmpbIHAgPSAndG9FeHBOZWcnIF0gKSAhPSB1ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggISggb3V0T2ZSYW5nZSA9IHYgPCAtRVhQX0xJTUlUIHx8IHYgPiAwICkgJiYgcGFyc2UodikgPT0gdiApIHtcclxuICAgICAgICAgICAgICAgICAgICBEZWNpbWFsW3BdID0gbWF0aGZsb29yKHYpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2NvbmZpZygpIHRvRXhwTmVnIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2NvbmZpZygpIHRvRXhwTmVnIG91dCBvZiByYW5nZToge3Z9J1xyXG4gICAgICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBEZWNpbWFsLCBwLCB2LCBjLCAwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHRvRXhwUG9zIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gRVhQX0xJTUlUIGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgaWYgKCAoIHYgPSBvYmpbIHAgPSAndG9FeHBQb3MnIF0gKSAhPSB1ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggISggb3V0T2ZSYW5nZSA9IHYgPCAwIHx8IHYgPiBFWFBfTElNSVQgKSAmJiBwYXJzZSh2KSA9PSB2ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIERlY2ltYWxbcF0gPSBtYXRoZmxvb3Iodik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAnY29uZmlnKCkgdG9FeHBQb3Mgbm90IGFuIGludGVnZXI6IHt2fSdcclxuICAgICAgICAgICAgICAgICAgICAvLyAnY29uZmlnKCkgdG9FeHBQb3Mgb3V0IG9mIHJhbmdlOiB7dn0nXHJcbiAgICAgICAgICAgICAgICAgICAgaWZFeGNlcHRpb25zVGhyb3coIERlY2ltYWwsIHAsIHYsIGMsIDAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgIC8vIG1pbkUge251bWJlcn0gSW50ZWdlciwgLUVYUF9MSU1JVCB0byAwIGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgaWYgKCAoIHYgPSBvYmpbIHAgPSAnbWluRScgXSApICE9IHUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhKCBvdXRPZlJhbmdlID0gdiA8IC1FWFBfTElNSVQgfHwgdiA+IDAgKSAmJiBwYXJzZSh2KSA9PSB2ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIERlY2ltYWxbcF0gPSBtYXRoZmxvb3Iodik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAnY29uZmlnKCkgbWluRSBub3QgYW4gaW50ZWdlcjoge3Z9J1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICdjb25maWcoKSBtaW5FIG91dCBvZiByYW5nZToge3Z9J1xyXG4gICAgICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBEZWNpbWFsLCBwLCB2LCBjLCAwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIG1heEUge251bWJlcn0gSW50ZWdlciwgMCB0byBFWFBfTElNSVQgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgICBpZiAoICggdiA9IG9ialsgcCA9ICdtYXhFJyBdICkgIT0gdSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICEoIG91dE9mUmFuZ2UgPSB2IDwgMCB8fCB2ID4gRVhQX0xJTUlUICkgJiYgcGFyc2UodikgPT0gdiApIHtcclxuICAgICAgICAgICAgICAgICAgICBEZWNpbWFsW3BdID0gbWF0aGZsb29yKHYpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2NvbmZpZygpIG1heEUgbm90IGFuIGludGVnZXI6IHt2fSdcclxuICAgICAgICAgICAgICAgICAgICAvLyAnY29uZmlnKCkgbWF4RSBvdXQgb2YgcmFuZ2U6IHt2fSdcclxuICAgICAgICAgICAgICAgICAgICBpZkV4Y2VwdGlvbnNUaHJvdyggRGVjaW1hbCwgcCwgdiwgYywgMCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBlcnJvcnMge2Jvb2xlYW58bnVtYmVyfSB0cnVlLCBmYWxzZSwgMSBvciAwLlxyXG4gICAgICAgICAgICBpZiAoICggdiA9IG9ialsgcCA9ICdlcnJvcnMnIF0gKSAhPSB1ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdiA9PT0gISF2IHx8IHYgPT09IDEgfHwgdiA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRPZlJhbmdlID0gaWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIERlY2ltYWxbcF0gPSAhIXY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAnY29uZmlnKCkgZXJyb3JzIG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0OiB7dn0nXHJcbiAgICAgICAgICAgICAgICAgICAgaWZFeGNlcHRpb25zVGhyb3coIERlY2ltYWwsIHAsIHYsIGMsIDEgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY3J5cHRvIHtib29sZWFufG51bWJlcn0gdHJ1ZSwgZmFsc2UsIDEgb3IgMC5cclxuICAgICAgICAgICAgaWYgKCAoIHYgPSBvYmpbIHAgPSAnY3J5cHRvJyBdICkgIT0gdSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHYgPT09ICEhdiB8fCB2ID09PSAxIHx8IHYgPT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVjaW1hbFtwXSA9ICEhKCB2ICYmIGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvID09ICdvYmplY3QnICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAnY29uZmlnKCkgY3J5cHRvIG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0OiB7dn0nXHJcbiAgICAgICAgICAgICAgICAgICAgaWZFeGNlcHRpb25zVGhyb3coIERlY2ltYWwsIHAsIHYsIGMsIDEgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gbW9kdWxvIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAgIGlmICggKCB2ID0gb2JqWyBwID0gJ21vZHVsbycgXSApICE9IHUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhKCBvdXRPZlJhbmdlID0gdiA8IDAgfHwgdiA+IDkgKSAmJiBwYXJzZSh2KSA9PSB2ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIERlY2ltYWxbcF0gPSB2IHwgMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vICdjb25maWcoKSBtb2R1bG8gbm90IGFuIGludGVnZXI6IHt2fSdcclxuICAgICAgICAgICAgICAgICAgICAvLyAnY29uZmlnKCkgbW9kdWxvIG91dCBvZiByYW5nZToge3Z9J1xyXG4gICAgICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBEZWNpbWFsLCBwLCB2LCBjLCAwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBEZWNpbWFsO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGNvc2luZSBvZiBuLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogbiB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIG51bWJlciBnaXZlbiBpbiByYWRpYW5zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgZnVuY3Rpb24gY29zKG4pIHsgcmV0dXJuIG5ldyB0aGlzKCBNYXRoLmNvcyhuKSArICcnICkgfVxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgZXhwb25lbnRpYWwgb2YgbixcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIG4ge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIHBvd2VyIHRvIHdoaWNoIHRvIHJhaXNlIHRoZSBiYXNlIG9mIHRoZSBuYXR1cmFsIGxvZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGV4cChuKSB7IHJldHVybiBuZXcgdGhpcyhuKVsnZXhwJ10oKSB9XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIG4gcm91bmQgdG8gYW4gaW50ZWdlciB1c2luZyBST1VORF9GTE9PUi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIG4ge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgICAgICAgKlxyXG4gICAgICAgIGZ1bmN0aW9uIGZsb29yKG4pIHsgcmV0dXJuIG5ldyB0aGlzKG4pWydmbG9vciddKCkgfVxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2Ygbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIG4ge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGxuKG4pIHsgcmV0dXJuIG5ldyB0aGlzKG4pWydsbiddKCkgfVxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbG9nIG9mIHggdG8gdGhlIGJhc2UgeSwgb3IgdG8gYmFzZSAxMCBpZiBub1xyXG4gICAgICAgICAqIGJhc2UgaXMgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogbG9nW3ldKHgpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBhcmd1bWVudCBvZiB0aGUgbG9nYXJpdGhtLlxyXG4gICAgICAgICAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIGJhc2Ugb2YgdGhlIGxvZ2FyaXRobS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGxvZyggeCwgeSApIHsgcmV0dXJuIG5ldyB0aGlzKHgpWydsb2cnXSh5KSB9XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIEhhbmRsZSBtYXggYW5kIG1pbi4gbHRndCBpcyAnbHQnIG9yICdndCcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbWF4T3JNaW4oIERlY2ltYWwsIGFyZ3MsIGx0Z3QgKSB7XHJcbiAgICAgICAgICAgIHZhciBtLCBuLFxyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRvU3RyaW5nLmNhbGwoIGFyZ3NbMF0gKSA9PSAnW29iamVjdCBBcnJheV0nICkge1xyXG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG0gPSBuZXcgRGVjaW1hbCggYXJnc1swXSApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggOyArK2kgPCBhcmdzLmxlbmd0aDsgKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbmV3IERlY2ltYWwoIGFyZ3NbaV0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoICFuWydzJ10gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IG47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbVtsdGd0XShuKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBtYXgoKSB7IHJldHVybiBtYXhPck1pbiggdGhpcywgYXJndW1lbnRzLCAnbHQnICkgfVxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBtaW4oKSB7IHJldHVybiBtYXhPck1pbiggdGhpcywgYXJndW1lbnRzLCAnZ3QnICkgfVxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBQYXJzZSB0aGUgdmFsdWUgb2YgYSBuZXcgRGVjaW1hbCBmcm9tIGEgbnVtYmVyIG9yIHN0cmluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgcGFyc2VEZWNpbWFsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSAvXi0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSxcclxuICAgICAgICAgICAgICAgIHRyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW0gfHwgZnVuY3Rpb24gKCkge3JldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKX07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCBEZWNpbWFsLCB4LCBuLCBiICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQsIGUsIGksIGlzTnVtLCBvcmlnLCB2YWxpZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBuICE9ICdzdHJpbmcnICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtb2RpZnkgc28gcmVnZXggdGVzdCBiZWxvdyBpcyBhdm9pZGVkIGlmIHR5cGUgaXMgbnVtYmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgYSBudW1iZXIsIGNoZWNrIGlmIG1pbnVzIHplcm8uXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9ICggaXNOdW0gPSB0eXBlb2YgbiA9PSAnbnVtYmVyJyB8fCB0b1N0cmluZy5jYWxsKG4pID09ICdbb2JqZWN0IE51bWJlcl0nICkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9PT0gMCAmJiAxIC8gbiA8IDAgPyAnLTAnIDogbiArICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3JpZyA9IG47XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBiID09IGUgJiYgaXNWYWxpZC50ZXN0KG4pICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi5cclxuICAgICAgICAgICAgICAgICAgICB4WydzJ10gPSBuLmNoYXJBdCgwKSA9PSAnLScgPyAoIG4gPSBuLnNsaWNlKDEpLCAtMSApIDogMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgbiBpcyBub3QgYSB2YWxpZCBEZWNpbWFsIG9yIGEgYmFzZSBoYXMgYmVlbiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICBFbmFibGUgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgIEVuc3VyZSByZXR1cm4gdmFsdWUgaXMgcm91bmRlZCB0byBwcmVjaXNpb24gYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGIgPT0gMTAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm5kKCBuZXcgRGVjaW1hbChuKSwgRGVjaW1hbFsncHJlY2lzaW9uJ10sIERlY2ltYWxbJ3JvdW5kaW5nJ10gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSB0cmltLmNhbGwobikucmVwbGFjZSggL15cXCsoPyEtKS8sICcnICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHhbJ3MnXSA9IG4uY2hhckF0KDApID09ICctJyA/ICggbiA9IG4ucmVwbGFjZSggL14tKD8hLSkvLCAnJyApLCAtMSApIDogMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBiICE9IGUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggYiA9PSAoYiB8IDApIHx8ICFEZWNpbWFsWydlcnJvcnMnXSApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgISggb3V0T2ZSYW5nZSA9ICEoIGIgPj0gMiAmJiBiIDwgNjUgKSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9ICdbJyArIE5VTUVSQUxTLnNsaWNlKCAwLCBiID0gYiB8IDAgKSArICddKyc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGAuYCBmcm9tIGUuZy4gJzEuJywgYW5kIHJlcGxhY2UgZS5nLiAnLjEnIHdpdGggJzAuMScuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbi5yZXBsYWNlKCAvXFwuJC8sICcnICkucmVwbGFjZSggL15cXC4vLCAnMC4nICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW55IG51bWJlciBpbiBleHBvbmVudGlhbCBmb3JtIHdpbGwgZmFpbCBkdWUgdG8gdGhlIGUrLy0uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbGlkID0gbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ14nICsgZCArICcoPzpcXFxcLicgKyBkICsgJyk/JCcsIGIgPCAzNyA/ICdpJyA6ICcnICkudGVzdChuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuLnJlcGxhY2UoIC9eMFxcLjAqfFxcLi8sICcnICkubGVuZ3RoID4gMTUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ3ttZXRob2R9IG51bWJlciB0eXBlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZkV4Y2VwdGlvbnNUaHJvdyggRGVjaW1hbCwgMCwgb3JpZyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSAhaXNOdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBjb252ZXJ0QmFzZSggRGVjaW1hbCwgbiwgMTAsIGIsIHhbJ3MnXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG4gIT0gJ0luZmluaXR5JyAmJiBuICE9ICdOYU4nICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAne21ldGhvZH0gbm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZFeGNlcHRpb25zVGhyb3coIERlY2ltYWwsICdub3QgYSBiYXNlICcgKyBiICsgJyBudW1iZXInLCBvcmlnICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9ICdOYU4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICd7bWV0aG9kfSBiYXNlIG5vdCBhbiBpbnRlZ2VyOiB7Yn0nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAne21ldGhvZH0gYmFzZSBvdXQgb2YgcmFuZ2U6IHtifSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBEZWNpbWFsLCAnYmFzZScsIGIsIDAsIDAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYmFzZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gaXNWYWxpZC50ZXN0KG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBpc1ZhbGlkLnRlc3Qobik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICF2YWxpZCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4WydjJ10gPSB4WydlJ10gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbiAhPSAnSW5maW5pdHknICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiBOYU4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG4gIT0gJ05hTicgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICd7bWV0aG9kfSBub3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZkV4Y2VwdGlvbnNUaHJvdyggRGVjaW1hbCwgJ25vdCBhIG51bWJlcicsIG9yaWcgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhbJ3MnXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgICAgICAgICBpZiAoICggZSA9IG4uaW5kZXhPZignLicpICkgPiAtMSApIHtcclxuICAgICAgICAgICAgICAgICAgICBuID0gbi5yZXBsYWNlKCAnLicsICcnICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgICAgICAgICAgIGlmICggKCBpID0gbi5zZWFyY2goIC9lL2kgKSApID4gMCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZSA8IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlICs9ICtuLnNsaWNlKCBpICsgMSApO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLnN1YnN0cmluZyggMCwgaSApO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBuLmNoYXJBdChpKSA9PSAnMCc7IGkrKyApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIGZvciAoIGIgPSBuLmxlbmd0aDsgbi5jaGFyQXQoLS1iKSA9PSAnMCc7ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgbiA9IG4uc2xpY2UoIGksIGIgKyAxICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG4pIHtcclxuICAgICAgICAgICAgICAgICAgICBiID0gbi5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERpc2FsbG93IG51bWJlcnMgd2l0aCBvdmVyIDE1IHNpZ25pZmljYW50IGRpZ2l0cyBpZiBudW1iZXIgdHlwZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzTnVtICYmIGIgPiAxNSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICd7bWV0aG9kfSBudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZkV4Y2VwdGlvbnNUaHJvdyggRGVjaW1hbCwgMCwgb3JpZyApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeFsnZSddID0gZSA9IGUgLSBpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB4WydjJ10gPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIG4gdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgICAgICAgICAgICBpID0gKCBlICsgMSApICUgTE9HQkFTRTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlIDwgMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBMT0dCQVNFO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYiBpcyBuLmxlbmd0aC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPCBiICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhbJ2MnXS5wdXNoKCArbi5zbGljZSggMCwgaSApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGIgLT0gTE9HQkFTRTsgaSA8IGI7ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFsnYyddLnB1c2goICtuLnNsaWNlKCBpLCBpICs9IExPR0JBU0UgKSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gbi5zbGljZShpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IExPR0JBU0UgLSBuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpIC09IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGktLTsgbiArPSAnMCcgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeFsnYyddLnB1c2goICtuICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeFsnZSddID4gRGVjaW1hbFsnbWF4RSddICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFsnYyddID0geFsnZSddID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggeFsnZSddIDwgRGVjaW1hbFsnbWluRSddICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4WydjJ10gPSBbIHhbJ2UnXSA9IDAgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgICAgICAgeFsnYyddID0gWyB4WydlJ10gPSAwIF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgeCByYWlzZWQgdG8gdGhlIHBvd2VyIHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBiYXNlLlxyXG4gICAgICAgICAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcG93KCB4LCB5ICkgeyByZXR1cm4gbmV3IHRoaXMoeClbJ3BvdyddKHkpIH1cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBEZWNpbWFsIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLCBhbmRcclxuICAgICAgICAgKiB3aXRoIGRwLCBvciBEZWNpbWFsLnByZWNpc2lvbiBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tKGRwKSB7XHJcbiAgICAgICAgICAgIHZhciBhLCBuLCB2LFxyXG4gICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICByID0gW10sXHJcbiAgICAgICAgICAgICAgICBEZWNpbWFsID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIHJhbmQgPSBuZXcgRGVjaW1hbCggRGVjaW1hbFsnT05FJ10gKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggZHAgPT0gbnVsbCB8fCAhY2hlY2tBcmcoIHJhbmQsIGRwLCAncmFuZG9tJyApICkge1xyXG4gICAgICAgICAgICAgICAgZHAgPSBEZWNpbWFsWydwcmVjaXNpb24nXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRwIHw9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG4gPSBNYXRoLmNlaWwoIGRwIC8gTE9HQkFTRSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBEZWNpbWFsWydjcnlwdG8nXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGNyeXB0byAmJiBjcnlwdG9bJ2dldFJhbmRvbVZhbHVlcyddICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhID0gY3J5cHRvWydnZXRSYW5kb21WYWx1ZXMnXSggbmV3IFVpbnQzMkFycmF5KG4pICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IG47ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gYVtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPj0gdiA8IDQyOTQ5NjcyOTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDQuMjllOSwgaXMgNDk2NzI5NiAvIDQyOTQ5NjcyOTYgPSAwLjAwMTE2ICgxIGluIDg2NSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdiA+PSA0LjI5ZTkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IGNyeXB0b1snZ2V0UmFuZG9tVmFsdWVzJ10oIG5ldyBVaW50MzJBcnJheSgxKSApWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA0Mjg5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9ICggdiAlIDFlNyApIDw9IDk5OTk5OTlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbaSsrXSA9IHYgJSAxZTc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNyeXB0byAmJiBjcnlwdG9bJ3JhbmRvbUJ5dGVzJ10gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBjcnlwdG9bJ3JhbmRvbUJ5dGVzJ10oIG4gKj0gNCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBuOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDIxNDc0ODM2NDhcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGFbaV0gKyAoIGFbaSArIDFdIDw8IDggKSArICggYVtpICsgMl0gPDwgMTYgKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoICggYVtpICsgM10gJiAweDdmICkgPDwgMjQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSAyLjE0ZTksIGlzIDc0ODM2NDggLyAyMTQ3NDgzNjQ4ID0gMC4wMDM1ICgxIGluIDI4NikuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdiA+PSAyLjE0ZTkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcnlwdG9bJ3JhbmRvbUJ5dGVzJ10oNCkuY29weSggYSwgaSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA0Mjg5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9ICggdiAlIDFlNyApIDw9IDk5OTk5OTlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucHVzaCggdiAlIDFlNyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBuIC8gNDtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBEZWNpbWFsLCAnY3J5cHRvIHVuYXZhaWxhYmxlJywgY3J5cHRvLCAncmFuZG9tJyApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb206IGVpdGhlciBEZWNpbWFsLmNyeXB0byBpcyBmYWxzZSBvciBjcnlwdG8gaXMgdW5hdmFpbGFibGUgYW5kIGVycm9ycyBpcyBmYWxzZS5cclxuICAgICAgICAgICAgaWYgKCFpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbjsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcltpKytdID0gTWF0aC5yYW5kb20oKSAqIDFlNyB8IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG4gPSByWy0taV07XHJcbiAgICAgICAgICAgIGRwICU9IExPR0JBU0U7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgICAgICAgIGlmICggbiAmJiBkcCApIHtcclxuICAgICAgICAgICAgICAgIHYgPSBtYXRocG93KCAxMCwgTE9HQkFTRSAtIGRwICk7XHJcbiAgICAgICAgICAgICAgICByW2ldID0gKCBuIC8gdiB8IDAgKSAqIHY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cclxuICAgICAgICAgICAgZm9yICggOyByW2ldID09PSAwOyBpLS0gKSB7XHJcbiAgICAgICAgICAgICAgICByLnBvcCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgICAgICBpZiAoIGkgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgciA9IFsgbiA9IDAgXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG4gPSAtMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICAgICAgZm9yICggOyByWzBdID09PSAwOyApIHtcclxuICAgICAgICAgICAgICAgICAgICByLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbiAtPSBMT0dCQVNFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgciB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAxLCB2ID0gclswXTsgdiA+PSAxMDsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiAvPSAxMDtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSBleHBvbmVudCBmb3IgbGVhZGluZyB6ZXJvcyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiByLlxyXG4gICAgICAgICAgICAgICAgaWYgKCBpIDwgTE9HQkFTRSApIHtcclxuICAgICAgICAgICAgICAgICAgICBuIC09IExPR0JBU0UgLSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByYW5kWydlJ10gPSBuO1xyXG4gICAgICAgICAgICByYW5kWydjJ10gPSByO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBuIHJvdW5kIHRvIGFuIGludGVnZXIgdXNpbmcgcm91bmRpbmcgbW9kZSByb3VuZGluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRvIGVtdWxhdGUgTWF0aC5yb3VuZCwgc2V0IHJvdW5kaW5nIHRvIDcgKFJPVU5EX0hBTEZfQ0VJTCkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAgICAgICAgICpcclxuICAgICAgICBmdW5jdGlvbiByb3VuZChuKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gbmV3IHRoaXMobik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcm5kKCB4LCB4WydlJ10gKyAxLCB0aGlzWydyb3VuZGluZyddICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc2luZSBvZiBuLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogbiB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIG51bWJlciBnaXZlbiBpbiByYWRpYW5zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgZnVuY3Rpb24gc2luKG4pIHsgcmV0dXJuIG5ldyB0aGlzKCBNYXRoLnNpbihuKSArICcnICkgfVxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2Ygbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIG4ge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHNxcnQobikgeyByZXR1cm4gbmV3IHRoaXMobilbJ3NxcnQnXSgpIH1cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHRhbmdlbnQgb2Ygbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIG4ge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSBudW1iZXIgZ2l2ZW4gaW4gcmFkaWFucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgIGZ1bmN0aW9uIHRhbihuKSB7IHJldHVybiBuZXcgdGhpcyggTWF0aC50YW4obikgKyAnJyApIH1cclxuICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgbiB0cnVuY2F0ZWQgdG8gYW4gaW50ZWdlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIG4ge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICAgICAgICAgKlxyXG4gICAgICAgIGZ1bmN0aW9uIHRydW5jKG4pIHsgcmV0dXJuIG5ldyB0aGlzKG4pWyd0cnVuYyddKCkgfVxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBEZWNpbWFsIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRGVjaW1hbEZhY3Rvcnkob2JqKSB7XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBUaGUgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBEZWNpbWFsIG9iamVjdC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogbiB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgICAgICAgICAqIFtiXSB7bnVtYmVyfSBUaGUgYmFzZSBvZiBuLiBJbnRlZ2VyLCAyIHRvIDY0IGluY2x1c2l2ZS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIERlY2ltYWwoIG4sIGIgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0b3IgY2FsbGVkIHdpdGhvdXQgbmV3LlxyXG4gICAgICAgICAgICAgICAgaWYgKCAhKCB4IGluc3RhbmNlb2YgRGVjaW1hbCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmRXhjZXB0aW9uc1Rocm93KCBEZWNpbWFsLCAnRGVjaW1hbCBjYWxsZWQgd2l0aG91dCBuZXcnLCBuICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbCggbiwgYiApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIER1cGxpY2F0ZS5cclxuICAgICAgICAgICAgICAgIGlmICggbiBpbnN0YW5jZW9mIERlY2ltYWwgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggYiA9PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhbJ2NvbnN0cnVjdG9yJ10gPSBuWydjb25zdHJ1Y3RvciddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4WydzJ10gPSBuWydzJ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhbJ2UnXSA9IG5bJ2UnXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeFsnYyddID0gKCBuID0gblsnYyddICkgPyBuLnNsaWNlKCkgOiBuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGIgPT0gMTAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm5kKCBuZXcgRGVjaW1hbChuKSwgRGVjaW1hbFsncHJlY2lzaW9uJ10sIERlY2ltYWxbJ3JvdW5kaW5nJ10gKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEZWNpbWFsKCB4Wydjb25zdHJ1Y3RvciddID0gRGVjaW1hbCwgeCwgbiwgYiApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgLyogKioqKioqKioqKioqKioqKioqKioqKioqIENPTlNUUlVDVE9SIERFRkFVTFQgUFJPUEVSVElFUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHJcbiAgICAgICAgICAgICBUaGVzZSBkZWZhdWx0IHZhbHVlcyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgc3RhdGVkIHJhbmdlcyAoaW5jbHVzaXZlKS5cclxuICAgICAgICAgICAgIE1vc3Qgb2YgdGhlc2UgdmFsdWVzIGNhbiBiZSBjaGFuZ2VkIGR1cmluZyBydW4tdGltZSB1c2luZyBEZWNpbWFsLmNvbmZpZy5cclxuICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIGEgY2FsY3VsYXRpb24gb3IgYmFzZVxyXG4gICAgICAgICAgICAgY29udmVyc2lvbi5cclxuICAgICAgICAgICAgIEUuZy4gIERlY2ltYWwuY29uZmlnKHsgcHJlY2lzaW9uOiAyMCB9KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRGVjaW1hbFsncHJlY2lzaW9uJ10gPSAyMDsgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWF9ESUdJVFNcclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gcHJlY2lzaW9uLlxyXG5cclxuICAgICAgICAgICAgIFJPVU5EX1VQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgICAgICAgIFJPVU5EX0RPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAgICAgICAgICBST1VORF9DRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgICAgICAgICBST1VORF9GTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgICAgICBST1VORF9IQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgICAgICAgICAgUk9VTkRfSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAgICAgICAgUk9VTkRfSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAgICAgICAgUk9VTkRfSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgICAgICAgIFJPVU5EX0hBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcblxyXG4gICAgICAgICAgICAgRS5nLlxyXG4gICAgICAgICAgICAgRGVjaW1hbC5yb3VuZGluZyA9IDQ7XHJcbiAgICAgICAgICAgICBEZWNpbWFsLnJvdW5kaW5nID0gRGVjaW1hbC5ST1VORF9IQUxGX1VQO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRGVjaW1hbFsncm91bmRpbmcnXSA9IDQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAgICAgICAgVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG5cclxuICAgICAgICAgICAgIFVQICAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgIERPV04gICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzIFwidHJ1bmNhdGVkIGRpdmlzaW9uXCIgYW5kIG1hdGNoZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcyBjbG9zZWx5IGFzIHBvc3NpYmxlLCB0aGUgYmVoYXZpb3VyIG9mIEpTIHJlbWFpbmRlciBvcGVyYXRvciAoYSAlIG4pLlxyXG4gICAgICAgICAgICAgRkxPT1IgICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgICAgICAgICAgIEhBTEZfRVZFTiAgNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgICAgICAgIEVVQ0xJRCAgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcblxyXG4gICAgICAgICAgICAgVGhlIGFib3ZlIG1vZGVzIC0gdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0XHJcbiAgICAgICAgICAgICByZW1haW5kZXIgLSBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLiBBbHRob3VnaCBhbnkgb3RoZXIgb2YgdGhlXHJcbiAgICAgICAgICAgICByb3VuZGluZyBtb2RlcyBjYW4gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEZWNpbWFsWydtb2R1bG8nXSA9IDE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICAgICAgICBEZWNpbWFsWyd0b0V4cE5lZyddID0gLTc7ICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1FWFBfTElNSVRcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICAgICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgICAgICAgIERlY2ltYWxbJ3RvRXhwUG9zJ10gPSAyMTsgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gRVhQX0xJTUlUXHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgICAgICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICAgICAgICBEZWNpbWFsWydtaW5FJ10gPSAtRVhQX0xJTUlUOyAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLUVYUF9MSU1JVFxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgICAgICAgRGVjaW1hbFsnbWF4RSddID0gRVhQX0xJTUlUOyAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gRVhQX0xJTUlUXHJcblxyXG4gICAgICAgICAgICAvLyBXaGV0aGVyIERlY2ltYWwgRXJyb3JzIGFyZSBldmVyIHRocm93bi5cclxuICAgICAgICAgICAgRGVjaW1hbFsnZXJyb3JzJ10gPSB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlL2ZhbHNlXHJcblxyXG4gICAgICAgICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgICAgICAgIERlY2ltYWxbJ2NyeXB0byddID0gZmFsc2U7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZS9mYWxzZVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKiogRU5EIE9GIENPTlNUUlVDVE9SIERFRkFVTFQgUFJPUEVSVElFUyAqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcblxyXG4gICAgICAgICAgICBEZWNpbWFsLnByb3RvdHlwZSA9IFA7XHJcblxyXG4gICAgICAgICAgICBEZWNpbWFsWydPTkUnXSA9IG5ldyBEZWNpbWFsKDEpO1xyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgLy8gUGkgdG8gODAgcy5kLlxyXG4gICAgICAgICAgICBEZWNpbWFsWydQSSddID0gbmV3IERlY2ltYWwoXHJcbiAgICAgICAgICAgICAgICAnMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDYyODYyMDg5J1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIERlY2ltYWxbJ1JPVU5EX1VQJ10gPSAwO1xyXG4gICAgICAgICAgICBEZWNpbWFsWydST1VORF9ET1dOJ10gPSAxO1xyXG4gICAgICAgICAgICBEZWNpbWFsWydST1VORF9DRUlMJ10gPSAyO1xyXG4gICAgICAgICAgICBEZWNpbWFsWydST1VORF9GTE9PUiddID0gMztcclxuICAgICAgICAgICAgRGVjaW1hbFsnUk9VTkRfSEFMRl9VUCddID0gNDtcclxuICAgICAgICAgICAgRGVjaW1hbFsnUk9VTkRfSEFMRl9ET1dOJ10gPSA1O1xyXG4gICAgICAgICAgICBEZWNpbWFsWydST1VORF9IQUxGX0VWRU4nXSA9IDY7XHJcbiAgICAgICAgICAgIERlY2ltYWxbJ1JPVU5EX0hBTEZfQ0VJTCddID0gNztcclxuICAgICAgICAgICAgRGVjaW1hbFsnUk9VTkRfSEFMRl9GTE9PUiddID0gODtcclxuXHJcbiAgICAgICAgICAgIC8vIG1vZHVsbyBtb2RlXHJcbiAgICAgICAgICAgIERlY2ltYWxbJ0VVQ0xJRCddID0gOTtcclxuXHJcbiAgICAgICAgICAgIC8vRGVjaW1hbFsnYWJzJ10gPSBhYnM7XHJcbiAgICAgICAgICAgIC8vRGVjaW1hbFsnYWNvcyddID0gYWNvcztcclxuICAgICAgICAgICAgLy9EZWNpbWFsWydhc2luJ10gPSBhc2luO1xyXG4gICAgICAgICAgICAvL0RlY2ltYWxbJ2F0YW4nXSA9IGF0YW47XHJcbiAgICAgICAgICAgIC8vRGVjaW1hbFsnYXRhbjInXSA9IGF0YW4yO1xyXG4gICAgICAgICAgICAvL0RlY2ltYWxbJ2NlaWwnXSA9IGNlaWw7XHJcbiAgICAgICAgICAgIC8vRGVjaW1hbFsnY29zJ10gPSBjb3M7XHJcbiAgICAgICAgICAgIC8vRGVjaW1hbFsnZmxvb3InXSA9IGZsb29yO1xyXG4gICAgICAgICAgICAvL0RlY2ltYWxbJ3JvdW5kJ10gPSByb3VuZDtcclxuICAgICAgICAgICAgLy9EZWNpbWFsWydzaW4nXSA9IHNpbjtcclxuICAgICAgICAgICAgLy9EZWNpbWFsWyd0YW4nXSA9IHRhbjtcclxuICAgICAgICAgICAgLy9EZWNpbWFsWyd0cnVuYyddID0gdHJ1bmM7XHJcblxyXG4gICAgICAgICAgICBEZWNpbWFsWydjb25maWcnXSA9IGNvbmZpZztcclxuICAgICAgICAgICAgRGVjaW1hbFsnY29uc3RydWN0b3InXSA9IERlY2ltYWxGYWN0b3J5O1xyXG4gICAgICAgICAgICBEZWNpbWFsWydleHAnXSA9IGV4cDtcclxuICAgICAgICAgICAgRGVjaW1hbFsnbG4nXSA9IGxuO1xyXG4gICAgICAgICAgICBEZWNpbWFsWydsb2cnXSA9IGxvZztcclxuICAgICAgICAgICAgRGVjaW1hbFsnbWF4J10gPSBtYXg7XHJcbiAgICAgICAgICAgIERlY2ltYWxbJ21pbiddID0gbWluO1xyXG4gICAgICAgICAgICBEZWNpbWFsWydwb3cnXSA9IHBvdztcclxuICAgICAgICAgICAgRGVjaW1hbFsnc3FydCddID0gc3FydDtcclxuICAgICAgICAgICAgRGVjaW1hbFsncmFuZG9tJ10gPSByYW5kb207XHJcblxyXG4gICAgICAgICAgICBpZiAoIG9iaiAhPSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgRGVjaW1hbFsnY29uZmlnJ10ob2JqKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIERlY2ltYWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gRGVjaW1hbEZhY3RvcnkoKTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIEV4cG9ydC5cclxuXHJcblxyXG4gICAgLy8gQU1ELlxyXG4gICAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuXHJcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERlY2ltYWxDb25zdHJ1Y3RvcjtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAvLyBOb2RlIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IERlY2ltYWxDb25zdHJ1Y3RvcjtcclxuXHJcbiAgICAgICAgaWYgKCAhY3J5cHRvICkge1xyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAvLyBCcm93c2VyLlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBub0NvbmZsaWN0ID0gZ2xvYmFsWydEZWNpbWFsJ107XHJcblxyXG4gICAgICAgIERlY2ltYWxDb25zdHJ1Y3Rvclsnbm9Db25mbGljdCddID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBnbG9iYWxbJ0RlY2ltYWwnXSA9IG5vQ29uZmxpY3Q7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gRGVjaW1hbENvbnN0cnVjdG9yO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGdsb2JhbFsnRGVjaW1hbCddID0gRGVjaW1hbENvbnN0cnVjdG9yO1xyXG4gICAgfVxyXG59KSh0aGlzKTtcclxuXG59KSgpIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJhbmdlIGVycm9yIHdpdGggdGhlIG1lc3NhZ2U6XG4gKiAgICAgJ0luZGV4IG91dCBvZiByYW5nZSAoaW5kZXggPCBtaW4pJ1xuICogICAgICdJbmRleCBvdXQgb2YgcmFuZ2UgKGluZGV4IDwgbWF4KSdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggICAgIFRoZSBhY3R1YWwgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdICAgTWluaW11bSBpbmRleCAoaW5jbHVkZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gW21heF0gICAgIE1heGltdW0gaW5kZXggKGV4Y2x1ZGVkKVxuICogQGV4dGVuZHMgUmFuZ2VFcnJvclxuICovXG5mdW5jdGlvbiBJbmRleEVycm9yKGluZGV4LCBtaW4sIG1heCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5kZXhFcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICB9XG5cbiAgdGhpcy5pbmRleCA9IGluZGV4O1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICB0aGlzLm1pbiA9IDA7XG4gICAgdGhpcy5tYXggPSBtaW47XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBpZiAodGhpcy5taW4gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmluZGV4IDwgdGhpcy5taW4pIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnSW5kZXggb3V0IG9mIHJhbmdlICgnICsgdGhpcy5pbmRleCArICcgPCAnICsgdGhpcy5taW4gKyAnKSc7XG4gIH1cbiAgZWxzZSBpZiAodGhpcy5tYXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLmluZGV4ID49IHRoaXMubWF4KSB7XG4gICAgdGhpcy5tZXNzYWdlID0gJ0luZGV4IG91dCBvZiByYW5nZSAoJyArIHRoaXMuaW5kZXggKyAnID4gJyArICh0aGlzLm1heCAtIDEpICsgJyknO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9ICdJbmRleCBvdXQgb2YgcmFuZ2UgKCcgKyB0aGlzLmluZGV4ICsgJyknO1xuICB9XG5cbiAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5cbkluZGV4RXJyb3IucHJvdG90eXBlID0gbmV3IFJhbmdlRXJyb3IoKTtcbkluZGV4RXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFuZ2VFcnJvcjtcbkluZGV4RXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSW5kZXhFcnJvcic7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5kZXhFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGUgYSByYW5nZSBlcnJvciB3aXRoIHRoZSBtZXNzYWdlOlxuICogICAgICdEaW1lbnNpb24gbWlzbWF0Y2ggKDxhY3R1YWwgc2l6ZT4gIT0gPGV4cGVjdGVkIHNpemU+KSdcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVtYmVyW119IGFjdHVhbCAgICAgICAgVGhlIGFjdHVhbCBzaXplXG4gKiBAcGFyYW0ge251bWJlciB8IG51bWJlcltdfSBleHBlY3RlZCAgICAgIFRoZSBleHBlY3RlZCBzaXplXG4gKiBAcGFyYW0ge3N0cmluZ30gW3JlbGF0aW9uPSchPSddICAgICAgICAgIE9wdGlvbmFsIHJlbGF0aW9uIGJldHdlZW4gYWN0dWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBleHBlY3RlZCBzaXplOiAnIT0nLCAnPCcsIGV0Yy5cbiAqIEBleHRlbmRzIFJhbmdlRXJyb3JcbiAqL1xuZnVuY3Rpb24gRGltZW5zaW9uRXJyb3IoYWN0dWFsLCBleHBlY3RlZCwgcmVsYXRpb24pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERpbWVuc2lvbkVycm9yKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICB0aGlzLmFjdHVhbCAgID0gYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gIHRoaXMucmVsYXRpb24gPSByZWxhdGlvbjtcblxuICB0aGlzLm1lc3NhZ2UgPSAnRGltZW5zaW9uIG1pc21hdGNoICgnICtcbiAgICAgIChBcnJheS5pc0FycmF5KGFjdHVhbCkgPyAoJ1snICsgYWN0dWFsLmpvaW4oJywgJykgKyAnXScpIDogYWN0dWFsKSArXG4gICAgICAnICcgKyAodGhpcy5yZWxhdGlvbiB8fCAnIT0nKSArICcgJyArXG4gICAgICAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkgPyAoJ1snICsgZXhwZWN0ZWQuam9pbignLCAnKSArICddJykgOiBleHBlY3RlZCkgK1xuICAgICAgJyknO1xuXG4gIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xufVxuXG5EaW1lbnNpb25FcnJvci5wcm90b3R5cGUgPSBuZXcgUmFuZ2VFcnJvcigpO1xuRGltZW5zaW9uRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFuZ2VFcnJvcjtcbkRpbWVuc2lvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0RpbWVuc2lvbkVycm9yJztcblxubW9kdWxlLmV4cG9ydHMgPSBEaW1lbnNpb25FcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGUgYSBUeXBlRXJyb3Igd2l0aCBtZXNzYWdlOlxuICogICAgICAnRnVuY3Rpb24gPGZuPiBkb2VzIG5vdCBzdXBwb3J0IGEgcGFyYW1ldGVyIG9mIHR5cGUgPHR5cGU+JztcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbiAgICAgRnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIHsqLi4ufSBbdHlwZXNdICBUaGUgdHlwZXMgb2YgdGhlIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICogQGV4dGVuZHMgVHlwZUVycm9yXG4gKi9cbmZ1bmN0aW9uIFVuc3VwcG9ydGVkVHlwZUVycm9yKGZuLCB0eXBlcykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVW5zdXBwb3J0ZWRUeXBlRXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy50eXBlcyA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGlmICghZm4pIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnVW5zdXBwb3J0ZWQgdHlwZSBvZiBhcmd1bWVudCc7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHRoaXMudHlwZXMubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9ICdVbnN1cHBvcnRlZCB0eXBlIG9mIGFyZ3VtZW50IGluIGZ1bmN0aW9uICcgKyBmbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSAnRnVuY3Rpb24gJyArIGZuICsgJygnICsgdGhpcy50eXBlcy5qb2luKCcsICcpICsgJykgbm90IHN1cHBvcnRlZCc7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5cblVuc3VwcG9ydGVkVHlwZUVycm9yLnByb3RvdHlwZSA9IG5ldyBUeXBlRXJyb3IoKTtcblVuc3VwcG9ydGVkVHlwZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVFcnJvcjtcblVuc3VwcG9ydGVkVHlwZUVycm9yLnByb3RvdHlwZS5uYW1lID0gJ1Vuc3VwcG9ydGVkVHlwZUVycm9yJztcblxubW9kdWxlLmV4cG9ydHMgPSBVbnN1cHBvcnRlZFR5cGVFcnJvcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdlJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2UnXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdFdWxlclxcJ3MgbnVtYmVyLCB0aGUgYmFzZSBvZiB0aGUgbmF0dXJhbCBsb2dhcml0aG0uIEFwcHJveGltYXRlbHkgZXF1YWwgdG8gMi43MTgyOCcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZScsXG4gICAgJ2UgXiAyJyxcbiAgICAnZXhwKDIpJyxcbiAgICAnbG9nKGUpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnZXhwJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZmFsc2UnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZmFsc2UnXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdCb29sZWFuIHZhbHVlIGZhbHNlJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdmYWxzZSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3RydWUnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdpJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2knXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdJbWFnaW5hcnkgdW5pdCwgZGVmaW5lZCBhcyBpKmk9LTEuIEEgY29tcGxleCBudW1iZXIgaXMgZGVzY3JpYmVkIGFzIGEgKyBiKmksIHdoZXJlIGEgaXMgdGhlIHJlYWwgcGFydCwgYW5kIGIgaXMgdGhlIGltYWdpbmFyeSBwYXJ0LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaScsXG4gICAgJ2kgKiBpJyxcbiAgICAnc3FydCgtMSknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnSW5maW5pdHknLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnSW5maW5pdHknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdJbmZpbml0eSwgYSBudW1iZXIgd2hpY2ggaXMgbGFyZ2VyIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIHRoYXQgY2FuIGJlIGhhbmRsZWQgYnkgYSBmbG9hdGluZyBwb2ludCBudW1iZXIuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdJbmZpbml0eScsXG4gICAgJzEgLyAwJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ0xOMicsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICdMTjInXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdSZXR1cm5zIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiAyLCBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIDAuNjkzJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdMTjInLFxuICAgICdsb2coMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnTE4xMCcsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICdMTjEwJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUmV0dXJucyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMTAsIGFwcHJveGltYXRlbHkgZXF1YWwgdG8gMi4zMDInLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ0xOMTAnLFxuICAgICdsb2coMTApJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ0xPRzJFJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ0xPRzJFJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUmV0dXJucyB0aGUgYmFzZS0yIGxvZ2FyaXRobSBvZiBFLCBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIDEuNDQyJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdMT0cyRScsXG4gICAgJ2xvZyhlLCAyKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdMT0cxMEUnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnTE9HMTBFJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUmV0dXJucyB0aGUgYmFzZS0xMCBsb2dhcml0aG0gb2YgRSwgYXBwcm94aW1hdGVseSBlcXVhbCB0byAwLjQzNCcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnTE9HMTBFJyxcbiAgICAnbG9nKGUsIDEwKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdOYU4nLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnTmFOJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnTm90IGEgbnVtYmVyJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdOYU4nLFxuICAgICcwIC8gMCdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdudWxsJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ251bGwnXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdWYWx1ZSBudWxsJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdudWxsJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsndHJ1ZScsICdmYWxzZSddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3BpJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3BpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnVGhlIG51bWJlciBwaSBpcyBhIG1hdGhlbWF0aWNhbCBjb25zdGFudCB0aGF0IGlzIHRoZSByYXRpbyBvZiBhIGNpcmNsZVxcJ3MgY2lyY3VtZmVyZW5jZSB0byBpdHMgZGlhbWV0ZXIsIGFuZCBpcyBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIDMuMTQxNTknLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3BpJyxcbiAgICAnc2luKHBpLzIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsndGF1J11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncGhpJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3BoaSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1BoaSBpcyB0aGUgZ29sZGVuIHJhdGlvLiBUd28gcXVhbnRpdGllcyBhcmUgaW4gdGhlIGdvbGRlbiByYXRpbyBpZiB0aGVpciByYXRpbyBpcyB0aGUgc2FtZSBhcyB0aGUgcmF0aW8gb2YgdGhlaXIgc3VtIHRvIHRoZSBsYXJnZXIgb2YgdGhlIHR3byBxdWFudGl0aWVzLiBQaGkgaXMgZGVmaW5lZCBhcyBgKDEgKyBzcXJ0KDUpKSAvIDJgIGFuZCBpcyBhcHByb3hpbWF0ZWx5IDEuNjE4MDM0Li4uJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd0YXUnXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnU1FSVDFfMicsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICdTUVJUMV8yJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgMS8yLCBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIDAuNzA3JyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdTUVJUMV8yJyxcbiAgICAnc3FydCgxLzIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ1NRUlQyJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ1NRUlQyJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgMiwgYXBwcm94aW1hdGVseSBlcXVhbCB0byAxLjQxNCcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnU1FSVDInLFxuICAgICdzcXJ0KDIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3RhdScsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICd0YXUnXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdUYXUgaXMgdGhlIHJhdGlvIGNvbnN0YW50IG9mIGEgY2lyY2xlXFwncyBjaXJjdW1mZXJlbmNlIHRvIHJhZGl1cywgZXF1YWwgdG8gMiAqIHBpLCBhcHByb3hpbWF0ZWx5IDYuMjgzMi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3RhdScsXG4gICAgJzIgKiBwaSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3BpJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndHJ1ZScsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICd0cnVlJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQm9vbGVhbiB2YWx1ZSB0cnVlJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd0cnVlJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnZmFsc2UnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd2ZXJzaW9uJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ZlcnNpb24nXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdBIHN0cmluZyB3aXRoIHRoZSB2ZXJzaW9uIG51bWJlciBvZiBtYXRoLmpzJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd2ZXJzaW9uJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2FicycsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYWJzKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgYWJzb2x1dGUgdmFsdWUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhYnMoMy41KScsXG4gICAgJ2FicygtNC4yKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3NpZ24nXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhZGQnLFxuICAnY2F0ZWdvcnknOiAnT3BlcmF0b3JzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCArIHknLFxuICAgICdhZGQoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdBZGQgdHdvIHZhbHVlcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2EgPSAyLjEgKyAzLjYnLFxuICAgICdhIC0gMy42JyxcbiAgICAnMyArIDJpJyxcbiAgICAnXCJoZWxsb1wiICsgXCIgd29ybGRcIicsXG4gICAgJzMgY20gKyAyIGluY2gnXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdzdWJ0cmFjdCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjZWlsJyxcbiAgJ2NhdGVnb3J5JzogJ0FyaXRobWV0aWMnLFxuICAnc3ludGF4JzogW1xuICAgICdjZWlsKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ1JvdW5kIGEgdmFsdWUgdG93YXJkcyBwbHVzIGluZmluaXR5LiBJZiB4IGlzIGNvbXBsZXgsIGJvdGggcmVhbCBhbmQgaW1hZ2luYXJ5IHBhcnQgYXJlIHJvdW5kZWQgdG93YXJkcyBwbHVzIGluZmluaXR5LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnY2VpbCgzLjIpJyxcbiAgICAnY2VpbCgzLjgpJyxcbiAgICAnY2VpbCgtNC4yKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2Zsb29yJywgJ2ZpeCcsICdyb3VuZCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2N1YmUnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2N1YmUoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBjdWJlIG9mIGEgdmFsdWUuIFRoZSBjdWJlIG9mIHggaXMgeCAqIHggKiB4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnY3ViZSgyKScsXG4gICAgJzJeMycsXG4gICAgJzIgKiAyICogMidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ211bHRpcGx5JyxcbiAgICAnc3F1YXJlJyxcbiAgICAncG93J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2RpdmlkZScsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4IC8geScsXG4gICAgJ2RpdmlkZSh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0RpdmlkZSB0d28gdmFsdWVzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IDIgLyAzJyxcbiAgICAnYSAqIDMnLFxuICAgICc0LjUgLyAyJyxcbiAgICAnMyArIDQgLyAyJyxcbiAgICAnKDMgKyA0KSAvIDInLFxuICAgICcxOCBrbSAvIDQuNSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ211bHRpcGx5J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2RvdERpdmlkZScsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4IC4vIHknLFxuICAgICdkb3REaXZpZGUoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdEaXZpZGUgdHdvIHZhbHVlcyBlbGVtZW50IHdpc2UuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhID0gWzEsIDIsIDM7IDQsIDUsIDZdJyxcbiAgICAnYiA9IFsyLCAxLCAxOyAzLCAyLCA1XScsXG4gICAgJ2EgLi8gYidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ211bHRpcGx5JyxcbiAgICAnZG90TXVsdGlwbHknLFxuICAgICdkaXZpZGUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZG90TXVsdGlwbHknLFxuICAnY2F0ZWdvcnknOiAnT3BlcmF0b3JzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCAuKiB5JyxcbiAgICAnZG90TXVsdGlwbHkoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdNdWx0aXBseSB0d28gdmFsdWVzIGVsZW1lbnQgd2lzZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2EgPSBbMSwgMiwgMzsgNCwgNSwgNl0nLFxuICAgICdiID0gWzIsIDEsIDE7IDMsIDIsIDVdJyxcbiAgICAnYSAuKiBiJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknLFxuICAgICdkaXZpZGUnLFxuICAgICdkb3REaXZpZGUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZG90cG93JyxcbiAgJ2NhdGVnb3J5JzogJ09wZXJhdG9ycycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggLl4geScsXG4gICAgJ2RvdHBvdyh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBwb3dlciBvZiB4IHRvIHkgZWxlbWVudCB3aXNlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ2EgLl4gMidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3BvdydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdleHAnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2V4cCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgZXhwb25lbnQgb2YgYSB2YWx1ZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2V4cCgxLjMpJyxcbiAgICAnZSBeIDEuMycsXG4gICAgJ2xvZyhleHAoMS4zKSknLFxuICAgICd4ID0gMi40JyxcbiAgICAnKGV4cChpKngpID09IGNvcyh4KSArIGkqc2luKHgpKSAgICMgRXVsZXJcXCdzIGZvcm11bGEnXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdwb3cnLFxuICAgICdsb2cnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZml4JyxcbiAgJ2NhdGVnb3J5JzogJ0FyaXRobWV0aWMnLFxuICAnc3ludGF4JzogW1xuICAgICdmaXgoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnUm91bmQgYSB2YWx1ZSB0b3dhcmRzIHplcm8uIElmIHggaXMgY29tcGxleCwgYm90aCByZWFsIGFuZCBpbWFnaW5hcnkgcGFydCBhcmUgcm91bmRlZCB0b3dhcmRzIHplcm8uJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdmaXgoMy4yKScsXG4gICAgJ2ZpeCgzLjgpJyxcbiAgICAnZml4KC00LjIpJyxcbiAgICAnZml4KC00LjgpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnY2VpbCcsICdmbG9vcicsICdyb3VuZCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2Zsb29yJyxcbiAgJ2NhdGVnb3J5JzogJ0FyaXRobWV0aWMnLFxuICAnc3ludGF4JzogW1xuICAgICdmbG9vcih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdSb3VuZCBhIHZhbHVlIHRvd2FyZHMgbWludXMgaW5maW5pdHkuSWYgeCBpcyBjb21wbGV4LCBib3RoIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0IGFyZSByb3VuZGVkIHRvd2FyZHMgbWludXMgaW5maW5pdHkuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdmbG9vcigzLjIpJyxcbiAgICAnZmxvb3IoMy44KScsXG4gICAgJ2Zsb29yKC00LjIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnY2VpbCcsICdmaXgnLCAncm91bmQnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdnY2QnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2djZChhLCBiKScsXG4gICAgJ2djZChhLCBiLCBjLCAuLi4pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3IuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdnY2QoOCwgMTIpJyxcbiAgICAnZ2NkKC00LCA2KScsXG4gICAgJ2djZCgyNSwgMTUsIC0xMCknXG4gIF0sXG4gICdzZWVhbHNvJzogWyAnbGNtJywgJ3hnY2QnIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbGNtJyxcbiAgJ2NhdGVnb3J5JzogJ0FyaXRobWV0aWMnLFxuICAnc3ludGF4JzogW1xuICAgICdsY20oeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBsZWFzdCBjb21tb24gbXVsdGlwbGUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdsY20oNCwgNiknLFxuICAgICdsY20oNiwgMjEpJyxcbiAgICAnbGNtKDYsIDIxLCA1KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbICdnY2QnIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbG9nJyxcbiAgJ2NhdGVnb3J5JzogJ0FyaXRobWV0aWMnLFxuICAnc3ludGF4JzogW1xuICAgICdsb2coeCknLFxuICAgICdsb2coeCwgYmFzZSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBsb2dhcml0aG0gb2YgYSB2YWx1ZS4gSWYgbm8gYmFzZSBpcyBwcm92aWRlZCwgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIHggaXMgY2FsY3VsYXRlZC4gSWYgYmFzZSBpZiBwcm92aWRlZCwgdGhlIGxvZ2FyaXRobSBpcyBjYWxjdWxhdGVkIGZvciB0aGUgc3BlY2lmaWVkIGJhc2UuIGxvZyh4LCBiYXNlKSBpcyBkZWZpbmVkIGFzIGxvZyh4KSAvIGxvZyhiYXNlKS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2xvZygzLjUpJyxcbiAgICAnYSA9IGxvZygyLjQpJyxcbiAgICAnZXhwKGEpJyxcbiAgICAnMTAgXiA0JyxcbiAgICAnbG9nKDEwMDAwLCAxMCknLFxuICAgICdsb2coMTAwMDApIC8gbG9nKDEwKScsXG4gICAgJ2IgPSBsb2coMTAyNCwgMiknLFxuICAgICcyIF4gYidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2V4cCcsXG4gICAgJ2xvZzEwJ1xuICBdXG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdsb2cxMCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbG9nMTAoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSAxMC1iYXNlIGxvZ2FyaXRobSBvZiBhIHZhbHVlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnbG9nMTAoMC4wMDAwMSknLFxuICAgICdsb2cxMCgxMDAwMCknLFxuICAgICcxMCBeIDQnLFxuICAgICdsb2coMTAwMDApIC8gbG9nKDEwKScsXG4gICAgJ2xvZygxMDAwMCwgMTApJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnZXhwJyxcbiAgICAnbG9nJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ21vZCcsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4ICUgeScsXG4gICAgJ3ggbW9kIHknLFxuICAgICdtb2QoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgbW9kdWx1cywgdGhlIHJlbWFpbmRlciBvZiBhbiBpbnRlZ2VyIGRpdmlzaW9uLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnNyAlIDMnLFxuICAgICcxMSAlIDInLFxuICAgICcxMCBtb2QgNCcsXG4gICAgJ2Z1bmN0aW9uIGlzT2RkKHgpID0geCAlIDInLFxuICAgICdpc09kZCgyKScsXG4gICAgJ2lzT2RkKDMpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnZGl2aWRlJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbXVsdGlwbHknLFxuICAnY2F0ZWdvcnknOiAnT3BlcmF0b3JzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCAqIHknLFxuICAgICdtdWx0aXBseSh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ211bHRpcGx5IHR3byB2YWx1ZXMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhID0gMi4xICogMy40JyxcbiAgICAnYSAvIDMuNCcsXG4gICAgJzIgKiAzICsgNCcsXG4gICAgJzIgKiAoMyArIDQpJyxcbiAgICAnMyAqIDIuMSBrbSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2RpdmlkZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdub3JtJyxcbiAgJ2NhdGVnb3J5JzogJ0FyaXRobWV0aWMnLFxuICAnc3ludGF4JzogW1xuICAgICdub3JtKHgpJyxcbiAgICAnbm9ybSh4LCBwKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgbm9ybSBvZiBhIG51bWJlciwgdmVjdG9yIG9yIG1hdHJpeC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2FicygtMy41KScsXG4gICAgJ25vcm0oLTMuNSknLFxuICAgICdub3JtKDMgLSA0aSkpJyxcbiAgICAnbm9ybShbMSwgMiwgLTNdLCBJbmZpbml0eSknLFxuICAgICdub3JtKFsxLCAyLCAtM10sIC1JbmZpbml0eSknLFxuICAgICdub3JtKFszLCA0XSwgMiknLFxuICAgICdub3JtKFtbMSwgMl0sIFszLCA0XV0sIDEpJyxcbiAgICAnbm9ybShbWzEsIDJdLCBbMywgNF1dLCBcXCdpbmZcXCcpJyxcbiAgICAnbm9ybShbWzEsIDJdLCBbMywgNF1dLCBcXCdmcm9cXCcpJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3BvdycsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4IF4geScsXG4gICAgJ3Bvdyh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBwb3dlciBvZiB4IHRvIHksIHheeS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzJeMyA9IDgnLFxuICAgICcyKjIqMicsXG4gICAgJzEgKyBlIF4gKHBpICogaSknXG4gIF0sXG4gICdzZWVhbHNvJzogWyAnbXVsdGlwbHknIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncm91bmQnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3JvdW5kKHgpJyxcbiAgICAncm91bmQoeCwgbiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAncm91bmQgYSB2YWx1ZSB0b3dhcmRzIHRoZSBuZWFyZXN0IGludGVnZXIuSWYgeCBpcyBjb21wbGV4LCBib3RoIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0IGFyZSByb3VuZGVkIHRvd2FyZHMgdGhlIG5lYXJlc3QgaW50ZWdlci4gV2hlbiBuIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlIGlzIHJvdW5kZWQgdG8gbiBkZWNpbWFscy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3JvdW5kKDMuMiknLFxuICAgICdyb3VuZCgzLjgpJyxcbiAgICAncm91bmQoLTQuMiknLFxuICAgICdyb3VuZCgtNC44KScsXG4gICAgJ3JvdW5kKHBpLCAzKScsXG4gICAgJ3JvdW5kKDEyMy40NTY3OCwgMiknXG4gIF0sXG4gICdzZWVhbHNvJzogWydjZWlsJywgJ2Zsb29yJywgJ2ZpeCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3NpZ24nLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NpZ24oeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ29tcHV0ZSB0aGUgc2lnbiBvZiBhIHZhbHVlLiBUaGUgc2lnbiBvZiBhIHZhbHVlIHggaXMgMSB3aGVuIHg+MSwgLTEgd2hlbiB4PDAsIGFuZCAwIHdoZW4geD0wLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc2lnbigzLjUpJyxcbiAgICAnc2lnbigtNC4yKScsXG4gICAgJ3NpZ24oMCknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdhYnMnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc3FydCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc3FydCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDb21wdXRlIHRoZSBzcXVhcmUgcm9vdCB2YWx1ZS4gSWYgeCA9IHkgKiB5LCB0aGVuIHkgaXMgdGhlIHNxdWFyZSByb290IG9mIHguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzcXJ0KDI1KScsXG4gICAgJzUgKiA1JyxcbiAgICAnc3FydCgtMSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdzcXVhcmUnLFxuICAgICdtdWx0aXBseSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzcXVhcmUnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NxdWFyZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDb21wdXRlIHRoZSBzcXVhcmUgb2YgYSB2YWx1ZS4gVGhlIHNxdWFyZSBvZiB4IGlzIHggKiB4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc3F1YXJlKDMpJyxcbiAgICAnc3FydCg5KScsXG4gICAgJzNeMicsXG4gICAgJzMgKiAzJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknLFxuICAgICdwb3cnLFxuICAgICdzcXJ0JyxcbiAgICAnY3ViZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzdWJ0cmFjdCcsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4IC0geScsXG4gICAgJ3N1YnRyYWN0KHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnc3VidHJhY3QgdHdvIHZhbHVlcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2EgPSA1LjMgLSAyJyxcbiAgICAnYSArIDInLFxuICAgICcyLzMgLSAxLzYnLFxuICAgICcyICogMyAtIDMnLFxuICAgICcyLjEga20gLSA1MDBtJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYWRkJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3VuYXJ5TWludXMnLFxuICAnY2F0ZWdvcnknOiAnT3BlcmF0b3JzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnLXgnLFxuICAgICd1bmFyeU1pbnVzKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0ludmVyc2UgdGhlIHNpZ24gb2YgYSB2YWx1ZS4gQ29udmVydHMgYm9vbGVhbnMgYW5kIHN0cmluZ3MgdG8gbnVtYmVycy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJy00LjUnLFxuICAgICctKC01LjYpJyxcbiAgICAnLVwiMjJcIidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2FkZCcsICdzdWJ0cmFjdCcsICd1bmFyeVBsdXMnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndW5hcnlQbHVzJyxcbiAgJ2NhdGVnb3J5JzogJ09wZXJhdG9ycycsXG4gICdzeW50YXgnOiBbXG4gICAgJyt4JyxcbiAgICAndW5hcnlQbHVzKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbnZlcnRzIGJvb2xlYW5zIGFuZCBzdHJpbmdzIHRvIG51bWJlcnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcrdHJ1ZScsXG4gICAgJytcIjJcIidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2FkZCcsICdzdWJ0cmFjdCcsICd1bmFyeU1pbnVzJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3hnY2QnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3hnY2QoYSwgYiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGV4dGVuZGVkIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIGZvciB0d28gdmFsdWVzJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd4Z2NkKDgsIDEyKScsXG4gICAgJ2djZCg4LCAxMiknLFxuICAgICd4Z2NkKDM2MTYzLCAyMTE5OSknXG4gIF0sXG4gICdzZWVhbHNvJzogWyAnZ2NkJywgJ2xjbScgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb21wYXJlJyxcbiAgJ2NhdGVnb3J5JzogJ1JlbGF0aW9uYWwnLFxuICAnc3ludGF4JzogW1xuICAgICdjb21wYXJlKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbXBhcmUgdHdvIHZhbHVlcy4gUmV0dXJucyAxIGlmIHggaXMgbGFyZ2VyIHRoYW4geSwgLTEgaWYgeCBpcyBzbWFsbGVyIHRoYW4geSwgYW5kIDAgaWYgeCBhbmQgeSBhcmUgZXF1YWwuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjb21wYXJlKDIsIDMpJyxcbiAgICAnY29tcGFyZSgzLCAyKScsXG4gICAgJ2NvbXBhcmUoMiwgMiknLFxuICAgICdjb21wYXJlKDVjbSwgNDBtbSknLFxuICAgICdjb21wYXJlKDIsIFsxLCAyLCAzXSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdlcXVhbCcsICd1bmVxdWFsJywgJ3NtYWxsZXInLCAnc21hbGxlckVxJywgJ2xhcmdlckVxJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2RlZXBFcXVhbCcsXG4gICdjYXRlZ29yeSc6ICdSZWxhdGlvbmFsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZGVlcEVxdWFsKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NoZWNrIGVxdWFsaXR5IG9mIHR3byBtYXRyaWNlcyBlbGVtZW50IHdpc2UuIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2l6ZSBvZiBib3RoIG1hdHJpY2VzIGlzIGVxdWFsIGFuZCB3aGVuIGFuZCBlYWNoIG9mIHRoZSBlbGVtZW50cyBhcmUgZXF1YWwuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdbMSwzLDRdID09IFsxLDMsNF0nLFxuICAgICdbMSwzLDRdID09IFsxLDNdJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnZXF1YWwnLCAndW5lcXVhbCcsICdzbWFsbGVyJywgJ2xhcmdlcicsICdzbWFsbGVyRXEnLCAnbGFyZ2VyRXEnLCAnY29tcGFyZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdlcXVhbCcsXG4gICdjYXRlZ29yeSc6ICdSZWxhdGlvbmFsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCA9PSB5JyxcbiAgICAnZXF1YWwoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ2hlY2sgZXF1YWxpdHkgb2YgdHdvIHZhbHVlcy4gUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWFsLCBhbmQgZmFsc2UgaWYgbm90LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMisyID09IDMnLFxuICAgICcyKzIgPT0gNCcsXG4gICAgJ2EgPSAzLjInLFxuICAgICdiID0gNi0yLjgnLFxuICAgICdhID09IGInLFxuICAgICc1MGNtID09IDAuNW0nXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICd1bmVxdWFsJywgJ3NtYWxsZXInLCAnbGFyZ2VyJywgJ3NtYWxsZXJFcScsICdsYXJnZXJFcScsICdjb21wYXJlJywgJ2RlZXBFcXVhbCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdsYXJnZXInLFxuICAnY2F0ZWdvcnknOiAnUmVsYXRpb25hbCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggPiB5JyxcbiAgICAnbGFyZ2VyKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NoZWNrIGlmIHZhbHVlIHggaXMgbGFyZ2VyIHRoYW4geS4gUmV0dXJucyB0cnVlIGlmIHggaXMgbGFyZ2VyIHRoYW4geSwgYW5kIGZhbHNlIGlmIG5vdC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzIgPiAzJyxcbiAgICAnNSA+IDIqMicsXG4gICAgJ2EgPSAzLjMnLFxuICAgICdiID0gNi0yLjgnLFxuICAgICcoYSA+IGIpJyxcbiAgICAnKGIgPCBhKScsXG4gICAgJzUgY20gPiAyIGluY2gnXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdlcXVhbCcsICd1bmVxdWFsJywgJ3NtYWxsZXInLCAnc21hbGxlckVxJywgJ2xhcmdlckVxJywgJ2NvbXBhcmUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbGFyZ2VyRXEnLFxuICAnY2F0ZWdvcnknOiAnUmVsYXRpb25hbCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggPj0geScsXG4gICAgJ2xhcmdlckVxKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NoZWNrIGlmIHZhbHVlIHggaXMgbGFyZ2VyIG9yIGVxdWFsIHRvIHkuIFJldHVybnMgdHJ1ZSBpZiB4IGlzIGxhcmdlciBvciBlcXVhbCB0byB5LCBhbmQgZmFsc2UgaWYgbm90LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMiA+IDErMScsXG4gICAgJzIgPj0gMSsxJyxcbiAgICAnYSA9IDMuMicsXG4gICAgJ2IgPSA2LTIuOCcsXG4gICAgJyhhID4gYiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdlcXVhbCcsICd1bmVxdWFsJywgJ3NtYWxsZXJFcScsICdzbWFsbGVyJywgJ2xhcmdlckVxJywgJ2NvbXBhcmUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc21hbGxlcicsXG4gICdjYXRlZ29yeSc6ICdSZWxhdGlvbmFsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCA8IHknLFxuICAgICdzbWFsbGVyKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NoZWNrIGlmIHZhbHVlIHggaXMgc21hbGxlciB0aGFuIHZhbHVlIHkuIFJldHVybnMgdHJ1ZSBpZiB4IGlzIHNtYWxsZXIgdGhhbiB5LCBhbmQgZmFsc2UgaWYgbm90LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMiA8IDMnLFxuICAgICc1IDwgMioyJyxcbiAgICAnYSA9IDMuMycsXG4gICAgJ2IgPSA2LTIuOCcsXG4gICAgJyhhIDwgYiknLFxuICAgICc1IGNtIDwgMiBpbmNoJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnZXF1YWwnLCAndW5lcXVhbCcsICdsYXJnZXInLCAnc21hbGxlckVxJywgJ2xhcmdlckVxJywgJ2NvbXBhcmUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc21hbGxlckVxJyxcbiAgJ2NhdGVnb3J5JzogJ1JlbGF0aW9uYWwnLFxuICAnc3ludGF4JzogW1xuICAgICd4IDw9IHknLFxuICAgICdzbWFsbGVyRXEoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ2hlY2sgaWYgdmFsdWUgeCBpcyBzbWFsbGVyIG9yIGVxdWFsIHRvIHZhbHVlIHkuIFJldHVybnMgdHJ1ZSBpZiB4IGlzIHNtYWxsZXIgdGhhbiB5LCBhbmQgZmFsc2UgaWYgbm90LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMiA8IDErMScsXG4gICAgJzIgPD0gMSsxJyxcbiAgICAnYSA9IDMuMicsXG4gICAgJ2IgPSA2LTIuOCcsXG4gICAgJyhhIDwgYiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdlcXVhbCcsICd1bmVxdWFsJywgJ2xhcmdlcicsICdzbWFsbGVyJywgJ2xhcmdlckVxJywgJ2NvbXBhcmUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndW5lcXVhbCcsXG4gICdjYXRlZ29yeSc6ICdSZWxhdGlvbmFsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCAhPSB5JyxcbiAgICAndW5lcXVhbCh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDaGVjayB1bmVxdWFsaXR5IG9mIHR3byB2YWx1ZXMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWVzIGFyZSB1bmVxdWFsLCBhbmQgZmFsc2UgaWYgdGhleSBhcmUgZXF1YWwuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcyKzIgIT0gMycsXG4gICAgJzIrMiAhPSA0JyxcbiAgICAnYSA9IDMuMicsXG4gICAgJ2IgPSA2LTIuOCcsXG4gICAgJ2EgIT0gYicsXG4gICAgJzUwY20gIT0gMC41bScsXG4gICAgJzUgY20gIT0gMiBpbmNoJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnZXF1YWwnLCAnc21hbGxlcicsICdsYXJnZXInLCAnc21hbGxlckVxJywgJ2xhcmdlckVxJywgJ2NvbXBhcmUnLCAnZGVlcEVxdWFsJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2FyZycsXG4gICdjYXRlZ29yeSc6ICdDb21wbGV4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYXJnKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbXB1dGUgdGhlIGFyZ3VtZW50IG9mIGEgY29tcGxleCB2YWx1ZS4gSWYgeCA9IGErYmksIHRoZSBhcmd1bWVudCBpcyBjb21wdXRlZCBhcyBhdGFuMihiLCBhKS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2FyZygyICsgMmkpJyxcbiAgICAnYXRhbjIoMywgMiknLFxuICAgICdhcmcoMiArIDNpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3JlJyxcbiAgICAnaW0nLFxuICAgICdjb25qJyxcbiAgICAnYWJzJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvbmonLFxuICAnY2F0ZWdvcnknOiAnQ29tcGxleCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ2NvbmooeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ29tcHV0ZSB0aGUgY29tcGxleCBjb25qdWdhdGUgb2YgYSBjb21wbGV4IHZhbHVlLiBJZiB4ID0gYStiaSwgdGhlIGNvbXBsZXggY29uanVnYXRlIGlzIGEtYmkuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjb25qKDIgKyAzaSknLFxuICAgICdjb25qKDIgLSAzaSknLFxuICAgICdjb25qKC01LjJpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3JlJyxcbiAgICAnaW0nLFxuICAgICdhYnMnLFxuICAgICdhcmcnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncmUnLFxuICAnY2F0ZWdvcnknOiAnQ29tcGxleCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ3JlKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnR2V0IHRoZSByZWFsIHBhcnQgb2YgYSBjb21wbGV4IG51bWJlci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3JlKDIgKyAzaSknLFxuICAgICdpbSgyICsgM2kpJyxcbiAgICAncmUoLTUuMmkpJyxcbiAgICAncmUoMi40KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2ltJyxcbiAgICAnY29uaicsXG4gICAgJ2FicycsXG4gICAgJ2FyZydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdpbScsXG4gICdjYXRlZ29yeSc6ICdDb21wbGV4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnaW0oeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdHZXQgdGhlIGltYWdpbmFyeSBwYXJ0IG9mIGEgY29tcGxleCBudW1iZXIuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdpbSgyICsgM2kpJyxcbiAgICAncmUoMiArIDNpKScsXG4gICAgJ2ltKC01LjJpKScsXG4gICAgJ2ltKDIuNCknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdyZScsXG4gICAgJ2NvbmonLFxuICAgICdhYnMnLFxuICAgICdhcmcnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYmlnbnVtYmVyJyxcbiAgJ2NhdGVnb3J5JzogJ1R5cGUnLFxuICAnc3ludGF4JzogW1xuICAgICdiaWdudW1iZXIoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ3JlYXRlIGEgYmlnIG51bWJlciBmcm9tIGEgbnVtYmVyIG9yIHN0cmluZy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzAuMSArIDAuMicsXG4gICAgJ2JpZ251bWJlcigwLjEpICsgYmlnbnVtYmVyKDAuMiknLFxuICAgICdiaWdudW1iZXIoXCI3LjJcIiknLFxuICAgICdiaWdudW1iZXIoXCI3LjJlNTAwXCIpJyxcbiAgICAnYmlnbnVtYmVyKFswLjEsIDAuMiwgMC4zXSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdib29sZWFuJywgJ2NvbXBsZXgnLCAnaW5kZXgnLCAnbWF0cml4JywgJ3N0cmluZycsICd1bml0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2Jvb2xlYW4nLFxuICAnY2F0ZWdvcnknOiAnVHlwZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3gnLFxuICAgICdib29sZWFuKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbnZlcnQgYSBzdHJpbmcgb3IgbnVtYmVyIGludG8gYSBib29sZWFuLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYm9vbGVhbigwKScsXG4gICAgJ2Jvb2xlYW4oMSknLFxuICAgICdib29sZWFuKDMpJyxcbiAgICAnYm9vbGVhbihcInRydWVcIiknLFxuICAgICdib29sZWFuKFwiZmFsc2VcIiknLFxuICAgICdib29sZWFuKFsxLCAwLCAxLCAxXSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnY29tcGxleCcsICdpbmRleCcsICdtYXRyaXgnLCAnbnVtYmVyJywgJ3N0cmluZycsICd1bml0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvbXBsZXgnLFxuICAnY2F0ZWdvcnknOiAnVHlwZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2NvbXBsZXgoKScsXG4gICAgJ2NvbXBsZXgocmUsIGltKScsXG4gICAgJ2NvbXBsZXgoc3RyaW5nKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDcmVhdGUgYSBjb21wbGV4IG51bWJlci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvbXBsZXgoKScsXG4gICAgJ2NvbXBsZXgoMiwgMyknLFxuICAgICdjb21wbGV4KFwiNyAtIDJpXCIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYmlnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnaW5kZXgnLCAnbWF0cml4JywgJ251bWJlcicsICdzdHJpbmcnLCAndW5pdCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdpbmRleCcsXG4gICdjYXRlZ29yeSc6ICdUeXBlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnW3N0YXJ0XScsXG4gICAgJ1tzdGFydDplbmRdJyxcbiAgICAnW3N0YXJ0OnN0ZXA6ZW5kXScsXG4gICAgJ1tzdGFydDEsIHN0YXJ0IDIsIC4uLl0nLFxuICAgICdbc3RhcnQxOmVuZDEsIHN0YXJ0MjplbmQyLCAuLi5dJyxcbiAgICAnW3N0YXJ0MTpzdGVwMTplbmQxLCBzdGFydDI6c3RlcDI6ZW5kMiwgLi4uXSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDcmVhdGUgYW4gaW5kZXggdG8gZ2V0IG9yIHJlcGxhY2UgYSBzdWJzZXQgb2YgYSBtYXRyaXgnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ1tdJyxcbiAgICAnWzEsIDIsIDNdJyxcbiAgICAnQSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ0FbMSwgOl0nLFxuICAgICdBWzEsIDJdID0gNTAnLFxuICAgICdBWzA6MiwgMDoyXSA9IG9uZXMoMiwgMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnYm9vbGVhbicsICdjb21wbGV4JywgJ21hdHJpeCwnLCAnbnVtYmVyJywgJ3JhbmdlJywgJ3N0cmluZycsICd1bml0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ21hdHJpeCcsXG4gICdjYXRlZ29yeSc6ICdUeXBlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnW10nLFxuICAgICdbYTEsIGIxLCAuLi47IGEyLCBiMiwgLi4uXScsXG4gICAgJ21hdHJpeCgpJyxcbiAgICAnbWF0cml4KFsuLi5dKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDcmVhdGUgYSBtYXRyaXguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdbXScsXG4gICAgJ1sxLCAyLCAzXScsXG4gICAgJ1sxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ21hdHJpeCgpJyxcbiAgICAnbWF0cml4KFszLCA0XSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnYm9vbGVhbicsICdjb21wbGV4JywgJ2luZGV4JywgJ251bWJlcicsICdzdHJpbmcnLCAndW5pdCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdudW1iZXInLFxuICAnY2F0ZWdvcnknOiAnVHlwZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3gnLFxuICAgICdudW1iZXIoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ3JlYXRlIGEgbnVtYmVyIG9yIGNvbnZlcnQgYSBzdHJpbmcgb3IgYm9vbGVhbiBpbnRvIGEgbnVtYmVyLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMicsXG4gICAgJzJlMycsXG4gICAgJzQuMDUnLFxuICAgICdudW1iZXIoMiknLFxuICAgICdudW1iZXIoXCI3LjJcIiknLFxuICAgICdudW1iZXIodHJ1ZSknLFxuICAgICdudW1iZXIoW3RydWUsIGZhbHNlLCB0cnVlLCB0cnVlXSknLFxuICAgICdudW1iZXIoXCI1MmNtXCIsIFwibVwiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2JpZ251bWJlcicsICdib29sZWFuJywgJ2NvbXBsZXgnLCAnaW5kZXgnLCAnbWF0cml4JywgJ3N0cmluZycsICd1bml0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3N0cmluZycsXG4gICdjYXRlZ29yeSc6ICdUeXBlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnXCJ0ZXh0XCInLFxuICAgICdzdHJpbmcoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ3JlYXRlIGEgc3RyaW5nIG9yIGNvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZycsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnXCJIZWxsbyBXb3JsZCFcIicsXG4gICAgJ3N0cmluZyg0LjIpJyxcbiAgICAnc3RyaW5nKDMgKyAyaSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnYm9vbGVhbicsICdjb21wbGV4JywgJ2luZGV4JywgJ21hdHJpeCcsICdudW1iZXInLCAndW5pdCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd1bml0JyxcbiAgJ2NhdGVnb3J5JzogJ1R5cGUnLFxuICAnc3ludGF4JzogW1xuICAgICd2YWx1ZSB1bml0JyxcbiAgICAndW5pdCh2YWx1ZSwgdW5pdCknLFxuICAgICd1bml0KHN0cmluZyknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ3JlYXRlIGEgdW5pdC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzUuNSBtbScsXG4gICAgJzMgaW5jaCcsXG4gICAgJ3VuaXQoNy4xLCBcImtpbG9ncmFtXCIpJyxcbiAgICAndW5pdChcIjIzIGRlZ1wiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2JpZ251bWJlcicsICdib29sZWFuJywgJ2NvbXBsZXgnLCAnaW5kZXgnLCAnbWF0cml4JywgJ251bWJlcicsICdzdHJpbmcnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZXZhbCcsXG4gICdjYXRlZ29yeSc6ICdFeHByZXNzaW9uJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZXZhbChleHByZXNzaW9uKScsXG4gICAgJ2V2YWwoW2V4cHIxLCBleHByMiwgZXhwcjMsIC4uLl0pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnRXZhbHVhdGUgYW4gZXhwcmVzc2lvbiBvciBhbiBhcnJheSB3aXRoIGV4cHJlc3Npb25zLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZXZhbChcIjIgKyAzXCIpJyxcbiAgICAnZXZhbChcInNxcnQoXCIgKyA0ICsgXCIpXCIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2hlbHAnLFxuICAnY2F0ZWdvcnknOiAnRXhwcmVzc2lvbicsXG4gICdzeW50YXgnOiBbXG4gICAgJ2hlbHAob2JqZWN0KScsXG4gICAgJ2hlbHAoc3RyaW5nKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0Rpc3BsYXkgZG9jdW1lbnRhdGlvbiBvbiBhIGZ1bmN0aW9uIG9yIGRhdGEgdHlwZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2hlbHAoc3FydCknLFxuICAgICdoZWxwKFwiY29tcGxleFwiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb25jYXQnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY29uY2F0KEEsIEIsIEMsIC4uLiknLFxuICAgICdjb25jYXQoQSwgQiwgQywgLi4uLCBkaW0pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29uY2F0ZW5hdGUgbWF0cmljZXMuIEJ5IGRlZmF1bHQsIHRoZSBtYXRyaWNlcyBhcmUgY29uY2F0ZW5hdGVkIGJ5IHRoZSBsYXN0IGRpbWVuc2lvbi4gVGhlIGRpbWVuc2lvbiBvbiB3aGljaCB0byBjb25jYXRlbmF0ZSBjYW4gYmUgcHJvdmlkZWQgYXMgbGFzdCBhcmd1bWVudC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ0EgPSBbMSwgMjsgNSwgNl0nLFxuICAgICdCID0gWzMsIDQ7IDcsIDhdJyxcbiAgICAnY29uY2F0KEEsIEIpJyxcbiAgICAnY29uY2F0KEEsIEIsIDEpJyxcbiAgICAnY29uY2F0KEEsIEIsIDIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NpemUnLCAnc3F1ZWV6ZScsICdzdWJzZXQnLCAndHJhbnNwb3NlJywgJ3plcm9zJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2RldCcsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdkZXQoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGRldGVybWluYW50IG9mIGEgbWF0cml4JyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdkZXQoWzEsIDI7IDMsIDRdKScsXG4gICAgJ2RldChbLTIsIDIsIDM7IC0xLCAxLCAzOyAyLCAwLCAtMV0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY29uY2F0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NpemUnLCAnc3F1ZWV6ZScsICdzdWJzZXQnLCAndHJhbnNwb3NlJywgJ3plcm9zJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2RpYWcnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZGlhZyh4KScsXG4gICAgJ2RpYWcoeCwgayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDcmVhdGUgYSBkaWFnb25hbCBtYXRyaXggb3IgcmV0cmlldmUgdGhlIGRpYWdvbmFsIG9mIGEgbWF0cml4LiBXaGVuIHggaXMgYSB2ZWN0b3IsIGEgbWF0cml4IHdpdGggdGhlIHZlY3RvciB2YWx1ZXMgb24gdGhlIGRpYWdvbmFsIHdpbGwgYmUgcmV0dXJuZWQuIFdoZW4geCBpcyBhIG1hdHJpeCwgYSB2ZWN0b3Igd2l0aCB0aGUgZGlhZ29uYWwgdmFsdWVzIG9mIHRoZSBtYXRyaXggaXMgcmV0dXJuZWQuIFdoZW4gayBpcyBwcm92aWRlZCwgdGhlIGstdGggZGlhZ29uYWwgd2lsbCBiZSBmaWxsZWQgaW4gb3IgcmV0cmlldmVkLCBpZiBrIGlzIHBvc2l0aXZlLCB0aGUgdmFsdWVzIGFyZSBwbGFjZWQgb24gdGhlIHN1cGVyIGRpYWdvbmFsLiBXaGVuIGsgaXMgbmVnYXRpdmUsIHRoZSB2YWx1ZXMgYXJlIHBsYWNlZCBvbiB0aGUgc3ViIGRpYWdvbmFsLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZGlhZygxOjMpJyxcbiAgICAnZGlhZygxOjMsIDEpJyxcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2OyA3LCA4LCA5XScsXG4gICAgJ2RpYWcoYSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2V5ZScsICdpbnYnLCAnb25lcycsICdyYW5nZScsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdleWUnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZXllKG4pJyxcbiAgICAnZXllKG0sIG4pJyxcbiAgICAnZXllKFttLCBuXSknLFxuICAgICdleWUnXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdSZXR1cm5zIHRoZSBpZGVudGl0eSBtYXRyaXggd2l0aCBzaXplIG0tYnktbi4gVGhlIG1hdHJpeCBoYXMgb25lcyBvbiB0aGUgZGlhZ29uYWwgYW5kIHplcm9zIGVsc2V3aGVyZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2V5ZSgzKScsXG4gICAgJ2V5ZSgzLCA1KScsXG4gICAgJ2EgPSBbMSwgMiwgMzsgNCwgNSwgNl0nLFxuICAgICdleWUoc2l6ZShhKSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnaW52JywgJ29uZXMnLCAncmFuZ2UnLCAnc2l6ZScsICdzcXVlZXplJywgJ3N1YnNldCcsICd0cmFuc3Bvc2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZmxhdHRlbicsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdmbGF0dGVuKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnRmxhdHRlbiBhIG11bHRpIGRpbWVuc2lvbmFsIG1hdHJpeCBpbnRvIGEgc2luZ2xlIGRpbWVuc2lvbmFsIG1hdHJpeC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2EgPSBbMSwgMiwgMzsgNCwgNSwgNl0nLFxuICAgICdzaXplKGEpJyxcbiAgICAnYiA9IGZsYXR0ZW4oYSknLFxuICAgICdzaXplKGIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY29uY2F0JywgJ3Jlc2l6ZScsICdzaXplJywgJ3NxdWVlemUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnaW52JyxcbiAgJ2NhdGVnb3J5JzogJ01hdHJpeCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ2ludih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgaW52ZXJzZSBvZiBhIG1hdHJpeCcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaW52KFsxLCAyOyAzLCA0XSknLFxuICAgICdpbnYoNCknLFxuICAgICcxIC8gNCdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvbmNhdCcsICdkZXQnLCAnZGlhZycsICdleWUnLCAnb25lcycsICdyYW5nZScsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdvbmVzJyxcbiAgJ2NhdGVnb3J5JzogJ01hdHJpeCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ29uZXMobSknLFxuICAgICdvbmVzKG0sIG4pJyxcbiAgICAnb25lcyhtLCBuLCBwLCAuLi4pJyxcbiAgICAnb25lcyhbbV0pJyxcbiAgICAnb25lcyhbbSwgbl0pJyxcbiAgICAnb25lcyhbbSwgbiwgcCwgLi4uXSknLFxuICAgICdvbmVzJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ3JlYXRlIGEgbWF0cml4IGNvbnRhaW5pbmcgb25lcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ29uZXMoMyknLFxuICAgICdvbmVzKDMsIDUpJyxcbiAgICAnb25lcyhbMiwzXSkgKiA0LjUnLFxuICAgICdhID0gWzEsIDIsIDM7IDQsIDUsIDZdJyxcbiAgICAnb25lcyhzaXplKGEpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvbmNhdCcsICdkZXQnLCAnZGlhZycsICdleWUnLCAnaW52JywgJ3JhbmdlJywgJ3NpemUnLCAnc3F1ZWV6ZScsICdzdWJzZXQnLCAndHJhbnNwb3NlJywgJ3plcm9zJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3JhbmdlJyxcbiAgJ2NhdGVnb3J5JzogJ1R5cGUnLFxuICAnc3ludGF4JzogW1xuICAgICdzdGFydDplbmQnLFxuICAgICdzdGFydDpzdGVwOmVuZCcsXG4gICAgJ3JhbmdlKHN0YXJ0LCBlbmQpJyxcbiAgICAncmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCknLFxuICAgICdyYW5nZShzdHJpbmcpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NyZWF0ZSBhIHJhbmdlLiBMb3dlciBib3VuZCBvZiB0aGUgcmFuZ2UgaXMgaW5jbHVkZWQsIHVwcGVyIGJvdW5kIGlzIGV4Y2x1ZGVkLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMTo1JyxcbiAgICAnMzotMTotMycsXG4gICAgJ3JhbmdlKDMsIDcpJyxcbiAgICAncmFuZ2UoMCwgMTIsIDIpJyxcbiAgICAncmFuZ2UoXCI0OjEwXCIpJyxcbiAgICAnYSA9IFsxLCAyLCAzLCA0OyA1LCA2LCA3LCA4XScsXG4gICAgJ2FbMToyLCAxOjJdJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY29uY2F0JywgJ2RldCcsICdkaWFnJywgJ2V5ZScsICdpbnYnLCAnb25lcycsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdyZXNpemUnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncmVzaXplKHgsIHNpemUpJyxcbiAgICAncmVzaXplKHgsIHNpemUsIGRlZmF1bHRWYWx1ZSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdSZXNpemUgYSBtYXRyaXguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdyZXNpemUoWzEsMiwzLDQsNV0sIFszXSknLFxuICAgICdyZXNpemUoWzEsMiwzXSwgWzVdKScsXG4gICAgJ3Jlc2l6ZShbMSwyLDNdLCBbNV0sIC0xKScsXG4gICAgJ3Jlc2l6ZSgyLCBbMiwgM10pJyxcbiAgICAncmVzaXplKFwiaGVsbG9cIiwgWzhdLCBcIiFcIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdzaXplJywgJ3N1YnNldCcsICdzcXVlZXplJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3NpemUnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc2l6ZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBhIG1hdHJpeC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3NpemUoMi4zKScsXG4gICAgJ3NpemUoXCJoZWxsbyB3b3JsZFwiKScsXG4gICAgJ2EgPSBbMSwgMjsgMywgNDsgNSwgNl0nLFxuICAgICdzaXplKGEpJyxcbiAgICAnc2l6ZSgxOjYpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY29uY2F0JywgJ2RldCcsICdkaWFnJywgJ2V5ZScsICdpbnYnLCAnb25lcycsICdyYW5nZScsICdzcXVlZXplJywgJ3N1YnNldCcsICd0cmFuc3Bvc2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc3F1ZWV6ZScsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdzcXVlZXplKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUmVtb3ZlIGlubmVyIGFuZCBvdXRlciBzaW5nbGV0b24gZGltZW5zaW9ucyBmcm9tIGEgbWF0cml4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IHplcm9zKDMsMiwxKScsXG4gICAgJ3NpemUoc3F1ZWV6ZShhKSknLFxuICAgICdiID0gemVyb3MoMSwxLDMpJyxcbiAgICAnc2l6ZShzcXVlZXplKGIpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvbmNhdCcsICdkZXQnLCAnZGlhZycsICdleWUnLCAnaW52JywgJ29uZXMnLCAncmFuZ2UnLCAnc2l6ZScsICdzdWJzZXQnLCAndHJhbnNwb3NlJywgJ3plcm9zJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3N1YnNldCcsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICd2YWx1ZShpbmRleCknLFxuICAgICd2YWx1ZShpbmRleCkgPSByZXBsYWNlbWVudCcsXG4gICAgJ3N1YnNldCh2YWx1ZSwgW2luZGV4XSknLFxuICAgICdzdWJzZXQodmFsdWUsIFtpbmRleF0sIHJlcGxhY2VtZW50KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0dldCBvciBzZXQgYSBzdWJzZXQgb2YgYSBtYXRyaXggb3Igc3RyaW5nLiAnICtcbiAgICAgICdJbmRleGVzIGFyZSBvbmUtYmFzZWQuICcgK1xuICAgICAgJ0JvdGggdGhlIHJhbmdlcyBsb3dlci1ib3VuZCBhbmQgdXBwZXItYm91bmQgYXJlIGluY2x1ZGVkLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZCA9IFsxLCAyOyAzLCA0XScsXG4gICAgJ2UgPSBbXScsXG4gICAgJ2VbMSwgMToyXSA9IFs1LCA2XScsXG4gICAgJ2VbMiwgOl0gPSBbNywgOF0nLFxuICAgICdmID0gZCAqIGUnLFxuICAgICdmWzIsIDFdJyxcbiAgICAnZls6LCAxXSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvbmNhdCcsICdkZXQnLCAnZGlhZycsICdleWUnLCAnaW52JywgJ29uZXMnLCAncmFuZ2UnLCAnc2l6ZScsICdzcXVlZXplJywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd0cmFuc3Bvc2UnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneFxcJycsXG4gICAgJ3RyYW5zcG9zZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1RyYW5zcG9zZSBhIG1hdHJpeCcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ2FcXCcnLFxuICAgICd0cmFuc3Bvc2UoYSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NpemUnLCAnc3F1ZWV6ZScsICdzdWJzZXQnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnemVyb3MnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnemVyb3MobSknLFxuICAgICd6ZXJvcyhtLCBuKScsXG4gICAgJ3plcm9zKG0sIG4sIHAsIC4uLiknLFxuICAgICd6ZXJvcyhbbV0pJyxcbiAgICAnemVyb3MoW20sIG5dKScsXG4gICAgJ3plcm9zKFttLCBuLCBwLCAuLi5dKScsXG4gICAgJ3plcm9zJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ3JlYXRlIGEgbWF0cml4IGNvbnRhaW5pbmcgemVyb3MuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd6ZXJvcygzKScsXG4gICAgJ3plcm9zKDMsIDUpJyxcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ3plcm9zKHNpemUoYSkpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY29uY2F0JywgJ2RldCcsICdkaWFnJywgJ2V5ZScsICdpbnYnLCAnb25lcycsICdyYW5nZScsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYW5zcG9zZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb21iaW5hdGlvbnMnLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICdjb21iaW5hdGlvbnMobiwgayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBudW1iZXIgb2YgY29tYmluYXRpb25zIG9mIG4gaXRlbXMgdGFrZW4gayBhdCBhIHRpbWUnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvbWJpbmF0aW9ucyg3LCA1KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3Blcm11dGF0aW9ucycsICdmYWN0b3JpYWwnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdmYWN0b3JpYWwnLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICduIScsXG4gICAgJ2ZhY3RvcmlhbChuKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGZhY3RvcmlhbCBvZiBhIHZhbHVlJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICc1IScsXG4gICAgJzUqNCozKjIqMScsXG4gICAgJzMhJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnY29tYmluYXRpb25zJywgJ3Blcm11dGF0aW9ucyddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3Blcm11dGF0aW9ucycsXG4gICdjYXRlZ29yeSc6ICdQcm9iYWJpbGl0eScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3Blcm11dGF0aW9ucyhuKScsXG4gICAgJ3Blcm11dGF0aW9ucyhuLCBrKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIG51bWJlciBvZiBwZXJtdXRhdGlvbnMgb2YgbiBpdGVtcyB0YWtlbiBrIGF0IGEgdGltZScsXG4gICdleGFtcGxlcyc6IFtcbiAgICAncGVybXV0YXRpb25zKDUpJyxcbiAgICAncGVybXV0YXRpb25zKDUsIDMpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnY29tYmluYXRpb25zJywgJ2ZhY3RvcmlhbCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3BpY2tSYW5kb20nLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICdwaWNrUmFuZG9tKGFycmF5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdQaWNrIGEgcmFuZG9tIGVudHJ5IGZyb20gYSBnaXZlbiBhcnJheS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3BpY2tSYW5kb20oMDoxMCknLFxuICAgICdwaWNrUmFuZG9tKFsxLCAzLCAxLCA2XSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydyYW5kb20nLCAncmFuZG9tSW50J11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncmFuZG9tJyxcbiAgJ2NhdGVnb3J5JzogJ1Byb2JhYmlsaXR5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncmFuZG9tKCknLFxuICAgICdyYW5kb20obWF4KScsXG4gICAgJ3JhbmRvbShtaW4sIG1heCknLFxuICAgICdyYW5kb20oc2l6ZSknLFxuICAgICdyYW5kb20oc2l6ZSwgbWF4KScsXG4gICAgJ3JhbmRvbShzaXplLCBtaW4sIG1heCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnUmV0dXJuIGEgcmFuZG9tIG51bWJlci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3JhbmRvbSgpJyxcbiAgICAncmFuZG9tKDEwLCAyMCknLFxuICAgICdyYW5kb20oWzIsIDNdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3BpY2tSYW5kb20nLCAncmFuZG9tSW50J11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncmFuZEludCcsXG4gICdjYXRlZ29yeSc6ICdQcm9iYWJpbGl0eScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3JhbmRJbnQoKScsXG4gICAgJ3JhbmRJbnQobWF4KScsXG4gICAgJ3JhbmRJbnQobWluLCBtYXgpJyxcbiAgICAncmFuZEludChzaXplKScsXG4gICAgJ3JhbmRJbnQoc2l6ZSwgbWF4KScsXG4gICAgJ3JhbmRJbnQoc2l6ZSwgbWluLCBtYXgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ1JldHVybiBhIHJhbmRvbSBpbnRlZ2VyIG51bWJlcicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAncmFuZEludCgpJyxcbiAgICAncmFuZEludCgxMCwgMjApJyxcbiAgICAncmFuZEludChbMiwgM10sIDEwKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3BpY2tSYW5kb20nLCAncmFuZG9tJ11cbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ21heCcsXG4gICdjYXRlZ29yeSc6ICdTdGF0aXN0aWNzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbWF4KGEsIGIsIGMsIC4uLiknLFxuICAgICdtYXgoQSknLFxuICAgICdtYXgoQSwgZGltKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIG1heGltdW0gdmFsdWUgb2YgYSBsaXN0IG9mIHZhbHVlcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ21heCgyLCAzLCA0LCAxKScsXG4gICAgJ21heChbMiwgMywgNCwgMV0pJyxcbiAgICAnbWF4KFsyLCA1OyA0LCAzXSwgMCknLFxuICAgICdtYXgoWzIsIDU7IDQsIDNdLCAxKScsXG4gICAgJ21heCgyLjcsIDcuMSwgLTQuNSwgMi4wLCA0LjEpJyxcbiAgICAnbWluKDIuNywgNy4xLCAtNC41LCAyLjAsIDQuMSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtZWFuJyxcbiAgICAnbWVkaWFuJyxcbiAgICAnbWluJyxcbiAgICAncHJvZCcsXG4gICAgJ3N0ZCcsXG4gICAgJ3N1bScsXG4gICAgJ3ZhcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdtZWFuJyxcbiAgJ2NhdGVnb3J5JzogJ1N0YXRpc3RpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICdtZWFuKGEsIGIsIGMsIC4uLiknLFxuICAgICdtZWFuKEEpJyxcbiAgICAnbWVhbihBLCBkaW0pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgYXJpdGhtZXRpYyBtZWFuIG9mIGEgbGlzdCBvZiB2YWx1ZXMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdtZWFuKDIsIDMsIDQsIDEpJyxcbiAgICAnbWVhbihbMiwgMywgNCwgMV0pJyxcbiAgICAnbWVhbihbMiwgNTsgNCwgM10sIDApJyxcbiAgICAnbWVhbihbMiwgNTsgNCwgM10sIDEpJyxcbiAgICAnbWVhbihbMS4wLCAyLjcsIDMuMiwgNC4wXSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtYXgnLFxuICAgICdtZWRpYW4nLFxuICAgICdtaW4nLFxuICAgICdwcm9kJyxcbiAgICAnc3RkJyxcbiAgICAnc3VtJyxcbiAgICAndmFyJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ21lZGlhbicsXG4gICdjYXRlZ29yeSc6ICdTdGF0aXN0aWNzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbWVkaWFuKGEsIGIsIGMsIC4uLiknLFxuICAgICdtZWRpYW4oQSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBtZWRpYW4gb2YgYWxsIHZhbHVlcy4gVGhlIHZhbHVlcyBhcmUgc29ydGVkIGFuZCB0aGUgbWlkZGxlIHZhbHVlIGlzIHJldHVybmVkLiBJbiBjYXNlIG9mIGFuIGV2ZW4gbnVtYmVyIG9mIHZhbHVlcywgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBtaWRkbGUgdmFsdWVzIGlzIHJldHVybmVkLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnbWVkaWFuKDUsIDIsIDcpJyxcbiAgICAnbWVkaWFuKFszLCAtMSwgNSwgN10pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbWF4JyxcbiAgICAnbWVhbicsXG4gICAgJ21pbicsXG4gICAgJ3Byb2QnLFxuICAgICdzdGQnLFxuICAgICdzdW0nLFxuICAgICd2YXInXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbWluJyxcbiAgJ2NhdGVnb3J5JzogJ1N0YXRpc3RpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICdtaW4oYSwgYiwgYywgLi4uKScsXG4gICAgJ21pbihBKScsXG4gICAgJ21pbihBLCBkaW0pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgbWluaW11bSB2YWx1ZSBvZiBhIGxpc3Qgb2YgdmFsdWVzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnbWluKDIsIDMsIDQsIDEpJyxcbiAgICAnbWluKFsyLCAzLCA0LCAxXSknLFxuICAgICdtaW4oWzIsIDU7IDQsIDNdLCAwKScsXG4gICAgJ21pbihbMiwgNTsgNCwgM10sIDEpJyxcbiAgICAnbWluKDIuNywgNy4xLCAtNC41LCAyLjAsIDQuMSknLFxuICAgICdtYXgoMi43LCA3LjEsIC00LjUsIDIuMCwgNC4xKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ21heCcsXG4gICAgJ21lYW4nLFxuICAgICdtZWRpYW4nLFxuICAgICdwcm9kJyxcbiAgICAnc3RkJyxcbiAgICAnc3VtJyxcbiAgICAndmFyJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3Byb2QnLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3Byb2QoYSwgYiwgYywgLi4uKScsXG4gICAgJ3Byb2QoQSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBwcm9kdWN0IG9mIGFsbCB2YWx1ZXMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdwcm9kKDIsIDMsIDQpJyxcbiAgICAncHJvZChbMiwgMywgNF0pJyxcbiAgICAncHJvZChbMiwgNTsgNCwgM10pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbWF4JyxcbiAgICAnbWVhbicsXG4gICAgJ21pbicsXG4gICAgJ21lZGlhbicsXG4gICAgJ21pbicsXG4gICAgJ3N0ZCcsXG4gICAgJ3N1bScsXG4gICAgJ3ZhcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzdGQnLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3N0ZChhLCBiLCBjLCAuLi4pJyxcbiAgICAnc3RkKEEpJyxcbiAgICAnc3RkKEEsIG5vcm1hbGl6YXRpb24pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGFsbCB2YWx1ZXMsIGRlZmluZWQgYXMgc3RkKEEpID0gc3FydCh2YXIoQSkpLiBPcHRpb25hbCBwYXJhbWV0ZXIgbm9ybWFsaXphdGlvbiBjYW4gYmUgXCJ1bmJpYXNlZFwiIChkZWZhdWx0KSwgXCJ1bmNvcnJlY3RlZFwiLCBvciBcImJpYXNlZFwiLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc3RkKDIsIDQsIDYpJyxcbiAgICAnc3RkKFsyLCA0LCA2LCA4XSknLFxuICAgICdzdGQoWzIsIDQsIDYsIDhdLCBcInVuY29ycmVjdGVkXCIpJyxcbiAgICAnc3RkKFsyLCA0LCA2LCA4XSwgXCJiaWFzZWRcIiknLFxuICAgICdzdGQoWzEsIDIsIDM7IDQsIDUsIDZdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ21heCcsXG4gICAgJ21lYW4nLFxuICAgICdtaW4nLFxuICAgICdtZWRpYW4nLFxuICAgICdtaW4nLFxuICAgICdwcm9kJyxcbiAgICAnc3VtJyxcbiAgICAndmFyJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3N1bScsXG4gICdjYXRlZ29yeSc6ICdTdGF0aXN0aWNzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc3VtKGEsIGIsIGMsIC4uLiknLFxuICAgICdzdW0oQSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBzdW0gb2YgYWxsIHZhbHVlcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3N1bSgyLCAzLCA0LCAxKScsXG4gICAgJ3N1bShbMiwgMywgNCwgMV0pJyxcbiAgICAnc3VtKFsyLCA1OyA0LCAzXSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtYXgnLFxuICAgICdtZWFuJyxcbiAgICAnbWVkaWFuJyxcbiAgICAnbWluJyxcbiAgICAncHJvZCcsXG4gICAgJ3N0ZCcsXG4gICAgJ3N1bScsXG4gICAgJ3ZhcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd2YXInLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ZhcihhLCBiLCBjLCAuLi4pJyxcbiAgICAndmFyKEEpJyxcbiAgICAndmFyKEEsIG5vcm1hbGl6YXRpb24pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgdmFyaWFuY2Ugb2YgYWxsIHZhbHVlcy4gT3B0aW9uYWwgcGFyYW1ldGVyIG5vcm1hbGl6YXRpb24gY2FuIGJlIFwidW5iaWFzZWRcIiAoZGVmYXVsdCksIFwidW5jb3JyZWN0ZWRcIiwgb3IgXCJiaWFzZWRcIi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3ZhcigyLCA0LCA2KScsXG4gICAgJ3ZhcihbMiwgNCwgNiwgOF0pJyxcbiAgICAndmFyKFsyLCA0LCA2LCA4XSwgXCJ1bmNvcnJlY3RlZFwiKScsXG4gICAgJ3ZhcihbMiwgNCwgNiwgOF0sIFwiYmlhc2VkXCIpJyxcbiAgICAndmFyKFsxLCAyLCAzOyA0LCA1LCA2XSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtYXgnLFxuICAgICdtZWFuJyxcbiAgICAnbWluJyxcbiAgICAnbWVkaWFuJyxcbiAgICAnbWluJyxcbiAgICAncHJvZCcsXG4gICAgJ3N0ZCcsXG4gICAgJ3N1bSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhY29zJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Fjb3MoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBpbnZlcnNlIGNvc2luZSBvZiBhIHZhbHVlIGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhY29zKDAuNSknLFxuICAgICdhY29zKGNvcygyLjMpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvcycsXG4gICAgJ2F0YW4nLFxuICAgICdhc2luJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2FzaW4nLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYXNpbih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGludmVyc2Ugc2luZSBvZiBhIHZhbHVlIGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhc2luKDAuNSknLFxuICAgICdhc2luKHNpbigyLjMpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3NpbicsXG4gICAgJ2Fjb3MnLFxuICAgICdhdGFuJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2F0YW4nLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYXRhbih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGludmVyc2UgdGFuZ2VudCBvZiBhIHZhbHVlIGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhdGFuKDAuNSknLFxuICAgICdhdGFuKHRhbigyLjMpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3RhbicsXG4gICAgJ2Fjb3MnLFxuICAgICdhc2luJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2F0YW4yJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2F0YW4yKHksIHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbXB1dGVzIHRoZSBwcmluY2lwYWwgdmFsdWUgb2YgdGhlIGFyYyB0YW5nZW50IG9mIHkveCBpbiByYWRpYW5zLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYXRhbjIoMiwgMikgLyBwaScsXG4gICAgJ2FuZ2xlID0gNjAgZGVnIGluIHJhZCcsXG4gICAgJ3ggPSBjb3MoYW5nbGUpJyxcbiAgICAneSA9IHNpbihhbmdsZSknLFxuICAgICdhdGFuMih5LCB4KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3NpbicsXG4gICAgJ2NvcycsXG4gICAgJ3RhbidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb3MnLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY29zKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgY29zaW5lIG9mIHggaW4gcmFkaWFucy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvcygyKScsXG4gICAgJ2NvcyhwaSAvIDQpIF4gMicsXG4gICAgJ2NvcygxODAgZGVnKScsXG4gICAgJ2Nvcyg2MCBkZWcpJyxcbiAgICAnc2luKDAuMileMiArIGNvcygwLjIpXjInXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdhY29zJyxcbiAgICAnc2luJyxcbiAgICAndGFuJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgJ25hbWUnOiAnY29zaCcsXHJcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXHJcbiAgJ3N5bnRheCc6IFtcclxuICAgICdjb3NoKHgpJ1xyXG4gIF0sXHJcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIHggaW4gcmFkaWFucy4nLFxyXG4gICdleGFtcGxlcyc6IFtcclxuICAgICdjb3NoKDAuNSknXHJcbiAgXSxcclxuICAnc2VlYWxzbyc6IFtcclxuICAgICdzaW5oJyxcclxuICAgICd0YW5oJyxcclxuICAgICdjb3RoJ1xyXG4gIF1cclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvdCcsXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdjb3QoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBjb3RhbmdlbnQgb2YgeCBpbiByYWRpYW5zLiBEZWZpbmVkIGFzIDEvdGFuKHgpJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjb3QoMiknLFxuICAgICcxIC8gdGFuKDIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnc2VjJyxcbiAgICAnY3NjJyxcbiAgICAndGFuJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgJ25hbWUnOiAnY290aCcsXHJcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXHJcbiAgJ3N5bnRheCc6IFtcclxuICAgICdjb3RoKHgpJ1xyXG4gIF0sXHJcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGh5cGVyYm9saWMgY290YW5nZW50IG9mIHggaW4gcmFkaWFucy4nLFxyXG4gICdleGFtcGxlcyc6IFtcclxuICAgICdjb3RoKDIpJyxcclxuICAgICcxIC8gdGFuaCgyKSdcclxuICBdLFxyXG4gICdzZWVhbHNvJzogW1xyXG4gICAgJ3NlY2gnLFxyXG4gICAgJ2NzY2gnLFxyXG4gICAgJ3RhbmgnXHJcbiAgXVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY3NjJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2NzYyh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGNvc2VjYW50IG9mIHggaW4gcmFkaWFucy4gRGVmaW5lZCBhcyAxL3Npbih4KScsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnY3NjKDIpJyxcbiAgICAnMSAvIHNpbigyKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3NlYycsXG4gICAgJ2NvdCcsXG4gICAgJ3NpbidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICduYW1lJzogJ2NzY2gnLFxyXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxyXG4gICdzeW50YXgnOiBbXHJcbiAgICAnY3NjaCh4KSdcclxuICBdLFxyXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBoeXBlcmJvbGljIGNvc2VjYW50IG9mIHggaW4gcmFkaWFucy4gRGVmaW5lZCBhcyAxL3NpbmgoeCknLFxyXG4gICdleGFtcGxlcyc6IFtcclxuICAgICdjc2NoKDIpJyxcclxuICAgICcxIC8gc2luaCgyKSdcclxuICBdLFxyXG4gICdzZWVhbHNvJzogW1xyXG4gICAgJ3NlY2gnLFxyXG4gICAgJ2NvdGgnLFxyXG4gICAgJ3NpbmgnXHJcbiAgXVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc2VjJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NlYyh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIHNlY2FudCBvZiB4IGluIHJhZGlhbnMuIERlZmluZWQgYXMgMS9jb3MoeCknLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3NlYygyKScsXG4gICAgJzEgLyBjb3MoMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb3QnLFxuICAgICdjc2MnLFxuICAgICdjb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAnbmFtZSc6ICdzZWNoJyxcclxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcclxuICAnc3ludGF4JzogW1xyXG4gICAgJ3NlY2goeCknXHJcbiAgXSxcclxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgaHlwZXJib2xpYyBzZWNhbnQgb2YgeCBpbiByYWRpYW5zLiBEZWZpbmVkIGFzIDEvY29zaCh4KScsXHJcbiAgJ2V4YW1wbGVzJzogW1xyXG4gICAgJ3NlY2goMiknLFxyXG4gICAgJzEgLyBjb3NoKDIpJ1xyXG4gIF0sXHJcbiAgJ3NlZWFsc28nOiBbXHJcbiAgICAnY290aCcsXHJcbiAgICAnY3NjaCcsXHJcbiAgICAnY29zaCdcclxuICBdXHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzaW4nLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc2luKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgc2luZSBvZiB4IGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzaW4oMiknLFxuICAgICdzaW4ocGkgLyA0KSBeIDInLFxuICAgICdzaW4oOTAgZGVnKScsXG4gICAgJ3NpbigzMCBkZWcpJyxcbiAgICAnc2luKDAuMileMiArIGNvcygwLjIpXjInXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdhc2luJyxcbiAgICAnY29zJyxcbiAgICAndGFuJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgJ25hbWUnOiAnc2luaCcsXHJcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXHJcbiAgJ3N5bnRheCc6IFtcclxuICAgICdzaW5oKHgpJ1xyXG4gIF0sXHJcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGh5cGVyYm9saWMgc2luZSBvZiB4IGluIHJhZGlhbnMuJyxcclxuICAnZXhhbXBsZXMnOiBbXHJcbiAgICAnc2luaCgwLjUpJ1xyXG4gIF0sXHJcbiAgJ3NlZWFsc28nOiBbXHJcbiAgICAnY29zaCcsXHJcbiAgICAndGFuaCdcclxuICBdXHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd0YW4nLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndGFuKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgdGFuZ2VudCBvZiB4IGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd0YW4oMC41KScsXG4gICAgJ3NpbigwLjUpIC8gY29zKDAuNSknLFxuICAgICd0YW4ocGkgLyA0KScsXG4gICAgJ3Rhbig0NSBkZWcpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYXRhbicsXG4gICAgJ3NpbicsXG4gICAgJ2NvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICduYW1lJzogJ3RhbmgnLFxyXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxyXG4gICdzeW50YXgnOiBbXHJcbiAgICAndGFuaCh4KSdcclxuICBdLFxyXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgeCBpbiByYWRpYW5zLicsXHJcbiAgJ2V4YW1wbGVzJzogW1xyXG4gICAgJ3RhbmgoMC41KScsXHJcbiAgICAnc2luaCgwLjUpIC8gY29zaCgwLjUpJ1xyXG4gIF0sXHJcbiAgJ3NlZWFsc28nOiBbXHJcbiAgICAnc2luaCcsXHJcbiAgICAnY29zaCdcclxuICBdXHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd0bycsXG4gICdjYXRlZ29yeSc6ICdVbml0cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggdG8gdW5pdCcsXG4gICAgJ3RvKHgsIHVuaXQpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2hhbmdlIHRoZSB1bml0IG9mIGEgdmFsdWUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICc1IGluY2ggdG8gY20nLFxuICAgICczLjJrZyB0byBnJyxcbiAgICAnMTYgYnl0ZXMgaW4gYml0cydcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjbG9uZScsXG4gICdjYXRlZ29yeSc6ICdVdGlscycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Nsb25lKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2xvbmUgYSB2YXJpYWJsZS4gQ3JlYXRlcyBhIGNvcHkgb2YgcHJpbWl0aXZlIHZhcmlhYmxlcyxhbmQgYSBkZWVwIGNvcHkgb2YgbWF0cmljZXMnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2Nsb25lKDMuNSknLFxuICAgICdjbG9uZSgyIC0gNGkpJyxcbiAgICAnY2xvbmUoNDUgZGVnKScsXG4gICAgJ2Nsb25lKFsxLCAyOyAzLCA0XSknLFxuICAgICdjbG9uZShcImhlbGxvIHdvcmxkXCIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ21hcCcsXG4gICdjYXRlZ29yeSc6ICdVdGlscycsXG4gICdzeW50YXgnOiBbXG4gICAgJ21hcCh4LCBjYWxsYmFjayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDcmVhdGUgYSBuZXcgbWF0cml4IG9yIGFycmF5IHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIG9uIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeC9hcnJheS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ21hcChbMSwgMiwgM10sIGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gdmFsdWUgKiB2YWx1ZSB9KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2ZpbHRlcicsICdmb3JFYWNoJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZmlsdGVyJyxcbiAgJ2NhdGVnb3J5JzogJ1V0aWxzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZmlsdGVyKHgsIHRlc3QpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnRmlsdGVyIGl0ZW1zIGluIGEgbWF0cml4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaXNQb3NpdGl2ZSh4KSA9IHggPiAwJyxcbiAgICAnZmlsdGVyKFs2LCAtMiwgLTEsIDQsIDNdLCBpc1Bvc2l0aXZlKScsXG4gICAgJ2ZpbHRlcihbNiwgLTIsIDAsIDEsIDBdLCB4ICE9IDApJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnc29ydCcsICdtYXAnLCAnZm9yRWFjaCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ZvckVhY2gnLFxuICAnY2F0ZWdvcnknOiAnVXRpbHMnLFxuICAnc3ludGF4JzogW1xuICAgICdmb3JFYWNoKHgsIGNhbGxiYWNrKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0l0ZXJhdGVzIG92ZXIgYWxsIGVsZW1lbnRzIG9mIGEgbWF0cml4L2FycmF5LCBhbmQgZXhlY3V0ZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGZ1bmN0aW9uLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZm9yRWFjaChbMSwgMiwgM10sIGZ1bmN0aW9uKHZhbCkgeyBjb25zb2xlLmxvZyh2YWwpIH0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnbWFwJywgJ3NvcnQnLCAnZmlsdGVyJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZm9ybWF0JyxcbiAgJ2NhdGVnb3J5JzogJ1V0aWxzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZm9ybWF0KHZhbHVlKScsXG4gICAgJ2Zvcm1hdCh2YWx1ZSwgcHJlY2lzaW9uKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0Zvcm1hdCBhIHZhbHVlIG9mIGFueSB0eXBlIGFzIHN0cmluZy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2Zvcm1hdCgyLjMpJyxcbiAgICAnZm9ybWF0KDMgLSA0aSknLFxuICAgICdmb3JtYXQoW10pJyxcbiAgICAnZm9ybWF0KHBpLCAzKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3ByaW50J11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnaW1wb3J0JyxcbiAgJ2NhdGVnb3J5JzogJ1V0aWxzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnaW1wb3J0KHN0cmluZyknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdJbXBvcnQgZnVuY3Rpb25zIGZyb20gYSBmaWxlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaW1wb3J0KFwibnVtYmVyc1wiKScsXG4gICAgJ2ltcG9ydChcIi4vbXlsaWIuanNcIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc29ydCcsXG4gICdjYXRlZ29yeSc6ICdVdGlscycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NvcnQoeCknLFxuICAgICdzb3J0KHgsIGNvbXBhcmUpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnU29ydCB0aGUgaXRlbXMgaW4gYSBtYXRyaXguIENvbXBhcmUgY2FuIGJlIGEgc3RyaW5nIFwiYXNjXCIgb3IgXCJkZXNjXCIsIG9yIGEgY3VzdG9tIHNvcnQgZnVuY3Rpb24uJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzb3J0KFs1LCAxMCwgMV0pJyxcbiAgICAnc29ydChbXCJDXCIsIFwiQlwiLCBcIkFcIiwgXCJEXCJdKScsXG4gICAgJ3NvcnRCeUxlbmd0aChhLCBiKSA9IHNpemUoYSlbMV0gLSBzaXplKGIpWzFdJyxcbiAgICAnc29ydChbXCJMYW5nZG9uXCIsIFwiVG9tXCIsIFwiU2FyYVwiXSwgc29ydEJ5TGVuZ3RoKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ21hcCcsICdmaWx0ZXInLCAnZm9yRWFjaCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3R5cGVvZicsXG4gICdjYXRlZ29yeSc6ICdVdGlscycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3R5cGVvZih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0dldCB0aGUgdHlwZSBvZiBhIHZhcmlhYmxlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAndHlwZW9mKDMuNSknLFxuICAgICd0eXBlb2YoMiAtIDRpKScsXG4gICAgJ3R5cGVvZig0NSBkZWcpJyxcbiAgICAndHlwZW9mKFwiaGVsbG8gd29ybGRcIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgdmFyaWFibGVcbiAqXG4gKiAgICAgdHlwZSh4KVxuICpcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7U3RyaW5nfSB0eXBlICBMb3dlciBjYXNlIHR5cGUsIGZvciBleGFtcGxlICdudW1iZXInLCAnc3RyaW5nJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgJ2FycmF5JywgJ2RhdGUnLlxuICovXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG5cbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHggPT09IG51bGwpICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIGlmICh4IGluc3RhbmNlb2YgQm9vbGVhbikgcmV0dXJuICdib29sZWFuJztcbiAgICBpZiAoeCBpbnN0YW5jZW9mIE51bWJlcikgIHJldHVybiAnbnVtYmVyJztcbiAgICBpZiAoeCBpbnN0YW5jZW9mIFN0cmluZykgIHJldHVybiAnc3RyaW5nJztcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSkgICAgIHJldHVybiAnYXJyYXknO1xuICAgIGlmICh4IGluc3RhbmNlb2YgRGF0ZSkgICAgcmV0dXJuICdkYXRlJztcbiAgICBpZiAoeCBpbnN0YW5jZW9mIFJlZ0V4cCkgIHJldHVybiAncmVnZXhwJztcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdmFsdWUgaXMgYSBCb29sZWFuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc0Jvb2xlYW5cbiAqL1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikgfHwgKHR5cGVvZiB2YWx1ZSA9PSAnYm9vbGVhbicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlciA9IHJlcXVpcmUoJy4vbnVtYmVyJyksXG4gICAgc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKSxcbiAgICBvYmplY3QgPSByZXF1aXJlKCcuL29iamVjdCcpLFxuICAgIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpLFxuXG4gICAgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9EaW1lbnNpb25FcnJvcicpLFxuICAgIEluZGV4RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9JbmRleEVycm9yJyksXG5cbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHNpemUgb2YgYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IHhcbiAqIEBSZXR1cm4ge051bWJlcltdfSBzaXplXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfc2l6ZSh4KSB7XG4gIHZhciBzaXplID0gW107XG5cbiAgd2hpbGUgKGlzQXJyYXkoeCkpIHtcbiAgICBzaXplLnB1c2goeC5sZW5ndGgpO1xuICAgIHggPSB4WzBdO1xuICB9XG5cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzaXplIG9mIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXkuXG4gKiBBbGwgZWxlbWVudHMgaW4gdGhlIGFycmF5IGFyZSBjaGVja2VkIGZvciBtYXRjaGluZyBkaW1lbnNpb25zIHVzaW5nIHRoZVxuICogbWV0aG9kIHZhbGlkYXRlXG4gKiBAcGFyYW0ge0FycmF5fSB4XG4gKiBAUmV0dXJuIHtOdW1iZXJbXX0gc2l6ZVxuICogQHRocm93cyBSYW5nZUVycm9yXG4gKi9cbmV4cG9ydHMuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgLy8gY2FsY3VsYXRlIHRoZSBzaXplXG4gIHZhciBzID0gX3NpemUoeCk7XG5cbiAgLy8gdmVyaWZ5IHRoZSBzaXplXG4gIGV4cG9ydHMudmFsaWRhdGUoeCwgcyk7XG4gIC8vIFRPRE86IGRvbid0IHZhbGlkYXRlIGhlcmU/IG9ubHkgaW4gYSBNYXRyaXggY29uc3RydWN0b3I/XG5cbiAgcmV0dXJuIHM7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHZhbGlkYXRlIHdoZXRoZXIgZWFjaCBlbGVtZW50IGluIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAqIGhhcyBhIHNpemUgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgc2l6ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5ICAgIEFycmF5IHRvIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtOdW1iZXJbXX0gc2l6ZSAgQXJyYXkgd2l0aCB0aGUgc2l6ZSBvZiBlYWNoIGRpbWVuc2lvblxuICogQHBhcmFtIHtOdW1iZXJ9IGRpbSAgIEN1cnJlbnQgZGltZW5zaW9uXG4gKiBAdGhyb3dzIERpbWVuc2lvbkVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfdmFsaWRhdGUoYXJyYXksIHNpemUsIGRpbSkge1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAobGVuICE9IHNpemVbZGltXSkge1xuICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihsZW4sIHNpemVbZGltXSk7XG4gIH1cblxuICBpZiAoZGltIDwgc2l6ZS5sZW5ndGggLSAxKSB7XG4gICAgLy8gcmVjdXJzaXZlbHkgdmFsaWRhdGUgZWFjaCBjaGlsZCBhcnJheVxuICAgIHZhciBkaW1OZXh0ID0gZGltICsgMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGFycmF5W2ldO1xuICAgICAgaWYgKCFpc0FycmF5KGNoaWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3Ioc2l6ZS5sZW5ndGggLSAxLCBzaXplLmxlbmd0aCwgJzwnKTtcbiAgICAgIH1cbiAgICAgIF92YWxpZGF0ZShhcnJheVtpXSwgc2l6ZSwgZGltTmV4dCk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGxhc3QgZGltZW5zaW9uLiBub25lIG9mIHRoZSBjaGlsZHMgbWF5IGJlIGFuIGFycmF5XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNBcnJheShhcnJheVtpXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKHNpemUubGVuZ3RoICsgMSwgc2l6ZS5sZW5ndGgsICc+Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgd2hldGhlciBlYWNoIGVsZW1lbnQgaW4gYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheSBoYXNcbiAqIGEgc2l6ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBzaXplIGFycmF5LlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgICAgQXJyYXkgdG8gYmUgdmFsaWRhdGVkXG4gKiBAcGFyYW0ge051bWJlcltdfSBzaXplICBBcnJheSB3aXRoIHRoZSBzaXplIG9mIGVhY2ggZGltZW5zaW9uXG4gKiBAdGhyb3dzIERpbWVuc2lvbkVycm9yXG4gKi9cbmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbihhcnJheSwgc2l6ZSkge1xuICB2YXIgaXNTY2FsYXIgPSAoc2l6ZS5sZW5ndGggPT0gMCk7XG4gIGlmIChpc1NjYWxhcikge1xuICAgIC8vIHNjYWxhclxuICAgIGlmIChpc0FycmF5KGFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKGFycmF5Lmxlbmd0aCwgMCk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGFycmF5XG4gICAgX3ZhbGlkYXRlKGFycmF5LCBzaXplLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgaW5kZXggaXMgYW4gaW50ZWdlciBudW1iZXIgd2l0aCBpbmRleCA+PSAwIGFuZCBpbmRleCA8IGxlbmd0aFxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgIFplcm8tYmFzZWQgaW5kZXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggb2YgdGhlIGFycmF5XG4gKi9cbmV4cG9ydHMudmFsaWRhdGVJbmRleCA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpIHtcbiAgaWYgKCFudW1iZXIuaXNOdW1iZXIoaW5kZXgpIHx8ICFudW1iZXIuaXNJbnRlZ2VyKGluZGV4KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luZGV4IG11c3QgYmUgYW4gaW50ZWdlciAodmFsdWU6ICcgKyBpbmRleCArICcpJyk7XG4gIH1cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHRocm93IG5ldyBJbmRleEVycm9yKGluZGV4KTtcbiAgfVxuICBpZiAobGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEluZGV4RXJyb3IoaW5kZXgsIGxlbmd0aCk7XG4gIH1cbn07XG5cbi8vIGEgY29uc3RhbnQgdXNlZCB0byBzcGVjaWZ5IGFuIHVuZGVmaW5lZCBkZWZhdWx0VmFsdWVcbmV4cG9ydHMuVU5JTklUSUFMSVpFRCA9IHt9O1xuXG4vKipcbiAqIFJlc2l6ZSBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5LiBUaGUgcmVzaXplZCBhcnJheSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5ICAgICAgICAgQXJyYXkgdG8gYmUgcmVzaXplZFxuICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gc2l6ZSBBcnJheSB3aXRoIHRoZSBzaXplIG9mIGVhY2ggZGltZW5zaW9uXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWU9MF0gIFZhbHVlIHRvIGJlIGZpbGxlZCBpbiBpbiBuZXcgZW50cmllcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVybyBieSBkZWZhdWx0LiBUbyBsZWF2ZSBuZXcgZW50cmllcyB1bmRlZmluZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZnkgYXJyYXkuVU5JTklUSUFMSVpFRCBhcyBkZWZhdWx0VmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSAgICAgICAgIFRoZSByZXNpemVkIGFycmF5XG4gKi9cbmV4cG9ydHMucmVzaXplID0gZnVuY3Rpb24oYXJyYXksIHNpemUsIGRlZmF1bHRWYWx1ZSkge1xuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3Igc2NhbGFycywgaGF2aW5nIHNpemU9W10gP1xuXG4gIC8vIGNoZWNrIHRoZSB0eXBlIG9mIHRoZSBhcmd1bWVudHNcbiAgaWYgKCFpc0FycmF5KGFycmF5KSB8fCAhaXNBcnJheShzaXplKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGV4cGVjdGVkJyk7XG4gIH1cbiAgaWYgKHNpemUubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemluZyB0byBzY2FsYXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgLy8gY2hlY2sgd2hldGhlciBzaXplIGNvbnRhaW5zIHBvc2l0aXZlIGludGVnZXJzXG4gIHNpemUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIW51bWJlci5pc051bWJlcih2YWx1ZSkgfHwgIW51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzaXplLCBtdXN0IGNvbnRhaW4gcG9zaXRpdmUgaW50ZWdlcnMgJyArXG4gICAgICAgICAgJyhzaXplOiAnICsgc3RyaW5nLmZvcm1hdChzaXplKSArICcpJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyByZWN1cnNpdmVseSByZXNpemUgdGhlIGFycmF5XG4gIHZhciBfZGVmYXVsdFZhbHVlID0gKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSA/IGRlZmF1bHRWYWx1ZSA6IDA7XG4gIF9yZXNpemUoYXJyYXksIHNpemUsIDAsIF9kZWZhdWx0VmFsdWUpO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgcmVzaXplIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5ICAgICAgICAgQXJyYXkgdG8gYmUgcmVzaXplZFxuICogQHBhcmFtIHtOdW1iZXJbXX0gc2l6ZSAgICAgICBBcnJheSB3aXRoIHRoZSBzaXplIG9mIGVhY2ggZGltZW5zaW9uXG4gKiBAcGFyYW0ge051bWJlcn0gZGltICAgICAgICAgIEN1cnJlbnQgZGltZW5zaW9uXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdICAgIFZhbHVlIHRvIGJlIGZpbGxlZCBpbiBpbiBuZXcgZW50cmllcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIGJ5IGRlZmF1bHQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVzaXplIChhcnJheSwgc2l6ZSwgZGltLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIGk7XG4gIHZhciBlbGVtO1xuICB2YXIgb2xkTGVuID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbmV3TGVuID0gc2l6ZVtkaW1dO1xuICB2YXIgbWluTGVuID0gTWF0aC5taW4ob2xkTGVuLCBuZXdMZW4pO1xuXG4gIC8vIGFwcGx5IG5ldyBsZW5ndGhcbiAgYXJyYXkubGVuZ3RoID0gbmV3TGVuO1xuXG4gIGlmIChkaW0gPCBzaXplLmxlbmd0aCAtIDEpIHtcbiAgICAvLyBub24tbGFzdCBkaW1lbnNpb25cbiAgICB2YXIgZGltTmV4dCA9IGRpbSArIDE7XG5cbiAgICAvLyByZXNpemUgZXhpc3RpbmcgY2hpbGQgYXJyYXlzXG4gICAgZm9yIChpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XG4gICAgICAvLyByZXNpemUgY2hpbGQgYXJyYXlcbiAgICAgIGVsZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmICghaXNBcnJheShlbGVtKSkge1xuICAgICAgICBlbGVtID0gW2VsZW1dOyAvLyBhZGQgYSBkaW1lbnNpb25cbiAgICAgICAgYXJyYXlbaV0gPSBlbGVtO1xuICAgICAgfVxuICAgICAgX3Jlc2l6ZShlbGVtLCBzaXplLCBkaW1OZXh0LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuZXcgY2hpbGQgYXJyYXlzXG4gICAgZm9yIChpID0gbWluTGVuOyBpIDwgbmV3TGVuOyBpKyspIHtcbiAgICAgIC8vIGdldCBjaGlsZCBhcnJheVxuICAgICAgZWxlbSA9IFtdO1xuICAgICAgYXJyYXlbaV0gPSBlbGVtO1xuXG4gICAgICAvLyByZXNpemUgbmV3IGNoaWxkIGFycmF5XG4gICAgICBfcmVzaXplKGVsZW0sIHNpemUsIGRpbU5leHQsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGxhc3QgZGltZW5zaW9uXG5cbiAgICAvLyByZW1vdmUgZGltZW5zaW9ucyBvZiBleGlzdGluZyB2YWx1ZXNcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICAgIHdoaWxlIChpc0FycmF5KGFycmF5W2ldKSkge1xuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2ldWzBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGRlZmF1bHRWYWx1ZSAhPT0gZXhwb3J0cy5VTklOSVRJQUxJWkVEKSB7XG4gICAgICAvLyBmaWxsIG5ldyBlbGVtZW50cyB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICBmb3IgKGkgPSBtaW5MZW47IGkgPCBuZXdMZW47IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IG9iamVjdC5jbG9uZShkZWZhdWx0VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNxdWVlemUgYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IFtzaXplXVxuICogQHJldHVybnMge0FycmF5fSByZXR1cm5zIHRoZSBhcnJheSBpdHNlbGZcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuc3F1ZWV6ZSA9IGZ1bmN0aW9uKGFycmF5LCBzaXplKSB7XG4gIHZhciBzID0gc2l6ZSB8fCBleHBvcnRzLnNpemUoYXJyYXkpO1xuXG4gIC8vIHNxdWVlemUgb3V0ZXIgZGltZW5zaW9uc1xuICB3aGlsZSAoaXNBcnJheShhcnJheSkgJiYgYXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgYXJyYXkgPSBhcnJheVswXTtcbiAgICBzLnNoaWZ0KCk7XG4gIH1cblxuICAvLyBmaW5kIHRoZSBmaXJzdCBkaW1lbnNpb24gdG8gYmUgc3F1ZWV6ZWRcbiAgdmFyIGRpbXMgPSBzLmxlbmd0aDtcbiAgd2hpbGUgKHNbZGltcyAtIDFdID09PSAxKSB7XG4gICAgZGltcy0tO1xuICB9XG5cbiAgLy8gc3F1ZWV6ZSBpbm5lciBkaW1lbnNpb25zXG4gIGlmIChkaW1zIDwgcy5sZW5ndGgpIHtcbiAgICBhcnJheSA9IF9zcXVlZXplKGFycmF5LCBkaW1zLCAwKTtcbiAgICBzLmxlbmd0aCA9IGRpbXM7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNxdWVlemUgYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW1zIFJlcXVpcmVkIG51bWJlciBvZiBkaW1lbnNpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gZGltICBDdXJyZW50IGRpbWVuc2lvblxuICogQHJldHVybnMge0FycmF5IHwgKn0gUmV0dXJucyB0aGUgc3F1ZWV6ZWQgYXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9zcXVlZXplIChhcnJheSwgZGltcywgZGltKSB7XG4gIHZhciBpLCBpaTtcblxuICBpZiAoZGltIDwgZGltcykge1xuICAgIHZhciBuZXh0ID0gZGltICsgMTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IGFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGFycmF5W2ldID0gX3NxdWVlemUoYXJyYXlbaV0sIGRpbXMsIG5leHQpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB3aGlsZSAoaXNBcnJheShhcnJheSkpIHtcbiAgICAgIGFycmF5ID0gYXJyYXlbMF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIFVuc3F1ZWV6ZSBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5OiBhZGQgZGltZW5zaW9ucyB3aGVuIG1pc3NpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gZGltcyAgICAgRGVzaXJlZCBudW1iZXIgb2YgZGltZW5zaW9ucyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3V0ZXJdICBOdW1iZXIgb2Ygb3V0ZXIgZGltZW5zaW9ucyB0byBiZSBhZGRlZFxuICogQHBhcmFtIHtBcnJheX0gW3NpemVdICAgIEN1cnJlbnQgc2l6ZSBvZiBhcnJheVxuICogQHJldHVybnMge0FycmF5fSByZXR1cm5zIHRoZSBhcnJheSBpdHNlbGZcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMudW5zcXVlZXplID0gZnVuY3Rpb24oYXJyYXksIGRpbXMsIG91dGVyLCBzaXplKSB7XG4gIHZhciBzID0gc2l6ZSB8fCBleHBvcnRzLnNpemUoYXJyYXkpO1xuXG4gIC8vIHVuc3F1ZWV6ZSBvdXRlciBkaW1lbnNpb25zXG4gIGlmIChvdXRlcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0ZXI7IGkrKykge1xuICAgICAgYXJyYXkgPSBbYXJyYXldO1xuICAgICAgcy51bnNoaWZ0KDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHVuc3F1ZWV6ZSBpbm5lciBkaW1lbnNpb25zXG4gIGFycmF5ID0gX3Vuc3F1ZWV6ZShhcnJheSwgZGltcywgMCk7XG4gIHdoaWxlIChzLmxlbmd0aCA8IGRpbXMpIHtcbiAgICBzLnB1c2goMSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHVuc3F1ZWV6ZSBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGRpbXMgUmVxdWlyZWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW0gIEN1cnJlbnQgZGltZW5zaW9uXG4gKiBAcmV0dXJucyB7QXJyYXkgfCAqfSBSZXR1cm5zIHRoZSBzcXVlZXplZCBhcnJheVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3Vuc3F1ZWV6ZSAoYXJyYXksIGRpbXMsIGRpbSkge1xuICB2YXIgaSwgaWk7XG5cbiAgaWYgKGlzQXJyYXkoYXJyYXkpKSB7XG4gICAgdmFyIG5leHQgPSBkaW0gKyAxO1xuICAgIGZvciAoaSA9IDAsIGlpID0gYXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgYXJyYXlbaV0gPSBfdW5zcXVlZXplKGFycmF5W2ldLCBkaW1zLCBuZXh0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgZm9yICh2YXIgZCA9IGRpbTsgZCA8IGRpbXM7IGQrKykge1xuICAgICAgYXJyYXkgPSBbYXJyYXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5LCBwdXQgYWxsIGVsZW1lbnRzIGluIGEgb25lIGRpbWVuc2lvbmFsXG4gKiBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgICBBIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgIFRoZSBmbGF0dGVuZWQgYXJyYXkgKDEgZGltZW5zaW9uYWwpXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSkge1xuICB2YXIgZmxhdCA9IGFycmF5LFxuICAgICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgd2hpbGUgKGlzQXJyYXkoZmxhdFswXSkpIHtcbiAgICB2YXIgbmV4dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZsYXQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgbmV4dCA9IG5leHQuY29uY2F0LmFwcGx5KG5leHQsIGZsYXRbaV0pO1xuICAgIH1cbiAgICBmbGF0ID0gbmV4dDtcbiAgfVxuXG4gIHJldHVybiBmbGF0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGZ1bmN0aW9uIGFyZ3VtZW50cyB0byBhbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBhcmdzXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gKi9cbmV4cG9ydHMuYXJnc1RvQXJyYXkgPSBmdW5jdGlvbihhcmdzKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFycmF5W2ldID0gYXJnc1tpXTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgYW4gYXJyYXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzQXJyYXlcbiAqL1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuYXJyYXkgPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5leHBvcnRzWydib29sZWFuJ10gPSByZXF1aXJlKCcuL2Jvb2xlYW4nKTtcbmV4cG9ydHMubnVtYmVyID0gcmVxdWlyZSgnLi9udW1iZXInKTtcbmV4cG9ydHMuYmlnbnVtYmVyID0gcmVxdWlyZSgnLi9iaWdudW1iZXInKTtcbmV4cG9ydHMub2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcbmV4cG9ydHMuc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKTtcbmV4cG9ydHMudHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgb2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9vYmplY3QnKSxcbiAgICBzdHJpbmcgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N0cmluZycpLFxuICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9pbmRleCcpLFxuXG4gICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgaXNOb2RlID0gTm9kZS5pc05vZGU7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEFycmF5Tm9kZVxuICogQGV4dGVuZHMge05vZGV9XG4gKiBIb2xkcyBhbiAxLWRpbWVuc2lvbmFsIGFycmF5IHdpdGggbm9kZXNcbiAqIEBwYXJhbSB7Tm9kZVtdfSBbbm9kZXNdICAgMSBkaW1lbnNpb25hbCBhcnJheSB3aXRoIG5vZGVzXG4gKi9cbmZ1bmN0aW9uIEFycmF5Tm9kZShub2Rlcykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQXJyYXlOb2RlKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICB0aGlzLm5vZGVzID0gbm9kZXMgfHwgW107XG5cbiAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgaWYgKCFpc0FycmF5KHRoaXMubm9kZXMpIHx8ICF0aGlzLm5vZGVzLmV2ZXJ5KGlzTm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBjb250YWluaW5nIE5vZGVzIGV4cGVjdGVkJylcbiAgfVxufVxuXG5BcnJheU5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuQXJyYXlOb2RlLnByb3RvdHlwZS50eXBlID0gJ0FycmF5Tm9kZSc7XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAqIEBwcml2YXRlXG4gKi9cbkFycmF5Tm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcykge1xuICB2YXIgYXNNYXRyaXggPSAoZGVmcy5tYXRoLmNvbmZpZygpLm1hdHJpeCAhPT0gJ2FycmF5Jyk7XG5cbiAgdmFyIG5vZGVzID0gdGhpcy5ub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5fY29tcGlsZShkZWZzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIChhc01hdHJpeCA/ICdtYXRoLm1hdHJpeChbJyA6ICdbJykgK1xuICAgICAgbm9kZXMuam9pbignLCcpICtcbiAgICAgIChhc01hdHJpeCA/ICddKScgOiAnXScpO1xufTtcblxuLyoqXG4gKiBGaW5kIGFsbCBub2RlcyBtYXRjaGluZyBnaXZlbiBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXIgIFNlZSBOb2RlLmZpbmQgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIGZpbHRlciBvcHRpb25zXG4gKiBAcmV0dXJucyB7Tm9kZVtdfSBub2Rlc1xuICovXG5BcnJheU5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgLy8gY2hlY2sgaXRzZWxmXG4gIGlmICh0aGlzLm1hdGNoKGZpbHRlcikpIHtcbiAgICByZXN1bHRzLnB1c2godGhpcyk7XG4gIH1cblxuICAvLyBzZWFyY2ggaW4gYWxsIG5vZGVzXG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIGZvciAodmFyIHIgPSAwLCByb3dzID0gbm9kZXMubGVuZ3RoOyByIDwgcm93czsgcisrKSB7XG4gICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KG5vZGVzW3JdLmZpbmQoZmlsdGVyKSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqIEBvdmVycmlkZVxuICovXG5BcnJheU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBzdHJpbmcuZm9ybWF0KHRoaXMubm9kZXMpO1xufTtcblxuLyoqXG4gKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb25cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyXG4gKi9cbkFycmF5Tm9kZS5wcm90b3R5cGUudG9UZXggPSBmdW5jdGlvbih0eXBlKSB7XG4gIHR5cGUgPSB0eXBlIHx8ICdibWF0cml4JztcbiAgdmFyIHMgPSAnXFxcXGJlZ2lueycgKyB0eXBlICsgJ30nO1xuXG4gIHRoaXMubm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZXMpIHtcbiAgICAgIHMgKz0gbm9kZS5ub2Rlcy5tYXAoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGUudG9UZXgoKTtcbiAgICAgIH0pLmpvaW4oJyYnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzICs9IG5vZGUudG9UZXgoKTtcbiAgICB9XG5cbiAgICAvLyBuZXcgbGluZVxuICAgIHMgKz0gJ1xcXFxcXFxcJztcbiAgfSk7XG4gIHMgKz0gJ1xcXFxlbmR7JyArIHR5cGUgKyAnfSc7XG4gIHJldHVybiBzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheU5vZGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgQXJyYXlOb2RlID0gcmVxdWlyZSgnLi9BcnJheU5vZGUnKSxcblxuICAgIGtleXdvcmRzID0gcmVxdWlyZSgnLi4va2V5d29yZHMnKSxcblxuICAgIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sYXRleCcpLFxuICAgIGlzU3RyaW5nID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9zdHJpbmcnKS5pc1N0cmluZztcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgQXNzaWdubWVudE5vZGVcbiAqIEBleHRlbmRzIHtOb2RlfVxuICogRGVmaW5lIGEgc3ltYm9sLCBsaWtlIFwiYSA9IDMuMlwiXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgICAgICAgU3ltYm9sIG5hbWVcbiAqIEBwYXJhbSB7Tm9kZX0gZXhwciAgICAgICAgIFRoZSBleHByZXNzaW9uIGRlZmluaW5nIHRoZSBzeW1ib2xcbiAqL1xuZnVuY3Rpb24gQXNzaWdubWVudE5vZGUobmFtZSwgZXhwcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQXNzaWdubWVudE5vZGUpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGlucHV0XG4gIGlmICghaXNTdHJpbmcobmFtZSkpICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZyBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwibmFtZVwiJyk7XG4gIGlmICghKGV4cHIgaW5zdGFuY2VvZiBOb2RlKSkgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vZGUgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcImV4cHJcIicpO1xuICBpZiAobmFtZSBpbiBrZXl3b3JkcykgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgc3ltYm9sIG5hbWUsIFwiJyAgKyBuYW1lICsgICdcIiBpcyBhIHJlc2VydmVkIGtleXdvcmQnKTtcblxuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmV4cHIgPSBleHByO1xufVxuXG5Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG5Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUudHlwZSA9ICdBc3NpZ25tZW50Tm9kZSc7XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAqIEBwcml2YXRlXG4gKi9cbkFzc2lnbm1lbnROb2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzKSB7XG4gIHJldHVybiAnc2NvcGVbXCInICsgdGhpcy5uYW1lICsgJ1wiXSA9ICcgKyB0aGlzLmV4cHIuX2NvbXBpbGUoZGVmcykgKyAnJztcbn07XG5cbi8qKlxuICogRmluZCBhbGwgbm9kZXMgbWF0Y2hpbmcgZ2l2ZW4gZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyICBTZWUgTm9kZS5maW5kIGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBmaWx0ZXIgb3B0aW9uc1xuICogQHJldHVybnMge05vZGVbXX0gbm9kZXNcbiAqL1xuQXNzaWdubWVudE5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gIHZhciBub2RlcyA9IFtdO1xuXG4gIC8vIGNoZWNrIGl0c2VsZlxuICBpZiAodGhpcy5tYXRjaChmaWx0ZXIpKSB7XG4gICAgbm9kZXMucHVzaCh0aGlzKTtcbiAgfVxuXG4gIC8vIHNlYXJjaCBpbiBleHByZXNzaW9uXG4gIG5vZGVzID0gbm9kZXMuY29uY2F0KHRoaXMuZXhwci5maW5kKGZpbHRlcikpO1xuXG4gIHJldHVybiBub2Rlcztcbn07XG5cbi8qKlxuICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubmFtZSArICcgPSAnICsgdGhpcy5leHByLnRvU3RyaW5nKCk7XG59O1xuXG4vKipcbiAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUudG9UZXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJyYWNlO1xuICBpZiAodGhpcy5leHByIGluc3RhbmNlb2YgQXJyYXlOb2RlKSB7XG4gICAgYnJhY2UgPSBbJ1xcXFxtYXRoYmZ7JywgJ30nXTtcbiAgfVxuICByZXR1cm4gbGF0ZXguYWRkQnJhY2VzKGxhdGV4LnRvU3ltYm9sKHRoaXMubmFtZSksIGJyYWNlKSArICc9JyArXG4gICAgICBsYXRleC5hZGRCcmFjZXModGhpcy5leHByLnRvVGV4KCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NpZ25tZW50Tm9kZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XG52YXIgUmVzdWx0U2V0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9SZXN1bHRTZXQnKTtcbnZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCcuLi8uLi91dGlsL2Jvb2xlYW4nKS5pc0Jvb2xlYW47XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEJsb2NrTm9kZVxuICogQGV4dGVuZHMge05vZGV9XG4gKiBIb2xkcyBhIHNldCB3aXRoIG5vZGVzXG4gKi9cbmZ1bmN0aW9uIEJsb2NrTm9kZSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJsb2NrTm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICB9XG5cbiAgdGhpcy5wYXJhbXMgPSBbXTtcbn1cblxuQmxvY2tOb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5cbkJsb2NrTm9kZS5wcm90b3R5cGUudHlwZSA9ICdCbG9ja05vZGUnO1xuXG4vKipcbiAqIEFkZCBhbiBleHByZXNzaW9uLiBJZiB2aXNpYmxlID0gZmFsc2UsIHRoZSBleHByZXNzaW9uIHdpbGwgYmUgZXZhbHVhdGVkXG4gKiBidXQgbm90IHJldHVybmVkIGluIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0ge05vZGV9IGV4cHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Zpc2libGU9dHJ1ZV1cbiAqL1xuQmxvY2tOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZXhwciwgdmlzaWJsZSkge1xuICBpZiAodmlzaWJsZSA9PT0gdW5kZWZpbmVkKSB2aXNpYmxlID0gdHJ1ZTtcblxuICAvLyB2YWxpZGF0ZSBpbnB1dFxuICBpZiAoIShleHByIGluc3RhbmNlb2YgTm9kZSkpICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb2RlIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJleHByXCInKTtcbiAgaWYgKCFpc0Jvb2xlYW4odmlzaWJsZSkpICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vbGVhbiBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwidmlzaWJsZVwiJyk7XG5cbiAgdmFyIGluZGV4ID0gdGhpcy5wYXJhbXMubGVuZ3RoO1xuICB0aGlzLnBhcmFtc1tpbmRleF0gPSB7XG4gICAgbm9kZTogZXhwcixcbiAgICB2aXNpYmxlOiB2aXNpYmxlXG4gIH07XG59O1xuXG4vKipcbiAqIENvbXBpbGUgdGhlIG5vZGUgdG8gamF2YXNjcmlwdCBjb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGpzXG4gKiBAcHJpdmF0ZVxuICovXG5CbG9ja05vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMpIHtcbiAgZGVmcy5SZXN1bHRTZXQgPSBSZXN1bHRTZXQ7XG4gIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIGpzID0gcGFyYW0ubm9kZS5fY29tcGlsZShkZWZzKTtcbiAgICBpZiAocGFyYW0udmlzaWJsZSkge1xuICAgICAgcmV0dXJuICdyZXN1bHRzLnB1c2goJyArIGpzICsgJyk7JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4ganMgKyAnOyc7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gJyhmdW5jdGlvbiAoKSB7JyArXG4gICAgICAndmFyIHJlc3VsdHMgPSBbXTsnICtcbiAgICAgIHBhcmFtcy5qb2luKCcnKSArXG4gICAgICAncmV0dXJuIG5ldyBSZXN1bHRTZXQocmVzdWx0cyk7JyArXG4gICAgICAnfSkoKSc7XG59O1xuXG4vKipcbiAqIEZpbmQgYWxsIG5vZGVzIG1hdGNoaW5nIGdpdmVuIGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlciAgU2VlIE5vZGUuZmluZCBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgZmlsdGVyIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtOb2RlW119IG5vZGVzXG4gKi9cbkJsb2NrTm9kZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgdmFyIG5vZGVzID0gW107XG5cbiAgLy8gY2hlY2sgaXRzZWxmXG4gIGlmICh0aGlzLm1hdGNoKGZpbHRlcikpIHtcbiAgICBub2Rlcy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgLy8gc2VhcmNoIGluIHBhcmFtZXRlcnNcbiAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFyYW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbm9kZXMgPSBub2Rlcy5jb25jYXQocGFyYW1zW2ldLm5vZGUuZmluZChmaWx0ZXIpKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn07XG5cbi8qKlxuICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqIEBvdmVycmlkZVxuICovXG5CbG9ja05vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtLm5vZGUudG9TdHJpbmcoKSArIChwYXJhbS52aXNpYmxlID8gJycgOiAnOycpO1xuICB9KS5qb2luKCdcXG4nKTtcbn07XG5cbi8qKlxuICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0clxuICovXG5CbG9ja05vZGUucHJvdG90eXBlLnRvVGV4ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtLm5vZGUudG9UZXgoKSArIChwYXJhbS52aXNpYmxlID8gJycgOiAnOycpO1xuICB9KS5qb2luKCdcXG4nKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmxvY2tOb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIGtleXdvcmRzID0gcmVxdWlyZSgnLi4va2V5d29yZHMnKTtcbnZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbGF0ZXgnKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc3RyaW5nJykuaXNTdHJpbmc7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEZ1bmN0aW9uQXNzaWdubWVudE5vZGVcbiAqIEBleHRlbmRzIHtOb2RlfVxuICogRnVuY3Rpb24gYXNzaWdubWVudFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgICAgICAgICBGdW5jdGlvbiBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBhcmdzICAgICAgICAgRnVuY3Rpb24gYXJndW1lbnQgbmFtZXNcbiAqIEBwYXJhbSB7Tm9kZX0gZXhwciAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gZXhwcmVzc2lvblxuICovXG5mdW5jdGlvbiBGdW5jdGlvbkFzc2lnbm1lbnROb2RlKG5hbWUsIGFyZ3MsIGV4cHIpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZ1bmN0aW9uQXNzaWdubWVudE5vZGUpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGlucHV0XG4gIGlmICghaXNTdHJpbmcobmFtZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZyBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwibmFtZVwiJyk7XG4gIGlmICghaXNBcnJheShhcmdzKSB8fCAhYXJncy5ldmVyeShpc1N0cmluZykpICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBjb250YWluaW5nIHN0cmluZ3MgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcImFyZ3NcIicpO1xuICBpZiAoIShleHByIGluc3RhbmNlb2YgTm9kZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vZGUgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcImV4cHJcIicpO1xuICBpZiAobmFtZSBpbiBrZXl3b3JkcykgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGZ1bmN0aW9uIG5hbWUsIFwiJyAgKyBuYW1lICsgICdcIiBpcyBhIHJlc2VydmVkIGtleXdvcmQnKTtcblxuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB0aGlzLmV4cHIgPSBleHByO1xufVxuXG5GdW5jdGlvbkFzc2lnbm1lbnROb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5cbkZ1bmN0aW9uQXNzaWdubWVudE5vZGUucHJvdG90eXBlLnR5cGUgPSAnRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZSc7XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAqIEByZXR1cm4ge1N0cmluZ30ganNcbiAqIEBwcml2YXRlXG4gKi9cbkZ1bmN0aW9uQXNzaWdubWVudE5vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMpIHtcbiAgcmV0dXJuICdzY29wZVtcIicgKyB0aGlzLm5hbWUgKyAnXCJdID0gJyArXG4gICAgICAnICAoZnVuY3Rpb24gKHNjb3BlKSB7JyArXG4gICAgICAnICAgIHNjb3BlID0gT2JqZWN0LmNyZWF0ZShzY29wZSk7ICcgK1xuICAgICAgJyAgICB2YXIgZm4gPSBmdW5jdGlvbiAnICsgdGhpcy5uYW1lICsgJygnICsgdGhpcy5hcmdzLmpvaW4oJywnKSArICcpIHsnICtcbiAgICAgICcgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAnICsgdGhpcy5hcmdzLmxlbmd0aCArICcpIHsnICtcbiAgICAgIC8vIFRPRE86IHVzZSB1dGlsLmVycm9yLkFyZ3VtZW50c0Vycm9yIGhlcmVcbiAgICAgIC8vIFRPRE86IHRlc3QgYXJndW1lbnRzIGVycm9yXG4gICAgICAnICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGluIGZ1bmN0aW9uICcgKyB0aGlzLm5hbWUgKyAnIChcIiArIGFyZ3VtZW50cy5sZW5ndGggKyBcIiBwcm92aWRlZCwgJyArIHRoaXMuYXJncy5sZW5ndGggKyAnIGV4cGVjdGVkKVwiKTsnICtcbiAgICAgICcgICAgICB9JyArXG4gICAgICB0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uICh2YXJpYWJsZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICdzY29wZVtcIicgKyB2YXJpYWJsZSArICdcIl0gPSBhcmd1bWVudHNbJyArIGluZGV4ICsgJ107JztcbiAgICAgIH0pLmpvaW4oJycpICtcbiAgICAgICcgICAgICByZXR1cm4gJyArIHRoaXMuZXhwci5fY29tcGlsZShkZWZzKSArICcnICtcbiAgICAgICcgICAgfTsnICtcbiAgICAgICcgICAgZm4uc3ludGF4ID0gXCInICsgdGhpcy5uYW1lICsgJygnICsgdGhpcy5hcmdzLmpvaW4oJywgJykgKyAnKVwiOycgK1xuICAgICAgJyAgICByZXR1cm4gZm47JyArXG4gICAgICAnICB9KShzY29wZSk7Jztcbn07XG5cbi8qKlxuICogRmluZCBhbGwgbm9kZXMgbWF0Y2hpbmcgZ2l2ZW4gZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyICBTZWUgTm9kZS5maW5kIGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBmaWx0ZXIgb3B0aW9uc1xuICogQHJldHVybnMge05vZGVbXX0gbm9kZXNcbiAqL1xuRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgdmFyIG5vZGVzID0gW107XG5cbiAgLy8gY2hlY2sgaXRzZWxmXG4gIGlmICh0aGlzLm1hdGNoKGZpbHRlcikpIHtcbiAgICBub2Rlcy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgLy8gc2VhcmNoIGluIGV4cHJlc3Npb25cbiAgbm9kZXMgPSBub2Rlcy5jb25jYXQodGhpcy5leHByLmZpbmQoZmlsdGVyKSk7XG5cbiAgcmV0dXJuIG5vZGVzO1xufTtcblxuLyoqXG4gKiBnZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0clxuICovXG5GdW5jdGlvbkFzc2lnbm1lbnROb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ2Z1bmN0aW9uICcgKyB0aGlzLm5hbWUgK1xuICAgICAgJygnICsgdGhpcy5hcmdzLmpvaW4oJywgJykgKyAnKSA9ICcgK1xuICAgICAgdGhpcy5leHByLnRvU3RyaW5nKCk7XG59O1xuXG4vKipcbiAqIGdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqL1xuRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUudG9UZXggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubmFtZSArXG4gICAgICBsYXRleC5hZGRCcmFjZXModGhpcy5hcmdzLm1hcChsYXRleC50b1N5bWJvbCkuam9pbignLCAnKSwgdHJ1ZSkgKyAnPScgK1xuICAgICAgbGF0ZXguYWRkQnJhY2VzKHRoaXMuZXhwci50b1RleCgpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKSxcbiAgICBDb25zdGFudE5vZGUgPSByZXF1aXJlKCcuL0NvbnN0YW50Tm9kZScpLFxuICAgIFN5bWJvbE5vZGUgPSByZXF1aXJlKCcuL1N5bWJvbE5vZGUnKSxcbiAgICBGdW5jdGlvbk5vZGUgPSByZXF1aXJlKCcuL0Z1bmN0aW9uTm9kZScpLFxuICAgIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sYXRleCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBPcGVyYXRvck5vZGVcbiAqIEBleHRlbmRzIHtOb2RlfVxuICogQW4gb3BlcmF0b3Igd2l0aCB0d28gYXJndW1lbnRzLCBsaWtlIDIrM1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcCAgICAgICBPcGVyYXRvciBuYW1lLCBmb3IgZXhhbXBsZSAnKydcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbiAgICAgICBGdW5jdGlvbiBuYW1lLCBmb3IgZXhhbXBsZSAnYWRkJ1xuICogQHBhcmFtIHtOb2RlW119IHBhcmFtcyAgIFBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gT3BlcmF0b3JOb2RlIChvcCwgZm4sIHBhcmFtcykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT3BlcmF0b3JOb2RlKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICAvLyBUT0RPOiB2YWxpZGF0ZSBpbnB1dFxuICB0aGlzLm9wID0gb3A7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG59XG5cbk9wZXJhdG9yTm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG5PcGVyYXRvck5vZGUucHJvdG90eXBlLnR5cGUgPSAnT3BlcmF0b3JOb2RlJztcblxuLyoqXG4gKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgdGhlIGNvbXBpbGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICogQHJldHVybiB7U3RyaW5nfSBqc1xuICogQHByaXZhdGVcbiAqL1xuT3BlcmF0b3JOb2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzKSB7XG4gIGlmICghKHRoaXMuZm4gaW4gZGVmcy5tYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gJyArIHRoaXMuZm4gKyAnIG1pc3NpbmcgaW4gcHJvdmlkZWQgbmFtZXNwYWNlIFwibWF0aFwiJyk7XG4gIH1cblxuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHJldHVybiBwYXJhbS5fY29tcGlsZShkZWZzKTtcbiAgfSk7XG4gIHJldHVybiAnbWF0aC4nICsgdGhpcy5mbiArICcoJyArIHBhcmFtcy5qb2luKCcsICcpICsgJyknO1xufTtcblxuLyoqXG4gKiBGaW5kIGFsbCBub2RlcyBtYXRjaGluZyBnaXZlbiBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXIgIFNlZSBOb2RlLmZpbmQgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIGZpbHRlciBvcHRpb25zXG4gKiBAcmV0dXJucyB7Tm9kZVtdfSBub2Rlc1xuICovXG5PcGVyYXRvck5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gIHZhciBub2RlcyA9IFtdO1xuXG4gIC8vIGNoZWNrIGl0c2VsZlxuICBpZiAodGhpcy5tYXRjaChmaWx0ZXIpKSB7XG4gICAgbm9kZXMucHVzaCh0aGlzKTtcbiAgfVxuXG4gIC8vIHNlYXJjaCBpbiBwYXJhbWV0ZXJzXG4gIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgaWYgKHBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJhbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KHBhcmFtc1tpXS5maW5kKGZpbHRlcikpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn07XG5cbi8qKlxuICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqL1xuT3BlcmF0b3JOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG5cbiAgc3dpdGNoIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgaWYgKHRoaXMub3AgPT0gJy0nKSB7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZTogdW5hcnkgbWludXNcbiAgICAgICAgcmV0dXJuICctJyArIHBhcmFtc1swXS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGZvciBleGFtcGxlICc1ISdcbiAgICAgICAgcmV0dXJuIHBhcmFtc1swXS50b1N0cmluZygpICsgdGhpcy5vcDtcbiAgICAgIH1cblxuICAgIGNhc2UgMjogLy8gZm9yIGV4YW1wbGUgJzIrMydcbiAgICAgIHZhciBsaHMgPSBwYXJhbXNbMF0udG9TdHJpbmcoKTtcbiAgICAgIGlmIChwYXJhbXNbMF0gaW5zdGFuY2VvZiBPcGVyYXRvck5vZGUpIHtcbiAgICAgICAgbGhzID0gJygnICsgbGhzICsgJyknO1xuICAgICAgfVxuICAgICAgdmFyIHJocyA9IHBhcmFtc1sxXS50b1N0cmluZygpO1xuICAgICAgaWYgKHBhcmFtc1sxXSBpbnN0YW5jZW9mIE9wZXJhdG9yTm9kZSkge1xuICAgICAgICByaHMgPSAnKCcgKyByaHMgKyAnKSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGhzICsgJyAnICsgdGhpcy5vcCArICcgJyArIHJocztcblxuICAgIGRlZmF1bHQ6IC8vIHRoaXMgc2hvdWxkIG5vdCBvY2N1ci4gZm9ybWF0IGFzIGEgZnVuY3Rpb24gY2FsbFxuICAgICAgcmV0dXJuIHRoaXMub3AgKyAnKCcgKyB0aGlzLnBhcmFtcy5qb2luKCcsICcpICsgJyknO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqL1xuT3BlcmF0b3JOb2RlLnByb3RvdHlwZS50b1RleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXMsXG4gICAgICBtb3AgPSBsYXRleC50b09wZXJhdG9yKHRoaXMub3ApLFxuICAgICAgbHAgPSBwYXJhbXNbMF0sXG4gICAgICBycCA9IHBhcmFtc1sxXTtcblxuICBzd2l0Y2ggKHBhcmFtcy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICBpZiAodGhpcy5vcCA9PT0gJy0nIHx8IHRoaXMub3AgPT09ICcrJykge1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IHVuYXJ5IG1pbnVzXG4gICAgICAgIHJldHVybiB0aGlzLm9wICsgbHAudG9UZXgoKTtcbiAgICAgIH1cbiAgICAgIC8vIGZvciBleGFtcGxlICc1ISdcbiAgICAgIHJldHVybiBscC50b1RleCgpICsgdGhpcy5vcDtcblxuICAgIGNhc2UgMjogLy8gZm9yIGV4YW1wbGUgJzIrMydcbiAgICAgIHZhciBsaHMgPSBscC50b1RleCgpLFxuICAgICAgICAgIGxoYiA9IGZhbHNlLFxuICAgICAgICAgIHJocyA9IHJwLnRvVGV4KCksXG4gICAgICAgICAgcmhiID0gZmFsc2UsXG4gICAgICAgICAgbG9wID0gJycsXG4gICAgICAgICAgcm9wID0gJyc7XG5cbiAgICAgIHN3aXRjaCAodGhpcy5vcCkge1xuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICBsb3AgPSBtb3A7XG4gICAgICAgICAgbW9wID0gJyc7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICBpZiAobHAgaW5zdGFuY2VvZiBPcGVyYXRvck5vZGUpIHtcbiAgICAgICAgICAgIGlmIChscC5vcCA9PT0gJysnIHx8IGxwLm9wID09PSAnLScpIHtcbiAgICAgICAgICAgICAgbGhiID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocnAgaW5zdGFuY2VvZiBPcGVyYXRvck5vZGUpIHtcbiAgICAgICAgICAgIGlmIChycC5vcCA9PT0gJysnIHx8IHJwLm9wID09PSAnLScpIHtcbiAgICAgICAgICAgICAgcmhiID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJwLm9wID09PSAnKicpIHtcbiAgICAgICAgICAgICAgcmhiID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoKGxwIGluc3RhbmNlb2YgQ29uc3RhbnROb2RlIHx8IGxwIGluc3RhbmNlb2YgT3BlcmF0b3JOb2RlKSAmJlxuICAgICAgICAgICAgICAocnAgaW5zdGFuY2VvZiBDb25zdGFudE5vZGUgfHwgcnAgaW5zdGFuY2VvZiBPcGVyYXRvck5vZGUpKSB7XG4gICAgICAgICAgICBtb3AgPSAnIFxcXFxjZG90ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9wID0gJyBcXFxcLCAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIGlmIChscCBpbnN0YW5jZW9mIE9wZXJhdG9yTm9kZSB8fCBscCBpbnN0YW5jZW9mIEZ1bmN0aW9uTm9kZSkge1xuICAgICAgICAgICAgbGhiID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobHAgaW5zdGFuY2VvZiBTeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICBsaGIgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvJzpcbiAgICAgICAgICByaHMgPSBsYXRleC50b1VuaXQocmhzLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbGhzID0gbGF0ZXguYWRkQnJhY2VzKGxocywgbGhiKTtcbiAgICAgIHJocyA9IGxhdGV4LmFkZEJyYWNlcyhyaHMsIHJoYik7XG5cbiAgICAgIHJldHVybiBsb3AgKyBsaHMgKyBtb3AgKyByaHMgKyByb3A7XG5cbiAgICBkZWZhdWx0OiAvLyB0aGlzIHNob3VsZCBub3Qgb2NjdXIuIGZvcm1hdCBhcyBhIGZ1bmN0aW9uIGNhbGxcbiAgICAgIHJldHVybiBtb3AgKyAnKCcgKyB0aGlzLnBhcmFtcy5tYXAobGF0ZXgudG9TeW1ib2wpLmpvaW4oJywgJykgKyAnKSc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0b3JOb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xuXG52YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlsL2xhdGV4Jyk7XG52YXIgaXNOb2RlID0gTm9kZS5pc05vZGU7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEZ1bmN0aW9uTm9kZVxuICogQGV4dGVuZHMge05vZGV9XG4gKiBpbnZva2UgYSBsaXN0IHdpdGggcGFyYW1ldGVycyBvbiBhIG5vZGVcbiAqIEBwYXJhbSB7U3ltYm9sTm9kZX0gc3ltYm9sXG4gKiBAcGFyYW0ge05vZGVbXX0gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIEZ1bmN0aW9uTm9kZSAoc3ltYm9sLCBwYXJhbXMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZ1bmN0aW9uTm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICB9XG5cbiAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgaWYgKCEoc3ltYm9sIGluc3RhbmNlb2YgTm9kZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N5bWJvbE5vZGUgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcInN5bWJvbFwiJyk7XG4gIGlmICghaXNBcnJheShwYXJhbXMpIHx8ICFwYXJhbXMuZXZlcnkoaXNOb2RlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGNvbnRhaW5pbmcgTm9kZXMgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcInBhcmFtc1wiJyk7XG4gIH1cblxuICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcbiAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG59XG5cbkZ1bmN0aW9uTm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG5GdW5jdGlvbk5vZGUucHJvdG90eXBlLnR5cGUgPSAnRnVuY3Rpb25Ob2RlJztcblxuLyoqXG4gKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgdGhlIGNvbXBpbGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICogQHJldHVybiB7U3RyaW5nfSBqc1xuICogQHByaXZhdGVcbiAqL1xuRnVuY3Rpb25Ob2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzKSB7XG4gIHZhciBmbiA9IGRlZnMubWF0aFt0aGlzLnN5bWJvbC5uYW1lXTtcbiAgdmFyIGlzUmF3ID0gKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykgJiYgKGZuLnJhd0FyZ3MgPT0gdHJ1ZSk7XG5cbiAgLy8gY29tcGlsZSB0aGUgcGFyYW1ldGVyc1xuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHJldHVybiBwYXJhbS5fY29tcGlsZShkZWZzKTtcbiAgfSk7XG5cbiAgaWYgKGlzUmF3KSB7XG4gICAgLy8gcGFzcyB1bmV2YWx1YXRlZCBwYXJhbWV0ZXJzIChub2RlcykgdG8gdGhlIGZ1bmN0aW9uXG4gICAgdmFyIG5hbWUgPSB0aGlzLnN5bWJvbC5uYW1lO1xuICAgIHZhciBwYXJhbXNOYW1lO1xuICAgIGRvIHtcbiAgICAgIHBhcmFtc05hbWUgPSAncCcgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG4gICAgfVxuICAgIHdoaWxlIChwYXJhbXNOYW1lIGluIGRlZnMpO1xuICAgIGRlZnNbcGFyYW1zTmFtZV0gPSB0aGlzLnBhcmFtcztcblxuICAgIHJldHVybiAnKFwiJyArIG5hbWUgKyAnXCIgaW4gc2NvcGUgPyAnICtcbiAgICAgICAgJ3Njb3BlW1wiJyArIG5hbWUgKyAnXCJdKCcgKyBwYXJhbXMuam9pbignLCAnKSArICcpIDogJyArXG4gICAgICAgICdtYXRoW1wiJyArIG5hbWUgKyAnXCJdJyArICcoJyArIHBhcmFtc05hbWUgKyAnLCBtYXRoLCBzY29wZSkpJztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBcInJlZ3VsYXJcIiBldmFsdWF0aW9uXG4gICAgcmV0dXJuIHRoaXMuc3ltYm9sLl9jb21waWxlKGRlZnMpICsgJygnICsgcGFyYW1zLmpvaW4oJywgJykgKyAnKSc7XG4gIH1cbn07XG5cbi8qKlxuICogRmluZCBhbGwgbm9kZXMgbWF0Y2hpbmcgZ2l2ZW4gZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyICBTZWUgTm9kZS5maW5kIGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBmaWx0ZXIgb3B0aW9uc1xuICogQHJldHVybnMge05vZGVbXX0gbm9kZXNcbiAqL1xuRnVuY3Rpb25Ob2RlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICB2YXIgbm9kZXMgPSBbXTtcblxuICAvLyBjaGVjayBpdHNlbGZcbiAgaWYgKHRoaXMubWF0Y2goZmlsdGVyKSkge1xuICAgIG5vZGVzLnB1c2godGhpcyk7XG4gIH1cblxuICAvLyBzZWFyY2ggc3ltYm9sXG4gIG5vZGVzID0gbm9kZXMuY29uY2F0KHRoaXMuc3ltYm9sLmZpbmQoZmlsdGVyKSk7XG5cbiAgLy8gc2VhcmNoIGluIHBhcmFtZXRlcnNcbiAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFyYW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbm9kZXMgPSBub2Rlcy5jb25jYXQocGFyYW1zW2ldLmZpbmQoZmlsdGVyKSk7XG4gIH1cblxuICByZXR1cm4gbm9kZXM7XG59O1xuXG4vKipcbiAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyXG4gKi9cbkZ1bmN0aW9uTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgLy8gZm9ybWF0IHRoZSBwYXJhbWV0ZXJzIGxpa2UgXCJhZGQoMiwgNC4yKVwiXG4gIHJldHVybiB0aGlzLnN5bWJvbC50b1N0cmluZygpICsgJygnICsgdGhpcy5wYXJhbXMuam9pbignLCAnKSArICcpJztcbn07XG5cbi8qKlxuICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0clxuICovXG5GdW5jdGlvbk5vZGUucHJvdG90eXBlLnRvVGV4ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBsYXRleC50b1BhcmFtcyh0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb25Ob2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xuXG52YXIgaXNOb2RlID0gTm9kZS5pc05vZGU7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIFJhbmdlTm9kZVxuICogQGV4dGVuZHMge05vZGV9XG4gKiBjcmVhdGUgYSByYW5nZVxuICogQHBhcmFtIHtOb2RlW119IHBhcmFtcyAgICAgICAgICAgQXJyYXkgW3N0YXJ0LCBlbmRdIG9yIFtzdGFydCwgZW5kLCBzdGVwXVxuICovXG5mdW5jdGlvbiBSYW5nZU5vZGUgKHBhcmFtcykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2VOb2RlKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBpbnB1dHNcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykgfHxcbiAgICAgIChwYXJhbXMubGVuZ3RoICE9IDIgJiYgcGFyYW1zLmxlbmd0aCAhPSAzKSB8fFxuICAgICAgIXBhcmFtcy5ldmVyeShpc05vZGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYW4gQXJyYXkgY29udGFpbmluZyAyIG9yIDMgTm9kZXMgYXMgcGFyYW1ldGVyIFwicGFyYW1zXCInKTtcbiAgfVxuXG4gIHRoaXMuc3RhcnQgPSBwYXJhbXNbMF07ICAvLyBpbmNsdWRlZCBsb3dlci1ib3VuZFxuICB0aGlzLmVuZCAgID0gcGFyYW1zWzFdOyAgLy8gaW5jbHVkZWQgdXBwZXItYm91bmRcbiAgdGhpcy5zdGVwICA9IHBhcmFtc1syXTsgIC8vIG9wdGlvbmFsIHN0ZXBcbn1cblxuUmFuZ2VOb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5cblJhbmdlTm9kZS5wcm90b3R5cGUudHlwZSA9ICdSYW5nZU5vZGUnO1xuXG4vKipcbiAqIENvbXBpbGUgdGhlIG5vZGUgdG8gamF2YXNjcmlwdCBjb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGpzXG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZU5vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMpIHtcbiAgcmV0dXJuICdtYXRoLnJhbmdlKCcgK1xuICAgICAgdGhpcy5zdGFydC5fY29tcGlsZShkZWZzKSArICcsICcgK1xuICAgICAgdGhpcy5lbmQuX2NvbXBpbGUoZGVmcykgK1xuICAgICAgKHRoaXMuc3RlcCA/ICgnLCAnICsgdGhpcy5zdGVwLl9jb21waWxlKGRlZnMpKSA6ICcnKSArXG4gICAgICAnKSc7XG59O1xuXG4vKipcbiAqIEZpbmQgYWxsIG5vZGVzIG1hdGNoaW5nIGdpdmVuIGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlciAgU2VlIE5vZGUuZmluZCBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgZmlsdGVyIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtOb2RlW119IG5vZGVzXG4gKi9cblJhbmdlTm9kZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgdmFyIG5vZGVzID0gW107XG5cbiAgLy8gY2hlY2sgaXRzZWxmXG4gIGlmICh0aGlzLm1hdGNoKGZpbHRlcikpIHtcbiAgICBub2Rlcy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgLy8gc2VhcmNoIGluIHBhcmFtZXRlcnNcbiAgbm9kZXMgPSBub2Rlcy5jb25jYXQodGhpcy5zdGFydC5maW5kKGZpbHRlcikpO1xuICBpZiAodGhpcy5zdGVwKSB7XG4gICAgbm9kZXMgPSBub2Rlcy5jb25jYXQodGhpcy5zdGVwLmZpbmQoZmlsdGVyKSk7XG4gIH1cbiAgbm9kZXMgPSBub2Rlcy5jb25jYXQodGhpcy5lbmQuZmluZChmaWx0ZXIpKTtcblxuICByZXR1cm4gbm9kZXM7XG59O1xuXG4vKipcbiAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyXG4gKi9cblJhbmdlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgLy8gZm9ybWF0IHRoZSByYW5nZSBsaWtlIFwic3RhcnQ6c3RlcDplbmRcIlxuICB2YXIgc3RyID0gdGhpcy5zdGFydC50b1N0cmluZygpO1xuICBpZiAodGhpcy5zdGVwKSB7XG4gICAgc3RyICs9ICc6JyArIHRoaXMuc3RlcC50b1N0cmluZygpO1xuICB9XG4gIHN0ciArPSAnOicgKyB0aGlzLmVuZC50b1N0cmluZygpO1xuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqL1xuUmFuZ2VOb2RlLnByb3RvdHlwZS50b1RleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RyID0gdGhpcy5zdGFydC50b1RleCgpO1xuICBpZiAodGhpcy5zdGVwKSB7XG4gICAgc3RyICs9ICc6JyArIHRoaXMuc3RlcC50b1RleCgpO1xuICB9XG4gIHN0ciArPSAnOicgKyB0aGlzLmVuZC50b1RleCgpO1xuXG4gIHJldHVybiBzdHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlTm9kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKSxcbiAgICBVbml0ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Vbml0JyksXG5cbiAgICBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbGF0ZXgnKSxcbiAgICBpc1N0cmluZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc3RyaW5nJykuaXNTdHJpbmc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIFN5bWJvbE5vZGVcbiAqIEBleHRlbmRzIHtOb2RlfVxuICogQSBzeW1ib2wgbm9kZSBjYW4gaG9sZCBhbmQgcmVzb2x2ZSBhIHN5bWJvbFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBleHRlbmRzIHtOb2RlfVxuICovXG5mdW5jdGlvbiBTeW1ib2xOb2RlKG5hbWUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN5bWJvbE5vZGUpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGlucHV0XG4gIGlmICghaXNTdHJpbmcobmFtZSkpICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdHJpbmcgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcIm5hbWVcIicpO1xuXG4gIHRoaXMubmFtZSA9IG5hbWU7XG59XG5cblN5bWJvbE5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuU3ltYm9sTm9kZS5wcm90b3R5cGUudHlwZSA9ICdTeW1ib2xOb2RlJztcblxuLyoqXG4gKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgdGhlIGNvbXBpbGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICogQHJldHVybiB7U3RyaW5nfSBqc1xuICogQHByaXZhdGVcbiAqL1xuU3ltYm9sTm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcykge1xuICAvLyBhZGQgYSBmdW5jdGlvbiB0byB0aGUgZGVmaW5pdGlvbnNcbiAgZGVmc1sndW5kZWYnXSA9IHVuZGVmO1xuICBkZWZzWydVbml0J10gPSBVbml0O1xuXG4gIGlmICh0aGlzLm5hbWUgaW4gZGVmcy5tYXRoKSB7XG4gICAgcmV0dXJuICcoXCInICsgdGhpcy5uYW1lICsgJ1wiIGluIHNjb3BlID8gc2NvcGVbXCInICsgdGhpcy5uYW1lICsgJ1wiXSA6IG1hdGhbXCInICsgdGhpcy5uYW1lICsgJ1wiXSknO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAnKCcgK1xuICAgICAgICAnXCInICsgdGhpcy5uYW1lICsgJ1wiIGluIHNjb3BlID8gc2NvcGVbXCInICsgdGhpcy5uYW1lICsgJ1wiXSA6ICcgK1xuICAgICAgICAoVW5pdC5pc1ZhbHVlbGVzc1VuaXQodGhpcy5uYW1lKSA/XG4gICAgICAgICAgICAnbmV3IFVuaXQobnVsbCwgXCInICsgdGhpcy5uYW1lICsgJ1wiKScgOlxuICAgICAgICAgICAgJ3VuZGVmKFwiJyArIHRoaXMubmFtZSArICdcIiknKSArXG4gICAgICAgICcpJztcbiAgfVxufTtcblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgJ1VuZGVmaW5lZCBzeW1ib2wge25hbWV9J1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gdW5kZWYgKG5hbWUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmRlZmluZWQgc3ltYm9sICcgKyBuYW1lKTtcbn1cblxuLyoqXG4gKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0clxuICogQG92ZXJyaWRlXG4gKi9cblN5bWJvbE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm5hbWU7XG59O1xuXG4vKipcbiAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqIEBvdmVycmlkZVxuICovXG5TeW1ib2xOb2RlLnByb3RvdHlwZS50b1RleCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbGF0ZXgudG9TeW1ib2wodGhpcy5uYW1lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sTm9kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKSxcbiAgICBJbmRleE5vZGUgPSByZXF1aXJlKCcuL0luZGV4Tm9kZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBVcGRhdGVOb2RlXG4gKiBAZXh0ZW5kcyB7Tm9kZX1cbiAqIFVwZGF0ZSBhIG1hdHJpeCBzdWJzZXQsIGxpa2UgQVsyLDNdID0gNC41XG4gKlxuICogQHBhcmFtIHtJbmRleE5vZGV9IGluZGV4ICAgICAgICAgICAgIEluZGV4Tm9kZSBjb250YWluaW5nIHN5bWJvbCBhbmQgcmFuZ2VzXG4gKiBAcGFyYW0ge05vZGV9IGV4cHIgICAgICAgICAgICAgICAgICAgVGhlIGV4cHJlc3Npb24gZGVmaW5pbmcgdGhlIHN5bWJvbFxuICovXG5mdW5jdGlvbiBVcGRhdGVOb2RlKGluZGV4LCBleHByKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcGRhdGVOb2RlKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICBpZiAoIShpbmRleCBpbnN0YW5jZW9mIEluZGV4Tm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBJbmRleE5vZGUgZm9yIHBhcmFtZXRlciBcImluZGV4XCInKTtcbiAgfVxuICBpZiAoIShleHByIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBOb2RlIGZvciBwYXJhbWV0ZXIgXCJleHByXCInKTtcbiAgfVxuXG4gIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgdGhpcy5leHByID0gZXhwcjtcbn1cblxuVXBkYXRlTm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG5VcGRhdGVOb2RlLnByb3RvdHlwZS50eXBlID0gJ1VwZGF0ZU5vZGUnO1xuXG4vKipcbiAqIENvbXBpbGUgdGhlIG5vZGUgdG8gamF2YXNjcmlwdCBjb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGpzXG4gKiBAcHJpdmF0ZVxuICovXG5VcGRhdGVOb2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzKSB7XG4gIHJldHVybiAnc2NvcGVbXCInICsgdGhpcy5pbmRleC5vYmplY3ROYW1lKCkgKyAnXFxcIl0gPSAnICtcbiAgICAgIHRoaXMuaW5kZXguY29tcGlsZVN1YnNldChkZWZzLCAgdGhpcy5leHByLl9jb21waWxlKGRlZnMpKTtcbn07XG5cbi8qKlxuICogRmluZCBhbGwgbm9kZXMgbWF0Y2hpbmcgZ2l2ZW4gZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyICBTZWUgTm9kZS5maW5kIGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBmaWx0ZXIgb3B0aW9uc1xuICogQHJldHVybnMge05vZGVbXX0gbm9kZXNcbiAqL1xuVXBkYXRlTm9kZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgdmFyIG5vZGVzID0gW107XG5cbiAgLy8gY2hlY2sgaXRzZWxmXG4gIGlmICh0aGlzLm1hdGNoKGZpbHRlcikpIHtcbiAgICBub2Rlcy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgLy8gc2VhcmNoIGluIGluZGV4XG4gIG5vZGVzID0gbm9kZXMuY29uY2F0KHRoaXMuaW5kZXguZmluZChmaWx0ZXIpKTtcblxuICAvLyBzZWFyY2ggaW4gZXhwcmVzc2lvblxuICBub2RlcyA9IG5vZGVzLmNvbmNhdCh0aGlzLmV4cHIuZmluZChmaWx0ZXIpKTtcblxuICByZXR1cm4gbm9kZXM7XG59O1xuXG4vKipcbiAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuVXBkYXRlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXgudG9TdHJpbmcoKSArICcgPSAnICsgdGhpcy5leHByLnRvU3RyaW5nKCk7XG59O1xuXG4vKipcbiAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5VcGRhdGVOb2RlLnByb3RvdHlwZS50b1RleCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pbmRleC50b1RleCgpICsgJyA9ICcgKyB0aGlzLmV4cHIudG9UZXgoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVXBkYXRlTm9kZTtcbiIsInZhciBzaGEgPSByZXF1aXJlKCcuL3NoYScpXG52YXIgcm5nID0gcmVxdWlyZSgnLi9ybmcnKVxudmFyIG1kNSA9IHJlcXVpcmUoJy4vbWQ1JylcblxudmFyIGFsZ29yaXRobXMgPSB7XG4gIHNoYTE6IHtcbiAgICBoZXg6IHNoYS5oZXhfc2hhMSxcbiAgICBiaW5hcnk6IHNoYS5iNjRfc2hhMSxcbiAgICBhc2NpaTogc2hhLnN0cl9zaGExXG4gIH0sXG4gIG1kNToge1xuICAgIGhleDogbWQ1LmhleF9tZDUsXG4gICAgYmluYXJ5OiBtZDUuYjY0X21kNSxcbiAgICBhc2NpaTogbWQ1LmFueV9tZDVcbiAgfVxufVxuXG5mdW5jdGlvbiBlcnJvciAoKSB7XG4gIHZhciBtID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKVxuICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgIG0sXG4gICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbiAgICAnaHR0cDovL2dpdGh1Yi5jb20vZG9taW5pY3RhcnIvY3J5cHRvLWJyb3dzZXJpZnknXG4gICAgXS5qb2luKCdcXG4nKSlcbn1cblxuZXhwb3J0cy5jcmVhdGVIYXNoID0gZnVuY3Rpb24gKGFsZykge1xuICBhbGcgPSBhbGcgfHwgJ3NoYTEnXG4gIGlmKCFhbGdvcml0aG1zW2FsZ10pXG4gICAgZXJyb3IoJ2FsZ29yaXRobTonLCBhbGcsICdpcyBub3QgeWV0IHN1cHBvcnRlZCcpXG4gIHZhciBzID0gJydcbiAgdmFyIF9hbGcgPSBhbGdvcml0aG1zW2FsZ11cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBzICs9IGRhdGFcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBkaWdlc3Q6IGZ1bmN0aW9uIChlbmMpIHtcbiAgICAgIGVuYyA9IGVuYyB8fCAnYmluYXJ5J1xuICAgICAgdmFyIGZuXG4gICAgICBpZighKGZuID0gX2FsZ1tlbmNdKSlcbiAgICAgICAgZXJyb3IoJ2VuY29kaW5nOicsIGVuYyAsICdpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgYWxnb3JpdGhtJywgYWxnKVxuICAgICAgdmFyIHIgPSBmbihzKVxuICAgICAgcyA9IG51bGwgLy9ub3QgbWVhbnQgdG8gdXNlIHRoZSBoYXNoIGFmdGVyIHlvdSd2ZSBjYWxsZWQgZGlnZXN0LlxuICAgICAgcmV0dXJuIHJcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKHNpemUsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdW5kZWZpbmVkLCBybmcoc2l6ZSkpO1xuICAgIH0gY2F0Y2ggKGVycikgeyBjYWxsYmFjayhlcnIpOyB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJuZyhzaXplKTtcbiAgfVxufVxuXG4vLyB0aGUgbGVhc3QgSSBjYW4gZG8gaXMgbWFrZSBlcnJvciBtZXNzYWdlcyBmb3IgdGhlIHJlc3Qgb2YgdGhlIG5vZGUuanMvY3J5cHRvIGFwaS5cbjtbJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLCAnY3JlYXRlSG1hYydcbiwgJ2NyZWF0ZUN5cGhlcidcbiwgJ2NyZWF0ZUN5cGhlcml2J1xuLCAnY3JlYXRlRGVjaXBoZXInXG4sICdjcmVhdGVEZWNpcGhlcml2J1xuLCAnY3JlYXRlU2lnbidcbiwgJ2NyZWF0ZVZlcmlmeSdcbiwgJ2NyZWF0ZURlZmZpZUhlbGxtYW4nXG4sICdwYmtkZjInXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ3NvcnJ5LCcsIG5hbWUsICdpcyBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgfVxufSlcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXdvcmRzID0gcmVxdWlyZSgnLi4va2V5d29yZHMnKTtcblxuLyoqXG4gKiBOb2RlXG4gKi9cbmZ1bmN0aW9uIE5vZGUoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgbm9kZVxuICogQHJldHVybiB7Kn0gcmVzdWx0XG4gKi9cbi8vIFRPRE86IGNsZWFudXAgZGVwcmVjYXRlZCBjb2RlIG9uZSBkYXkuIERlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAwLjE5LjBcbk5vZGUucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm9kZS5ldmFsIGlzIGRlcHJlY2F0ZWQuICcgK1xuICAgICAgJ1VzZSBOb2RlLmNvbXBpbGUobWF0aCkuZXZhbChbc2NvcGVdKSBpbnN0ZWFkLicpO1xufTtcblxuTm9kZS5wcm90b3R5cGUudHlwZSA9ICdOb2RlJztcblxuLyoqXG4gKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICogQHBhcmFtIHtPYmplY3R9IG1hdGggICAgICAgICAgICAgbWF0aC5qcyBpbnN0YW5jZVxuICogQHJldHVybiB7e2V2YWw6IGZ1bmN0aW9ufX0gZXhwciAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIGZ1bmN0aW9uICdldmFsJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGNhbiBiZSBpbnZva2VkIGFzIGV4cHIuZXZhbChbc2NvcGVdKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlIHNjb3BlIGlzIGFuIG9wdGlvbmFsIG9iamVjdCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMuXG4gKi9cbk5vZGUucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAobWF0aCkge1xuICBpZiAoIShtYXRoIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIG1hdGgnKTtcbiAgfVxuXG4gIC8vIGRlZmluaXRpb25zIGdsb2JhbGx5IGF2YWlsYWJsZSBpbnNpZGUgdGhlIGNsb3N1cmUgb2YgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb25zXG4gIHZhciBkZWZzID0ge1xuICAgIG1hdGg6IF90cmFuc2Zvcm0obWF0aCksXG4gICAgX3ZhbGlkYXRlU2NvcGU6IF92YWxpZGF0ZVNjb3BlXG4gIH07XG5cbiAgdmFyIGNvZGUgPSB0aGlzLl9jb21waWxlKGRlZnMpO1xuXG4gIHZhciBkZWZzQ29kZSA9IE9iamVjdC5rZXlzKGRlZnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAnICAgIHZhciAnICsgbmFtZSArICcgPSBkZWZzW1wiJyArIG5hbWUgKyAnXCJdOyc7XG4gIH0pO1xuXG4gIHZhciBmYWN0b3J5Q29kZSA9XG4gICAgICBkZWZzQ29kZS5qb2luKCcgJykgK1xuICAgICAgICAgICdyZXR1cm4geycgK1xuICAgICAgICAgICcgIFwiZXZhbFwiOiBmdW5jdGlvbiAoc2NvcGUpIHsnICtcbiAgICAgICAgICAnICAgIGlmIChzY29wZSkgX3ZhbGlkYXRlU2NvcGUoc2NvcGUpOycgK1xuICAgICAgICAgICcgICAgc2NvcGUgPSBzY29wZSB8fCB7fTsnICtcbiAgICAgICAgICAnICAgIHJldHVybiAnICsgY29kZSArICc7JyArXG4gICAgICAgICAgJyAgfScgK1xuICAgICAgICAgICd9Oyc7XG5cbiAgdmFyIGZhY3RvcnkgPSBuZXcgRnVuY3Rpb24gKCdkZWZzJywgZmFjdG9yeUNvZGUpO1xuICByZXR1cm4gZmFjdG9yeShkZWZzKTtcbn07XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGluc2lkZSB0aGUgY2xvc3VyZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBjb21waWxlZCBleHByZXNzaW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGpzXG4gKiBAcHJpdmF0ZVxuICovXG5Ob2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBpbGUgYSBOb2RlIGludGVyZmFjZScpO1xufTtcblxuLyoqXG4gKiBGaW5kIGFueSBub2RlIGluIHRoZSBub2RlIHRyZWUgbWF0Y2hpbmcgZ2l2ZW4gZmlsdGVyLiBGb3IgZXhhbXBsZSwgdG9cbiAqIGZpbmQgYWxsIG5vZGVzIG9mIHR5cGUgU3ltYm9sTm9kZSBoYXZpbmcgbmFtZSAneCc6XG4gKlxuICogICAgIHZhciByZXN1bHRzID0gTm9kZS5maW5kKHtcbiAqICAgICAgICAgdHlwZTogU3ltYm9sTm9kZSxcbiAqICAgICAgICAgcHJvcGVydGllczoge1xuICogICAgICAgICAgICAgbmFtZTogJ3gnXG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyICAgICAgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9ufSB0eXBlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0PFN0cmluZywgU3RyaW5nPn0gcHJvcGVydGllc1xuICogQHJldHVybiB7Tm9kZVtdfSBub2RlcyAgICAgICBBbiBhcnJheSB3aXRoIG5vZGVzIG1hdGNoaW5nIGdpdmVuIGZpbHRlciBjcml0ZXJpYVxuICovXG5Ob2RlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICByZXR1cm4gdGhpcy5tYXRjaChmaWx0ZXIpID8gW3RoaXNdIDogW107XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhpcyBvYmplY3QgbWF0Y2hlcyBnaXZlbiBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXSAgICAgQXZhaWxhYmxlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbn0gdHlwZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0PFN0cmluZywgKj59IHByb3BlcnRpZXNcbiAqIEByZXR1cm4ge0Jvb2xlYW59IG1hdGNoZXMgICAgVHJ1ZSBpZiB0aGVyZSBpcyBhIG1hdGNoXG4gKi9cbk5vZGUucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICB2YXIgbWF0Y2ggPSB0cnVlO1xuXG4gIGlmIChmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyLnR5cGUgJiYgISh0aGlzIGluc3RhbmNlb2YgZmlsdGVyLnR5cGUpKSB7XG4gICAgICBtYXRjaCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0aWVzID0gZmlsdGVyLnByb3BlcnRpZXM7XG4gICAgaWYgKG1hdGNoICYmIHByb3BlcnRpZXMpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIGlmICh0aGlzW3Byb3BdICE9PSBwcm9wZXJ0aWVzW3Byb3BdKSB7XG4gICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufTtcblxuLyoqXG4gKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbk5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbk5vZGUucHJvdG90eXBlLnRvVGV4ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyBhIE5vZGVcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXNOb2RlXG4gKi9cbk5vZGUuaXNOb2RlID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBOb2RlO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgc3ltYm9sIG5hbWVzIG9mIGEgc2NvcGUuXG4gKiBUaHJvd3MgYW4gZXJyb3Igd2hlbiB0aGUgc2NvcGUgY29udGFpbnMgYW4gaWxsZWdhbCBzeW1ib2wuXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqL1xuZnVuY3Rpb24gX3ZhbGlkYXRlU2NvcGUgKHNjb3BlKSB7XG4gIGZvciAodmFyIHN5bWJvbCBpbiBzY29wZSkge1xuICAgIGlmIChzY29wZS5oYXNPd25Qcm9wZXJ0eShzeW1ib2wpKSB7XG4gICAgICBpZiAoc3ltYm9sIGluIGtleXdvcmRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NvcGUgY29udGFpbnMgYW4gaWxsZWdhbCBzeW1ib2wsIFwiJyArIHN5bWJvbCArICdcIiBpcyBhIHJlc2VydmVkIGtleXdvcmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXBsYWNlIGFsbCBmdW5jdGlvbnMgaGF2aW5nIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIGF0dGFjaGVkIGF0IHByb3BlcnR5IHRyYW5zZm9ybVxuICogd2l0aCB0aGVpciB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0aFxuICogQHJldHVybiB7T2JqZWN0fSB0cmFuc2Zvcm1lZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3RyYW5zZm9ybShtYXRoKSB7XG4gIHZhciB0cmFuc2Zvcm1lZCA9IE9iamVjdC5jcmVhdGUobWF0aCk7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBtYXRoKSB7XG4gICAgaWYgKG1hdGguaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhciBmbiA9IG1hdGhbbmFtZV07XG4gICAgICB2YXIgdHJhbnNmb3JtID0gZm4gJiYgZm4udHJhbnNmb3JtO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm1lZFtuYW1lXSA9IHRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTk9URTogZGlzdHJpYnV0aW9uIGlzIE5PVCBhZGRlZCB0byBtYXRoLmRpc3RyaWJ1dGlvbiBidXQgcmV0dXJuZWQgYnkgdGhlIGZhY3RvcnkgZnVuY3Rpb25cbi8vIFRPRE86IHJldGhpbmsgbWF0aC5kaXN0cmlidXRpb25cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKTtcbiAgdmFyIGFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9hcnJheScpO1xuICB2YXIgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvY29sbGVjdGlvbicpO1xuICB2YXIgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRpc3RyaWJ1dGlvbiBvYmplY3Qgd2l0aCBhIHNldCBvZiByYW5kb20gZnVuY3Rpb25zIGZvciBnaXZlblxuICAgKiByYW5kb20gZGlzdHJpYnV0aW9uLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmRpc3RyaWJ1dGlvbihuYW1lKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIHZhciBub3JtYWxEaXN0ID0gbWF0aC5kaXN0cmlidXRpb24oJ25vcm1hbCcpOyAvLyBjcmVhdGUgYSBub3JtYWwgZGlzdHJpYnV0aW9uXG4gICAqICAgICBub3JtYWxEaXN0LnJhbmRvbSgwLCAxMCk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBhIHJhbmRvbSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgcmFuZG9tLCByYW5kb21JbnQsIHBpY2tSYW5kb21cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgICBOYW1lIG9mIGEgZGlzdHJpYnV0aW9uLiBDaG9vc2UgZnJvbSAndW5pZm9ybScsICdub3JtYWwnLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFJldHVybnMgYSBkaXN0cmlidXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgZnVuY3Rpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGByYW5kb20oW3NpemVdIFssIG1pbl0gWywgbWF4XSlgLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGByYW5kb21JbnQoW21pbl0gWywgbWF4XSlgLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGBwaWNrUmFuZG9tKGFycmF5KWBcbiAgICovXG4gIGZ1bmN0aW9uIGRpc3RyaWJ1dGlvbihuYW1lKSB7XG4gICAgaWYgKCFkaXN0cmlidXRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRpc3RyaWJ1dGlvbiAnICsgbmFtZSk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgIGRpc3RyaWJ1dGlvbiA9IGRpc3RyaWJ1dGlvbnNbbmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uKGRpc3RyaWJ1dGlvbikge1xuXG4gICAgICAvLyBUaGlzIGlzIHRoZSBwdWJsaWMgQVBJIGZvciBhbGwgZGlzdHJpYnV0aW9uc1xuICAgICAgdmFyIHJhbmRGdW5jdGlvbnMgPSB7XG5cbiAgICAgICAgcmFuZG9tOiBmdW5jdGlvbihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgICAgdmFyIHNpemUsIG1pbiwgbWF4O1xuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3JhbmRvbScsIGFyZ3VtZW50cy5sZW5ndGgsIDAsIDMpO1xuXG4gICAgICAgICAgLy8gYHJhbmRvbShtYXgpYCBvciBgcmFuZG9tKHNpemUpYFxuICAgICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihhcmcxKSkge1xuICAgICAgICAgICAgICBzaXplID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBtYXggPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGByYW5kb20obWluLCBtYXgpYCBvciBgcmFuZG9tKHNpemUsIG1heClgXG4gICAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKGFyZzEpKSB7XG4gICAgICAgICAgICAgIHNpemUgPSBhcmcxO1xuICAgICAgICAgICAgICBtYXggPSBhcmcyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG1pbiA9IGFyZzE7XG4gICAgICAgICAgICAgIG1heCA9IGFyZzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gYHJhbmRvbShzaXplLCBtaW4sIG1heClgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgPSBhcmcxO1xuICAgICAgICAgICAgbWluID0gYXJnMjtcbiAgICAgICAgICAgIG1heCA9IGFyZzM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogdmFsaWRhdGUgdHlwZSBvZiBtaW4sIG1heCwgYW5kIHNpemVcblxuICAgICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkgbWF4ID0gMTtcbiAgICAgICAgICBpZiAobWluID09PSB1bmRlZmluZWQpIG1pbiA9IDA7XG4gICAgICAgICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IF9yYW5kb21EYXRhRm9yTWF0cml4KHNpemUudmFsdWVPZigpLCBtaW4sIG1heCwgX3JhbmRvbSk7XG4gICAgICAgICAgICByZXR1cm4gKHNpemUgaW5zdGFuY2VvZiBNYXRyaXgpID8gbmV3IE1hdHJpeChyZXMpIDogcmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHJldHVybiBfcmFuZG9tKG1pbiwgbWF4KTtcbiAgICAgICAgfSxcblxuICAgICAgICByYW5kb21JbnQ6IGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgICB2YXIgc2l6ZSwgbWluLCBtYXg7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzIHx8IGFyZ3VtZW50cy5sZW5ndGggPCAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ3JhbmRvbUludCcsIGFyZ3VtZW50cy5sZW5ndGgsIDEsIDMpO1xuXG4gICAgICAgICAgLy8gYHJhbmRvbShtYXgpYCBvciBgcmFuZG9tKHNpemUpYFxuICAgICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKGFyZzEpKSB7XG4gICAgICAgICAgICAgIHNpemUgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG1heCA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gYHJhbmRvbUludChtaW4sIG1heClgIG9yIGByYW5kb21JbnQoc2l6ZSwgbWF4KWBcbiAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKGFyZzEpKSB7XG4gICAgICAgICAgICAgIHNpemUgPSBhcmcxO1xuICAgICAgICAgICAgICBtYXggPSBhcmcyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG1pbiA9IGFyZzE7XG4gICAgICAgICAgICAgIG1heCA9IGFyZzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gYHJhbmRvbUludChzaXplLCBtaW4sIG1heClgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgPSBhcmcxO1xuICAgICAgICAgICAgbWluID0gYXJnMjtcbiAgICAgICAgICAgIG1heCA9IGFyZzM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogdmFsaWRhdGUgdHlwZSBvZiBtaW4sIG1heCwgYW5kIHNpemVcblxuICAgICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkgbWluID0gMDtcbiAgICAgICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gX3JhbmRvbURhdGFGb3JNYXRyaXgoc2l6ZS52YWx1ZU9mKCksIG1pbiwgbWF4LCBfcmFuZG9tSW50KTtcbiAgICAgICAgICAgIHJldHVybiAoc2l6ZSBpbnN0YW5jZW9mIE1hdHJpeCkgPyBuZXcgTWF0cml4KHJlcykgOiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgcmV0dXJuIF9yYW5kb21JbnQobWluLCBtYXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBpY2tSYW5kb206IGZ1bmN0aW9uKHBvc3NpYmxlcykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcigncGlja1JhbmRvbScsIGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zc2libGVzIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICBwb3NzaWJsZXMgPSBwb3NzaWJsZXMudmFsdWVPZigpOyAvLyBnZXQgQXJyYXlcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocG9zc2libGVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuVW5zdXBwb3J0ZWRUeXBlRXJyb3IoJ3BpY2tSYW5kb20nLCBtYXRoWyd0eXBlb2YnXShwb3NzaWJsZXMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXJyYXkuc2l6ZShwb3NzaWJsZXMpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgZGltZW5zaW9uYWwgdmVjdG9ycyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgbXVsdGkgZGltZW5zaW9uYWwgbWF0cmljZXNcbiAgICAgICAgICByZXR1cm4gcG9zc2libGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvc3NpYmxlcy5sZW5ndGgpXTtcbiAgICAgICAgfVxuXG4gICAgICB9O1xuXG4gICAgICB2YXIgX3JhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBtaW4gKyBkaXN0cmlidXRpb24oKSAqIChtYXggLSBtaW4pO1xuICAgICAgfTtcblxuICAgICAgdmFyIF9yYW5kb21JbnQgPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihtaW4gKyBkaXN0cmlidXRpb24oKSAqIChtYXggLSBtaW4pKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFRoaXMgaXMgYSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBhIHJhbmRvbSBtYXRyaXggcmVjdXJzaXZlbHkuXG4gICAgICB2YXIgX3JhbmRvbURhdGFGb3JNYXRyaXggPSBmdW5jdGlvbihzaXplLCBtaW4sIG1heCwgcmFuZEZ1bmMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXSwgbGVuZ3RoLCBpO1xuICAgICAgICBzaXplID0gc2l6ZS5zbGljZSgwKTtcblxuICAgICAgICBpZiAoc2l6ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2l6ZS5zaGlmdCgpOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBkYXRhLnB1c2goX3JhbmRvbURhdGFGb3JNYXRyaXgoc2l6ZSwgbWluLCBtYXgsIHJhbmRGdW5jKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2l6ZS5zaGlmdCgpOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBkYXRhLnB1c2gocmFuZEZ1bmMobWluLCBtYXgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJhbmRGdW5jdGlvbnM7XG5cbiAgICB9KShkaXN0cmlidXRpb24pO1xuICB9O1xuXG4gIC8vIEVhY2ggZGlzdHJpYnV0aW9uIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBubyBhcmd1bWVudCBhbmQgd2hlbiBjYWxsZWQgcmV0dXJuc1xuICAvLyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gIHZhciBkaXN0cmlidXRpb25zID0ge1xuXG4gICAgdW5pZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb207XG4gICAgfSxcblxuICAgIC8vIEltcGxlbWVudGF0aW9uIG9mIG5vcm1hbCBkaXN0cmlidXRpb24gdXNpbmcgQm94LU11bGxlciB0cmFuc2Zvcm1cbiAgICAvLyByZWYgOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JveCVFMiU4MCU5M011bGxlcl90cmFuc2Zvcm1cbiAgICAvLyBXZSB0YWtlIDogbWVhbiA9IDAuNSwgc3RhbmRhcmQgZGV2aWF0aW9uID0gMS82XG4gICAgLy8gc28gdGhhdCA5OS43JSB2YWx1ZXMgYXJlIGluIFswLCAxXS5cbiAgICBub3JtYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdTEsIHUyLFxuICAgICAgICAgICAgcGlja2VkID0gLTE7XG4gICAgICAgIC8vIFdlIHJlamVjdCB2YWx1ZXMgb3V0c2lkZSBvZiB0aGUgaW50ZXJ2YWwgWzAsIDFdXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIGl0IGlzIG9rIHRvIGRvIHRoYXQ/XG4gICAgICAgIHdoaWxlIChwaWNrZWQgPCAwIHx8IHBpY2tlZCA+IDEpIHtcbiAgICAgICAgICB1MSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgdTIgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgIHBpY2tlZCA9IDEvNiAqIE1hdGgucG93KC0yICogTWF0aC5sb2codTEpLCAwLjUpICogTWF0aC5jb3MoMiAqIE1hdGguUEkgKiB1MikgKyAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2tlZDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGRpc3RyaWJ1dGlvbjtcbn07XG4iLCJ2YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xudmFyIEluZGV4RXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9JbmRleEVycm9yJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHplcm8tYmFzZWQgaW5kaWNlcyB0byBvbmUtYmFzZWQgaW5kaWNlcyBpbiBlcnJvcnNcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHJldHVybnMge0Vycm9yfSBSZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCBlcnJvclxuICovXG5leHBvcnRzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEluZGV4RXJyb3IpIHtcbiAgICByZXR1cm4gbmV3IEluZGV4RXJyb3IoZXJyLmluZGV4ICsgMSwgZXJyLm1pbiArIDEsIGVyci5tYXggKyAxKTtcbiAgfVxuXG4gIHJldHVybiBlcnI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBSZXNlcnZlZCBrZXl3b3JkcyBub3QgYWxsb3dlZCB0byB1c2UgaW4gdGhlIHBhcnNlclxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuZDogdHJ1ZVxufTtcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbmV4cG9ydHMuaGV4X3NoYTEgPSBoZXhfc2hhMTtcbmV4cG9ydHMuYjY0X3NoYTEgPSBiNjRfc2hhMTtcbmV4cG9ydHMuc3RyX3NoYTEgPSBzdHJfc2hhMTtcbmV4cG9ydHMuaGV4X2htYWNfc2hhMSA9IGhleF9obWFjX3NoYTE7XG5leHBvcnRzLmI2NF9obWFjX3NoYTEgPSBiNjRfaG1hY19zaGExO1xuZXhwb3J0cy5zdHJfaG1hY19zaGExID0gc3RyX2htYWNfc2hhMTtcblxuLypcbiAqIENvbmZpZ3VyYWJsZSB2YXJpYWJsZXMuIFlvdSBtYXkgbmVlZCB0byB0d2VhayB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGhcbiAqIHRoZSBzZXJ2ZXItc2lkZSwgYnV0IHRoZSBkZWZhdWx0cyB3b3JrIGluIG1vc3QgY2FzZXMuXG4gKi9cbnZhciBoZXhjYXNlID0gMDsgIC8qIGhleCBvdXRwdXQgZm9ybWF0LiAwIC0gbG93ZXJjYXNlOyAxIC0gdXBwZXJjYXNlICAgICAgICAqL1xudmFyIGI2NHBhZCAgPSBcIlwiOyAvKiBiYXNlLTY0IHBhZCBjaGFyYWN0ZXIuIFwiPVwiIGZvciBzdHJpY3QgUkZDIGNvbXBsaWFuY2UgICAqL1xudmFyIGNocnN6ICAgPSA4OyAgLyogYml0cyBwZXIgaW5wdXQgY2hhcmFjdGVyLiA4IC0gQVNDSUk7IDE2IC0gVW5pY29kZSAgICAgICovXG5cbi8qXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcbiAqIFRoZXkgdGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIGhleCBvciBiYXNlLTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5mdW5jdGlvbiBoZXhfc2hhMShzKXtyZXR1cm4gYmluYjJoZXgoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBiNjRfc2hhMShzKXtyZXR1cm4gYmluYjJiNjQoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBzdHJfc2hhMShzKXtyZXR1cm4gYmluYjJzdHIoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBoZXhfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMmhleChjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5mdW5jdGlvbiBiNjRfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMmI2NChjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5mdW5jdGlvbiBzdHJfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMnN0cihjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5cbi8qXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmdcbiAqL1xuZnVuY3Rpb24gc2hhMV92bV90ZXN0KClcbntcbiAgcmV0dXJuIGhleF9zaGExKFwiYWJjXCIpID09IFwiYTk5OTNlMzY0NzA2ODE2YWJhM2UyNTcxNzg1MGMyNmM5Y2QwZDg5ZFwiO1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBTSEEtMSBvZiBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvcmVfc2hhMSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbGVuICUgMzIpO1xuICB4WygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG5cbiAgdmFyIHcgPSBBcnJheSg4MCk7XG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuICB2YXIgZSA9IC0xMDA5NTg5Nzc2O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcbiAgICB2YXIgb2xkZSA9IGU7XG5cbiAgICBmb3IodmFyIGogPSAwOyBqIDwgODA7IGorKylcbiAgICB7XG4gICAgICBpZihqIDwgMTYpIHdbal0gPSB4W2kgKyBqXTtcbiAgICAgIGVsc2Ugd1tqXSA9IHJvbCh3W2otM10gXiB3W2otOF0gXiB3W2otMTRdIF4gd1tqLTE2XSwgMSk7XG4gICAgICB2YXIgdCA9IHNhZmVfYWRkKHNhZmVfYWRkKHJvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXG4gICAgICAgICAgICAgICAgICAgICAgIHNhZmVfYWRkKHNhZmVfYWRkKGUsIHdbal0pLCBzaGExX2t0KGopKSk7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IHJvbChiLCAzMCk7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgICBlID0gc2FmZV9hZGQoZSwgb2xkZSk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQsIGUpO1xuXG59XG5cbi8qXG4gKiBQZXJmb3JtIHRoZSBhcHByb3ByaWF0ZSB0cmlwbGV0IGNvbWJpbmF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudFxuICogaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfZnQodCwgYiwgYywgZClcbntcbiAgaWYodCA8IDIwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZCk7XG4gIGlmKHQgPCA0MCkgcmV0dXJuIGIgXiBjIF4gZDtcbiAgaWYodCA8IDYwKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpO1xuICByZXR1cm4gYiBeIGMgXiBkO1xufVxuXG4vKlxuICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBhZGRpdGl2ZSBjb25zdGFudCBmb3IgdGhlIGN1cnJlbnQgaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfa3QodClcbntcbiAgcmV0dXJuICh0IDwgMjApID8gIDE1MTg1MDAyNDkgOiAodCA8IDQwKSA/ICAxODU5Nzc1MzkzIDpcbiAgICAgICAgICh0IDwgNjApID8gLTE4OTQwMDc1ODggOiAtODk5NDk3NTE0O1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBITUFDLVNIQTEgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YVxuICovXG5mdW5jdGlvbiBjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpXG57XG4gIHZhciBia2V5ID0gc3RyMmJpbmIoa2V5KTtcbiAgaWYoYmtleS5sZW5ndGggPiAxNikgYmtleSA9IGNvcmVfc2hhMShia2V5LCBrZXkubGVuZ3RoICogY2hyc3opO1xuXG4gIHZhciBpcGFkID0gQXJyYXkoMTYpLCBvcGFkID0gQXJyYXkoMTYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAge1xuICAgIGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNjtcbiAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7XG4gIH1cblxuICB2YXIgaGFzaCA9IGNvcmVfc2hhMShpcGFkLmNvbmNhdChzdHIyYmluYihkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogY2hyc3opO1xuICByZXR1cm4gY29yZV9zaGExKG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxNjApO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIDgtYml0IG9yIDE2LWJpdCBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3Jkc1xuICogSW4gOC1iaXQgZnVuY3Rpb24sIGNoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAqL1xuZnVuY3Rpb24gc3RyMmJpbmIoc3RyKVxue1xuICB2YXIgYmluID0gQXJyYXkoKTtcbiAgdmFyIG1hc2sgPSAoMSA8PCBjaHJzeikgLSAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aCAqIGNocnN6OyBpICs9IGNocnN6KVxuICAgIGJpbltpPj41XSB8PSAoc3RyLmNoYXJDb2RlQXQoaSAvIGNocnN6KSAmIG1hc2spIDw8ICgzMiAtIGNocnN6IC0gaSUzMik7XG4gIHJldHVybiBiaW47XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYmluYjJzdHIoYmluKVxue1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdmFyIG1hc2sgPSAoMSA8PCBjaHJzeikgLSAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYmluLmxlbmd0aCAqIDMyOyBpICs9IGNocnN6KVxuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChiaW5baT4+NV0gPj4+ICgzMiAtIGNocnN6IC0gaSUzMikpICYgbWFzayk7XG4gIHJldHVybiBzdHI7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiaW5iMmhleChiaW5hcnJheSlcbntcbiAgdmFyIGhleF90YWIgPSBoZXhjYXNlID8gXCIwMTIzNDU2Nzg5QUJDREVGXCIgOiBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiaW5hcnJheS5sZW5ndGggKiA0OyBpKyspXG4gIHtcbiAgICBzdHIgKz0gaGV4X3RhYi5jaGFyQXQoKGJpbmFycmF5W2k+PjJdID4+ICgoMyAtIGklNCkqOCs0KSkgJiAweEYpICtcbiAgICAgICAgICAgaGV4X3RhYi5jaGFyQXQoKGJpbmFycmF5W2k+PjJdID4+ICgoMyAtIGklNCkqOCAgKSkgJiAweEYpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBiaW5iMmI2NChiaW5hcnJheSlcbntcbiAgdmFyIHRhYiA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICB2YXIgc3RyID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJpbmFycmF5Lmxlbmd0aCAqIDQ7IGkgKz0gMylcbiAge1xuICAgIHZhciB0cmlwbGV0ID0gKCgoYmluYXJyYXlbaSAgID4+IDJdID4+IDggKiAoMyAtICBpICAgJTQpKSAmIDB4RkYpIDw8IDE2KVxuICAgICAgICAgICAgICAgIHwgKCgoYmluYXJyYXlbaSsxID4+IDJdID4+IDggKiAoMyAtIChpKzEpJTQpKSAmIDB4RkYpIDw8IDggKVxuICAgICAgICAgICAgICAgIHwgICgoYmluYXJyYXlbaSsyID4+IDJdID4+IDggKiAoMyAtIChpKzIpJTQpKSAmIDB4RkYpO1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAge1xuICAgICAgaWYoaSAqIDggKyBqICogNiA+IGJpbmFycmF5Lmxlbmd0aCAqIDMyKSBzdHIgKz0gYjY0cGFkO1xuICAgICAgZWxzZSBzdHIgKz0gdGFiLmNoYXJBdCgodHJpcGxldCA+PiA2KigzLWopKSAmIDB4M0YpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4iLCIvLyBPcmlnaW5hbCBjb2RlIGFkYXB0ZWQgZnJvbSBSb2JlcnQgS2llZmZlci5cbi8vIGRldGFpbHMgYXQgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWRcbihmdW5jdGlvbigpIHtcbiAgdmFyIF9nbG9iYWwgPSB0aGlzO1xuXG4gIHZhciBtYXRoUk5HLCB3aGF0d2dSTkc7XG5cbiAgLy8gTk9URTogTWF0aC5yYW5kb20oKSBkb2VzIG5vdCBndWFyYW50ZWUgXCJjcnlwdG9ncmFwaGljIHF1YWxpdHlcIlxuICBtYXRoUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgcjtcblxuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgYnl0ZXNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgLy8gY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGluIHdlYmtpdC1iYXNlZCBicm93c2Vycy5cbiAgaWYgKF9nbG9iYWwuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB2YXIgX3JuZHMgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgd2hhdHdnUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kcyk7XG5cbiAgICAgIGZvciAodmFyIGMgPSAwIDsgYyA8IHNpemU7IGMrKykge1xuICAgICAgICBieXRlc1tjXSA9IF9ybmRzW2MgPj4gMl0gPj4+ICgoYyAmIDB4MDMpICogOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gd2hhdHdnUk5HIHx8IG1hdGhSTkc7XG5cbn0oKSkiLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5cbi8qXG4gKiBDb25maWd1cmFibGUgdmFyaWFibGVzLiBZb3UgbWF5IG5lZWQgdG8gdHdlYWsgdGhlc2UgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4gKiB0aGUgc2VydmVyLXNpZGUsIGJ1dCB0aGUgZGVmYXVsdHMgd29yayBpbiBtb3N0IGNhc2VzLlxuICovXG52YXIgaGV4Y2FzZSA9IDA7ICAgLyogaGV4IG91dHB1dCBmb3JtYXQuIDAgLSBsb3dlcmNhc2U7IDEgLSB1cHBlcmNhc2UgICAgICAgICovXG52YXIgYjY0cGFkICA9IFwiXCI7ICAvKiBiYXNlLTY0IHBhZCBjaGFyYWN0ZXIuIFwiPVwiIGZvciBzdHJpY3QgUkZDIGNvbXBsaWFuY2UgICAqL1xuXG4vKlxuICogVGhlc2UgYXJlIHRoZSBmdW5jdGlvbnMgeW91J2xsIHVzdWFsbHkgd2FudCB0byBjYWxsXG4gKiBUaGV5IHRha2Ugc3RyaW5nIGFyZ3VtZW50cyBhbmQgcmV0dXJuIGVpdGhlciBoZXggb3IgYmFzZS02NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuZnVuY3Rpb24gaGV4X21kNShzKSAgICB7IHJldHVybiByc3RyMmhleChyc3RyX21kNShzdHIycnN0cl91dGY4KHMpKSk7IH1cbmZ1bmN0aW9uIGI2NF9tZDUocykgICAgeyByZXR1cm4gcnN0cjJiNjQocnN0cl9tZDUoc3RyMnJzdHJfdXRmOChzKSkpOyB9XG5mdW5jdGlvbiBhbnlfbWQ1KHMsIGUpIHsgcmV0dXJuIHJzdHIyYW55KHJzdHJfbWQ1KHN0cjJyc3RyX3V0ZjgocykpLCBlKTsgfVxuZnVuY3Rpb24gaGV4X2htYWNfbWQ1KGssIGQpXG4gIHsgcmV0dXJuIHJzdHIyaGV4KHJzdHJfaG1hY19tZDUoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSkpOyB9XG5mdW5jdGlvbiBiNjRfaG1hY19tZDUoaywgZClcbiAgeyByZXR1cm4gcnN0cjJiNjQocnN0cl9obWFjX21kNShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKSk7IH1cbmZ1bmN0aW9uIGFueV9obWFjX21kNShrLCBkLCBlKVxuICB7IHJldHVybiByc3RyMmFueShyc3RyX2htYWNfbWQ1KHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpLCBlKTsgfVxuXG4vKlxuICogUGVyZm9ybSBhIHNpbXBsZSBzZWxmLXRlc3QgdG8gc2VlIGlmIHRoZSBWTSBpcyB3b3JraW5nXG4gKi9cbmZ1bmN0aW9uIG1kNV92bV90ZXN0KClcbntcbiAgcmV0dXJuIGhleF9tZDUoXCJhYmNcIikudG9Mb3dlckNhc2UoKSA9PSBcIjkwMDE1MDk4M2NkMjRmYjBkNjk2M2Y3ZDI4ZTE3ZjcyXCI7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhIHJhdyBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cl9tZDUocylcbntcbiAgcmV0dXJuIGJpbmwycnN0cihiaW5sX21kNShyc3RyMmJpbmwocyksIHMubGVuZ3RoICogOCkpO1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBITUFDLU1ENSwgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YSAocmF3IHN0cmluZ3MpXG4gKi9cbmZ1bmN0aW9uIHJzdHJfaG1hY19tZDUoa2V5LCBkYXRhKVxue1xuICB2YXIgYmtleSA9IHJzdHIyYmlubChrZXkpO1xuICBpZihia2V5Lmxlbmd0aCA+IDE2KSBia2V5ID0gYmlubF9tZDUoYmtleSwga2V5Lmxlbmd0aCAqIDgpO1xuXG4gIHZhciBpcGFkID0gQXJyYXkoMTYpLCBvcGFkID0gQXJyYXkoMTYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAge1xuICAgIGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNjtcbiAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7XG4gIH1cblxuICB2YXIgaGFzaCA9IGJpbmxfbWQ1KGlwYWQuY29uY2F0KHJzdHIyYmlubChkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogOCk7XG4gIHJldHVybiBiaW5sMnJzdHIoYmlubF9tZDUob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDEyOCkpO1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHJzdHIyaGV4KGlucHV0KVxue1xuICB0cnkgeyBoZXhjYXNlIH0gY2F0Y2goZSkgeyBoZXhjYXNlPTA7IH1cbiAgdmFyIGhleF90YWIgPSBoZXhjYXNlID8gXCIwMTIzNDU2Nzg5QUJDREVGXCIgOiBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIHZhciB4O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspXG4gIHtcbiAgICB4ID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICBvdXRwdXQgKz0gaGV4X3RhYi5jaGFyQXQoKHggPj4+IDQpICYgMHgwRilcbiAgICAgICAgICAgKyAgaGV4X3RhYi5jaGFyQXQoIHggICAgICAgICYgMHgwRik7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGEgYmFzZS02NCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cjJiNjQoaW5wdXQpXG57XG4gIHRyeSB7IGI2NHBhZCB9IGNhdGNoKGUpIHsgYjY0cGFkPScnOyB9XG4gIHZhciB0YWIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIHZhciBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMylcbiAge1xuICAgIHZhciB0cmlwbGV0ID0gKGlucHV0LmNoYXJDb2RlQXQoaSkgPDwgMTYpXG4gICAgICAgICAgICAgICAgfCAoaSArIDEgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrMSkgPDwgOCA6IDApXG4gICAgICAgICAgICAgICAgfCAoaSArIDIgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrMikgICAgICA6IDApO1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAge1xuICAgICAgaWYoaSAqIDggKyBqICogNiA+IGlucHV0Lmxlbmd0aCAqIDgpIG91dHB1dCArPSBiNjRwYWQ7XG4gICAgICBlbHNlIG91dHB1dCArPSB0YWIuY2hhckF0KCh0cmlwbGV0ID4+PiA2KigzLWopKSAmIDB4M0YpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYW4gYXJiaXRyYXJ5IHN0cmluZyBlbmNvZGluZ1xuICovXG5mdW5jdGlvbiByc3RyMmFueShpbnB1dCwgZW5jb2RpbmcpXG57XG4gIHZhciBkaXZpc29yID0gZW5jb2RpbmcubGVuZ3RoO1xuICB2YXIgaSwgaiwgcSwgeCwgcXVvdGllbnQ7XG5cbiAgLyogQ29udmVydCB0byBhbiBhcnJheSBvZiAxNi1iaXQgYmlnLWVuZGlhbiB2YWx1ZXMsIGZvcm1pbmcgdGhlIGRpdmlkZW5kICovXG4gIHZhciBkaXZpZGVuZCA9IEFycmF5KE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyAyKSk7XG4gIGZvcihpID0gMDsgaSA8IGRpdmlkZW5kLmxlbmd0aDsgaSsrKVxuICB7XG4gICAgZGl2aWRlbmRbaV0gPSAoaW5wdXQuY2hhckNvZGVBdChpICogMikgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KGkgKiAyICsgMSk7XG4gIH1cblxuICAvKlxuICAgKiBSZXBlYXRlZGx5IHBlcmZvcm0gYSBsb25nIGRpdmlzaW9uLiBUaGUgYmluYXJ5IGFycmF5IGZvcm1zIHRoZSBkaXZpZGVuZCxcbiAgICogdGhlIGxlbmd0aCBvZiB0aGUgZW5jb2RpbmcgaXMgdGhlIGRpdmlzb3IuIE9uY2UgY29tcHV0ZWQsIHRoZSBxdW90aWVudFxuICAgKiBmb3JtcyB0aGUgZGl2aWRlbmQgZm9yIHRoZSBuZXh0IHN0ZXAuIEFsbCByZW1haW5kZXJzIGFyZSBzdG9yZWQgZm9yIGxhdGVyXG4gICAqIHVzZS5cbiAgICovXG4gIHZhciBmdWxsX2xlbmd0aCA9IE1hdGguY2VpbChpbnB1dC5sZW5ndGggKiA4IC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChNYXRoLmxvZyhlbmNvZGluZy5sZW5ndGgpIC8gTWF0aC5sb2coMikpKTtcbiAgdmFyIHJlbWFpbmRlcnMgPSBBcnJheShmdWxsX2xlbmd0aCk7XG4gIGZvcihqID0gMDsgaiA8IGZ1bGxfbGVuZ3RoOyBqKyspXG4gIHtcbiAgICBxdW90aWVudCA9IEFycmF5KCk7XG4gICAgeCA9IDA7XG4gICAgZm9yKGkgPSAwOyBpIDwgZGl2aWRlbmQubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgeCA9ICh4IDw8IDE2KSArIGRpdmlkZW5kW2ldO1xuICAgICAgcSA9IE1hdGguZmxvb3IoeCAvIGRpdmlzb3IpO1xuICAgICAgeCAtPSBxICogZGl2aXNvcjtcbiAgICAgIGlmKHF1b3RpZW50Lmxlbmd0aCA+IDAgfHwgcSA+IDApXG4gICAgICAgIHF1b3RpZW50W3F1b3RpZW50Lmxlbmd0aF0gPSBxO1xuICAgIH1cbiAgICByZW1haW5kZXJzW2pdID0geDtcbiAgICBkaXZpZGVuZCA9IHF1b3RpZW50O1xuICB9XG5cbiAgLyogQ29udmVydCB0aGUgcmVtYWluZGVycyB0byB0aGUgb3V0cHV0IHN0cmluZyAqL1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKGkgPSByZW1haW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIG91dHB1dCArPSBlbmNvZGluZy5jaGFyQXQocmVtYWluZGVyc1tpXSk7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIEVuY29kZSBhIHN0cmluZyBhcyB1dGYtOC5cbiAqIEZvciBlZmZpY2llbmN5LCB0aGlzIGFzc3VtZXMgdGhlIGlucHV0IGlzIHZhbGlkIHV0Zi0xNi5cbiAqL1xuZnVuY3Rpb24gc3RyMnJzdHJfdXRmOChpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIHZhciBpID0gLTE7XG4gIHZhciB4LCB5O1xuXG4gIHdoaWxlKCsraSA8IGlucHV0Lmxlbmd0aClcbiAge1xuICAgIC8qIERlY29kZSB1dGYtMTYgc3Vycm9nYXRlIHBhaXJzICovXG4gICAgeCA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgeSA9IGkgKyAxIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckNvZGVBdChpICsgMSkgOiAwO1xuICAgIGlmKDB4RDgwMCA8PSB4ICYmIHggPD0gMHhEQkZGICYmIDB4REMwMCA8PSB5ICYmIHkgPD0gMHhERkZGKVxuICAgIHtcbiAgICAgIHggPSAweDEwMDAwICsgKCh4ICYgMHgwM0ZGKSA8PCAxMCkgKyAoeSAmIDB4MDNGRik7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgLyogRW5jb2RlIG91dHB1dCBhcyB1dGYtOCAqL1xuICAgIGlmKHggPD0gMHg3RilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICAgIGVsc2UgaWYoeCA8PSAweDdGRilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4QzAgfCAoKHggPj4+IDYgKSAmIDB4MUYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xuICAgIGVsc2UgaWYoeCA8PSAweEZGRkYpXG4gICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEUwIHwgKCh4ID4+PiAxMikgJiAweDBGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKHggPj4+IDYgKSAmIDB4M0YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xuICAgIGVsc2UgaWYoeCA8PSAweDFGRkZGRilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RjAgfCAoKHggPj4+IDE4KSAmIDB4MDcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoeCA+Pj4gMTIpICYgMHgzRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCh4ID4+PiA2ICkgJiAweDNGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoIHggICAgICAgICAmIDB4M0YpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi0xNlxuICovXG5mdW5jdGlvbiBzdHIycnN0cl91dGYxNmxlKGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKVxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0LmNoYXJDb2RlQXQoaSkgPj4+IDgpICYgMHhGRik7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjE2YmUoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0LmNoYXJDb2RlQXQoaSkgPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuY2hhckNvZGVBdChpKSAgICAgICAgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiByc3RyMmJpbmwoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBBcnJheShpbnB1dC5sZW5ndGggPj4gMik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspXG4gICAgb3V0cHV0W2ldID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDg7IGkgKz0gOClcbiAgICBvdXRwdXRbaT4+NV0gfD0gKGlucHV0LmNoYXJDb2RlQXQoaSAvIDgpICYgMHhGRikgPDwgKGklMzIpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGJpbmwycnN0cihpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggKiAzMjsgaSArPSA4KVxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnB1dFtpPj41XSA+Pj4gKGkgJSAzMikpICYgMHhGRik7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBiaW5sX21kNSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKChsZW4pICUgMzIpO1xuICB4WygoKGxlbiArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsZW47XG5cbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxuICB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDBdLCA3ICwgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA0XSwgNyAsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDcgLCAgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKzEyXSwgNyAsICAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XG5cbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDUgLCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgNl0sIDkgLCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDVdLCA1ICwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTBdLCA5ICwgIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDUgLCAgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxNF0sIDkgLCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKzEzXSwgNSAsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgMl0sIDkgLCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDQgLCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDFdLCA0ICwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA0XSwgMTEsICAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krMTNdLCA0ICwgIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDBdLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDZdLCAyMywgIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDQgLCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE2LCAgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcblxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyAwXSwgNiAsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDYgLCAgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDhdLCA2ICwgIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDYgLCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQpO1xufVxuXG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxue1xuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcbn1cbmZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5cbmV4cG9ydHMuaGV4X21kNSA9IGhleF9tZDU7XG5leHBvcnRzLmI2NF9tZDUgPSBiNjRfbWQ1O1xuZXhwb3J0cy5hbnlfbWQ1ID0gYW55X21kNTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvaW5kZXgnKSxcblxuICAgICAgQmlnTnVtYmVyID0gcmVxdWlyZSgnZGVjaW1hbC5qcycpLFxuICAgICAgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKSxcbiAgICAgIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKSxcblxuICAgICAgb2JqZWN0ID0gdXRpbC5vYmplY3QsXG4gICAgICBhcnJheSA9IHV0aWwuYXJyYXksXG4gICAgICBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyLFxuICAgICAgaXNJbnRlZ2VyID0gdXRpbC5udW1iZXIuaXNJbnRlZ2VyLFxuICAgICAgaXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5pc0NvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlIHR3byBvciBtb3JlIG1hdHJpY2VzLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmNvbmNhdChBLCBCLCBDLCAuLi4pXG4gICAqICAgICBtYXRoLmNvbmNhdChBLCBCLCBDLCAuLi4sIGRpbSlcbiAgICpcbiAgICogV2hlcmU6XG4gICAqXG4gICAqIC0gYGRpbTogbnVtYmVyYCBpcyBhIHplcm8tYmFzZWQgZGltZW5zaW9uIG92ZXIgd2hpY2ggdG8gY29uY2F0ZW5hdGUgdGhlIG1hdHJpY2VzLlxuICAgKiAgIEJ5IGRlZmF1bHQgdGhlIGxhc3QgZGltZW5zaW9uIG9mIHRoZSBtYXRyaWNlcy5cbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIHZhciBBID0gW1sxLCAyXSwgWzUsIDZdXTtcbiAgICogICAgdmFyIEIgPSBbWzMsIDRdLCBbNywgOF1dO1xuICAgKlxuICAgKiAgICBtYXRoLmNvbmNhdChBLCBCKTsgICAgICAvLyByZXR1cm5zIFtbMSwgMiwgMywgNF0sIFs1LCA2LCA3LCA4XV1cbiAgICogICAgbWF0aC5jb25jYXQoQSwgQiwgMCk7ICAgLy8gcmV0dXJucyBbWzEsIDJdLCBbNSwgNl0sIFszLCA0XSwgWzcsIDhdXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgc2l6ZSwgc3F1ZWV6ZSwgc3Vic2V0LCB0cmFuc3Bvc2VcbiAgICpcbiAgICogQHBhcmFtIHsuLi4gQXJyYXkgfCBNYXRyaXh9IGFyZ3MgICAgIFR3byBvciBtb3JlIG1hdHJpY2VzXG4gICAqIEByZXR1cm4ge0FycmF5IHwgTWF0cml4fSBDb25jYXRlbmF0ZWQgbWF0cml4XG4gICAqL1xuICBtYXRoLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAoYXJncykge1xuICAgIHZhciBpLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBkaW0gPSAtMSwgIC8vIHplcm8tYmFzZWQgZGltZW5zaW9uXG4gICAgICAgIHByZXZEaW0sXG4gICAgICAgIGFzTWF0cml4ID0gZmFsc2UsXG4gICAgICAgIG1hdHJpY2VzID0gW107ICAvLyBjb250YWlucyBtdWx0aSBkaW1lbnNpb25hbCBhcnJheXNcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgLy8gdGVzdCB3aGV0aGVyIHdlIG5lZWQgdG8gcmV0dXJuIGEgTWF0cml4IChpZiBub3Qgd2UgcmV0dXJuIGFuIEFycmF5KVxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICBhc01hdHJpeCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoaSA9PSBsZW4gLSAxKSAmJiAoaXNOdW1iZXIoYXJnKSB8fCBhcmcgaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSB7XG4gICAgICAgIC8vIGxhc3QgYXJndW1lbnQgY29udGFpbnMgdGhlIGRpbWVuc2lvbiBvbiB3aGljaCB0byBjb25jYXRlbmF0ZVxuICAgICAgICBwcmV2RGltID0gZGltO1xuICAgICAgICBkaW0gPSBhcmcudmFsdWVPZigpOyAvLyBjaGFuZ2UgYmlnbnVtYmVyIHRvIG51bWJlclxuXG4gICAgICAgIGlmICghaXNJbnRlZ2VyKGRpbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnRlZ2VyIG51bWJlciBleHBlY3RlZCBmb3IgZGltZW5zaW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGltIDwgMCkge1xuICAgICAgICAgIC8vIFRPRE86IHdvdWxkIGJlIG1vcmUgY2xlYXIgd2hlbiB0aHJvd2luZyBhIERpbWVuc2lvbkVycm9yIGhlcmVcbiAgICAgICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5JbmRleEVycm9yKGRpbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwICYmIGRpbSA+IHByZXZEaW0pIHtcbiAgICAgICAgICAvLyBUT0RPOiB3b3VsZCBiZSBtb3JlIGNsZWFyIHdoZW4gdGhyb3dpbmcgYSBEaW1lbnNpb25FcnJvciBoZXJlXG4gICAgICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuSW5kZXhFcnJvcihkaW0sIHByZXZEaW0gKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uKGFyZykpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIG1hdHJpeCBvciBhcnJheVxuICAgICAgICB2YXIgbWF0cml4ID0gb2JqZWN0LmNsb25lKGFyZykudmFsdWVPZigpO1xuICAgICAgICB2YXIgc2l6ZSA9IGFycmF5LnNpemUoYXJnLnZhbHVlT2YoKSk7XG4gICAgICAgIG1hdHJpY2VzW2ldID0gbWF0cml4O1xuICAgICAgICBwcmV2RGltID0gZGltO1xuICAgICAgICBkaW0gPSBzaXplLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgLy8gdmVyaWZ5IHdoZXRoZXIgZWFjaCBvZiB0aGUgbWF0cmljZXMgaGFzIHRoZSBzYW1lIG51bWJlciBvZiBkaW1lbnNpb25zXG4gICAgICAgIGlmIChpID4gMCAmJiBkaW0gIT0gcHJldkRpbSkge1xuICAgICAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLkRpbWVuc2lvbkVycm9yKHByZXZEaW0gKyAxLCBkaW0gKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBtYXRoLmVycm9yLlVuc3VwcG9ydGVkVHlwZUVycm9yKCdjb25jYXQnLCBtYXRoWyd0eXBlb2YnXShhcmcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0cmljZXMubGVuZ3RoID09IDApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQXQgbGVhc3Qgb25lIG1hdHJpeCBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSBtYXRyaWNlcy5zaGlmdCgpO1xuICAgIHdoaWxlIChtYXRyaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJlcyA9IF9jb25jYXQocmVzLCBtYXRyaWNlcy5zaGlmdCgpLCBkaW0sIDApO1xuICAgIH1cblxuICAgIHJldHVybiBhc01hdHJpeCA/IG5ldyBNYXRyaXgocmVzKSA6IHJlcztcbiAgfTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgY29uY2F0ZW5hdGUgdHdvIG1hdHJpY2VzLlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIG1hdHJpY2VzIGlzIG5vdCBjbG9uZWQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGEgICAgICAgICAgICAgTXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYiAgICAgICAgICAgICBNdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uY2F0RGltICAgIFRoZSBkaW1lbnNpb24gb24gd2hpY2ggdG8gY29uY2F0ZW5hdGUgKHplcm8tYmFzZWQpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaW0gICAgICAgICAgVGhlIGN1cnJlbnQgZGltICh6ZXJvLWJhc2VkKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gYyAgICAgICAgICAgIFRoZSBjb25jYXRlbmF0ZWQgbWF0cml4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfY29uY2F0KGEsIGIsIGNvbmNhdERpbSwgZGltKSB7XG4gICAgaWYgKGRpbSA8IGNvbmNhdERpbSkge1xuICAgICAgLy8gcmVjdXJzZSBpbnRvIG5leHQgZGltZW5zaW9uXG4gICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuRGltZW5zaW9uRXJyb3IoYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjW2ldID0gX2NvbmNhdChhW2ldLCBiW2ldLCBjb25jYXREaW0sIGRpbSArIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gY29uY2F0ZW5hdGUgdGhpcyBkaW1lbnNpb25cbiAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdkZWNpbWFsLmpzJyk7XG52YXIgZXJyb3JUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2Vycm9yLnRyYW5zZm9ybScpLnRyYW5zZm9ybTtcbnZhciBpc051bWJlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJykuaXNOdW1iZXI7XG52YXIgYXJnc1RvQXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlsL2FycmF5JykuYXJnc1RvQXJyYXk7XG5cbi8qKlxuICogQXR0YWNoIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIG1hdGgucmFuZ2VcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0cmFuc2Zvcm0gY29udGFpbmluZyB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgdHJhbnNmb3JtIGNoYW5nZWQgdGhlIGxhc3QgYGRpbWAgcGFyYW1ldGVyIG9mIGZ1bmN0aW9uIGNvbmNhdFxuICogZnJvbSBvbmUtYmFzZWQgdG8gemVybyBiYXNlZFxuICogQHBhcmFtIHtPYmplY3R9IG1hdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICBtYXRoLmNvbmNhdC50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY29weSBhcmd1bWVudHMgaW50byBhbiBhcnJheVxuICAgIHZhciBhcmdzID0gYXJnc1RvQXJyYXkoYXJndW1lbnRzKTtcblxuICAgIC8vIGNoYW5nZSBsYXN0IGFyZ3VtZW50IGZyb20gb25lLWJhc2VkIHRvIHplcm8tYmFzZWRcbiAgICB2YXIgbGFzdEluZGV4ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHZhciBsYXN0ID0gYXJnc1tsYXN0SW5kZXhdO1xuICAgIGlmIChpc051bWJlcihsYXN0KSkge1xuICAgICAgYXJnc1tsYXN0SW5kZXhdID0gbGFzdCAtIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxhc3QgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgIGFyZ3NbbGFzdEluZGV4XSA9IGxhc3QubWludXMoMSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtYXRoLmNvbmNhdC5hcHBseShtYXRoLCBhcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgZXJyb3JUcmFuc2Zvcm0oZXJyKTtcbiAgICB9XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmlnTnVtYmVyID0gcmVxdWlyZSgnZGVjaW1hbC5qcycpO1xudmFyIFJhbmdlID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9SYW5nZScpO1xudmFyIEluZGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9JbmRleCcpO1xudmFyIE1hdHJpeCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvTWF0cml4Jyk7XG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpLmlzTnVtYmVyO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLmluZGV4XG4gKiBBZGRzIGEgcHJvcGVydHkgdHJhbnNmb3JtIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIHRyYW5zZm9ybSBjcmVhdGVzIGEgb25lLWJhc2VkIGluZGV4IGluc3RlYWQgb2YgYSB6ZXJvLWJhc2VkIGluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gbWF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIG1hdGguaW5kZXgudHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIC8vIGNoYW5nZSBmcm9tIG9uZS1iYXNlZCB0byB6ZXJvIGJhc2VkLCBhbmQgY29udmVydCBCaWdOdW1iZXIgdG8gbnVtYmVyXG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICAgICAgYXJnLnN0YXJ0LS07XG4gICAgICAgIGFyZy5lbmQgLT0gKGFyZy5zdGVwID4gMCA/IDAgOiAyKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKGFyZykpIHtcbiAgICAgICAgYXJnLS07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgYXJnID0gYXJnLnRvTnVtYmVyKCkgLSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JhbmdlcyBtdXN0IGJlIGEgTnVtYmVyIG9yIFJhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIGFyZ3NbaV0gPSBhcmc7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IG5ldyBJbmRleCgpO1xuICAgIEluZGV4LmFwcGx5KHJlcywgYXJncyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNYXRyaXggPSByZXF1aXJlKCcuLi8uLi90eXBlL01hdHJpeCcpO1xudmFyIEJpZ051bWJlciA9IHJlcXVpcmUoJ2RlY2ltYWwuanMnKTtcbnZhciBSYW5nZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvUmFuZ2UnKTtcbnZhciBJbmRleCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvSW5kZXgnKTtcbnZhciBpc051bWJlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJykuaXNOdW1iZXI7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQXR0YWNoIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIG1hdGguZm9yRWFjaFxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gY3JlYXRlcyBhIG9uZS1iYXNlZCBpbmRleCBpbnN0ZWFkIG9mIGEgemVyby1iYXNlZCBpbmRleFxuICogQHBhcmFtIHtPYmplY3R9IG1hdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICBtYXRoLmZvckVhY2gudHJhbnNmb3JtID0gZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikge1xuICAgICAgdGhyb3cgbmV3IG1hdGguZXJyb3IuQXJndW1lbnRzRXJyb3IoJ2ZvckVhY2gnLCBhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlJbiA9IHggaW5zdGFuY2VvZiBNYXRyaXggPyB4LnZhbHVlT2YoKSA6IHg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlJbikpIHtcbiAgICAgIHZhciBpbmRleCA9IFtdO1xuXG4gICAgICB2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGltKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgICAgICBpbmRleFtkaW1dID0gaSArIDE7IC8vIG9uZS1iYXNlZCBpbmRleCFcbiAgICAgICAgICAgIHJldHVybiByZWN1cnNlKGNoaWxkLCBkaW0gKyAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIHgpOyAvLyBOb3RlOiBwYXNzIHRoZSBvcmlnaW5hbCBtYXRyaXggaGVyZVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZWN1cnNlKGFycmF5SW4sIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignZm9yRWFjaCcsIG1hdGhbJ3R5cGVvZiddKHgpKTtcbiAgICB9XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWF0cml4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9NYXRyaXgnKTtcbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdkZWNpbWFsLmpzJyk7XG52YXIgUmFuZ2UgPSByZXF1aXJlKCcuLi8uLi90eXBlL1JhbmdlJyk7XG52YXIgSW5kZXggPSByZXF1aXJlKCcuLi8uLi90eXBlL0luZGV4Jyk7XG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpLmlzTnVtYmVyO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLm1hcFxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gY3JlYXRlcyBhIG9uZS1iYXNlZCBpbmRleCBpbnN0ZWFkIG9mIGEgemVyby1iYXNlZCBpbmRleFxuICogQHBhcmFtIHtPYmplY3R9IG1hdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICBtYXRoLm1hcC50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5Bcmd1bWVudHNFcnJvcignbWFwJywgYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuXG4gICAgdmFyIGFzTWF0cml4ID0geCBpbnN0YW5jZW9mIE1hdHJpeDtcbiAgICB2YXIgYXJyYXlJbiA9IGFzTWF0cml4ID8geC52YWx1ZU9mKCkgOiB4O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5SW4pKSB7XG4gICAgICB2YXIgaW5kZXggPSBbXTtcblxuICAgICAgdmFyIHJlY3Vyc2UgPSBmdW5jdGlvbiAodmFsdWUsIGRpbSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICAgICAgaW5kZXhbZGltXSA9IGkgKyAxOyAvLyBvbmUtYmFzZWQgaW5kZXghXG4gICAgICAgICAgICByZXR1cm4gcmVjdXJzZShjaGlsZCwgZGltICsgMSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgeCk7IC8vIE5vdGU6IHBhc3MgdGhlIG9yaWdpbmFsIG1hdHJpeCBoZXJlXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciByZXMgPSByZWN1cnNlKGFycmF5SW4sIDApO1xuICAgICAgcmV0dXJuIGFzTWF0cml4ID8gbmV3IE1hdHJpeChyZXMpIDogcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgbWF0aC5lcnJvci5VbnN1cHBvcnRlZFR5cGVFcnJvcignbWFwJywgbWF0aFsndHlwZW9mJ10oeCkpO1xuICAgIH1cbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdkZWNpbWFsLmpzJyk7XG52YXIgZXJyb3JUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2Vycm9yLnRyYW5zZm9ybScpLnRyYW5zZm9ybTtcbnZhciBpc051bWJlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJykuaXNOdW1iZXI7XG52YXIgaXNDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9jb2xsZWN0aW9uJykuaXNDb2xsZWN0aW9uO1xudmFyIGFyZ3NUb0FycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9hcnJheScpLmFyZ3NUb0FycmF5O1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLm1heFxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gY2hhbmdlZCB0aGUgbGFzdCBgZGltYCBwYXJhbWV0ZXIgb2YgZnVuY3Rpb24gbWF4XG4gKiBmcm9tIG9uZS1iYXNlZCB0byB6ZXJvIGJhc2VkXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gIG1hdGgubWF4LnRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3NUb0FycmF5KGFyZ3VtZW50cyk7XG5cbiAgICAvLyBjaGFuZ2UgbGFzdCBhcmd1bWVudCBkaW0gZnJvbSBvbmUtYmFzZWQgdG8gemVyby1iYXNlZFxuICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyICYmIGlzQ29sbGVjdGlvbihhcmdzWzBdKSkge1xuICAgICAgdmFyIGRpbSA9IGFyZ3NbMV07XG4gICAgICBpZiAoaXNOdW1iZXIoZGltKSkge1xuICAgICAgICBhcmdzWzFdID0gZGltIC0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGRpbSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICBhcmdzWzFdID0gZGltLm1pbnVzKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbWF0aC5tYXguYXBwbHkobWF0aCwgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycm9yVHJhbnNmb3JtKGVycik7XG4gICAgfVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJpZ051bWJlciA9IHJlcXVpcmUoJ2RlY2ltYWwuanMnKTtcbnZhciBlcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZXJyb3IudHJhbnNmb3JtJykudHJhbnNmb3JtO1xudmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKS5pc051bWJlcjtcbnZhciBpc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKS5pc0NvbGxlY3Rpb247XG52YXIgYXJnc1RvQXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlsL2FycmF5JykuYXJnc1RvQXJyYXk7XG5cbi8qKlxuICogQXR0YWNoIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIG1hdGgubWVhblxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gY2hhbmdlZCB0aGUgbGFzdCBgZGltYCBwYXJhbWV0ZXIgb2YgZnVuY3Rpb24gbWVhblxuICogZnJvbSBvbmUtYmFzZWQgdG8gemVybyBiYXNlZFxuICogQHBhcmFtIHtPYmplY3R9IG1hdGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuICBtYXRoLm1lYW4udHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJnc1RvQXJyYXkoYXJndW1lbnRzKTtcblxuICAgIC8vIGNoYW5nZSBsYXN0IGFyZ3VtZW50IGRpbSBmcm9tIG9uZS1iYXNlZCB0byB6ZXJvLWJhc2VkXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09IDIgJiYgaXNDb2xsZWN0aW9uKGFyZ3NbMF0pKSB7XG4gICAgICB2YXIgZGltID0gYXJnc1sxXTtcbiAgICAgIGlmIChpc051bWJlcihkaW0pKSB7XG4gICAgICAgIGFyZ3NbMV0gPSBkaW0gLSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZGltIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIGFyZ3NbMV0gPSBkaW0ubWludXMoMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtYXRoLm1lYW4uYXBwbHkobWF0aCwgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycm9yVHJhbnNmb3JtKGVycik7XG4gICAgfVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJpZ051bWJlciA9IHJlcXVpcmUoJ2RlY2ltYWwuanMnKTtcbnZhciBlcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZXJyb3IudHJhbnNmb3JtJykudHJhbnNmb3JtO1xudmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKS5pc051bWJlcjtcbnZhciBpc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi90eXBlL2NvbGxlY3Rpb24nKS5pc0NvbGxlY3Rpb247XG52YXIgYXJnc1RvQXJyYXkgPSByZXF1aXJlKCcuLi8uLi91dGlsL2FycmF5JykuYXJnc1RvQXJyYXk7XG5cbi8qKlxuICogQXR0YWNoIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIG1hdGgubWluXG4gKiBBZGRzIGEgcHJvcGVydHkgdHJhbnNmb3JtIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIHRyYW5zZm9ybSBjaGFuZ2VkIHRoZSBsYXN0IGBkaW1gIHBhcmFtZXRlciBvZiBmdW5jdGlvbiBtaW5cbiAqIGZyb20gb25lLWJhc2VkIHRvIHplcm8gYmFzZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgbWF0aC5taW4udHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJnc1RvQXJyYXkoYXJndW1lbnRzKTtcblxuICAgIC8vIGNoYW5nZSBsYXN0IGFyZ3VtZW50IGRpbSBmcm9tIG9uZS1iYXNlZCB0byB6ZXJvLWJhc2VkXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09IDIgJiYgaXNDb2xsZWN0aW9uKGFyZ3NbMF0pKSB7XG4gICAgICB2YXIgZGltID0gYXJnc1sxXTtcbiAgICAgIGlmIChpc051bWJlcihkaW0pKSB7XG4gICAgICAgIGFyZ3NbMV0gPSBkaW0gLSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZGltIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgIGFyZ3NbMV0gPSBkaW0ubWludXMoMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtYXRoLm1pbi5hcHBseShtYXRoLCBhcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgZXJyb3JUcmFuc2Zvcm0oZXJyKTtcbiAgICB9XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXJyYXlOb2RlID0gcmVxdWlyZSgnLi4vZXhwcmVzc2lvbi9ub2RlL0FycmF5Tm9kZScpLFxuICAgIE9wZXJhdG9yTm9kZSA9IHJlcXVpcmUoJy4uL2V4cHJlc3Npb24vbm9kZS9PcGVyYXRvck5vZGUnKTtcblxuLy8gR1JFRUsgTEVUVEVSU1xudmFyIGdyZWVrID0ge1xuICBBbHBoYTogJ0EnLCAgICAgYWxwaGE6IHRydWUsXG4gIEJldGE6ICdCJywgICAgICBiZXRhOiB0cnVlLFxuICBHYW1tYTogdHJ1ZSwgICAgZ2FtbWE6IHRydWUsXG4gIERlbHRhOiB0cnVlLCAgICBkZWx0YTogdHJ1ZSxcbiAgRXBzaWxvbjogJ0UnLCAgIGVwc2lsb246IHRydWUsICB2YXJlcHNpbG9uOiB0cnVlLFxuICBaZXRhOiAnWicsICAgICAgemV0YTogdHJ1ZSxcbiAgRXRhOiAnSCcsICAgICAgIGV0YTogdHJ1ZSxcbiAgVGhldGE6IHRydWUsICAgIHRoZXRhOiB0cnVlLCAgICB2YXJ0aGV0YTogdHJ1ZSxcbiAgSW90YTogJ0knLCAgICAgIGlvdGE6IHRydWUsXG4gIEthcHBhOiAnSycsICAgICBrYXBwYTogdHJ1ZSwgICAgdmFya2FwcGE6IHRydWUsXG4gIExhbWJkYTogdHJ1ZSwgICBsYW1iZGE6IHRydWUsXG4gIE11OiAnTScsICAgICAgICBtdTogdHJ1ZSxcbiAgTnU6ICdOJywgICAgICAgIG51OiB0cnVlLFxuICBYaTogdHJ1ZSwgICAgICAgeGk6IHRydWUsXG4gIE9taWNyb246ICdPJywgICBvbWljcm9uOiB0cnVlLFxuICBQaTogdHJ1ZSwgICAgICAgcGk6IHRydWUsICAgICAgIHZhcnBpOiB0cnVlLFxuICBSaG86ICdQJywgICAgICAgcmhvOiB0cnVlLCAgICAgIHZhcnJobzogdHJ1ZSxcbiAgU2lnbWE6IHRydWUsICAgIHNpZ21hOiB0cnVlLCAgICB2YXJzaWdtYTogdHJ1ZSxcbiAgVGF1OiAnVCcsICAgICAgIHRhdTogdHJ1ZSxcbiAgVXBzaWxvbjogdHJ1ZSwgIHVwc2lsb246IHRydWUsXG4gIFBoaTogdHJ1ZSwgICAgICBwaGk6IHRydWUsICAgICAgdmFycGhpOiB0cnVlLFxuICBDaGk6ICdYJywgICAgICAgY2hpOiB0cnVlLFxuICBQc2k6IHRydWUsICAgICAgcHNpOiB0cnVlLFxuICBPbWVnYTogdHJ1ZSwgICAgb21lZ2E6IHRydWVcbn07XG5cbnZhciBkb3RzID0ge1xuICBkb3RzOiB0cnVlLFxuICBsZG90czogdHJ1ZSxcbiAgY2RvdHM6IHRydWUsXG4gIHZkb3RzOiB0cnVlLFxuICBkZG90czogdHJ1ZSxcbiAgaWRvdHM6IHRydWVcbn07XG5cbnZhciBsb2dpYyA9IHtcbiAgJ3RydWUnOiAnXFxcXG1hdGhybXtUcnVlfScsXG4gICdmYWxzZSc6ICdcXFxcbWF0aHJte0ZhbHNlfSdcbn07XG5cbnZhciBvdGhlciA9IHtcbiAgaW5mOiAnXFxcXGluZnR5JyxcbiAgSW5mOiAnXFxcXGluZnR5JyxcbiAgaW5maW5pdHk6ICdcXFxcaW5mdHknLFxuICBJbmZpbml0eTogJ1xcXFxpbmZ0eScsXG4gIG9vOiAnXFxcXGluZnR5JyxcbiAgbGltOiB0cnVlLFxuICAndW5kZWZpbmVkJzogJ1xcXFxtYXRoYmZ7P30nXG59O1xuXG4vLyBGVU5DVElPTlNcbnZhciBmdW5jdGlvbnMgPSB7XG4gIGFjb3M6ICdcXFxcY29zXnstMX0nLFxuICBhcmNjb3M6ICdcXFxcY29zXnstMX0nLFxuICBjb3M6IHRydWUsXG4gIGNzYzogdHJ1ZSxcbiAgY3NjaDogZmFsc2UsXG4gIGV4cDogdHJ1ZSxcbiAga2VyOiB0cnVlLFxuICBsaW1zdXA6IHRydWUsXG4gIG1pbjogdHJ1ZSxcbiAgc2luaDogdHJ1ZSxcbiAgYXNpbjogJ1xcXFxzaW5eey0xfScsXG4gIGFyY3NpbjogJ1xcXFxzaW5eey0xfScsXG4gIGNvc2g6IHRydWUsXG4gIGRlZzogdHJ1ZSxcbiAgZ2NkOiB0cnVlLFxuICBsZzogdHJ1ZSxcbiAgbG46IHRydWUsXG4gIFByOiB0cnVlLFxuICBzdXA6IHRydWUsXG4gIGF0YW46ICdcXFxcdGFuXnstMX0nLFxuICBhdGFuMjogJ1xcXFx0YW4yXnstMX0nLFxuICBhcmN0YW46ICdcXFxcdGFuXnstMX0nLFxuICBjb3Q6IHRydWUsXG4gIGRldDogdHJ1ZSxcbiAgaG9tOiB0cnVlLFxuICBsb2c6IHRydWUsXG4gIGxvZzEwOiAnXFxcXGxvZ197MTB9JyxcbiAgc2VjOiB0cnVlLFxuICBzZWNoOiBmYWxzZSxcbiAgdGFuOiB0cnVlLFxuICBhcmc6IHRydWUsXG4gIGNvdGg6IHRydWUsXG4gIGRpbTogdHJ1ZSxcbiAgaW5mOiB0cnVlLFxuICBtYXg6IHRydWUsXG4gIHNpbjogdHJ1ZSxcbiAgdGFuaDogdHJ1ZSxcblxuICBmaXg6IGZhbHNlLFxuICBsY206IGZhbHNlLFxuICBzaWduOiBmYWxzZSxcbiAgeGdjZDogZmFsc2UsXG4gIHVuYXJ5TWludXM6IGZhbHNlLFxuICB1bmFyeVBsdXM6IGZhbHNlLFxuXG4gIC8vIGNvbXBsZXhcbiAgY29tcGxleDogZmFsc2UsXG4gIGNvbmo6IGZhbHNlLFxuICBpbTogZmFsc2UsXG4gIHJlOiBmYWxzZSxcblxuICAvLyBtYXRyaXhcbiAgZGlhZzogZmFsc2UsXG4gIHJlc2l6ZTogZmFsc2UsXG4gIHNpemU6IGZhbHNlLFxuICBzcXVlZXplOiBmYWxzZSxcbiAgc3Vic2V0OiBmYWxzZSxcbiAgaW5kZXg6IGZhbHNlLFxuICBvbmVzOiBmYWxzZSxcbiAgemVyb3M6IGZhbHNlLFxuICByYW5nZTogZmFsc2UsXG5cbiAgLy8gcHJvYmFiaWxpdHlcbiAgcmFuZG9tOiBmYWxzZSxcblxuICAvLyBzdGF0aXN0aWNzXG4gIG1lYW46ICdcXFxcbXUnLFxuICBtZWRpYW46IGZhbHNlLFxuICBwcm9kOiBmYWxzZSxcbiAgc3RkOiAnXFxcXHNpZ21hJyxcbiAgJ3Zhcic6ICdcXFxcc2lnbWFeMidcbn07XG5cbi8vIENVUkxZIEZVTkNUSU9OU1xuLy8gd3JhcCBwYXJhbWV0ZXJzIHdpdGgge31cbnZhciBjdXJseUZ1bmN0aW9ucyA9IHtcbiAgc3FydDogdHJ1ZSxcbiAgaW52OiB0cnVlLFxuICBpbnQ6ICdcXFxcaW50JyxcbiAgSW50OiAnXFxcXGludCcsXG4gIGludGVncmF0ZTogJ1xcXFxpbnQnLFxuICBlaWdlbnZhbHVlczogJ1xcXFxsYW1iZGEnLFxuICBsaW1pbmY6IHRydWUsXG4gIGxpbTogdHJ1ZSxcbiAgZXhwOiAnZV4nLFxuICBzdW06IHRydWUsXG5cbiAgZXllOiAnXFxcXG1hdGhiZntJfSdcbn07XG5cbnZhciBvcGVyYXRvcnMgPSB7XG4gICc8PSc6ICdcXFxcbGVxJyxcbiAgJz49JzogJ1xcXFxnZXEnLFxuICAnIT0nOiAnXFxcXG5lcScsXG4gICdpbic6IHRydWUsXG4gICcqJzogJ1xcXFxjZG90JyxcbiAgJy8nOiAnXFxcXGZyYWMnLFxuICAnbW9kJzogJ1xcXFxibW9kJyxcbiAgJ3RvJzogJ1xcXFxyaWdodGFycm93J1xufTtcblxudmFyIHVuaXRzID0ge1xuICBkZWc6ICdee1xcXFxjaXJjfSdcbn07XG5cbnZhciBzeW1ib2xzID0ge307XG5cbmZ1bmN0aW9uIG1hcFN5bWJvbHMoKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgIG9iajtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvYmogPSBhcmdzW2ldO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBzeW1ib2xzW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubWFwU3ltYm9scyhcbiAgZnVuY3Rpb25zLFxuICBjdXJseUZ1bmN0aW9ucyxcbiAgZ3JlZWssXG4gIGRvdHMsXG4gIGxvZ2ljLFxuICBvdGhlclxuKTtcblxuZnVuY3Rpb24gbGF0ZXhJcyhhcnIsIHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgYXJyW3ZhbHVlXSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIGxhdGV4SXNGbihhcnIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGxhdGV4SXMoYXJyLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGxhdGV4VG9GbihhcnIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBhcnJbdmFsdWVdID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGlmIChhcnJbdmFsdWVdID09PSB0cnVlKSB7XG4gICAgICAgIHZhbHVlID0gJ1xcXFwnICsgdmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSAnXFxcXG1hdGhybXsnICsgdmFsdWUgKyAnfSc7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhcnJbdmFsdWVdID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBhcnJbdmFsdWVdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgaW5kZXggPSB2YWx1ZS5pbmRleE9mKCdfJyk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHZhbHVlID0gZXhwb3J0cy50b1N5bWJvbCh2YWx1ZS5zdWJzdHJpbmcoMCwgaW5kZXgpKSArICdfeycgK1xuICAgICAgICAgICAgZXhwb3J0cy50b1N5bWJvbCh2YWx1ZS5zdWJzdHJpbmcoaW5kZXgrMSkpICsgJ30nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0cy5pc1N5bWJvbCA9IGxhdGV4SXNGbihzeW1ib2xzKTtcbmV4cG9ydHMudG9TeW1ib2wgPSBsYXRleFRvRm4oc3ltYm9scyk7XG5cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGxhdGV4SXNGbihmdW5jdGlvbnMpO1xuZXhwb3J0cy50b0Z1bmN0aW9uID0gbGF0ZXhUb0ZuKGZ1bmN0aW9ucyk7XG5cbmV4cG9ydHMuaXNDdXJseUZ1bmN0aW9uID0gbGF0ZXhJc0ZuKGN1cmx5RnVuY3Rpb25zKTtcbmV4cG9ydHMudG9DdXJseUZ1bmN0aW9uID0gbGF0ZXhUb0ZuKGN1cmx5RnVuY3Rpb25zKTtcblxuZXhwb3J0cy5pc09wZXJhdG9yID0gbGF0ZXhJc0ZuKG9wZXJhdG9ycyk7XG5leHBvcnRzLnRvT3BlcmF0b3IgPSBsYXRleFRvRm4ob3BlcmF0b3JzKTtcblxuZXhwb3J0cy5pc1VuaXQgPSBsYXRleElzRm4odW5pdHMpO1xuZXhwb3J0cy50b1VuaXQgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBfdG9Vbml0ID0gbGF0ZXhUb0ZuKHVuaXRzKTtcblxuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG5vdFNwYWNlZCkge1xuICAgIGlmIChleHBvcnRzLmlzVW5pdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBfdG9Vbml0KHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKG5vdFNwYWNlZCA/ICcnIDogJ1xcXFwsJykgKyAnXFxcXG1hdGhybXsnICsgdmFsdWUgKyAnfSc7XG4gIH07XG59KCkpO1xuXG5leHBvcnRzLmFkZEJyYWNlcyA9IGZ1bmN0aW9uKHMsIGJyYWNlLCB0eXBlKSB7XG4gIGlmIChicmFjZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgdmFyIGJyYWNlcyA9IFsnJywgJyddO1xuICB0eXBlID0gdHlwZSB8fCAnbm9ybWFsJztcblxuICBpZiAodHlwZW9mIGJyYWNlID09PSAndW5kZWZpbmVkJyB8fCBicmFjZSA9PT0gZmFsc2UpIHtcbiAgICBicmFjZXMgPSBbJ3snLCAnfSddO1xuICB9XG4gIGVsc2UgaWYgKGJyYWNlID09PSB0cnVlKSB7XG4gICAgYnJhY2VzID0gWycoJywgJyknXTtcbiAgICB0eXBlID0gJ2xyJztcbiAgfVxuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJyYWNlKSAmJiBicmFjZS5sZW5ndGggPT09IDIpIHtcbiAgICBicmFjZXMgPSBicmFjZTtcbiAgfVxuICBlbHNlIHtcbiAgICBicmFjZXMgPSBbYnJhY2UsIGJyYWNlXTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgY2FzZSBmYWxzZTpcbiAgICAgIHJldHVybiBicmFjZXNbMF0gKyBzICsgYnJhY2VzWzFdO1xuXG4gICAgY2FzZSAnbHInOlxuICAgICAgcmV0dXJuICdcXFxcbGVmdCcgKyBicmFjZXNbMF0gKyAneycgKyBzICsgJ30nICsgJ1xcXFxyaWdodCcgKyBicmFjZXNbMV07XG5cbiAgICBjYXNlICdiZSc6XG4gICAgICByZXR1cm4gJ1xcXFxiZWdpbnsnICsgYnJhY2VzWzBdICsgJ30nICsgcyArICdcXFxcZW5keycgKyBicmFjZXNbMV0gKyAnfSc7XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgcyArIGJyYWNlc1sxXTtcbn07XG5cbmV4cG9ydHMudG9QYXJhbXMgPSBmdW5jdGlvbih0aGF0KSB7XG4gIHZhciBzeW1ib2wgPSB0aGF0LnN5bWJvbCxcbiAgICAgIHBhcmFtcyA9IHRoYXQucGFyYW1zLFxuICAgICAgZnVuYyA9IHN5bWJvbC50b1RleCgpLFxuICAgICAgdGV4UGFyYW1zID0gbnVsbCxcbiAgICAgIGJyYWNlID0gbnVsbCxcbiAgICAgIHR5cGUgPSBmYWxzZSxcbiAgICAgIHNob3dGdW5jID0gZmFsc2UsXG4gICAgICBwcmVmaXggPSAnJyxcbiAgICAgIHN1ZmZpeCA9ICcnLFxuICAgICAgb3AgPSBudWxsO1xuXG4gIHN3aXRjaCAoc3ltYm9sLm5hbWUpIHtcbiAgICAvLyBPUEVSQVRPUlNcbiAgICBjYXNlICdhZGQnOlxuICAgICAgb3AgPSAnKyc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3N1YnRyYWN0JzpcbiAgICAgIG9wID0gJy0nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdsYXJnZXInOlxuICAgICAgb3AgPSAnPic7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2xhcmdlckVxJzpcbiAgICAgIG9wID0gJz49JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc21hbGxlcic6XG4gICAgICBvcCA9ICc8JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc21hbGxlckVxJzpcbiAgICAgIG9wID0gJzw9JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndW5lcXVhbCc6XG4gICAgICBvcCA9ICchPSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2VxdWFsJzpcbiAgICAgIG9wID0gJz0nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtb2QnOlxuICAgICAgb3AgPSAnbW9kJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgb3AgPSAnKic7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Bvdyc6XG4gICAgICBvcCA9ICdeJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY29uY2F0JzpcbiAgICAgIG9wID0gJ3x8JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZmFjdG9yaWFsJzpcbiAgICAgIG9wID0gJyEnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwZXJtdXRhdGlvbnMnOlxuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgb3AgPSAnISc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gb3AgPSAnUCc7XG4gICAgICAgIHZhciBuID0gcGFyYW1zWzBdLnRvVGV4KCksXG4gICAgICAgICAgICBrID0gcGFyYW1zWzFdLnRvVGV4KCk7XG4gICAgICAgIHJldHVybiAnXFxcXGZyYWN7JyArIG4gKyAnIX17XFxcXGxlZnQoJyArIG4gKyAnIC0gJyArIGsgKyAnXFxcXHJpZ2h0KSF9JztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gcHJvYmFiaWxpdHlcbiAgICBjYXNlICdjb21iaW5hdGlvbnMnOlxuICAgICAgb3AgPSAnXFxcXGNob29zZSc7XG4gICAgICBicmVhaztcblxuICAgIC8vIExSIEJSQUNFU1xuICAgIGNhc2UgJ2Ficyc6XG4gICAgICBicmFjZSA9ICd8JztcbiAgICAgIHR5cGUgPSAnbHInO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdub3JtJzpcbiAgICAgIGJyYWNlID0gJ1xcXFx8JztcbiAgICAgIHR5cGUgPSAnbHInO1xuXG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YXIgdG1wID0gcGFyYW1zWzFdLnRvVGV4KCk7XG5cbiAgICAgICAgaWYgKHRtcCA9PT0gJ1xcXFx0ZXh0e2luZn0nKSB7XG4gICAgICAgICAgdG1wID0gJ1xcXFxpbmZ0eSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG1wID09PSAnXFxcXHRleHR7LWluZn0nKSB7XG4gICAgICAgICAgdG1wID0gJ3stIFxcXFxpbmZ0eX0nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRtcCA9PT0gJ1xcXFx0ZXh0e2Zyb30nKSB7XG4gICAgICAgICAgdG1wID0gJ0YnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VmZml4ID0gJ197JyArIHRtcCArICd9JztcbiAgICAgICAgcGFyYW1zID0gW3BhcmFtc1swXV07XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2NlaWwnOlxuICAgICAgYnJhY2UgPSBbJ1xcXFxsY2VpbCcsICdcXFxccmNlaWwnXTtcbiAgICAgIHR5cGUgPSAnbHInO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdmbG9vcic6XG4gICAgICBicmFjZSA9IFsnXFxcXGxmbG9vcicsICdcXFxccmZsb29yJ107XG4gICAgICB0eXBlID0gJ2xyJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncm91bmQnOlxuICAgICAgYnJhY2UgPSBbJ1xcXFxsZmxvb3InLCAnXFxcXHJjZWlsJ107XG4gICAgICB0eXBlID0gJ2xyJztcblxuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgc3VmZml4ID0gJ18nICsgZXhwb3J0cy5hZGRCcmFjZXMocGFyYW1zWzFdLnRvVGV4KCkpO1xuICAgICAgICBwYXJhbXMgPSBbcGFyYW1zWzBdXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG5cbiAgICAvLyBOT1JNQUwgQlJBQ0VTXG4gICAgY2FzZSAnaW52JzpcbiAgICAgIHN1ZmZpeCA9ICdeey0xfSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RyYW5zcG9zZSc6XG4gICAgICBzdWZmaXggPSAnXntUfSc7XG4gICAgICBicmFjZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBTUEVDSUFMIE5PVEFUSU9OXG4gICAgY2FzZSAnbG9nJzpcbiAgICAgIHZhciBiYXNlID0gJ2UnO1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgYmFzZSA9IHBhcmFtc1sxXS50b1RleCgpO1xuICAgICAgICBmdW5jID0gJ1xcXFxsb2dfeycgKyBiYXNlICsgJ30nO1xuICAgICAgICBwYXJhbXMgPSBbcGFyYW1zWzBdXTtcbiAgICAgIH1cbiAgICAgIGlmIChiYXNlID09PSAnZScpIHtcbiAgICAgICAgZnVuYyA9ICdcXFxcbG4nO1xuICAgICAgfVxuXG4gICAgICBzaG93RnVuYyA9IHRydWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICBzdWZmaXggPSAnXnsyfSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2N1YmUnOlxuICAgICAgc3VmZml4ID0gJ157M30nO1xuICAgICAgYnJlYWs7XG5cblxuICAgIC8vIE1BVFJJQ0VTXG4gICAgY2FzZSAnZXllJzpcbiAgICAgIHNob3dGdW5jID0gdHJ1ZTtcbiAgICAgIGJyYWNlID0gZmFsc2U7XG4gICAgICBmdW5jICs9ICdfJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZGV0JzpcbiAgICAgIGlmICh0aGF0LnBhcmFtc1swXSBpbnN0YW5jZW9mIEFycmF5Tm9kZSkge1xuICAgICAgICByZXR1cm4gdGhhdC5wYXJhbXNbMF0udG9UZXgoJ3ZtYXRyaXgnKTtcbiAgICAgIH1cblxuICAgICAgYnJhY2UgPSAndm1hdHJpeCc7XG4gICAgICB0eXBlID0gJ2JlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHNob3dGdW5jID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKG9wICE9PSBudWxsKSB7XG4gICAgYnJhY2UgPSAob3AgPT09ICcrJyB8fCBvcCA9PT0gJy0nKTtcbiAgICB0ZXhQYXJhbXMgPSAobmV3IE9wZXJhdG9yTm9kZShvcCwgc3ltYm9sLm5hbWUsIHBhcmFtcykpLnRvVGV4KCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgb3AgPSAnLCAnO1xuICB9XG5cbiAgaWYgKGJyYWNlID09PSBudWxsICYmICFleHBvcnRzLmlzQ3VybHlGdW5jdGlvbihzeW1ib2wubmFtZSkpIHtcbiAgICBicmFjZSA9IHRydWU7XG4gIH1cblxuICB0ZXhQYXJhbXMgPSB0ZXhQYXJhbXMgfHwgcGFyYW1zLm1hcChmdW5jdGlvbihwYXJhbSkge1xuICAgIHJldHVybiAneycgKyBwYXJhbS50b1RleCgpICsgJ30nICA7XG4gIH0pLmpvaW4ob3ApO1xuXG4gIHJldHVybiBwcmVmaXggKyAoc2hvd0Z1bmMgPyBmdW5jIDogJycpICtcbiAgICAgIGV4cG9ydHMuYWRkQnJhY2VzKHRleFBhcmFtcywgYnJhY2UsIHR5cGUpICtcbiAgICAgIHN1ZmZpeDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdkZWNpbWFsLmpzJyk7XG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuL251bWJlcicpLmlzTnVtYmVyO1xudmFyIGRpZ2l0cyA9IHJlcXVpcmUoJy4vbnVtYmVyJykuZGlnaXRzO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciB2YWx1ZSBpcyBhIEJpZ051bWJlclxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNCaWdOdW1iZXJcbiAqL1xuZXhwb3J0cy5pc0JpZ051bWJlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBCaWdOdW1iZXIpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIHRvIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBTeW50YXg6XG4gKlxuICogICAgZm9ybWF0KHZhbHVlKVxuICogICAgZm9ybWF0KHZhbHVlLCBvcHRpb25zKVxuICogICAgZm9ybWF0KHZhbHVlLCBwcmVjaXNpb24pXG4gKiAgICBmb3JtYXQodmFsdWUsIGZuKVxuICpcbiAqIFdoZXJlOlxuICpcbiAqICAgIHtOdW1iZXJ9IHZhbHVlICAgVGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICogICAge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3Qgd2l0aCBmb3JtYXR0aW5nIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBub3RhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyIG5vdGF0aW9uLiBDaG9vc2UgZnJvbTpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdmaXhlZCcgICAgICAgICAgQWx3YXlzIHVzZSByZWd1bGFyIG51bWJlciBub3RhdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgJzEyMy40MCcgYW5kICcxNDAwMDAwMCdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdleHBvbmVudGlhbCcgICAgQWx3YXlzIHVzZSBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgJzEuMjM0ZSsyJyBhbmQgJzEuNGUrNydcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdhdXRvJyAoZGVmYXVsdCkgUmVndWxhciBudW1iZXIgbm90YXRpb24gZm9yIG51bWJlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2aW5nIGFuIGFic29sdXRlIHZhbHVlIGJldHdlZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMsIGFuZCB1c2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50aWFsIG5vdGF0aW9uIGVsc2V3aGVyZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTG93ZXIgYm91bmQgaXMgaW5jbHVkZWQsIHVwcGVyIGJvdW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGV4Y2x1ZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSAnMTIzLjQnIGFuZCAnMS40ZTcnLlxuICogICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBwcmVjaXNpb24gICBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDE2IHRvIHJvdW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBkaWdpdHMgb2YgdGhlIG51bWJlci5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gY2FzZSBvZiBub3RhdGlvbnMgJ2V4cG9uZW50aWFsJyBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG8nLCBgcHJlY2lzaW9uYCBkZWZpbmVzIHRoZSB0b3RhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIHJldHVybmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gY2FzZSBvZiBub3RhdGlvbiAnZml4ZWQnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgcHJlY2lzaW9uYCBkZWZpbmVzIHRoZSBudW1iZXIgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnQgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LCBhbmQgaXMgMCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBleHBvbmVudGlhbCBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcGFyYW1ldGVycyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbG93ZXIgYW5kIHtOdW1iZXJ9IHVwcGVyLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGJ5IG5vdGF0aW9uICdhdXRvJyB0byBkZXRlcm1pbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0byByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWVzIGFyZSBgbG93ZXI9MWUtM2AgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB1cHBlcj0xZTVgLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IGFwcGxpY2FibGUgZm9yIG5vdGF0aW9uIGBhdXRvYC5cbiAqICAgIHtGdW5jdGlvbn0gZm4gICAgQSBjdXN0b20gZm9ybWF0dGluZyBmdW5jdGlvbi4gQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgIGJ1aWx0LWluIG5vdGF0aW9ucy4gRnVuY3Rpb24gYGZuYCBpcyBjYWxsZWQgd2l0aCBgdmFsdWVgIGFzXG4gKiAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlciBhbmQgbXVzdCByZXR1cm4gYSBzdHJpbmcuIElzIHVzZWZ1bCBmb3IgZXhhbXBsZSB0b1xuICogICAgICAgICAgICAgICAgICAgICBmb3JtYXQgYWxsIHZhbHVlcyBpbnNpZGUgYSBtYXRyaXggaW4gYSBwYXJ0aWN1bGFyIHdheS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICBmb3JtYXQoNi40KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzYuNCdcbiAqICAgIGZvcm1hdCgxMjQwMDAwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnMS4yNGU2J1xuICogICAgZm9ybWF0KDEvMyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwLjMzMzMzMzMzMzMzMzMzMzMnXG4gKiAgICBmb3JtYXQoMS8zLCAzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAuMzMzJ1xuICogICAgZm9ybWF0KDIxMzg1LCAyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICcyMTAwMCdcbiAqICAgIGZvcm1hdCgxMi4wNzEsIHtub3RhdGlvbjogJ2ZpeGVkJ30pOyAgICAgICAgICAgICAgICAvLyAnMTInXG4gKiAgICBmb3JtYXQoMi4zLCAgICB7bm90YXRpb246ICdmaXhlZCcsIHByZWNpc2lvbjogMn0pOyAgLy8gJzIuMzAnXG4gKiAgICBmb3JtYXQoNTIuOCwgICB7bm90YXRpb246ICdleHBvbmVudGlhbCd9KTsgICAgICAgICAgLy8gJzUuMjhlKzEnXG4gKlxuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdCB8IEZ1bmN0aW9uIHwgTnVtYmVyfSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyIFRoZSBmb3JtYXR0ZWQgdmFsdWVcbiAqL1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBoYW5kbGUgZm9ybWF0KHZhbHVlLCBmbilcbiAgICByZXR1cm4gb3B0aW9ucyh2YWx1ZSk7XG4gIH1cblxuICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlc1xuICBpZiAoIXZhbHVlLmlzRmluaXRlKCkpIHtcbiAgICByZXR1cm4gdmFsdWUuaXNOYU4oKSA/ICdOYU4nIDogKHZhbHVlLmd0KDApID8gJ0luZmluaXR5JyA6ICctSW5maW5pdHknKTtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zXG4gIHZhciBub3RhdGlvbiA9ICdhdXRvJztcbiAgdmFyIHByZWNpc2lvbiA9IHVuZGVmaW5lZDtcblxuICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gZGV0ZXJtaW5lIG5vdGF0aW9uIGZyb20gb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLm5vdGF0aW9uKSB7XG4gICAgICBub3RhdGlvbiA9IG9wdGlvbnMubm90YXRpb247XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIHByZWNpc2lvbiBmcm9tIG9wdGlvbnNcbiAgICBpZiAoaXNOdW1iZXIob3B0aW9ucykpIHtcbiAgICAgIHByZWNpc2lvbiA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMucHJlY2lzaW9uKSB7XG4gICAgICBwcmVjaXNpb24gPSBvcHRpb25zLnByZWNpc2lvbjtcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgdGhlIHZhcmlvdXMgbm90YXRpb25zXG4gIHN3aXRjaCAobm90YXRpb24pIHtcbiAgICBjYXNlICdmaXhlZCc6XG4gICAgICByZXR1cm4gZXhwb3J0cy50b0ZpeGVkKHZhbHVlLCBwcmVjaXNpb24pO1xuXG4gICAgY2FzZSAnZXhwb25lbnRpYWwnOlxuICAgICAgcmV0dXJuIGV4cG9ydHMudG9FeHBvbmVudGlhbCh2YWx1ZSwgcHJlY2lzaW9uKTtcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgLy8gZGV0ZXJtaW5lIGxvd2VyIGFuZCB1cHBlciBib3VuZCBmb3IgZXhwb25lbnRpYWwgbm90YXRpb24uXG4gICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBzdXBwb3J0IGZvciB1cHBlciBhbmQgbG93ZXIgdG8gYmUgQmlnTnVtYmVycyB0aGVtc2VsdmVzXG4gICAgICB2YXIgbG93ZXIgPSAxZS0zO1xuICAgICAgdmFyIHVwcGVyID0gMWU1O1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5leHBvbmVudGlhbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5leHBvbmVudGlhbC5sb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbG93ZXIgPSBvcHRpb25zLmV4cG9uZW50aWFsLmxvd2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmV4cG9uZW50aWFsLnVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IG9wdGlvbnMuZXhwb25lbnRpYWwudXBwZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYWRqdXN0IHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgKHllYWgsIHRoaXMgaXMgcXVpdGUgdHJpY2t5Li4uKVxuICAgICAgdmFyIG9sZENvbmZpZyA9IHtcbiAgICAgICAgdG9FeHBOZWc6IHZhbHVlLmNvbnN0cnVjdG9yLnRvRXhwTmVnLFxuICAgICAgICB0b0V4cFBvczogdmFsdWUuY29uc3RydWN0b3IudG9FeHBQb3NcbiAgICAgIH07XG5cbiAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLmNvbmZpZyh7XG4gICAgICAgIHRvRXhwTmVnOiBNYXRoLnJvdW5kKE1hdGgubG9nKGxvd2VyKSAvIE1hdGguTE4xMCksXG4gICAgICAgIHRvRXhwUG9zOiBNYXRoLnJvdW5kKE1hdGgubG9nKHVwcGVyKSAvIE1hdGguTE4xMClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIHplcm9cbiAgICAgIGlmICh2YWx1ZS5pc1plcm8oKSkgcmV0dXJuICcwJztcblxuICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIG91dHB1dCBleHBvbmVudGlhbCBub3RhdGlvblxuICAgICAgdmFyIHN0cjtcbiAgICAgIHZhciBhYnMgPSB2YWx1ZS5hYnMoKTtcbiAgICAgIGlmIChhYnMuZ3RlKGxvd2VyKSAmJiBhYnMubHQodXBwZXIpKSB7XG4gICAgICAgIC8vIG5vcm1hbCBudW1iZXIgbm90YXRpb25cbiAgICAgICAgc3RyID0gdmFsdWUudG9TaWduaWZpY2FudERpZ2l0cyhwcmVjaXNpb24pLnRvRml4ZWQoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBleHBvbmVudGlhbCBub3RhdGlvblxuICAgICAgICBzdHIgPSBleHBvcnRzLnRvRXhwb25lbnRpYWwodmFsdWUsIHByZWNpc2lvbik7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvcyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oKFxcLlxcZCo/KSgwKykpKCR8ZSkvLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaWdpdHMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIHZhciBlID0gYXJndW1lbnRzWzRdO1xuICAgICAgICByZXR1cm4gKGRpZ2l0cyAhPT0gJy4nKSA/IGRpZ2l0cyArIGUgOiBlO1xuICAgICAgfSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vdGF0aW9uIFwiJyArIG5vdGF0aW9uICsgJ1wiLiAnICtcbiAgICAgICAgICAnQ2hvb3NlIFwiYXV0b1wiLCBcImV4cG9uZW50aWFsXCIsIG9yIFwiZml4ZWRcIi4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24uIExpa2UgJzEuMjNlKzUnLCAnMi4zZSswJywgJzMuNTAwZS0zJ1xuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gW3ByZWNpc2lvbl0gIE51bWJlciBvZiBkaWdpdHMgaW4gZm9ybWF0dGVkIG91dHB1dC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGUgbWF4aW11bSBhdmFpbGFibGUgZGlnaXRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHVzZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBzdHJcbiAqL1xuZXhwb3J0cy50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24odmFsdWUsIHByZWNpc2lvbikge1xuICBpZiAocHJlY2lzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWUudG9FeHBvbmVudGlhbChwcmVjaXNpb24gLSAxKTsgLy8gTm90ZSB0aGUgb2Zmc2V0IG9mIG9uZVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZS50b0V4cG9uZW50aWFsKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRm9ybWF0IGEgbnVtYmVyIHdpdGggZml4ZWQgbm90YXRpb24uXG4gKiBAcGFyYW0ge0JpZ051bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJlY2lzaW9uPTBdICAgICAgICBPcHRpb25hbCBudW1iZXIgb2YgZGVjaW1hbHMgYWZ0ZXIgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCBwb2ludC4gWmVybyBieSBkZWZhdWx0LlxuICovXG5leHBvcnRzLnRvRml4ZWQgPSBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiB2YWx1ZS50b0ZpeGVkKHByZWNpc2lvbiB8fCAwKTtcbiAgLy8gTm90ZTogdGhlIChwcmVjaXNpb24gfHwgMCkgaXMgbmVlZGVkIGFzIHRoZSB0b0ZpeGVkIG9mIEJpZ051bWJlciBoYXMgYW5cbiAgLy8gdW5kZWZpbmVkIGRlZmF1bHQgcHJlY2lzaW9uIGluc3RlYWQgb2YgMC5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBudW1iZXIgPSByZXF1aXJlKCcuL251bWJlcicpLFxuICAgIGJpZ251bWJlciA9IHJlcXVpcmUoJy4vYmlnbnVtYmVyJyksXG4gICAgQmlnTnVtYmVyID0gcmVxdWlyZSgnZGVjaW1hbC5qcycpO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciB2YWx1ZSBpcyBhIFN0cmluZ1xuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNTdHJpbmdcbiAqL1xuZXhwb3J0cy5pc1N0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHx8ICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHRleHQgZW5kcyB3aXRoIGEgY2VydGFpbiBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICovXG5leHBvcnRzLmVuZHNXaXRoID0gZnVuY3Rpb24odGV4dCwgc2VhcmNoKSB7XG4gIHZhciBzdGFydCA9IHRleHQubGVuZ3RoIC0gc2VhcmNoLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHRleHQubGVuZ3RoO1xuICByZXR1cm4gKHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpID09PSBzZWFyY2gpO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgYSB2YWx1ZSBvZiBhbnkgdHlwZSBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIFVzYWdlOlxuICogICAgIG1hdGguZm9ybWF0KHZhbHVlKVxuICogICAgIG1hdGguZm9ybWF0KHZhbHVlLCBwcmVjaXNpb24pXG4gKlxuICogSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgdGhlIHJldHVybmVkIHN0cmluZyBpcyAnZnVuY3Rpb24nIHVubGVzcyB0aGUgZnVuY3Rpb25cbiAqIGhhcyBhIHByb3BlcnR5IGBkZXNjcmlwdGlvbmAsIGluIHRoYXQgY2FzZSB0aGlzIHByb3BlcnRpZXMgdmFsdWUgaXMgcmV0dXJuZWQuXG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqICAgICBtYXRoLmZvcm1hdCgyLzcpOyAgICAgICAgICAgICAgICAvLyAnMC4yODU3MTQyODU3MTQyODU3J1xuICogICAgIG1hdGguZm9ybWF0KG1hdGgucGksIDMpOyAgICAgICAgIC8vICczLjE0J1xuICogICAgIG1hdGguZm9ybWF0KG5ldyBDb21wbGV4KDIsIDMpKTsgIC8vICcyICsgM2knXG4gKiAgICAgbWF0aC5mb3JtYXQoJ2hlbGxvJyk7ICAgICAgICAgICAgLy8gJ1wiaGVsbG9cIidcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlICAgICAgICAgICAgIFZhbHVlIHRvIGJlIHN0cmluZ2lmaWVkXG4gKiBAcGFyYW0ge09iamVjdCB8IE51bWJlciB8IEZ1bmN0aW9ufSBbb3B0aW9uc10gIEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYi91dGlsL251bWJlcjpmb3JtYXQgZm9yIGFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gb2YgdGhlIGF2YWlsYWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLlxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqL1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAobnVtYmVyLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiBudW1iZXIuZm9ybWF0KHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgIHJldHVybiBiaWdudW1iZXIuZm9ybWF0KHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmb3JtYXRBcnJheSh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoZXhwb3J0cy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ1wiJyArIHZhbHVlICsgJ1wiJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWUuc3ludGF4ID8gdmFsdWUuc3ludGF4ICsgJycgOiAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5mb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5mb3JtYXQob3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGZvcm1hdCBhbiBuLWRpbWVuc2lvbmFsIG1hdHJpeFxuICogRXhhbXBsZSBvdXRwdXQ6IFwiW1sxLCAyXSwgWzMsIDRdXVwiXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHtPYmplY3QgfCBOdW1iZXIgfCBGdW5jdGlvbn0gW29wdGlvbnNdICBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIvdXRpbC9udW1iZXI6Zm9ybWF0IGZvciBhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uIG9mIHRoZSBhdmFpbGFibGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiBmb3JtYXRBcnJheSAoYXJyYXksIG9wdGlvbnMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgdmFyIHN0ciA9ICdbJztcbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChpICE9IDApIHtcbiAgICAgICAgc3RyICs9ICcsICc7XG4gICAgICB9XG4gICAgICBzdHIgKz0gZm9ybWF0QXJyYXkoYXJyYXlbaV0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdHIgKz0gJ10nO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZm9ybWF0KGFycmF5LCBvcHRpb25zKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sYXRleCcpO1xudmFyIEJpZ051bWJlciA9IHJlcXVpcmUoJ2RlY2ltYWwuanMnKTtcbnZhciBDb21wbGV4ID0gcmVxdWlyZSgnLi4vLi4vdHlwZS9Db21wbGV4Jyk7XG52YXIgVW5pdCA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvVW5pdCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgaXNTdHJpbmcgPSB1dGlsLnN0cmluZy5pc1N0cmluZztcbnZhciBpc051bWJlciA9IHV0aWwubnVtYmVyLmlzTnVtYmVyO1xudmFyIGlzQm9vbGVhbiA9IHV0aWxbJ2Jvb2xlYW4nXS5pc0Jvb2xlYW47XG5cbi8qKlxuICogQSBsYXp5IGV2YWx1YXRpbmcgY29uZGl0aW9uYWwgb3BlcmF0b3I6ICdjb25kaXRpb24gPyB0cnVlRXhwciA6IGZhbHNlRXhwcidcbiAqXG4gKiBAcGFyYW0ge05vZGV9IGNvbmRpdGlvbiAgIENvbmRpdGlvbiwgbXVzdCByZXN1bHQgaW4gYSBib29sZWFuXG4gKiBAcGFyYW0ge05vZGV9IHRydWVFeHByICAgIEV4cHJlc3Npb24gZXZhbHVhdGVkIHdoZW4gY29uZGl0aW9uIGlzIHRydWVcbiAqIEBwYXJhbSB7Tm9kZX0gZmFsc2VFeHByICAgRXhwcmVzc2lvbiBldmFsdWF0ZWQgd2hlbiBjb25kaXRpb24gaXMgdHJ1ZVxuICpcbiAqIEBjb25zdHJ1Y3RvciBDb25kaXRpb25hbE5vZGVcbiAqIEBleHRlbmRzIHtOb2RlfVxuICovXG5mdW5jdGlvbiBDb25kaXRpb25hbE5vZGUgKGNvbmRpdGlvbiwgdHJ1ZUV4cHIsIGZhbHNlRXhwcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29uZGl0aW9uYWxOb2RlKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cbiAgaWYgKCEoY29uZGl0aW9uIGluc3RhbmNlb2YgTm9kZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBjb25kaXRpb24gbXVzdCBiZSBhIE5vZGUnKTtcbiAgaWYgKCEodHJ1ZUV4cHIgaW5zdGFuY2VvZiBOb2RlKSkgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciB0cnVlRXhwciBtdXN0IGJlIGEgTm9kZScpO1xuICBpZiAoIShmYWxzZUV4cHIgaW5zdGFuY2VvZiBOb2RlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVyIGZhbHNlRXhwciBtdXN0IGJlIGEgTm9kZScpO1xuXG4gIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICB0aGlzLnRydWVFeHByID0gdHJ1ZUV4cHI7XG4gIHRoaXMuZmFsc2VFeHByID0gZmFsc2VFeHByO1xufVxuXG5Db25kaXRpb25hbE5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuQ29uZGl0aW9uYWxOb2RlLnByb3RvdHlwZS50eXBlID0gJ0NvbmRpdGlvbmFsTm9kZSc7XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAqIEByZXR1cm4ge1N0cmluZ30ganNcbiAqIEBwcml2YXRlXG4gKi9cbkNvbmRpdGlvbmFsTm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbihkZWZzKSB7XG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgYSBjb25kaXRpb24gaXMgbWV0XG4gICAqIEBwYXJhbSB7Kn0gY29uZGl0aW9uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGNvbmRpdGlvbiBpcyB0cnVlIG9yIG5vbi16ZXJvLCBlbHNlIGZhbHNlXG4gICAqL1xuICBkZWZzLnRlc3RDb25kaXRpb24gPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGlzTnVtYmVyKGNvbmRpdGlvbikgfHwgaXNCb29sZWFuKGNvbmRpdGlvbikgfHwgaXNTdHJpbmcoY29uZGl0aW9uKSkge1xuICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICByZXR1cm4gY29uZGl0aW9uLmlzWmVybygpID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjb25kaXRpb24gaW5zdGFuY2VvZiBDb21wbGV4KSB7XG4gICAgICByZXR1cm4gKGNvbmRpdGlvbi5yZSB8fCBjb25kaXRpb24uaW0pID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChjb25kaXRpb24gaW5zdGFuY2VvZiBVbml0KSB7XG4gICAgICByZXR1cm4gY29uZGl0aW9uLnZhbHVlID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChjb25kaXRpb24gPT09IG51bGwgfHwgY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCB0eXBlIG9mIGNvbmRpdGlvbiBcIicgKyBkZWZzLm1hdGhbJ3R5cGVvZiddKGNvbmRpdGlvbikgKyAnXCInKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgICAgJ3Rlc3RDb25kaXRpb24oJyArIHRoaXMuY29uZGl0aW9uLl9jb21waWxlKGRlZnMpICsgJykgPyAnICtcbiAgICAgICcoICcgKyB0aGlzLnRydWVFeHByLl9jb21waWxlKGRlZnMpICsgJykgOiAnICtcbiAgICAgICcoICcgKyB0aGlzLmZhbHNlRXhwci5fY29tcGlsZShkZWZzKSArICcpJ1xuICAgICAgKTtcbn07XG5cbi8qKlxuICogRmluZCBhbGwgbm9kZXMgbWF0Y2hpbmcgZ2l2ZW4gZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyICBTZWUgTm9kZS5maW5kIGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBmaWx0ZXIgb3B0aW9uc1xuICogQHJldHVybnMge05vZGVbXX0gbm9kZXNcbiAqL1xuQ29uZGl0aW9uYWxOb2RlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICB2YXIgbm9kZXMgPSBbXTtcblxuICAvLyBjaGVjayBpdHNlbGZcbiAgaWYgKHRoaXMubWF0Y2goZmlsdGVyKSkge1xuICAgIG5vZGVzLnB1c2godGhpcyk7XG4gIH1cblxuICAvLyBzZWFyY2ggaW4gcGFyYW1ldGVyc1xuICBub2RlcyA9IG5vZGVzLmNvbmNhdChcbiAgICAgIHRoaXMuY29uZGl0aW9uLmZpbmQoZmlsdGVyKSxcbiAgICAgIHRoaXMudHJ1ZUV4cHIuZmluZChmaWx0ZXIpLFxuICAgICAgdGhpcy5mYWxzZUV4cHIuZmluZChmaWx0ZXIpKTtcblxuICByZXR1cm4gbm9kZXM7XG59O1xuXG4vKipcbiAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyXG4gKi9cbkNvbmRpdGlvbmFsTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETzogbm90IG5pY2UgYWRkaW5nIHBhcmVudGhlc2lzIGFsIHRoZSB0aW1lXG4gIHJldHVybiAnKCcgKyB0aGlzLmNvbmRpdGlvbi50b1N0cmluZygpICsgJykgPyAoJyArXG4gICAgICB0aGlzLnRydWVFeHByLnRvU3RyaW5nKCkgKyAnKSA6ICgnICtcbiAgICAgIHRoaXMuZmFsc2VFeHByLnRvU3RyaW5nKCkgKyAnKSc7XG59O1xuXG4vKipcbiAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqL1xuQ29uZGl0aW9uYWxOb2RlLnByb3RvdHlwZS50b1RleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcyA9IChcbiAgICAgIGxhdGV4LmFkZEJyYWNlcyh0aGlzLnRydWVFeHByLnRvVGV4KCkpICtcbiAgICAgICcsICZcXFxccXVhZCcgK1xuICAgICAgbGF0ZXguYWRkQnJhY2VzKCdcXFxcdGV4dHtpZn1cXFxcOycgKyB0aGlzLmNvbmRpdGlvbi50b1RleCgpKVxuICAgICAgKSArICdcXFxcXFxcXCcgKyAoXG4gICAgICBsYXRleC5hZGRCcmFjZXModGhpcy5mYWxzZUV4cHIudG9UZXgoKSkgK1xuICAgICAgJywgJlxcXFxxdWFkJyArXG4gICAgICBsYXRleC5hZGRCcmFjZXMoJ1xcXFx0ZXh0e290aGVyd2lzZX0nKVxuICAgICAgKTtcblxuICByZXR1cm4gbGF0ZXguYWRkQnJhY2VzKHMsIFtcbiAgICAnXFxcXGxlZnRcXFxce1xcXFxiZWdpbnthcnJheX17bCBsfScsXG4gICAgJ1xcXFxlbmR7YXJyYXl9XFxcXHJpZ2h0LidcbiAgXSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbmRpdGlvbmFsTm9kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUuanMnKTtcbnZhciBSYW5nZU5vZGUgPSByZXF1aXJlKCcuL1JhbmdlTm9kZScpO1xudmFyIFN5bWJvbE5vZGUgPSByZXF1aXJlKCcuL1N5bWJvbE5vZGUnKTtcblxudmFyIEJpZ051bWJlciA9IHJlcXVpcmUoJ2RlY2ltYWwuanMnKTtcbnZhciBSYW5nZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUvUmFuZ2UnKTtcblxudmFyIGlzTm9kZSA9IE5vZGUuaXNOb2RlO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBJbmRleE5vZGVcbiAqIEBleHRlbmRzIE5vZGVcbiAqXG4gKiBnZXQgYSBzdWJzZXQgb2YgYSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG9iamVjdFxuICogQHBhcmFtIHtOb2RlW119IHJhbmdlc1xuICovXG5mdW5jdGlvbiBJbmRleE5vZGUgKG9iamVjdCwgcmFuZ2VzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmRleE5vZGUpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGlucHV0XG4gIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIE5vZGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb2RlIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJvYmplY3RcIicpO1xuICBpZiAoIWlzQXJyYXkocmFuZ2VzKSB8fCAhcmFuZ2VzLmV2ZXJ5KGlzTm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBjb250YWluaW5nIE5vZGVzIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJyYW5nZXNcIicpO1xuICB9XG5cbiAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xufVxuXG5JbmRleE5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuSW5kZXhOb2RlLnByb3RvdHlwZS50eXBlID0gJ0luZGV4Tm9kZSc7XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAqIEByZXR1cm4ge1N0cmluZ30ganNcbiAqIEBwcml2YXRlXG4gKi9cbkluZGV4Tm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcykge1xuICByZXR1cm4gdGhpcy5jb21waWxlU3Vic2V0KGRlZnMpO1xufTtcblxuLyoqXG4gKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgICAgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsZWQgZXhwcmVzc2lvblxuICogQHBhcmFtIHtTdHJpbmd9IFtyZXBsYWNlbWVudF0gIElmIHByb3ZpZGVkLCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXRoLnN1YnNldChvYmosIG1hdGguaW5kZXgoLi4uKSwgcmVwbGFjZW1lbnQpXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbHNlLCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXRoLnN1YnNldChvYmosIG1hdGguaW5kZXgoLi4uKSlcIlxuICogQHJldHVybiB7U3RyaW5nfSBqc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuSW5kZXhOb2RlLnByb3RvdHlwZS5jb21waWxlU3Vic2V0ID0gZnVuY3Rpb24oZGVmcywgcmVwbGFjZW1lbnQpIHtcbiAgLy8gY2hlY2sgd2hldGhlciBhbnkgb2YgdGhlIHJhbmdlcyBleHByZXNzaW9ucyB1c2VzIHRoZSBjb250ZXh0IHN5bWJvbCAnZW5kJ1xuICB2YXIgZmlsdGVyID0ge1xuICAgIHR5cGU6IFN5bWJvbE5vZGUsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgbmFtZTogJ2VuZCdcbiAgICB9XG4gIH07XG4gIHZhciBzb21lVXNlRW5kID0gZmFsc2U7XG4gIHZhciByYW5nZXNVc2VFbmQgPSB0aGlzLnJhbmdlcy5tYXAoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgdmFyIHVzZUVuZCA9IHJhbmdlLmZpbmQoZmlsdGVyKS5sZW5ndGggPiAwO1xuICAgIHNvbWVVc2VFbmQgPSB1c2VFbmQgPyB1c2VFbmQgOiBzb21lVXNlRW5kO1xuICAgIHJldHVybiB1c2VFbmQ7XG4gIH0pO1xuXG4gIC8vIGNyZWF0ZSBhIFJhbmdlIGZyb20gc3RhcnQsIHN0ZXAgYW5kIGVuZFxuICBkZWZzLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKFxuICAgICAgICAgICAgc3RhcnQgaW5zdGFuY2VvZiBCaWdOdW1iZXIgPyBzdGFydC50b051bWJlcigpIDogc3RhcnQsXG4gICAgICAgICAgICBlbmQgaW5zdGFuY2VvZiBCaWdOdW1iZXIgPyBlbmQudG9OdW1iZXIoKSA6IGVuZCxcbiAgICAgICAgICAgIHN0ZXAgaW5zdGFuY2VvZiBCaWdOdW1iZXIgPyBzdGVwLnRvTnVtYmVyKCkgOiBzdGVwXG4gICAgKTtcbiAgfTtcblxuICAvLyBUT0RPOiBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgYmlnbnVtYmVyIChjdXJyZW50bHkgYmlnbnVtYmVycyBhcmUgc2lsZW50bHlcbiAgLy8gICAgICAgcmVkdWNlZCB0byBudW1iZXJzIHdoZW4gY2hhbmdpbmcgdGhlIHZhbHVlIHRvIHplcm8tYmFzZWQpXG5cbiAgLy8gVE9ETzogT3B0aW1pemF0aW9uOiB3aGVuIHRoZSByYW5nZSB2YWx1ZXMgYXJlIENvbnN0YW50Tm9kZXMsXG4gIC8vICAgICAgIHdlIGNhbiBiZWZvcmVoYW5kIHJlc29sdmUgdGhlIHplcm8tYmFzZWQgdmFsdWVcblxuICB2YXIgcmFuZ2VzID0gdGhpcy5yYW5nZXMubWFwKGZ1bmN0aW9uKHJhbmdlLCBpKSB7XG4gICAgdmFyIHVzZUVuZCA9IHJhbmdlc1VzZUVuZFtpXTtcbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZU5vZGUpIHtcbiAgICAgIGlmICh1c2VFbmQpIHtcbiAgICAgICAgLy8gcmVzb2x2ZSBlbmQgYW5kIGNyZWF0ZSByYW5nZVxuICAgICAgICByZXR1cm4gJyhmdW5jdGlvbiAoc2NvcGUpIHsnICtcbiAgICAgICAgICAgICcgIHNjb3BlID0gT2JqZWN0LmNyZWF0ZShzY29wZSk7ICcgK1xuICAgICAgICAgICAgJyAgc2NvcGVbXCJlbmRcIl0gPSBzaXplWycgKyBpICsgJ107JyArXG4gICAgICAgICAgICAnICByZXR1cm4gcmFuZ2UoJyArXG4gICAgICAgICAgICAnICAgICcgKyByYW5nZS5zdGFydC5fY29tcGlsZShkZWZzKSArICcsICcgK1xuICAgICAgICAgICAgJyAgICAnICsgcmFuZ2UuZW5kLl9jb21waWxlKGRlZnMpICsgJywgJyArXG4gICAgICAgICAgICAnICAgICcgKyAocmFuZ2Uuc3RlcCA/IHJhbmdlLnN0ZXAuX2NvbXBpbGUoZGVmcykgOiAnMScpICtcbiAgICAgICAgICAgICcgICk7JyArXG4gICAgICAgICAgICAnfSkoc2NvcGUpJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgcmFuZ2VcbiAgICAgICAgcmV0dXJuICdyYW5nZSgnICtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0Ll9jb21waWxlKGRlZnMpICsgJywgJyArXG4gICAgICAgICAgICByYW5nZS5lbmQuX2NvbXBpbGUoZGVmcykgKyAnLCAnICtcbiAgICAgICAgICAgIChyYW5nZS5zdGVwID8gcmFuZ2Uuc3RlcC5fY29tcGlsZShkZWZzKSA6ICcxJykgK1xuICAgICAgICAgICAgJyknO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh1c2VFbmQpIHtcbiAgICAgICAgLy8gcmVzb2x2ZSB0aGUgcGFyYW1ldGVyICdlbmQnXG4gICAgICAgIHJldHVybiAnKGZ1bmN0aW9uIChzY29wZSkgeycgK1xuICAgICAgICAgICAgJyAgc2NvcGUgPSBPYmplY3QuY3JlYXRlKHNjb3BlKTsgJyArXG4gICAgICAgICAgICAnICBzY29wZVtcImVuZFwiXSA9IHNpemVbJyArIGkgKyAnXTsnICtcbiAgICAgICAgICAgICcgIHJldHVybiAnICsgcmFuZ2UuX2NvbXBpbGUoZGVmcykgKyAnOycgK1xuICAgICAgICAgICAgJ30pKHNjb3BlKSdcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBqdXN0IGV2YWx1YXRlIHRoZSBleHByZXNzaW9uXG4gICAgICAgIHJldHVybiByYW5nZS5fY29tcGlsZShkZWZzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIGlmIHNvbWUgcGFyYW1ldGVycyB1c2UgdGhlICdlbmQnIHBhcmFtZXRlciwgd2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIHNpemVcbiAgaWYgKHNvbWVVc2VFbmQpIHtcbiAgICByZXR1cm4gJyhmdW5jdGlvbiAoKSB7JyArXG4gICAgICAgICcgIHZhciBvYmogPSAnICsgdGhpcy5vYmplY3QuX2NvbXBpbGUoZGVmcykgKyAnOycgK1xuICAgICAgICAnICB2YXIgc2l6ZSA9IG1hdGguc2l6ZShvYmopLnZhbHVlT2YoKTsnICtcbiAgICAgICAgJyAgcmV0dXJuIG1hdGguc3Vic2V0KCcgK1xuICAgICAgICAnICAgIG9iaiwgJyArXG4gICAgICAgICcgICAgbWF0aC5pbmRleCgnICsgcmFuZ2VzLmpvaW4oJywgJykgKyAnKScgK1xuICAgICAgICAnICAgICcgKyAocmVwbGFjZW1lbnQgPyAoJywgJyArIHJlcGxhY2VtZW50KSA6ICcnKSArXG4gICAgICAgICcgICk7JyArXG4gICAgICAgICd9KSgpJztcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gJ21hdGguc3Vic2V0KCcgK1xuICAgICAgICB0aGlzLm9iamVjdC5fY29tcGlsZShkZWZzKSArICcsJyArXG4gICAgICAgICdtYXRoLmluZGV4KCcgKyByYW5nZXMuam9pbignLCAnKSArICcpJyArXG4gICAgICAgIChyZXBsYWNlbWVudCA/ICgnLCAnICsgcmVwbGFjZW1lbnQpIDogJycpICtcbiAgICAgICAgJyknO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbmQgYWxsIG5vZGVzIG1hdGNoaW5nIGdpdmVuIGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlciAgU2VlIE5vZGUuZmluZCBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgZmlsdGVyIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtOb2RlW119IG5vZGVzXG4gKi9cbkluZGV4Tm9kZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgdmFyIG5vZGVzID0gW107XG5cbiAgLy8gY2hlY2sgaXRzZWxmXG4gIGlmICh0aGlzLm1hdGNoKGZpbHRlcikpIHtcbiAgICBub2Rlcy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgLy8gc2VhcmNoIG9iamVjdFxuICBub2RlcyA9IG5vZGVzLmNvbmNhdCh0aGlzLm9iamVjdC5maW5kKGZpbHRlcikpO1xuXG4gIC8vIHNlYXJjaCBpbiBwYXJhbWV0ZXJzXG4gIHZhciByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KHJhbmdlc1tpXS5maW5kKGZpbHRlcikpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgdGhlIG9iamVjdCBsaW5rZWQgdG8gdGhpcyBJbmRleE5vZGVcbiAqIEByZXR1cm4ge3N0cmluZ30gbmFtZVxuICovXG5JbmRleE5vZGUucHJvdG90eXBlLm9iamVjdE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub2JqZWN0Lm5hbWU7XG59O1xuXG4vKipcbiAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyXG4gKi9cbkluZGV4Tm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgLy8gZm9ybWF0IHRoZSBwYXJhbWV0ZXJzIGxpa2UgXCJbMSwgMDo1XVwiXG4gIHJldHVybiB0aGlzLm9iamVjdC50b1N0cmluZygpICsgJ1snICsgdGhpcy5yYW5nZXMuam9pbignLCAnKSArICddJztcbn07XG5cbi8qKlxuICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0clxuICovXG5JbmRleE5vZGUucHJvdG90eXBlLnRvVGV4ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9iamVjdC50b1RleCgpICsgJ1snICsgdGhpcy5yYW5nZXMuam9pbignLCAnKSArICddJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5kZXhOb2RlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKSxcbiAgICBCaWdOdW1iZXIgPSByZXF1aXJlKCdkZWNpbWFsLmpzJyksXG4gICAgdHlwZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdHlwZXMnKS50eXBlLFxuICAgIGlzU3RyaW5nID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9zdHJpbmcnKS5pc1N0cmluZztcblxuLyoqXG4gKiBBIENvbnN0YW50Tm9kZSBob2xkcyBhIGNvbnN0YW50IHZhbHVlIGxpa2UgYSBudW1iZXIgb3Igc3RyaW5nLiBBIENvbnN0YW50Tm9kZVxuICogc3RvcmVzIGEgc3RyaW5naWZpZWQgdmVyc2lvbiBvZiB0aGUgdmFsdWUgYW5kIHVzZXMgdGhpcyB0byBjb21waWxlIHRvXG4gKiBKYXZhU2NyaXB0LlxuICpcbiAqIEluIGNhc2Ugb2YgYSBzdHJpbmdpZmllZCBudW1iZXIgYXMgaW5wdXQsIHRoaXMgbWF5IGJlIGNvbXBpbGVkIHRvIGEgQmlnTnVtYmVyXG4gKiB3aGVuIHRoZSBtYXRoIGluc3RhbmNlIGlzIGNvbmZpZ3VyZWQgZm9yIEJpZ051bWJlcnMuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAgIC8vIHN0cmluZ2lmaWVkIHZhbHVlcyB3aXRoIHR5cGVcbiAqICAgICBuZXcgQ29uc3RhbnROb2RlKCcyLjMnLCAnbnVtYmVyJyk7XG4gKiAgICAgbmV3IENvbnN0YW50Tm9kZSgndHJ1ZScsICdib29sZWFuJyk7XG4gKiAgICAgbmV3IENvbnN0YW50Tm9kZSgnaGVsbG8nLCAnc3RyaW5nJyk7XG4gKlxuICogICAgIC8vIG5vbi1zdHJpbmdpZmllZCB2YWx1ZXMsIHR5cGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRldGVjdGVkXG4gKiAgICAgbmV3IENvbnN0YW50Tm9kZSgyLjMpO1xuICogICAgIG5ldyBDb25zdGFudE5vZGUoJ2hlbGxvJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBCb29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gdmFsdWVUeXBlIGlzIHByb3ZpZGVkLCB2YWx1ZSBtdXN0IGNvbnRhaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIHVuaW50ZXJwcmV0ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHZhbHVlVHlwZSBpcyB1bmRlZmluZWQsIHZhbHVlIGNhbiBiZSBhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIsIHN0cmluZywgYm9vbGVhbiwgbnVsbCwgb3IgdW5kZWZpbmVkLCBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB0eXBlIHdpbGwgYmUgZGV0ZXJtaW5lZCBhdXRvbWF0aWNhbGx5LlxuICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZVR5cGVdICBUaGUgdHlwZSBvZiB2YWx1ZS4gQ2hvb3NlIGZyb20gJ251bWJlcicsICdzdHJpbmcnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYm9vbGVhbicsICd1bmRlZmluZWQnLCAnbnVsbCdcbiAqIEBjb25zdHJ1Y3RvciBDb25zdGFudE5vZGVcbiAqIEBleHRlbmRzIHtOb2RlfVxuICovXG5mdW5jdGlvbiBDb25zdGFudE5vZGUodmFsdWUsIHZhbHVlVHlwZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29uc3RhbnROb2RlKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gIH1cblxuICBpZiAodmFsdWVUeXBlKSB7XG4gICAgaWYgKCFpc1N0cmluZyh2YWx1ZVR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdHJpbmcgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcInZhbHVlVHlwZVwiJyk7XG4gICAgfVxuICAgIGlmICghaXNTdHJpbmcodmFsdWUpKXtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZyBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwidmFsdWVcIicpO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnZhbHVlVHlwZSA9IHZhbHVlVHlwZTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBzdHJpbmdpZnkgdGhlIHZhbHVlIGFuZCBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUgKyAnJztcbiAgICB0aGlzLnZhbHVlVHlwZSA9IHR5cGUodmFsdWUpO1xuICB9XG5cbiAgaWYgKCFTVVBQT1JURURfVFlQRVNbdGhpcy52YWx1ZVR5cGVdKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBvZiB2YWx1ZSBcIicgKyB0aGlzLnZhbHVlVHlwZSArICdcIicpO1xuICB9XG59XG5cbnZhciBTVVBQT1JURURfVFlQRVMgPSB7XG4gICdudW1iZXInOiB0cnVlLFxuICAnc3RyaW5nJzogdHJ1ZSxcbiAgJ2Jvb2xlYW4nOiB0cnVlLFxuICAndW5kZWZpbmVkJzogdHJ1ZSxcbiAgJ251bGwnOiB0cnVlXG59O1xuXG5Db25zdGFudE5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuQ29uc3RhbnROb2RlLnByb3RvdHlwZS50eXBlID0gJ0NvbnN0YW50Tm9kZSc7XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAqIEByZXR1cm4ge1N0cmluZ30ganNcbiAqIEBwcml2YXRlXG4gKi9cbkNvbnN0YW50Tm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcykge1xuICBzd2l0Y2ggKHRoaXMudmFsdWVUeXBlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChkZWZzLm1hdGguY29uZmlnKCkubnVtYmVyID09PSAnYmlnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gJ21hdGguYmlnbnVtYmVyKFwiJyArIHRoaXMudmFsdWUgKyAnXCIpJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgbGVhZGluZyB6ZXJvcyBsaWtlICcwMDMuMicgd2hpY2ggYXJlIG5vdCBhbGxvd2VkIGJ5IEphdmFTY3JpcHRcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUucmVwbGFjZSgvXigwKilbMC05XS8sIGZ1bmN0aW9uIChtYXRjaCwgemVyb3MpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2guc3Vic3RyaW5nKHplcm9zLmxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiAnXCInICsgdGhpcy52YWx1ZSArICdcIic7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuXG4gICAgY2FzZSAnbnVsbCc6XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFRPRE86IG1vdmUgdGhpcyBlcnJvciB0byB0aGUgY29uc3RydWN0b3I/XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCB0eXBlIG9mIGNvbnN0YW50IFwiJyArIHRoaXMudmFsdWVUeXBlICsgJ1wiJyk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqL1xuQ29uc3RhbnROb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBzd2l0Y2ggKHRoaXMudmFsdWVUeXBlKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiAnXCInICsgdGhpcy52YWx1ZSArICdcIic7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0clxuICovXG5Db25zdGFudE5vZGUucHJvdG90eXBlLnRvVGV4ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG4gICAgICBpbmRleDtcbiAgc3dpdGNoICh0aGlzLnZhbHVlVHlwZSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gJ1xcXFx0ZXh0eycgKyB2YWx1ZSArICd9JztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpbmRleCA9IHZhbHVlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZScpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDAsIGluZGV4KSArICcgXFxcXGNkb3QgMTBeeycgK1xuICAgICAgICAgICAgdmFsdWUuc3Vic3RyaW5nKGluZGV4ICsgMSkgKyAnfSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0YW50Tm9kZTtcbiJdfQ==
;