// Generated by CoffeeScript 1.7.1
(function() {
  var calcDistance, clustering, clusteringWrapper, hypot, rgb2hsl;

  if (Math.hypot != null) {
    hypot = Math.hypot;
  } else {
    hypot = function(args) {
      var sum;
      sum = 0;
      args.forEach(function(val) {
        return sum += val * val;
      });
      return Math.sqrt(sum);
    };
  }

  rgb2hsl = function(r, g, b) {
    var h, l, max, min, s, _ref, _ref1;
    _ref = [r, g, b].map(function(elem) {
      return elem / 255;
    }), r = _ref[0], g = _ref[1], b = _ref[2];
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    if (max === min) {
      h = 0;
    } else if (max === r && g >= b) {
      h = 60 * (g - b) / (max - min);
    } else if (max === r && g < b) {
      h = 60 * (g - b) / (max - min) + 360;
    } else if (max === g) {
      h = 60 * (b - r) / (max - min) + 120;
    } else {
      h = 60 * (r - g) / (max - min) + 240;
    }
    l = (max + min) / 2;
    if (max === min || l === 0) {
      s = 0;
    } else if (l > 0 && l <= 0.5) {
      s = (max - min) / (max + min);
    } else {
      s = (max - min) / (2 - (max + min));
    }
    h = parseInt(h);
    _ref1 = [s, l].map(function(elem) {
      return Math.round(elem * 100) / 100;
    }), s = _ref1[0], l = _ref1[1];
    return [h, s, l];
  };

  calcDistance = function(p1, p2) {
    var delta, weights;
    weights = [1, 0.8, 0.8];
    delta = p1.map(function(val, i) {
      return (val - p2[i]) * weights[i];
    });
    return hypot(delta);
  };

  clustering = function(points, config) {
    var N, calc, calcCenter, centers, clusters, debug, display, h, i, imagePixels, l, s, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2;
    debug = config.debug, display = config.display;
    points = points.map(function(point) {
      var h, l, s;
      h = point[0], s = point[1], l = point[2];
      s *= 100;
      l *= 100;
      return [h, s, l];
    });
    imagePixels = points;
    N = 16;
    calcCenter = function(points) {
      var H, L, S, atan, center, d, minDistance, newCenter, point, x, y, _i, _len;
      if (points.length === 0) {
        center = imagePixels[parseInt(Math.random() * imagePixels.length)];
        console.log(center);
        return center;
      }
      L = math.mean(points.map(function(point) {
        return point[2];
      }));
      x = math.mean(points.map(function(point) {
        var h, l, s;
        h = point[0], s = point[1], l = point[2];
        return s * math.cos(math.unit(h, 'deg'));
      }));
      y = math.mean(points.map(function(point) {
        var h, l, s;
        h = point[0], s = point[1], l = point[2];
        return s * math.sin(math.unit(h, 'deg'));
      }));
      S = Math.sqrt(x * x + y * y);
      atan = Math.atan(y / x);
      H = atan / Math.PI * 180;
      if (H < 0) {
        H += 360;
      }
      [H, S, L].map(function(elem) {
        return parseInt(elem);
      });
      newCenter = 0;
      minDistance = null;
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        d = calcDistance(point, [H, S, L]);
        if ((minDistance == null) || (d < minDistance)) {
          minDistance = d;
          newCenter = point;
        }
      }
      return newCenter;
    };
    centers = [];
    clusters = [];
    _ref = [0, 45, 90, 135, 180, 225, 270, 315];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      h = _ref[_i];
      _ref1 = [50];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        s = _ref1[_j];
        _ref2 = [25, 75];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          l = _ref2[_k];
          centers.push([h, s, l]);
        }
      }
    }
    for (i = _l = 0; 0 <= N ? _l < N : _l > N; i = 0 <= N ? ++_l : --_l) {
      clusters.push([]);
    }
    if (debug) {
      display(centers);
    }
    calc = function() {
      var d, minDistance, minIndex, point, _len3, _m, _n;
      for (_m = 0, _len3 = points.length; _m < _len3; _m++) {
        point = points[_m];
        minIndex = 0;
        minDistance = null;
        for (i = _n = 0; 0 <= N ? _n < N : _n > N; i = 0 <= N ? ++_n : --_n) {
          d = calcDistance(centers[i], point);
          if ((minDistance == null) || (d < minDistance)) {
            minIndex = i;
            minDistance = d;
          }
        }
        clusters[minIndex].push(point);
      }
      centers = clusters.map(function(cluster) {
        return calcCenter(cluster);
      });
      if (debug) {
        return display(centers);
      }
    };
    calc();
    calc();
    return centers;
  };

  clusteringWrapper = function(config) {
    var debug, display, img, maxHeight, maxWidth, url;
    maxWidth = config.maxWidth, maxHeight = config.maxHeight, url = config.url, debug = config.debug, display = config.display;
    img = new Image();
    img.onload = function() {
      var b, canvas, centers, ctx, g, h, i, image, imgData, points, r, scale, w, _ref, _ref1;
      image = this;
      scale = Math.max(image.width / maxWidth, image.height / maxHeight, 1);
      _ref = [image.width, image.height].map(function(elem) {
        return parseInt(elem / scale);
      }), w = _ref[0], h = _ref[1];
      canvas = document.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      ctx = canvas.getContext("2d");
      ctx.drawImage(this, 0, 0, image.width, image.height, 0, 0, w, h);
      imgData = ctx.getImageData(0, 0, w, h);
      points = [];
      i = 0;
      while (i < imgData.data.length) {
        _ref1 = [imgData.data[i], imgData.data[i + 1], imgData.data[i + 2]], r = _ref1[0], g = _ref1[1], b = _ref1[2];
        points.push(rgb2hsl(r, g, b));
        i += 4;
      }
      return centers = clustering(points, {
        debug: true,
        display: display
      });
    };
    return img.src = url;
  };

  window.clustering = clusteringWrapper;

}).call(this);
